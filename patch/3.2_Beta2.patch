diff --git a/BUILD.gn b/BUILD.gn
index cf3f6a2457a9a..059d93a124858 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -100,6 +100,16 @@ group("gn_all") {
     "//ohos_nweb:libnweb_adapter",
   ]
 
+  # ifdef ohos_nweb_ex
+  if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
+    deps += [
+      "//ohos_browser_shell",
+      "//ohos_nweb_ex/browser_service_ex",
+      "//ohos_nweb_hap",
+    ]
+  }
+  # endif 
+
   if (!is_component_build) {
     deps += [ "//third_party/abseil-cpp:absl_tests" ]
   }
diff --git a/build/config/BUILD.gn b/build/config/BUILD.gn
index 631caef2db439..56f458aba4cfe 100644
--- a/build/config/BUILD.gn
+++ b/build/config/BUILD.gn
@@ -117,6 +117,25 @@ config("feature_flags") {
 
 # Debug/release ----------------------------------------------------------------
 
+#ifdef OHOS_NWEB_EX
+config("ohos_nweb_ex_def_main") {
+  if (defined(ohos_nweb_ex_config_name) && ohos_nweb_ex_config_name != "") {
+    defines = ohos_nweb_ex_defines_main
+  }
+}
+ 
+config("ohos_nweb_ex_def_blink") {
+  if (defined(ohos_nweb_ex_config_name) && ohos_nweb_ex_config_name != "") {
+    defines = ohos_nweb_ex_defines_blink_core
+  }
+}
+ 
+config("ohos_nweb_ex_def_other") {
+  if (defined(ohos_nweb_ex_config_name) && ohos_nweb_ex_config_name != "") {
+    defines = ohos_nweb_ex_defines_other
+  }
+}  #endif  // ohos_nweb_ex
+
 config("debug") {
   defines = [
     "_DEBUG",
diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
index f4f9d9bf460b5..a7aa11cf3af05 100644
--- a/build/config/BUILDCONFIG.gn
+++ b/build/config/BUILDCONFIG.gn
@@ -46,6 +46,15 @@
 # When writing build files, to do something only for the host:
 #   if (current_toolchain == host_toolchain) { ...
 
+#ifdef OHOS_NWEB_EX
+declare_args() {
+  ohos_nweb_ex_config_name = ""
+}
+ 
+if (ohos_nweb_ex_config_name != "") {
+  import("$ohos_nweb_ex_config_name")
+}  #endif  // OHOS_NWEB_EX
+
 if (target_os == "") {
   target_os = host_os
 }
@@ -386,6 +395,12 @@ if (is_debug) {
   default_compiler_configs += [ "//build/config:release" ]
 }
 
+#ifdef OHOS_NWEB_EX
+if (ohos_nweb_ex_config_name != "") {
+  default_compiler_configs += [ "//build/config:ohos_nweb_ex_def_main" ]
+}
+# endif //OHOS_NWEB_EX
+
 # Static libraries and source sets use only the compiler ones.
 set_defaults("static_library") {
   configs = default_compiler_configs
diff --git a/build/config/ohos/config.gni b/build/config/ohos/config.gni
index 1ad2a5244f1ee..a29757adeedd9 100644
--- a/build/config/ohos/config.gni
+++ b/build/config/ohos/config.gni
@@ -2,22 +2,27 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
+  import("//ohos_sdk/ohos_sdk.gni")
+}
 if (is_ohos) {
   import("//build/config/dcheck_always_on.gni")
   import("//build_overrides/build.gni")
   import("abi.gni")
 
   declare_args() {
-    arm32_ndk_api_level = 21
-    arm64_ndk_api_level = 21
+    use_ohos_sdk_sysroot = false
   }
 
   declare_args() {
-    build_chromium_with_ohos_src = true
+    arm32_ndk_api_level = 21
+    arm64_ndk_api_level = 21
   }
 
   declare_args() {
+    build_chromium_with_ohos_src = true
     product_name = ""
+    gpu_switch = "on"
   }
 
   # Defines the name the ohos build gives to the current host CPU
@@ -63,19 +68,20 @@ if (is_ohos) {
       "$ohos_build_root/base/location/services/location_locator/callback/include",
       "$ohos_build_root/base/location/services/location_common/common/include",
       "$ohos_build_root/base/location/interfaces/inner_api/include",
+      "$ohos_build_root/base/notification/eventhandler/interfaces/inner_api",
       "$ohos_build_root/base/location/services/utils/include",
       "$ohos_build_root/foundation/bundlemanager/bundle_framework/interfaces/innerkits/libeventhandler/include",
 
       "$ohos_build_root/foundation/appexecfwk/standard/interfaces/innerkits/libeventhandler/include",
       "$ohos_build_root/utils/native/base/include",
       "$ohos_build_root/base/hiviewdfx/hilog/interfaces/native/innerkits/include",
-      "$ohos_build_root/foundation/graphic/graphic/interfaces/inner_api/common",
+      "$ohos_build_root/foundation/graphic/graphic_2d/interfaces/inner_api/common",
       "$ohos_build_root/drivers/peripheral/display/interfaces/include",
-      "$ohos_build_root/foundation/graphic/graphic/utils/buffer_handle/export",
+      "$ohos_build_root/foundation/graphic/graphic_2d/utils/buffer_handle/export",
       "$ohos_build_root/foundation/multimedia/media_standard/interfaces/innerkits/native/media/include",
       "$ohos_build_root/foundation/multimedia/media_standard/interfaces/inner_api/native",
       "$ohos_build_root/drivers/peripheral/base",
-      "$ohos_build_root/foundation/graphic/graphic/interfaces/inner_api/surface",
+      "$ohos_build_root/foundation/graphic/graphic_2d/interfaces/inner_api/surface",
       "$ohos_build_root/foundation/graphic/surface/interfaces/kits",
       "$ohos_build_root/foundation/communication/ipc/interfaces/innerkits/ipc_core/include",
       "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_controller/include",
@@ -103,20 +109,26 @@ if (is_ohos) {
       "$ohos_build_root/base/location/services/location_common/common/include",
       "$ohos_build_root/base/location/interfaces/inner_api/include",
       "$ohos_build_root/base/location/services/utils/include",
-      "$ohos_build_root/base/location/services/location_locator/callback/include"
+      "$ohos_build_root/base/location/services/location_locator/callback/include",
     ]
 
     if (use_musl) {
       if (current_cpu == "arm") {
-        ohos_libs_dir = [ "$ohos_build_root/out/rk3568/packages/phone/system/lib" ]
+        ohos_libs_dir =
+            [ "$ohos_build_root/out/rk3568/packages/phone/system/lib" ]
       } else if (current_cpu == "arm64") {
-        ohos_libs_dir = [ "$ohos_build_root/out/rk3568/packages/phone/system/lib64" ]
+        ohos_libs_dir =
+            [ "$ohos_build_root/out/rk3568/packages/phone/system/lib64" ]
       }
     } else {
       if (current_cpu == "arm") {
-        ohos_libs_dir = [ "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib" ]
+        ohos_libs_dir = [
+          "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib",
+        ]
       } else if (current_cpu == "arm64") {
-        ohos_libs_dir = [ "$ohos_build_root/out/ohos-arm64-release/packages/phone/system/lib64" ]
+        ohos_libs_dir = [
+          "$ohos_build_root/out/ohos-arm64-release/packages/phone/system/lib64",
+        ]
       }
     }
   } else {
@@ -129,7 +141,18 @@ if (is_ohos) {
       ohos_build_root = "//ohos_ndk_aosp"
       ohos_ndk_root = "//ohos_ndk_aosp"
       ohos_toolchain_root = "$ohos_ndk_root/toolchains/clang-r353983c"
-      ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
+      if (current_cpu == "arm") {
+        ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
+      } else if (current_cpu == "arm64") {
+        ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm64"
+      } else {
+        assert(false, "Unsupport target cpu")
+      }
+    }
+
+    if (use_ohos_sdk_sysroot) {
+      ohos_sdk_root = "//ohos_sdk"
+      ohos_sysroot = "$ohos_sdk_root/native/$ohos_sdk_version/sysroot/"
     }
 
     # ohos include and libs dependencies, corresponding to gen_ohos_ndk.sh
@@ -160,9 +183,13 @@ if (is_ohos) {
       "$ohos_build_root/includes/aafwk/base/include",
       "$ohos_build_root/includes/json",
       "$ohos_build_root/includes/appexecfwk",
+      "$ohos_build_root/includes/ohos_adapter",
     ]
-    ohos_libs_dir = [
-      "$ohos_build_root/libs",
-    ]
+
+    if (current_cpu == "arm") {
+      ohos_libs_dir = [ "$ohos_build_root/libs" ]
+    } else if (current_cpu == "arm64") {
+      ohos_libs_dir = [ "$ohos_build_root/libs64" ]
+    }
   }
 }
diff --git a/cc/paint/paint_op_reader.cc b/cc/paint/paint_op_reader.cc
index 68429994cd952..201e67587f1d8 100644
--- a/cc/paint/paint_op_reader.cc
+++ b/cc/paint/paint_op_reader.cc
@@ -310,6 +310,10 @@ void PaintOpReader::Read(PaintImage* image) {
 
         SkImageInfo image_info =
             SkImageInfo::Make(width, height, color_type, kPremul_SkAlphaType);
+        if (pixel_size < image_info.computeMinByteSize()) {
+          SetInvalid();
+          return;
+        }
         const volatile void* pixel_data = ExtractReadableMemory(pixel_size);
         if (!valid_)
           return;
diff --git a/cef/BUILD.gn b/cef/BUILD.gn
index 19a8c155ce850..0abd6cd0686dd 100644
--- a/cef/BUILD.gn
+++ b/cef/BUILD.gn
@@ -113,6 +113,7 @@ import("//tools/grit/grit_rule.gni")
 import("//tools/v8_context_snapshot/v8_context_snapshot.gni")
 import("//ui/gl/features.gni")
 import("//v8/gni/v8.gni")
+import("//build/config/ohos/config.gni")
 if (is_clang) {
   import("//build/config/clang/clang.gni")
 }
@@ -397,6 +398,10 @@ test("libcef_static_unittests") {
 }
 
 static_library("libcef_static") {
+  if (gpu_switch == "off") {
+    defines = [ "DISABLE_GPU" ]
+  }
+
   sources = includes_common +
             gypi_paths.autogen_cpp_includes + [
     "libcef/browser/alloy/alloy_browser_context.cc",
@@ -415,6 +420,8 @@ static_library("libcef_static") {
     "libcef/browser/alloy/chrome_profile_alloy.h",
     "libcef/browser/alloy/alloy_content_browser_client.cc",
     "libcef/browser/alloy/alloy_content_browser_client.h",
+    "libcef/browser/alloy/alloy_web_contents_view_delegate.cc",
+    "libcef/browser/alloy/alloy_web_contents_view_delegate.h",
     "libcef/browser/audio_capturer.cc",
     "libcef/browser/audio_capturer.h",
     "libcef/browser/audio_loopback_stream_creator.cc",
@@ -573,6 +580,8 @@ static_library("libcef_static") {
     "libcef/browser/net/scheme_handler.h",
     "libcef/browser/net/throttle_handler.cc",
     "libcef/browser/net/throttle_handler.h",
+    "libcef/browser/net_database/cef_data_base_impl.cc",
+    "libcef/browser/net_database/cef_data_base_impl.h",
     "libcef/browser/net_service/browser_urlrequest_impl.cc",
     "libcef/browser/net_service/browser_urlrequest_impl.h",
     "libcef/browser/net_service/cookie_helper.cc",
@@ -615,6 +624,10 @@ static_library("libcef_static") {
     "libcef/browser/osr/video_consumer_osr.h",
     "libcef/browser/osr/web_contents_view_osr.cc",
     "libcef/browser/osr/web_contents_view_osr.h",
+    "libcef/browser/osr/touch_handle_drawable_osr.cc",
+    "libcef/browser/osr/touch_handle_drawable_osr.h",
+    "libcef/browser/osr/touch_selection_controller_client_osr.cc",
+    "libcef/browser/osr/touch_selection_controller_client_osr.h",
     "libcef/browser/path_util_impl.cc",
     "libcef/browser/permission/alloy_access_request.cc",
     "libcef/browser/permission/alloy_access_request.h",
@@ -656,6 +669,8 @@ static_library("libcef_static") {
     "libcef/browser/ssl_info_impl.h",
     "libcef/browser/ssl_status_impl.cc",
     "libcef/browser/ssl_status_impl.h",
+    "libcef/browser/storage/web_storage_impl.cc",
+    "libcef/browser/storage/web_storage_impl.h",
     "libcef/browser/stream_impl.cc",
     "libcef/browser/stream_impl.h",
     "libcef/browser/trace_impl.cc",
diff --git a/cef/cef_paths.gypi b/cef/cef_paths.gypi
index ba3e786a57241..65dff606c946e 100644
--- a/cef/cef_paths.gypi
+++ b/cef/cef_paths.gypi
@@ -8,7 +8,7 @@
 # by hand. See the translator.README.txt file in the tools directory for
 # more information.
 #
-# $hash=36817748589a28de2402aa1476d2820f0c3f7ead$
+# $hash=6877e69cfc3e737c9e7d4d00f15ea2f54b920548$
 #
 
 {
@@ -26,6 +26,7 @@
       'include/cef_context_menu_handler.h',
       'include/cef_cookie.h',
       'include/cef_crash_util.h',
+      'include/cef_data_base.h',
       'include/cef_devtools_message_observer.h',
       'include/cef_dialog_handler.h',
       'include/cef_display_handler.h',
@@ -85,6 +86,7 @@
       'include/cef_values.h',
       'include/cef_waitable_event.h',
       'include/cef_web_plugin.h',
+      'include/cef_web_storage.h',
       'include/cef_x509_certificate.h',
       'include/cef_xml_reader.h',
       'include/cef_zip_reader.h',
@@ -124,6 +126,7 @@
       'include/capi/cef_context_menu_handler_capi.h',
       'include/capi/cef_cookie_capi.h',
       'include/capi/cef_crash_util_capi.h',
+      'include/capi/cef_data_base_capi.h',
       'include/capi/cef_devtools_message_observer_capi.h',
       'include/capi/cef_dialog_handler_capi.h',
       'include/capi/cef_display_handler_capi.h',
@@ -183,6 +186,7 @@
       'include/capi/cef_values_capi.h',
       'include/capi/cef_waitable_event_capi.h',
       'include/capi/cef_web_plugin_capi.h',
+      'include/capi/cef_web_storage_capi.h',
       'include/capi/cef_x509_certificate_capi.h',
       'include/capi/cef_xml_reader_capi.h',
       'include/capi/cef_zip_reader_capi.h',
@@ -266,6 +270,8 @@
       'libcef_dll/cpptoc/domnode_cpptoc.h',
       'libcef_dll/ctocpp/domvisitor_ctocpp.cc',
       'libcef_dll/ctocpp/domvisitor_ctocpp.h',
+      'libcef_dll/cpptoc/data_base_cpptoc.cc',
+      'libcef_dll/cpptoc/data_base_cpptoc.h',
       'libcef_dll/ctocpp/delete_cookies_callback_ctocpp.cc',
       'libcef_dll/ctocpp/delete_cookies_callback_ctocpp.h',
       'libcef_dll/ctocpp/dev_tools_message_observer_ctocpp.cc',
@@ -310,6 +316,10 @@
       'libcef_dll/cpptoc/geolocation_acess_cpptoc.h',
       'libcef_dll/cpptoc/get_extension_resource_callback_cpptoc.cc',
       'libcef_dll/cpptoc/get_extension_resource_callback_cpptoc.h',
+      'libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.cc',
+      'libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.h',
+      'libcef_dll/ctocpp/get_origins_callback_ctocpp.cc',
+      'libcef_dll/ctocpp/get_origins_callback_ctocpp.h',
       'libcef_dll/cpptoc/image_cpptoc.cc',
       'libcef_dll/cpptoc/image_cpptoc.h',
       'libcef_dll/cpptoc/jsdialog_callback_cpptoc.cc',
@@ -422,6 +432,8 @@
       'libcef_dll/cpptoc/run_context_menu_callback_cpptoc.h',
       'libcef_dll/ctocpp/run_file_dialog_callback_ctocpp.cc',
       'libcef_dll/ctocpp/run_file_dialog_callback_ctocpp.h',
+      'libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.cc',
+      'libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.h',
       'libcef_dll/cpptoc/sslinfo_cpptoc.cc',
       'libcef_dll/cpptoc/sslinfo_cpptoc.h',
       'libcef_dll/cpptoc/sslstatus_cpptoc.cc',
@@ -514,6 +526,8 @@
       'libcef_dll/ctocpp/web_plugin_info_visitor_ctocpp.h',
       'libcef_dll/ctocpp/web_plugin_unstable_callback_ctocpp.cc',
       'libcef_dll/ctocpp/web_plugin_unstable_callback_ctocpp.h',
+      'libcef_dll/cpptoc/web_storage_cpptoc.cc',
+      'libcef_dll/cpptoc/web_storage_cpptoc.h',
       'libcef_dll/cpptoc/views/window_cpptoc.cc',
       'libcef_dll/cpptoc/views/window_cpptoc.h',
       'libcef_dll/ctocpp/views/window_delegate_ctocpp.cc',
@@ -586,6 +600,8 @@
       'libcef_dll/ctocpp/domnode_ctocpp.h',
       'libcef_dll/cpptoc/domvisitor_cpptoc.cc',
       'libcef_dll/cpptoc/domvisitor_cpptoc.h',
+      'libcef_dll/ctocpp/data_base_ctocpp.cc',
+      'libcef_dll/ctocpp/data_base_ctocpp.h',
       'libcef_dll/cpptoc/delete_cookies_callback_cpptoc.cc',
       'libcef_dll/cpptoc/delete_cookies_callback_cpptoc.h',
       'libcef_dll/cpptoc/dev_tools_message_observer_cpptoc.cc',
@@ -630,6 +646,10 @@
       'libcef_dll/ctocpp/geolocation_acess_ctocpp.h',
       'libcef_dll/ctocpp/get_extension_resource_callback_ctocpp.cc',
       'libcef_dll/ctocpp/get_extension_resource_callback_ctocpp.h',
+      'libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.cc',
+      'libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.h',
+      'libcef_dll/cpptoc/get_origins_callback_cpptoc.cc',
+      'libcef_dll/cpptoc/get_origins_callback_cpptoc.h',
       'libcef_dll/ctocpp/image_ctocpp.cc',
       'libcef_dll/ctocpp/image_ctocpp.h',
       'libcef_dll/ctocpp/jsdialog_callback_ctocpp.cc',
@@ -742,6 +762,8 @@
       'libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h',
       'libcef_dll/cpptoc/run_file_dialog_callback_cpptoc.cc',
       'libcef_dll/cpptoc/run_file_dialog_callback_cpptoc.h',
+      'libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.cc',
+      'libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.h',
       'libcef_dll/ctocpp/sslinfo_ctocpp.cc',
       'libcef_dll/ctocpp/sslinfo_ctocpp.h',
       'libcef_dll/ctocpp/sslstatus_ctocpp.cc',
@@ -834,6 +856,8 @@
       'libcef_dll/cpptoc/web_plugin_info_visitor_cpptoc.h',
       'libcef_dll/cpptoc/web_plugin_unstable_callback_cpptoc.cc',
       'libcef_dll/cpptoc/web_plugin_unstable_callback_cpptoc.h',
+      'libcef_dll/ctocpp/web_storage_ctocpp.cc',
+      'libcef_dll/ctocpp/web_storage_ctocpp.h',
       'libcef_dll/ctocpp/views/window_ctocpp.cc',
       'libcef_dll/ctocpp/views/window_ctocpp.h',
       'libcef_dll/cpptoc/views/window_delegate_cpptoc.cc',
diff --git a/cef/include/capi/cef_auth_callback_capi.h b/cef/include/capi/cef_auth_callback_capi.h
index 60424165135a8..98f2e7189e822 100644
--- a/cef/include/capi/cef_auth_callback_capi.h
+++ b/cef/include/capi/cef_auth_callback_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=01a33de48ac9780f78d606d8aee2429ddb0c81a2$
+// $hash=0938c1802b077b2b17708c6a8ee305984e079d64$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_AUTH_CALLBACK_CAPI_H_
@@ -59,18 +59,23 @@ typedef struct _cef_auth_callback_t {
   ///
   // Continue the authentication request.
   ///
-  void(CEF_CALLBACK* cont)(struct _cef_auth_callback_t* self,
-                           const cef_string_t* username,
-                           const cef_string_t* password);
+  void(CEF_CALLBACK *cont)(struct _cef_auth_callback_t *self,
+                           const cef_string_t *username,
+                           const cef_string_t *password);
 
   ///
   // Cancel the authentication request.
   ///
-  void(CEF_CALLBACK* cancel)(struct _cef_auth_callback_t* self);
+  void(CEF_CALLBACK *cancel)(struct _cef_auth_callback_t *self);
+
+  ///
+  // IsHttpAuthInfoSaved the authentication request.
+  ///
+  int(CEF_CALLBACK *is_http_auth_info_saved)(struct _cef_auth_callback_t *self);
 } cef_auth_callback_t;
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif  // CEF_INCLUDE_CAPI_CEF_AUTH_CALLBACK_CAPI_H_
+#endif // CEF_INCLUDE_CAPI_CEF_AUTH_CALLBACK_CAPI_H_
diff --git a/cef/include/capi/cef_browser_capi.h b/cef/include/capi/cef_browser_capi.h
index 08a853a713c2e..cb0c862369a17 100644
--- a/cef/include/capi/cef_browser_capi.h
+++ b/cef/include/capi/cef_browser_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=e434c8f59b8c8cbfa6c41550f4b53940c57d68f7$
+// $hash=c7e8c9198b6035c7a1a9e587bb5f1e14ec06c424$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_BROWSER_CAPI_H_
@@ -104,6 +104,12 @@ typedef struct _cef_browser_t {
   int(CEF_CALLBACK* can_go_back_or_forward)(struct _cef_browser_t* self,
                                             int num_steps);
 
+  ///
+  // Navigate backwards or forwards.
+  ///
+  void(CEF_CALLBACK* go_back_or_forward)(struct _cef_browser_t* self,
+                                         int num_steps);
+
   ///
   // DeleteHistory
   ///
@@ -124,6 +130,11 @@ typedef struct _cef_browser_t {
   ///
   void(CEF_CALLBACK* reload_ignore_cache)(struct _cef_browser_t* self);
 
+  ///
+  // Reload the current page with original url.
+  ///
+  void(CEF_CALLBACK* reload_original_url)(struct _cef_browser_t* self);
+
   ///
   // Stop loading the page.
   ///
@@ -799,6 +810,12 @@ typedef struct _cef_browser_host_t {
                                    int* type,
                                    cef_string_t* extra_data);
 
+  ///
+  // Set the inital page scale
+  ///
+  void(CEF_CALLBACK* set_initial_scale)(struct _cef_browser_host_t* self,
+                                        float scale);
+
   ///
   // Gets the progress for the current page.
   ///
@@ -1065,6 +1082,12 @@ typedef struct _cef_browser_host_t {
   // Get web debugging access
   ///
   int(CEF_CALLBACK* get_web_debugging_access)(struct _cef_browser_host_t* self);
+
+  ///
+  // GetImageForContextNode
+  ///
+  void(CEF_CALLBACK* get_image_for_context_node)(
+      struct _cef_browser_host_t* self);
 } cef_browser_host_t;
 
 ///
diff --git a/cef/include/capi/cef_context_menu_handler_capi.h b/cef/include/capi/cef_context_menu_handler_capi.h
index f83dfa36468f4..e5737699c3235 100644
--- a/cef/include/capi/cef_context_menu_handler_capi.h
+++ b/cef/include/capi/cef_context_menu_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=fd33ce439e4379d231b6be16bdc1786f314d98e4$
+// $hash=3da039a85d08c4fc670fe9f63bfa7e1dabdafa09$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_CONTEXT_MENU_HANDLER_CAPI_H_
@@ -43,6 +43,7 @@
 #include "include/capi/cef_base_capi.h"
 #include "include/capi/cef_browser_capi.h"
 #include "include/capi/cef_frame_capi.h"
+#include "include/capi/cef_image_capi.h"
 #include "include/capi/cef_menu_model_capi.h"
 
 #ifdef __cplusplus
@@ -74,6 +75,29 @@ typedef struct _cef_run_context_menu_callback_t {
   void(CEF_CALLBACK* cancel)(struct _cef_run_context_menu_callback_t* self);
 } cef_run_context_menu_callback_t;
 
+///
+// Callback structure used for continuation of custom quick menu display.
+///
+typedef struct _cef_run_quick_menu_callback_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // Complete quick menu display by selecting the specified |command_id| and
+  // |event_flags|.
+  ///
+  void(CEF_CALLBACK* cont)(struct _cef_run_quick_menu_callback_t* self,
+                           int command_id,
+                           cef_event_flags_t event_flags);
+
+  ///
+  // Cancel quick menu display.
+  ///
+  void(CEF_CALLBACK* cancel)(struct _cef_run_quick_menu_callback_t* self);
+} cef_run_quick_menu_callback_t;
+
 ///
 // Implement this structure to handle context menu events. The functions of this
 // structure will be called on the UI thread.
@@ -139,6 +163,53 @@ typedef struct _cef_context_menu_handler_t {
       struct _cef_context_menu_handler_t* self,
       struct _cef_browser_t* browser,
       struct _cef_frame_t* frame);
+
+  ///
+  // Called to allow custom display of the quick menu for a windowless browser.
+  // |location| is the top left corner of the selected region. |size| is the
+  // size of the selected region. |edit_state_flags| is a combination of flags
+  // that represent the state of the quick menu. Return true (1) if the menu
+  // will be handled and execute |callback| either synchronously or
+  // asynchronously with the selected command ID. Return false (0) to cancel the
+  // menu.
+  ///
+  int(CEF_CALLBACK* run_quick_menu)(
+      struct _cef_context_menu_handler_t* self,
+      struct _cef_browser_t* browser,
+      struct _cef_frame_t* frame,
+      const cef_point_t* location,
+      const cef_size_t* size,
+      cef_quick_menu_edit_state_flags_t edit_state_flags,
+      struct _cef_run_quick_menu_callback_t* callback);
+
+  ///
+  // Called to execute a command selected from the quick menu for a windowless
+  // browser. Return true (1) if the command was handled or false (0) for the
+  // default implementation. See cef_menu_id_t for command IDs that have default
+  // implementations.
+  ///
+  int(CEF_CALLBACK* on_quick_menu_command)(
+      struct _cef_context_menu_handler_t* self,
+      struct _cef_browser_t* browser,
+      struct _cef_frame_t* frame,
+      int command_id,
+      cef_event_flags_t event_flags);
+
+  ///
+  // Called when the quick menu for a windowless browser is dismissed
+  // irregardless of whether the menu was canceled or a command was selected.
+  ///
+  void(CEF_CALLBACK* on_quick_menu_dismissed)(
+      struct _cef_context_menu_handler_t* self,
+      struct _cef_browser_t* browser,
+      struct _cef_frame_t* frame);
+
+  ///
+  // Called when GetImageForContextNode function get image for context menu.
+  ///
+  void(CEF_CALLBACK* on_get_image_for_context_node)(
+      struct _cef_context_menu_handler_t* self,
+      struct _cef_image_t* image);
 } cef_context_menu_handler_t;
 
 ///
diff --git a/cef/include/capi/cef_data_base_capi.h b/cef/include/capi/cef_data_base_capi.h
new file mode 100644
index 0000000000000..e276ce87c91c1
--- /dev/null
+++ b/cef/include/capi/cef_data_base_capi.h
@@ -0,0 +1,95 @@
+// Copyright (c) 2022 Marshall A. Greenblatt. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the name Chromium Embedded
+// Framework nor the names of its contributors may be used to endorse
+// or promote products derived from this software without specific prior
+// written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool and should not edited
+// by hand. See the translator.README.txt file in the tools directory for
+// more information.
+//
+// $hash=ec6ed1e2d5ec96630f13da6fa95395d1147ec032$
+//
+
+#ifndef CEF_INCLUDE_CAPI_CEF_DATA_BASE_CAPI_H_
+#define CEF_INCLUDE_CAPI_CEF_DATA_BASE_CAPI_H_
+#pragma once
+
+#include "include/capi/cef_base_capi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+///
+// Structure used for managing web data base.
+///
+typedef struct _cef_data_base_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // clear all http auth data
+  ///
+  void(CEF_CALLBACK *delete_http_auth_credentials)(
+      struct _cef_data_base_t *self);
+
+  ///
+  // get whether there has any http auth data.
+  ///
+  int(CEF_CALLBACK *exist_http_auth_credentials)(struct _cef_data_base_t *self);
+
+  ///
+  // save http auth data.
+  ///
+  void(CEF_CALLBACK *save_http_auth_credentials)(struct _cef_data_base_t *self,
+                                                 const cef_string_t *host,
+                                                 const cef_string_t *realm,
+                                                 const cef_string_t *username,
+                                                 const char *password);
+
+  ///
+  // get http auth data by host and realm.
+  ///
+  void(CEF_CALLBACK *get_http_auth_credentials)(
+      struct _cef_data_base_t *self, const cef_string_t *host,
+      const cef_string_t *realm, cef_string_list_t username_password);
+} cef_data_base_t;
+
+///
+// Returns the global data base instance.
+///
+CEF_EXPORT cef_data_base_t *cef_data_base_get_global();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CEF_INCLUDE_CAPI_CEF_DATA_BASE_CAPI_H_
diff --git a/cef/include/capi/cef_display_handler_capi.h b/cef/include/capi/cef_display_handler_capi.h
index 5f5a0f34fcda5..e7b396601ca7e 100644
--- a/cef/include/capi/cef_display_handler_capi.h
+++ b/cef/include/capi/cef_display_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=0c615f158ce150e61102f4b3493b50951a302231$
+// $hash=0bc6d6a8d83ddea6a7ae5e47a2b171f60cbb06d9$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_DISPLAY_HANDLER_CAPI_H_
@@ -173,6 +173,14 @@ typedef struct _cef_display_handler_t {
       cef_cursor_handle_t cursor,
       cef_cursor_type_t type,
       const struct _cef_cursor_info_t* custom_cursor_info);
+
+  ///
+  // Called when the page scale factor has changed.
+  ///
+  void(CEF_CALLBACK* on_scale_changed)(struct _cef_display_handler_t* self,
+                                       struct _cef_browser_t* browser,
+                                       float old_page_scale_factor,
+                                       float new_page_scale_factor);
 } cef_display_handler_t;
 
 #ifdef __cplusplus
diff --git a/cef/include/capi/cef_render_handler_capi.h b/cef/include/capi/cef_render_handler_capi.h
index a57a968602ba8..0bbd5a9528f1b 100644
--- a/cef/include/capi/cef_render_handler_capi.h
+++ b/cef/include/capi/cef_render_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=da1762d0fa16d2e4c2b7281bcaeb6181e00eb1af$
+// $hash=abc9692a81344244c2936c37b1a2d1bcd7bf697a$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_RENDER_HANDLER_CAPI_H_
@@ -159,6 +159,25 @@ typedef struct _cef_render_handler_t {
                                            cef_rect_t const* dirtyRects,
                                            void* shared_handle);
 
+  ///
+  // Called to retrieve the size of the touch handle for the specified
+  // |orientation|.
+  ///
+  void(CEF_CALLBACK* get_touch_handle_size)(
+      struct _cef_render_handler_t* self,
+      struct _cef_browser_t* browser,
+      cef_horizontal_alignment_t orientation,
+      cef_size_t* size);
+
+  ///
+  // Called when touch handle state is updated. The client is responsible for
+  // rendering the touch handles.
+  ///
+  void(CEF_CALLBACK* on_touch_handle_state_changed)(
+      struct _cef_render_handler_t* self,
+      struct _cef_browser_t* browser,
+      const struct _cef_touch_handle_state_t* state);
+
   ///
   // Called when the user starts dragging content in the web view. Contextual
   // information about the dragged content is supplied by |drag_data|. (|x|,
diff --git a/cef/include/capi/cef_request_context_capi.h b/cef/include/capi/cef_request_context_capi.h
index 3dc3ab3a3f185..008aaa7f4ad98 100644
--- a/cef/include/capi/cef_request_context_capi.h
+++ b/cef/include/capi/cef_request_context_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=9faa2d004412793c0b4d9f9a487197bb02dc6da8$
+// $hash=b1a351be3e37d34c8e7ad3d30481d59d955102f4$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_REQUEST_CONTEXT_CAPI_H_
@@ -42,10 +42,12 @@
 
 #include "include/capi/cef_callback_capi.h"
 #include "include/capi/cef_cookie_capi.h"
+#include "include/capi/cef_data_base_capi.h"
 #include "include/capi/cef_extension_capi.h"
 #include "include/capi/cef_extension_handler_capi.h"
 #include "include/capi/cef_media_router_capi.h"
 #include "include/capi/cef_values_capi.h"
+#include "include/capi/cef_web_storage_capi.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -139,6 +141,21 @@ typedef struct _cef_request_context_t {
       struct _cef_request_context_t* self,
       struct _cef_completion_callback_t* callback);
 
+  ///
+  // Returns the web data base for this object.
+  ///
+  struct _cef_data_base_t*(CEF_CALLBACK* get_data_base)(
+      struct _cef_request_context_t* self);
+
+  ///
+  // Returns the web strorage for this object. If |callback| is non-NULL it will
+  // be executed asnychronously on the UI thread after the manager's storage has
+  // been initialized.
+  ///
+  struct _cef_web_storage_t*(CEF_CALLBACK* get_web_storage)(
+      struct _cef_request_context_t* self,
+      struct _cef_completion_callback_t* callback);
+
   ///
   // Register a scheme handler factory for the specified |scheme_name| and
   // optional |domain_name|. An NULL |domain_name| value for a standard scheme
diff --git a/cef/include/capi/cef_web_storage_capi.h b/cef/include/capi/cef_web_storage_capi.h
new file mode 100644
index 0000000000000..b013bf001c667
--- /dev/null
+++ b/cef/include/capi/cef_web_storage_capi.h
@@ -0,0 +1,161 @@
+// Copyright (c) 2022 Marshall A. Greenblatt. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the name Chromium Embedded
+// Framework nor the names of its contributors may be used to endorse
+// or promote products derived from this software without specific prior
+// written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool and should not edited
+// by hand. See the translator.README.txt file in the tools directory for
+// more information.
+//
+// $hash=4f98d594eaa1a0b41b534f51da2639bfc9a12778$
+//
+
+#ifndef CEF_INCLUDE_CAPI_CEF_WEB_STORAGE_CAPI_H_
+#define CEF_INCLUDE_CAPI_CEF_WEB_STORAGE_CAPI_H_
+#pragma once
+
+#include "include/capi/cef_base_capi.h"
+#include "include/capi/cef_callback_capi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct _cef_get_origin_usage_or_quota_callback_t;
+struct _cef_get_origins_callback_t;
+
+///
+// Structure used for managing storage. The functions of this structure may be
+// called on any thread unless otherwise indicated.
+///
+typedef struct _cef_web_storage_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // Clears all storage currently being used by the JavaScript storage APIs.
+  ///
+  void(CEF_CALLBACK* delete_all_data)(struct _cef_web_storage_t* self);
+
+  ///
+  // Clears the storage currently being used by the Web SQL Database APIs by the
+  // given origin.
+  ///
+  void(CEF_CALLBACK* delete_origin)(struct _cef_web_storage_t* self,
+                                    const cef_string_t* origin);
+
+  ///
+  // Gets the origins currently using the Web SQL Database APIs.
+  ///
+  void(CEF_CALLBACK* get_origins)(struct _cef_web_storage_t* self,
+                                  struct _cef_get_origins_callback_t* callback);
+
+  ///
+  // Gets the storage quota for the Web SQL Database API for the given origin.
+  ///
+  void(CEF_CALLBACK* get_origin_quota)(
+      struct _cef_web_storage_t* self,
+      const cef_string_t* origin,
+      struct _cef_get_origin_usage_or_quota_callback_t* callback);
+
+  ///
+  // Gets the amount of storage currently being used by the Web SQL Database
+  // APIs by the given origin.
+  ///
+  void(CEF_CALLBACK* get_origin_usage)(
+      struct _cef_web_storage_t* self,
+      const cef_string_t* origin,
+      struct _cef_get_origin_usage_or_quota_callback_t* callback);
+} cef_web_storage_t;
+
+///
+// Returns the global web storage.
+///
+CEF_EXPORT cef_web_storage_t* cef_web_storage_get_global_manager(
+    struct _cef_completion_callback_t* callback);
+
+///
+// Structure to implement to be notified of asynchronous completion via
+// cef_web_storage_t::get_origins().
+///
+typedef struct _cef_get_origins_callback_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // Method that will be called upon Origins completion.
+  ///
+  void(CEF_CALLBACK* on_origins)(struct _cef_get_origins_callback_t* self,
+                                 cef_string_list_t origins);
+
+  ///
+  // Method that will be called upon Usages completion.
+  ///
+  void(CEF_CALLBACK* on_usages)(struct _cef_get_origins_callback_t* self,
+                                cef_string_list_t usages);
+
+  ///
+  // Method that will be called upon Quotas completion.
+  ///
+  void(CEF_CALLBACK* on_quotas)(struct _cef_get_origins_callback_t* self,
+                                cef_string_list_t quotas);
+
+  ///
+  // Method that will be called upon completion.
+  ///
+  void(CEF_CALLBACK* on_complete)(struct _cef_get_origins_callback_t* self);
+} cef_get_origins_callback_t;
+
+///
+// Structure to implement to be notified of asynchronous completion via
+// cef_web_storage_t::GetOriginQuota.
+///
+typedef struct _cef_get_origin_usage_or_quota_callback_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // Method that will be called upon completion.
+  ///
+  void(CEF_CALLBACK* on_complete)(
+      struct _cef_get_origin_usage_or_quota_callback_t* self,
+      int64 nums);
+} cef_get_origin_usage_or_quota_callback_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // CEF_INCLUDE_CAPI_CEF_WEB_STORAGE_CAPI_H_
diff --git a/cef/include/cef_api_hash.h b/cef/include/cef_api_hash.h
index 26cd4c0945a15..012e3376c70ea 100644
--- a/cef/include/cef_api_hash.h
+++ b/cef/include/cef_api_hash.h
@@ -42,15 +42,15 @@
 // way that may cause binary incompatibility with other builds. The universal
 // hash value will change if any platform is affected whereas the platform hash
 // values will change only if that particular platform is affected.
-#define CEF_API_HASH_UNIVERSAL "e71457f3fd884ff5c35e8be2ad91e649d7b00e45"
+#define CEF_API_HASH_UNIVERSAL "4d742811e4dc7cc4871c9641fcf22685337736c5"
 #if defined(OS_WIN)
-#define CEF_API_HASH_PLATFORM "b950292957927fcf6a52690fb196331a3a44ce67"
+#define CEF_API_HASH_PLATFORM "653e3a03bb1a05545ae7a42e8782e2fc57745831"
 #elif defined(OS_MAC)
-#define CEF_API_HASH_PLATFORM "3b5736924b75007ae90ee5bc9979b829c564581d"
+#define CEF_API_HASH_PLATFORM "3463f005e66e2c13eed489c5c7b81b13d346a719"
 #elif defined(OS_LINUX)
-#define CEF_API_HASH_PLATFORM "3ed0e1dedda07cfe679f709fb96d40ca92900395"
+#define CEF_API_HASH_PLATFORM "0b8cfe1d67c0ae1b70f0fca7eb1430a3a4e571da"
 #elif defined(OS_OHOS)
-#define CEF_API_HASH_PLATFORM "3ed0e1dedda07cfe679f709fb96d40ca92900395"
+#define CEF_API_HASH_PLATFORM "0b8cfe1d67c0ae1b70f0fca7eb1430a3a4e571da"
 #endif
 
 #ifdef __cplusplus
diff --git a/cef/include/cef_auth_callback.h b/cef/include/cef_auth_callback.h
index fc8a10a9efbb8..35703605bac6c 100644
--- a/cef/include/cef_auth_callback.h
+++ b/cef/include/cef_auth_callback.h
@@ -59,6 +59,12 @@ class CefAuthCallback : public virtual CefBaseRefCounted {
   ///
   /*--cef()--*/
   virtual void Cancel() = 0;
+
+  ///
+  // IsHttpAuthInfoSaved the authentication request.
+  ///
+  /*--cef()--*/
+  virtual bool IsHttpAuthInfoSaved() = 0;
 };
 
 #endif  // CEF_INCLUDE_CEF_AUTH_CALLBACK_H_
diff --git a/cef/include/cef_browser.h b/cef/include/cef_browser.h
index 43a571f43df74..f9e8055c98c67 100644
--- a/cef/include/cef_browser.h
+++ b/cef/include/cef_browser.h
@@ -100,6 +100,12 @@ class CefBrowser : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual bool CanGoBackOrForward(int num_steps) = 0;
 
+  ///
+  // Navigate backwards or forwards.
+  ///
+  /*--cef()--*/
+  virtual void GoBackOrForward(int num_steps) = 0;
+
   ///
   // DeleteHistory
   ///
@@ -124,6 +130,15 @@ class CefBrowser : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void ReloadIgnoreCache() = 0;
 
+  /* ---------- ohos nweb_ex add begin --------- */
+  ///
+  // Reload the current page with original url.
+  ///
+  /*--cef()--*/
+  virtual void ReloadOriginalUrl() = 0;
+
+  /* ---------- ohos nweb_ex add end --------- */
+
   ///
   // Stop loading the page.
   ///
@@ -811,6 +826,7 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   ///
   /*--cef(optional_param=method_list)--*/
   virtual void UnregisterArkJSfunction(const CefString& object_name, const std::vector<CefString>& method_list) = 0;
+
   /* ---------- ohos webview add end --------- */
 
   ///
@@ -825,6 +841,12 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void GetHitData(int& type, CefString& extra_data) = 0;
 
+  ///
+  // Set the inital page scale
+  ///
+  /*--cef()--*/
+  virtual void SetInitialScale(float scale) = 0;
+
   ///
   // Gets the progress for the current page.
   ///
@@ -1096,6 +1118,12 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   ///
   /*--cef()--*/
   virtual bool GetWebDebuggingAccess() = 0;
+
+  ///
+  // GetImageForContextNode
+  ///
+  /*--cef()--*/
+  virtual void GetImageForContextNode() = 0;
 };
 
 ///
diff --git a/cef/include/cef_context_menu_handler.h b/cef/include/cef_context_menu_handler.h
index 61ff67ab61160..484a65bfebe05 100644
--- a/cef/include/cef_context_menu_handler.h
+++ b/cef/include/cef_context_menu_handler.h
@@ -41,6 +41,7 @@
 #include "include/cef_base.h"
 #include "include/cef_browser.h"
 #include "include/cef_frame.h"
+#include "include/cef_image.h"
 #include "include/cef_menu_model.h"
 
 class CefContextMenuParams;
@@ -51,14 +52,12 @@ class CefContextMenuParams;
 /*--cef(source=library)--*/
 class CefRunContextMenuCallback : public virtual CefBaseRefCounted {
  public:
-  typedef cef_event_flags_t EventFlags;
-
   ///
   // Complete context menu display by selecting the specified |command_id| and
   // |event_flags|.
   ///
   /*--cef(capi_name=cont)--*/
-  virtual void Continue(int command_id, EventFlags event_flags) = 0;
+  virtual void Continue(int command_id, cef_event_flags_t event_flags) = 0;
 
   ///
   // Cancel context menu display.
@@ -67,6 +66,26 @@ class CefRunContextMenuCallback : public virtual CefBaseRefCounted {
   virtual void Cancel() = 0;
 };
 
+///
+// Callback interface used for continuation of custom quick menu display.
+///
+/*--cef(source=library)--*/
+class CefRunQuickMenuCallback : public virtual CefBaseRefCounted {
+ public:
+  ///
+  // Complete quick menu display by selecting the specified |command_id| and
+  // |event_flags|.
+  ///
+  /*--cef(capi_name=cont)--*/
+  virtual void Continue(int command_id, cef_event_flags_t event_flags) = 0;
+
+  ///
+  // Cancel quick menu display.
+  ///
+  /*--cef()--*/
+  virtual void Cancel() = 0;
+};
+
 ///
 // Implement this interface to handle context menu events. The methods of this
 // class will be called on the UI thread.
@@ -75,6 +94,7 @@ class CefRunContextMenuCallback : public virtual CefBaseRefCounted {
 class CefContextMenuHandler : public virtual CefBaseRefCounted {
  public:
   typedef cef_event_flags_t EventFlags;
+  typedef cef_quick_menu_edit_state_flags_t QuickMenuEditStateFlags;
 
   ///
   // Called before a context menu is displayed. |params| provides information
@@ -131,6 +151,53 @@ class CefContextMenuHandler : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void OnContextMenuDismissed(CefRefPtr<CefBrowser> browser,
                                       CefRefPtr<CefFrame> frame) {}
+
+  ///
+  // Called to allow custom display of the quick menu for a windowless browser.
+  // |location| is the top left corner of the selected region. |size| is the
+  // size of the selected region. |edit_state_flags| is a combination of flags
+  // that represent the state of the quick menu. Return true if the menu will be
+  // handled and execute |callback| either synchronously or asynchronously with
+  // the selected command ID. Return false to cancel the menu.
+  ///
+  /*--cef()--*/
+  virtual bool RunQuickMenu(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            const CefPoint& location,
+                            const CefSize& size,
+                            QuickMenuEditStateFlags edit_state_flags,
+                            CefRefPtr<CefRunQuickMenuCallback> callback) {
+    return false;
+  }
+
+  ///
+  // Called to execute a command selected from the quick menu for a windowless
+  // browser. Return true if the command was handled or false for the default
+  // implementation. See cef_menu_id_t for command IDs that have default
+  // implementations.
+  ///
+  /*--cef()--*/
+  virtual bool OnQuickMenuCommand(CefRefPtr<CefBrowser> browser,
+                                  CefRefPtr<CefFrame> frame,
+                                  int command_id,
+                                  EventFlags event_flags) {
+    return false;
+  }
+
+  ///
+  // Called when the quick menu for a windowless browser is dismissed
+  // irregardless of whether the menu was canceled or a command was selected.
+  ///
+  /*--cef()--*/
+  virtual void OnQuickMenuDismissed(CefRefPtr<CefBrowser> browser,
+                                    CefRefPtr<CefFrame> frame) {}
+
+  ///
+  // Called when GetImageForContextNode function get image for
+  // context menu.
+  ///
+  /*--cef()--*/
+  virtual void OnGetImageForContextNode(CefRefPtr<CefImage> image) {}
 };
 
 ///
diff --git a/cef/include/cef_data_base.h b/cef/include/cef_data_base.h
new file mode 100644
index 0000000000000..5f628e66a3a8e
--- /dev/null
+++ b/cef/include/cef_data_base.h
@@ -0,0 +1,83 @@
+// Copyright (c) 2022 Marshall A. Greenblatt. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the name Chromium Embedded
+// Framework nor the names of its contributors may be used to endorse
+// or promote products derived from this software without specific prior
+// written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ---------------------------------------------------------------------------
+//
+// The contents of this file must follow a specific format in order to
+// support the CEF translator tool. See the translator.README.txt file in the
+// tools directory for more information.
+//
+
+#ifndef CEF_INCLUDE_CEF_DATA_BASE_H_
+#define CEF_INCLUDE_CEF_DATA_BASE_H_
+#pragma once
+
+#include <vector>
+#include "include/cef_base.h"
+
+///
+// Class used for managing web data base.
+///
+/*--cef(source=library,no_debugct_check)--*/
+class CefDataBase : public virtual CefBaseRefCounted {
+ public:
+ ///
+  // Returns the global data base instance.
+  ///
+  /*--cef()--*/
+  static CefRefPtr<CefDataBase> GetGlobalDataBase();
+
+  ///
+  // clear all http auth data
+  ///
+  /*--cef()--*/
+  virtual void DeleteHttpAuthCredentials() = 0;
+
+  ///
+  // get whether there has any http auth data.
+  ///
+  /*--cef()--*/
+  virtual bool ExistHttpAuthCredentials() = 0;
+
+  ///
+  // save http auth data.
+  ///
+  /*--cef()--*/
+  virtual void SaveHttpAuthCredentials(const CefString& host, const CefString& realm,
+    const CefString& username, const char* password) = 0;
+
+  ///
+  // get http auth data by host and realm.
+  ///
+  /*--cef()--*/
+  virtual void GetHttpAuthCredentials(const CefString& host, const CefString& realm,
+    std::vector<CefString>& username_password) = 0;
+};
+
+#endif  // CEF_INCLUDE_CEF_DATA_BASE_H_
\ No newline at end of file
diff --git a/cef/include/cef_display_handler.h b/cef/include/cef_display_handler.h
index cffbbe6fba980..2080b5129f8ba 100644
--- a/cef/include/cef_display_handler.h
+++ b/cef/include/cef_display_handler.h
@@ -166,6 +166,14 @@ class CefDisplayHandler : public virtual CefBaseRefCounted {
                               const CefCursorInfo& custom_cursor_info) {
     return false;
   }
+
+  ///
+  // Called when the page scale factor has changed.
+  ///
+  /*--cef()--*/
+  virtual void OnScaleChanged(CefRefPtr<CefBrowser> browser,
+                              float old_page_scale_factor,
+                              float new_page_scale_factor) {}
 };
 
 #endif  // CEF_INCLUDE_CEF_DISPLAY_HANDLER_H_
diff --git a/cef/include/cef_render_handler.h b/cef/include/cef_render_handler.h
index 286418081d85f..22c41245a96b6 100644
--- a/cef/include/cef_render_handler.h
+++ b/cef/include/cef_render_handler.h
@@ -161,6 +161,23 @@ class CefRenderHandler : public virtual CefBaseRefCounted {
                                   const RectList& dirtyRects,
                                   void* shared_handle) {}
 
+  ///
+  // Called to retrieve the size of the touch handle for the specified
+  // |orientation|.
+  ///
+  /*--cef()--*/
+  virtual void GetTouchHandleSize(CefRefPtr<CefBrowser> browser,
+                                  cef_horizontal_alignment_t orientation,
+                                  CefSize& size) {}
+
+  ///
+  // Called when touch handle state is updated. The client is responsible for
+  // rendering the touch handles.
+  ///
+  /*--cef()--*/
+  virtual void OnTouchHandleStateChanged(CefRefPtr<CefBrowser> browser,
+                                         const CefTouchHandleState& state) {}
+
   ///
   // Called when the user starts dragging content in the web view. Contextual
   // information about the dragged content is supplied by |drag_data|.
diff --git a/cef/include/cef_request_context.h b/cef/include/cef_request_context.h
index ca1a55e5f731f..204d3c492412c 100644
--- a/cef/include/cef_request_context.h
+++ b/cef/include/cef_request_context.h
@@ -42,10 +42,12 @@
 
 #include "include/cef_callback.h"
 #include "include/cef_cookie.h"
+#include "include/cef_data_base.h"
 #include "include/cef_extension.h"
 #include "include/cef_extension_handler.h"
 #include "include/cef_media_router.h"
 #include "include/cef_values.h"
+#include "include/cef_web_storage.h"
 
 class CefRequestContextHandler;
 class CefSchemeHandlerFactory;
@@ -153,6 +155,21 @@ class CefRequestContext : public virtual CefBaseRefCounted {
   virtual CefRefPtr<CefCookieManager> GetCookieManager(
       CefRefPtr<CefCompletionCallback> callback) = 0;
 
+  ///
+  // Returns the web data base for this object.
+  ///
+  /*--cef()--*/
+  virtual CefRefPtr<CefDataBase> GetDataBase() = 0;
+
+  ///
+  // Returns the web strorage for this object. If |callback| is non-NULL it
+  // will be executed asnychronously on the UI thread after the manager's
+  // storage has been initialized.
+  ///
+  /*--cef(optional_param=callback)--*/
+  virtual CefRefPtr<CefWebStorage> GetWebStorage(
+      CefRefPtr<CefCompletionCallback> callback) = 0;
+
   ///
   // Register a scheme handler factory for the specified |scheme_name| and
   // optional |domain_name|. An empty |domain_name| value for a standard scheme
diff --git a/cef/include/cef_web_storage.h b/cef/include/cef_web_storage.h
new file mode 100644
index 0000000000000..deb21a460a0aa
--- /dev/null
+++ b/cef/include/cef_web_storage.h
@@ -0,0 +1,109 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_INCLUDE_CEF_STORAGE_H_
+#define CEF_INCLUDE_CEF_STORAGE_H_
+#pragma once
+
+#include <vector>
+#include "include/cef_base.h"
+#include "include/cef_callback.h"
+
+class CefGetOriginsCallback;
+class CefGetOriginUsageOrQuotaCallback;
+
+///
+// Class used for managing storage. The methods of this class may be called on
+// any thread unless otherwise indicated.
+///
+/*--cef(source=library,no_debugct_check)--*/
+class CefWebStorage : public virtual CefBaseRefCounted {
+ public:
+  ///
+  // Returns the global web storage.
+  ///
+  /*--cef(optional_param=callback)--*/
+  static CefRefPtr<CefWebStorage> GetGlobalManager(
+    CefRefPtr<CefCompletionCallback> callback);
+
+  ///
+  // Clears all storage currently being used by the JavaScript storage APIs.
+  ///
+  /*--cef()--*/
+  virtual void DeleteAllData() = 0;
+
+  ///
+  // Clears the storage currently being used by the Web SQL Database APIs by the given origin.
+  ///
+  /*--cef()--*/
+  virtual void DeleteOrigin(const CefString& origin) = 0;
+
+  ///
+  // Gets the origins currently using the Web SQL Database APIs.
+  ///
+  /*--cef(optional_param=callback)--*/
+  virtual void GetOrigins(CefRefPtr<CefGetOriginsCallback> callback) = 0;
+
+  ///
+  // Gets the storage quota for the Web SQL Database API for the given origin.
+  ///
+  /*--cef(optional_param=origin,optional_param=callback)--*/
+  virtual void GetOriginQuota(const CefString& origin,
+                              CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) = 0;
+
+  ///
+  // Gets the amount of storage currently being used by the Web SQL Database APIs by the given origin.
+  ///
+  /*--cef(optional_param=origin,optional_param=callback)--*/
+  virtual void GetOriginUsage(const CefString& origin,
+                              CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) = 0;
+};
+
+///
+// Interface to implement to be notified of asynchronous completion via
+// CefWebStorage::GetOrigins().
+///
+/*--cef(source=client)--*/
+class CefGetOriginsCallback : public virtual CefBaseRefCounted {
+ public:
+  ///
+  // Method that will be called upon Origins completion.
+  ///
+  /*--cef()--*/
+  virtual void OnOrigins(std::vector<CefString>& origins) = 0;
+
+  ///
+  // Method that will be called upon Usages completion.
+  ///
+  /*--cef()--*/
+  virtual void OnUsages(std::vector<CefString>& usages) = 0;
+
+  ///
+  // Method that will be called upon Quotas completion.
+  ///
+  /*--cef()--*/
+  virtual void OnQuotas(std::vector<CefString>& quotas) = 0;
+
+  ///
+  // Method that will be called upon completion.
+  ///
+  /*--cef()--*/
+  virtual void OnComplete() = 0;
+};
+
+///
+// Interface to implement to be notified of asynchronous completion via
+// CefWebStorage::GetOriginQuota.
+///
+/*--cef(source=client)--*/
+class CefGetOriginUsageOrQuotaCallback : public virtual CefBaseRefCounted {
+ public:
+  ///
+  // Method that will be called upon completion.
+  ///
+  /*--cef()--*/
+  virtual void OnComplete(int64 nums) = 0;
+};
+
+#endif  // CEF_INCLUDE_CEF_STORAGE_H_
diff --git a/cef/include/internal/cef_types.h b/cef/include/internal/cef_types.h
index 1c5fb3b85c082..e788e57040a41 100644
--- a/cef/include/internal/cef_types.h
+++ b/cef/include/internal/cef_types.h
@@ -90,6 +90,8 @@ typedef uint32 cef_color_t;
 extern "C" {
 #endif
 
+#define DEFAULT_SCALE 50
+
 ///
 // Log severity levels.
 ///
@@ -710,6 +712,7 @@ typedef struct _cef_browser_settings_t {
   bool supports_double_tap_zoom;
   bool supports_multi_touch_zoom;
   cef_state_t initialize_at_minimum_page_scale;
+  bool viewport_meta_enabled;
   /* ohos webview end */
 } cef_browser_settings_t;
 
@@ -1629,6 +1632,17 @@ typedef enum {
   JSDIALOGTYPE_PROMPT,
 } cef_jsdialog_type_t;
 
+///
+// Screen orientation types.
+///
+typedef enum {
+  UNDEFINED,
+  PORTRAIT_PRIMARY,
+  PORTRAIT_SECONDARY,
+  LANDSCAPE_PRIMARY,
+  LANDSCAPE_SECONDARY
+} cef_screen_orientation_type_t;
+
 ///
 // Screen information used when window rendering is disabled. This structure is
 // passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled
@@ -1683,6 +1697,16 @@ typedef struct _cef_screen_info_t {
   // available surface for rendering popup views.
   ///
   cef_rect_t available_rect;
+
+  ///
+  // This is screen orientation angle.
+  ///
+  int16_t angle;
+
+  ///
+  // This is screen orientation type.
+  ///
+  cef_screen_orientation_type_t orientation;
 } cef_screen_info_t;
 
 ///
@@ -1740,6 +1764,10 @@ typedef enum {
   MBT_LEFT = 0,
   MBT_MIDDLE,
   MBT_RIGHT,
+#if defined(OS_OHOS)
+  MBT_BACK,
+  MBT_FORWARD,
+#endif
 } cef_mouse_button_type_t;
 
 ///
@@ -1874,6 +1902,10 @@ typedef enum {
   EVENTFLAG_IS_LEFT = 1 << 10,
   EVENTFLAG_IS_RIGHT = 1 << 11,
   EVENTFLAG_ALTGR_DOWN = 1 << 12,
+#if defined(OS_OHOS)
+  EVENTFLAG_BACK_MOUSE_BUTTON = 1 << 13,
+  EVENTFLAG_FORWARD_MOUSE_BUTTON = 1 << 14,
+#endif
 } cef_event_flags_t;
 
 ///
@@ -1984,6 +2016,17 @@ typedef enum {
   CM_EDITFLAG_CAN_TRANSLATE = 1 << 7,
 } cef_context_menu_edit_state_flags_t;
 
+///
+// Supported quick menu state bit flags.
+///
+typedef enum {
+  QM_EDITFLAG_NONE = 0,
+  QM_EDITFLAG_CAN_ELLIPSIS = 1 << 0,
+  QM_EDITFLAG_CAN_CUT = 1 << 1,
+  QM_EDITFLAG_CAN_COPY = 1 << 2,
+  QM_EDITFLAG_CAN_PASTE = 1 << 3,
+} cef_quick_menu_edit_state_flags_t;
+
 ///
 // Key event types.
 ///
@@ -3264,6 +3307,52 @@ typedef enum {
   CEF_CTT_LOCATION,
 } cef_chrome_toolbar_type_t;
 
+///
+// Values indicating what state of the touch handle is set.
+///
+typedef enum {
+  CEF_THS_FLAG_NONE = 0,
+  CEF_THS_FLAG_ENABLED = 1 << 0,
+  CEF_THS_FLAG_ORIENTATION = 1 << 1,
+  CEF_THS_FLAG_ORIGIN = 1 << 2,
+  CEF_THS_FLAG_ALPHA = 1 << 3,
+} cef_touch_handle_state_flags_t;
+
+typedef struct _cef_touch_handle_state_t {
+  ///
+  // Touch handle id. Increments for each new touch handle.
+  ///
+  int touch_handle_id;
+
+  ///
+  // Combination of cef_touch_handle_state_flags_t values indicating what state
+  // is set.
+  ///
+  uint32_t flags;
+
+  ///
+  // Enabled state. Only set if |flags| contains CEF_THS_FLAG_ENABLED.
+  ///
+  int enabled;
+
+  ///
+  // Orientation state. Only set if |flags| contains CEF_THS_FLAG_ORIENTATION.
+  ///
+  cef_horizontal_alignment_t orientation;
+  int mirror_vertical;
+  int mirror_horizontal;
+
+  ///
+  // Origin state. Only set if |flags| contains CEF_THS_FLAG_ORIGIN.
+  ///
+  cef_point_t origin;
+
+  ///
+  // Alpha state. Only set if |flags| contains CEF_THS_FLAG_ALPHA.
+  ///
+  float alpha;
+} cef_touch_handle_state_t;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/cef/include/internal/cef_types_wrappers.h b/cef/include/internal/cef_types_wrappers.h
index e4c0d643bcc7f..933cbad342fcd 100644
--- a/cef/include/internal/cef_types_wrappers.h
+++ b/cef/include/internal/cef_types_wrappers.h
@@ -386,6 +386,8 @@ struct CefScreenInfoTraits {
     target->is_monochrome = src->is_monochrome;
     target->rect = src->rect;
     target->available_rect = src->available_rect;
+    target->angle = src->angle;
+    target->orientation = src->orientation;
   }
 };
 
@@ -404,9 +406,11 @@ class CefScreenInfo : public CefStructBase<CefScreenInfoTraits> {
                 int depth_per_component,
                 bool is_monochrome,
                 const CefRect& rect,
-                const CefRect& available_rect) {
+                const CefRect& available_rect,
+                uint16_t angle,
+                cef_screen_orientation_type_t orientaion) {
     Set(device_scale_factor, depth, depth_per_component, is_monochrome, rect,
-        available_rect);
+        available_rect, angle, orientation);
   }
 
   void Set(float device_scale_factor_val,
@@ -414,13 +418,17 @@ class CefScreenInfo : public CefStructBase<CefScreenInfoTraits> {
            int depth_per_component_val,
            bool is_monochrome_val,
            const CefRect& rect_val,
-           const CefRect& available_rect_val) {
+           const CefRect& available_rect_val,
+           uint16_t angle_val,
+           cef_screen_orientation_type_t orientation_val) {
     device_scale_factor = device_scale_factor_val;
     depth = depth_val;
     depth_per_component = depth_per_component_val;
     is_monochrome = is_monochrome_val;
     rect = rect_val;
     available_rect = available_rect_val;
+    angle = angle_val;
+    orientation = orientation_val;
   }
 };
 
@@ -739,6 +747,7 @@ struct CefBrowserSettingsTraits {
     target->supports_double_tap_zoom = src->supports_double_tap_zoom;
     target->supports_multi_touch_zoom = src->supports_multi_touch_zoom;
     target->initialize_at_minimum_page_scale = src->initialize_at_minimum_page_scale;
+    target->viewport_meta_enabled = src->viewport_meta_enabled;
     /* ohos webview end */
   }
 };
@@ -845,6 +854,25 @@ class CefTime : public CefStructBase<CefTimeTraits> {
   }
 };
 
+struct CefTouchHandleStateTraits {
+  typedef cef_touch_handle_state_t struct_type;
+
+  static inline void init(struct_type* s) {}
+
+  static inline void clear(struct_type* s) {}
+
+  static inline void set(const struct_type* src,
+                         struct_type* target,
+                         bool copy) {
+    *target = *src;
+  }
+};
+
+///
+// Class representing the state of a touch handle.
+///
+typedef CefStructBase<CefTouchHandleStateTraits> CefTouchHandleState;
+
 struct CefCookieTraits {
   typedef cef_cookie_t struct_type;
 
diff --git a/cef/libcef/browser/alloy/alloy_browser_host_impl.cc b/cef/libcef/browser/alloy/alloy_browser_host_impl.cc
index 73e711380751c..15e2aa724e0dd 100644
--- a/cef/libcef/browser/alloy/alloy_browser_host_impl.cc
+++ b/cef/libcef/browser/alloy/alloy_browser_host_impl.cc
@@ -56,6 +56,8 @@
 #include "third_party/blink/public/mojom/page/widget.mojom-test-utils.h"
 #include "ui/events/base_event_utils.h"
 
+#include "third_party/blink/public/mojom/context_menu/context_menu.mojom.h"
+
 using content::KeyboardEventProcessingResult;
 
 namespace {
@@ -1229,7 +1231,15 @@ bool AlloyBrowserHostImpl::TakeFocus(content::WebContents* source,
 bool AlloyBrowserHostImpl::HandleContextMenu(
     content::RenderFrameHost* render_frame_host,
     const content::ContextMenuParams& params) {
-  return HandleContextMenu(web_contents(), params);
+  // notice: now only report kImage.
+  if (params.media_type == blink::mojom::ContextMenuDataMediaType::kImage) {
+    if (!menu_manager_.get() && platform_delegate_) {
+      menu_manager_.reset(
+          new CefMenuManager(this, platform_delegate_->CreateMenuRunner()));
+    }
+    return menu_manager_->CreateContextMenu(params);
+  }
+  return false;
 }
 
 void AlloyBrowserHostImpl::SetBackgroundColor(int color) {
@@ -1377,8 +1387,12 @@ void AlloyBrowserHostImpl::RunFileChooser(
   file_dialog_manager_->RunFileChooser(listener, params);
 }
 
+#ifndef OS_OHOS
 bool AlloyBrowserHostImpl::HandleContextMenu(
     content::WebContents* web_contents,
+#else
+bool AlloyBrowserHostImpl::ShowContextMenu(
+#endif
     const content::ContextMenuParams& params) {
   CEF_REQUIRE_UIT();
   if (!menu_manager_.get() && platform_delegate_) {
@@ -1502,6 +1516,19 @@ void AlloyBrowserHostImpl::ExitPictureInPicture() {
   PictureInPictureWindowManager::GetInstance()->ExitPictureInPicture();
 }
 
+void AlloyBrowserHostImpl::RequestToLockMouse(
+    content::WebContents* web_contents,
+    bool user_gesture,
+    bool last_unlocked_by_target) {
+  if (contents_delegate_)
+    contents_delegate_->RequestToLockMouse(web_contents, user_gesture, last_unlocked_by_target);
+}
+
+void AlloyBrowserHostImpl::LostMouseLock() {
+  if (contents_delegate_)
+    contents_delegate_->LostMouseLock();
+}
+
 // content::WebContentsObserver methods.
 // -----------------------------------------------------------------------------
 
diff --git a/cef/libcef/browser/alloy/alloy_browser_host_impl.h b/cef/libcef/browser/alloy/alloy_browser_host_impl.h
index 799295d3eb2fa..9c035a2051102 100644
--- a/cef/libcef/browser/alloy/alloy_browser_host_impl.h
+++ b/cef/libcef/browser/alloy/alloy_browser_host_impl.h
@@ -192,9 +192,12 @@ class AlloyBrowserHostImpl : public CefBrowserHostBase,
   // after the dialog is dismissed or if another dialog is already pending.
   void RunFileChooser(const CefFileDialogRunner::FileChooserParams& params,
                       CefFileDialogRunner::RunFileChooserCallback callback);
-
+#ifdef OS_OHOS
+  bool ShowContextMenu(const content::ContextMenuParams& params);
+#else
   bool HandleContextMenu(content::WebContents* web_contents,
                          const content::ContextMenuParams& params);
+#endif
 
   enum DestructionState {
     DESTRUCTION_STATE_NONE = 0,
@@ -297,6 +300,10 @@ class AlloyBrowserHostImpl : public CefBrowserHostBase,
       const viz::SurfaceId& surface_id,
       const gfx::Size& natural_size) override;
   void ExitPictureInPicture() override;
+  void RequestToLockMouse(content::WebContents* web_contents,
+                          bool user_gesture,
+                          bool last_unlocked_by_target) override;
+  void LostMouseLock() override;
 
   // content::WebContentsObserver methods.
   using content::WebContentsObserver::BeforeUnloadFired;
diff --git a/cef/libcef/browser/alloy/alloy_content_browser_client.cc b/cef/libcef/browser/alloy/alloy_content_browser_client.cc
index 4530987a86dfb..69fde6cece1d5 100644
--- a/cef/libcef/browser/alloy/alloy_content_browser_client.cc
+++ b/cef/libcef/browser/alloy/alloy_content_browser_client.cc
@@ -11,6 +11,7 @@
 #include "libcef/browser/alloy/alloy_browser_context.h"
 #include "libcef/browser/alloy/alloy_browser_host_impl.h"
 #include "libcef/browser/alloy/alloy_browser_main.h"
+#include "libcef/browser/alloy/alloy_web_contents_view_delegate.h"
 #include "libcef/browser/browser_context.h"
 #include "libcef/browser/browser_info.h"
 #include "libcef/browser/browser_info_manager.h"
@@ -1383,6 +1384,12 @@ std::string AlloyContentBrowserClient::GetUserAgent() {
   return embedder_support::GetUserAgent();
 }
 
+content::WebContentsViewDelegate*
+AlloyContentBrowserClient::GetWebContentsViewDelegate(
+    content::WebContents* web_contents) {
+  return new AlloyWebContentsViewDelegate(web_contents);
+}
+
 blink::UserAgentMetadata AlloyContentBrowserClient::GetUserAgentMetadata() {
   blink::UserAgentMetadata metadata;
 
diff --git a/cef/libcef/browser/alloy/alloy_content_browser_client.h b/cef/libcef/browser/alloy/alloy_content_browser_client.h
index b8b77c11f9e88..1238da6a484f0 100644
--- a/cef/libcef/browser/alloy/alloy_content_browser_client.h
+++ b/cef/libcef/browser/alloy/alloy_content_browser_client.h
@@ -205,6 +205,8 @@ class AlloyContentBrowserClient : public content::ContentBrowserClient {
   std::string GetProduct() override;
   std::string GetChromeProduct() override;
   std::string GetUserAgent() override;
+  content::WebContentsViewDelegate* GetWebContentsViewDelegate(
+      content::WebContents* web_contents) override;
   blink::UserAgentMetadata GetUserAgentMetadata() override;
   base::flat_set<std::string> GetPluginMimeTypesWithExternalHandlers(
       content::BrowserContext* browser_context) override;
diff --git a/cef/libcef/browser/alloy/alloy_web_contents_view_delegate.cc b/cef/libcef/browser/alloy/alloy_web_contents_view_delegate.cc
new file mode 100755
index 0000000000000..b135d91b3d9ce
--- /dev/null
+++ b/cef/libcef/browser/alloy/alloy_web_contents_view_delegate.cc
@@ -0,0 +1,22 @@
+// Copyright 2022 The Chromium Embedded Framework Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "libcef/browser/alloy/alloy_web_contents_view_delegate.h"
+
+#include "content/public/browser/web_contents.h"
+
+#include "libcef/browser/alloy/alloy_browser_host_impl.h"
+
+AlloyWebContentsViewDelegate::AlloyWebContentsViewDelegate(
+    content::WebContents* web_contents)
+    : web_contents_(web_contents) {}
+
+void AlloyWebContentsViewDelegate::ShowContextMenu(
+    content::RenderFrameHost* render_frame_host,
+    const content::ContextMenuParams& params) {
+  if (auto browser =
+          AlloyBrowserHostImpl::GetBrowserForContents(web_contents_)) {
+    browser->ShowContextMenu(params);
+  }
+}
\ No newline at end of file
diff --git a/cef/libcef/browser/alloy/alloy_web_contents_view_delegate.h b/cef/libcef/browser/alloy/alloy_web_contents_view_delegate.h
new file mode 100755
index 0000000000000..6b7db5f07ad77
--- /dev/null
+++ b/cef/libcef/browser/alloy/alloy_web_contents_view_delegate.h
@@ -0,0 +1,33 @@
+// Copyright 2022 The Chromium Embedded Framework Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_BROWSER_ALLOY_ALLOY_WEB_CONTENTS_VIEW_DELEGATE_H_
+#define CEF_LIBCEF_BROWSER_ALLOY_ALLOY_WEB_CONTENTS_VIEW_DELEGATE_H_
+#pragma once
+
+#include "include/internal/cef_ptr.h"
+
+#include "content/public/browser/web_contents_view_delegate.h"
+
+namespace content {
+class WebContents;
+}
+
+class AlloyWebContentsViewDelegate : public content::WebContentsViewDelegate {
+ public:
+  explicit AlloyWebContentsViewDelegate(content::WebContents* web_contents);
+
+  AlloyWebContentsViewDelegate(const AlloyWebContentsViewDelegate&) = delete;
+  AlloyWebContentsViewDelegate& operator=(const AlloyWebContentsViewDelegate&) =
+      delete;
+
+  // WebContentsViewDelegate methods:
+  void ShowContextMenu(content::RenderFrameHost* render_frame_host,
+                       const content::ContextMenuParams& params) override;
+
+ private:
+  content::WebContents* const web_contents_;
+};
+
+#endif  // CEF_LIBCEF_BROWSER_ALLOY_ALLOY_WEB_CONTENTS_VIEW_DELEGATE_H_
\ No newline at end of file
diff --git a/cef/libcef/browser/browser_contents_delegate.cc b/cef/libcef/browser/browser_contents_delegate.cc
index 6273fb3a88345..fb9a4cb920224 100644
--- a/cef/libcef/browser/browser_contents_delegate.cc
+++ b/cef/libcef/browser/browser_contents_delegate.cc
@@ -18,10 +18,21 @@
 #include "content/public/browser/notification_source.h"
 #include "content/public/browser/notification_types.h"
 #include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
 #include "third_party/blink/public/mojom/favicon/favicon_url.mojom.h"
+#include "ui/events/keycodes/keyboard_codes_posix.h"
 
 using content::KeyboardEventProcessingResult;
 
+namespace {
+// The amount of time to disallow repeated pointer lock calls after the user
+// successfully escapes from one lock request.
+constexpr base::TimeDelta kEffectiveUserEscapeDuration =
+    base::TimeDelta::FromMilliseconds(1250);
+
+}  // namespace
+
 CefBrowserContentsDelegate::CefBrowserContentsDelegate(
     scoped_refptr<CefBrowserInfo> browser_info)
     : browser_info_(browser_info) {
@@ -177,10 +188,34 @@ void CefBrowserContentsDelegate::ExitFullscreenModeForTab(
   OnFullscreenModeChange(/*fullscreen=*/false);
 }
 
+bool CefBrowserContentsDelegate::HandleUserKeyEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  if (event.windows_key_code != ui::VKEY_ESCAPE) {
+    return false;
+  }
+
+  if (IsMouseLocked()) {
+    if (tab_with_exclusive_access_) {
+      UnlockMouse();
+      SetTabWithExclusiveAccess(nullptr);
+      mouse_lock_state_ = MOUSELOCK_UNLOCKED;
+    }
+    last_user_escape_time_ = base::TimeTicks::Now();
+    return true;
+  }
+
+  return false;
+}
+
 KeyboardEventProcessingResult
 CefBrowserContentsDelegate::PreHandleKeyboardEvent(
     content::WebContents* source,
     const content::NativeWebKeyboardEvent& event) {
+  // Forward keyboard events to the manager for fullscreen / mouse lock. This
+  // may consume the event (e.g., Esc exits fullscreen mode).
+  if (HandleUserKeyEvent(event))
+    return KeyboardEventProcessingResult::HANDLED;
+
   if (auto delegate = platform_delegate()) {
     if (auto c = client()) {
       if (auto handler = c->GetKeyboardHandler()) {
@@ -231,6 +266,84 @@ bool CefBrowserContentsDelegate::HandleKeyboardEvent(
   return false;
 }
 
+bool CefBrowserContentsDelegate::IsMouseLocked() const {
+  return mouse_lock_state_ == MOUSELOCK_LOCKED ||
+         mouse_lock_state_ == MOUSELOCK_LOCKED_SILENTLY;
+}
+
+bool CefBrowserContentsDelegate::IsMouseLockedSilently() const {
+  return mouse_lock_state_ == MOUSELOCK_LOCKED_SILENTLY;
+}
+
+void CefBrowserContentsDelegate::SetTabWithExclusiveAccess(content::WebContents* tab) {
+  // Tab should never be replaced with another tab, or
+  // UpdateNotificationRegistrations would need updating.
+  DCHECK(tab_with_exclusive_access_ == tab ||
+         tab_with_exclusive_access_ == nullptr || tab == nullptr);
+  tab_with_exclusive_access_ = tab;
+
+  if (tab_with_exclusive_access_ && registrar_->IsEmpty()) {
+    registrar_->Add(this, content::NOTIFICATION_NAV_ENTRY_COMMITTED,
+                   content::Source<content::NavigationController>(
+                       &tab_with_exclusive_access_->GetController()));
+  } else if (!tab_with_exclusive_access_ && !registrar_->IsEmpty()) {
+    registrar_->RemoveAll();
+  }
+}
+
+void CefBrowserContentsDelegate::RequestToLockMouse(
+    content::WebContents* web_contents,
+    bool user_gesture,
+    bool last_unlocked_by_target) {
+  DCHECK(!IsMouseLocked());
+  if (!last_unlocked_by_target && !is_fullscreen()) {
+    if (!user_gesture) {
+      web_contents->GotResponseToLockMouseRequest(
+          blink::mojom::PointerLockResult::kRequiresUserGesture);
+      return;
+    }
+    if (base::TimeTicks::Now() <
+        last_user_escape_time_ + kEffectiveUserEscapeDuration) {
+      web_contents->GotResponseToLockMouseRequest(
+          blink::mojom::PointerLockResult::kUserRejected);
+      return;
+    }
+  }
+  SetTabWithExclusiveAccess(web_contents);
+
+  // Lock mouse.
+  if (web_contents->GotResponseToLockMouseRequest(blink::mojom::PointerLockResult::kSuccess)) {
+    if (last_unlocked_by_target) {
+      mouse_lock_state_ = MOUSELOCK_LOCKED_SILENTLY;
+    } else {
+      mouse_lock_state_ = MOUSELOCK_LOCKED;
+    }
+  } else {
+    SetTabWithExclusiveAccess(nullptr);
+    mouse_lock_state_ = MOUSELOCK_UNLOCKED;
+  }
+}
+
+void CefBrowserContentsDelegate::LostMouseLock() {
+  mouse_lock_state_ = MOUSELOCK_UNLOCKED;
+  SetTabWithExclusiveAccess(nullptr);
+}
+
+void CefBrowserContentsDelegate::UnlockMouse() {
+  if (!tab_with_exclusive_access_)
+    return;
+
+  content::RenderWidgetHostView* mouse_lock_view = nullptr;
+  content::RenderViewHost* rvh = tab_with_exclusive_access_->GetMainFrame()->GetRenderViewHost();
+  if (rvh) {
+    mouse_lock_view = rvh->GetWidget()->GetView();
+  }
+
+  if (mouse_lock_view) {
+    mouse_lock_view->UnlockMouse();
+  }
+}
+
 void CefBrowserContentsDelegate::RenderFrameCreated(
     content::RenderFrameHost* render_frame_host) {
   browser_info_->MaybeCreateFrame(render_frame_host, false /* is_guest_view */);
diff --git a/cef/libcef/browser/browser_contents_delegate.h b/cef/libcef/browser/browser_contents_delegate.h
index ab6a9ae07adf2..aabd1ba5dc31e 100644
--- a/cef/libcef/browser/browser_contents_delegate.h
+++ b/cef/libcef/browser/browser_contents_delegate.h
@@ -104,6 +104,11 @@ class CefBrowserContentsDelegate : public content::WebContentsDelegate,
   bool HandleKeyboardEvent(
       content::WebContents* source,
       const content::NativeWebKeyboardEvent& event) override;
+  void RequestToLockMouse(content::WebContents* web_contents,
+                          bool user_gesture,
+                          bool last_unlocked_by_target) override;
+  void LostMouseLock() override;
+  void UnlockMouse();
 
   // WebContentsObserver methods:
   void RenderFrameCreated(content::RenderFrameHost* render_frame_host) override;
@@ -178,6 +183,17 @@ class CefBrowserContentsDelegate : public content::WebContentsDelegate,
 
   void OnRefreshAccessedHistory(CefRefPtr<CefFrame> frame, const GURL& url, bool isReload);
 
+  // Returns true if the mouse is locked.
+  bool IsMouseLocked() const;
+
+  // Returns true if the mouse was locked and no notification should be
+  // displayed to the user.
+  bool IsMouseLockedSilently() const;
+
+  void SetTabWithExclusiveAccess(content::WebContents* tab);
+
+  bool HandleUserKeyEvent(const content::NativeWebKeyboardEvent& event);
+
   scoped_refptr<CefBrowserInfo> browser_info_;
 
   bool is_loading_ = false;
@@ -204,6 +220,21 @@ class CefBrowserContentsDelegate : public content::WebContentsDelegate,
   // Store web site icon.
   CefRefPtr<IconHelper> icon_helper_;
 
+  enum MouseLockState {
+    MOUSELOCK_UNLOCKED,
+    // Mouse has been locked.
+    MOUSELOCK_LOCKED,
+    // Mouse has been locked silently, with no notification to user.
+    MOUSELOCK_LOCKED_SILENTLY
+  };
+
+  MouseLockState mouse_lock_state_;
+
+  // Timestamp when the user last successfully escaped from a lock request.
+  base::TimeTicks last_user_escape_time_;
+
+  content::WebContents* tab_with_exclusive_access_ = nullptr;
+
   DISALLOW_COPY_AND_ASSIGN(CefBrowserContentsDelegate);
 };
 
diff --git a/cef/libcef/browser/browser_host_base.cc b/cef/libcef/browser/browser_host_base.cc
index 249d40e4f1cc9..9d2837d88ddea 100644
--- a/cef/libcef/browser/browser_host_base.cc
+++ b/cef/libcef/browser/browser_host_base.cc
@@ -479,6 +479,7 @@ void CefBrowserHostBase::UpdateBrowserSettings(
       browser_settings.supports_multi_touch_zoom;
   settings_.initialize_at_minimum_page_scale =
       browser_settings.initialize_at_minimum_page_scale;
+  settings_.viewport_meta_enabled = browser_settings.viewport_meta_enabled;
 }
 
 void CefBrowserHostBase::SetWebPreferences(
@@ -532,6 +533,7 @@ void CefBrowserHostBase::UnregisterArkJSfunction(
   }
   javascriptInjector->RemoveInterface(object_name.ToString(), method_vector);
 }
+
 #endif
 
 void CefBrowserHostBase::ReplaceMisspelling(const CefString& word) {
@@ -690,6 +692,23 @@ bool CefBrowserHostBase::CanGoBackOrForward(int num_steps) {
   return false;
 }
 
+void CefBrowserHostBase::GoBackOrForward(int num_steps) {
+  auto callback = base::BindOnce(&CefBrowserHostBase::GoBackOrForward, this, num_steps);
+  if (!CEF_CURRENTLY_ON_UIT()) {
+    CEF_POST_TASK(CEF_UIT, std::move(callback));
+    return;
+  }
+
+  if (browser_info_->IsNavigationLocked(std::move(callback))) {
+    return;
+  }
+
+  auto wc = GetWebContents();
+  if (wc && wc->GetController().CanGoToOffset(num_steps)) {
+    wc->GetController().GoToOffset(num_steps);
+  }
+}
+
 void CefBrowserHostBase::DeleteHistory() {
   auto callback = base::BindOnce(&CefBrowserHostBase::DeleteHistory, this);
   if (!CEF_CURRENTLY_ON_UIT()) {
@@ -744,6 +763,25 @@ void CefBrowserHostBase::ReloadIgnoreCache() {
   }
 }
 
+#if defined(OS_OHOS)
+void CefBrowserHostBase::ReloadOriginalUrl() {
+  auto callback = base::BindOnce(&CefBrowserHostBase::ReloadOriginalUrl, this);
+  if (!CEF_CURRENTLY_ON_UIT()) {
+    CEF_POST_TASK(CEF_UIT, std::move(callback));
+    return;
+  }
+
+  if (browser_info_->IsNavigationLocked(std::move(callback))) {
+    return;
+  }
+
+  auto wc = GetWebContents();
+  if (wc) {
+    wc->GetController().Reload(content::ReloadType::ORIGINAL_REQUEST_URL, true);
+  }
+}
+#endif  // OS_OHOS
+
 void CefBrowserHostBase::StopLoad() {
   auto callback = base::BindOnce(&CefBrowserHostBase::StopLoad, this);
   if (!CEF_CURRENTLY_ON_UIT()) {
@@ -1196,6 +1234,12 @@ void CefBrowserHostBase::GetHitData(int& type, CefString& extra_data) {
   extra_data = cef_hit_data_.extra_data;
 }
 
+void CefBrowserHostBase::SetInitialScale(float scale) {
+  auto frame = GetMainFrame();
+  if (frame && frame->IsValid()) {
+    static_cast<CefFrameHostImpl*>(frame.get())->SetInitialScale(scale / DEFAULT_SCALE);
+  }
+}
 float CefBrowserHostBase::Scale() {
   auto web_contents = GetWebContents();
   if (web_contents) {
@@ -1319,7 +1363,6 @@ cef_accelerated_widget_t CefBrowserHostBase::GetAcceleratedWidget()
 void CefBrowserHostBase::SetWebDebuggingAccess(bool isEnableDebug) {
   base::AutoLock lock_scope(state_lock_);
   if (is_web_debugging_access_ == isEnableDebug) {
-    LOG(ERROR) << "set web debugging access failed, already is " << isEnableDebug;
     return;
   }
 
@@ -1335,3 +1378,10 @@ bool CefBrowserHostBase::GetWebDebuggingAccess() {
   base::AutoLock lock_scope(state_lock_);
   return is_web_debugging_access_;
 }
+
+void CefBrowserHostBase::GetImageForContextNode() {
+  auto frame = GetMainFrame();
+  if (frame && frame->IsValid()) {
+    static_cast<CefFrameHostImpl*>(frame.get())->GetImageForContextNode();
+  }
+}
diff --git a/cef/libcef/browser/browser_host_base.h b/cef/libcef/browser/browser_host_base.h
index e85729d5a8967..e438e31ae214c 100644
--- a/cef/libcef/browser/browser_host_base.h
+++ b/cef/libcef/browser/browser_host_base.h
@@ -9,6 +9,7 @@
 
 #include "include/cef_browser.h"
 #include "include/cef_client.h"
+#include "include/cef_image.h"
 #include "include/cef_permission_request.h"
 #include "include/cef_task.h"
 #include "include/views/cef_browser_view.h"
@@ -209,6 +210,8 @@ class CefBrowserHostBase : public CefBrowserHost,
       const CefString& object_name,
       const std::vector<CefString>& method_list) override;
   void OnWebPreferencesChanged();
+  void ReloadOriginalUrl() override;
+  void GetImageForContextNode() override;
   /* ohos webview end */
 #endif
 
@@ -219,6 +222,7 @@ class CefBrowserHostBase : public CefBrowserHost,
   bool CanGoForward() override;
   void GoForward() override;
   bool CanGoBackOrForward(int num_steps) override;
+  void GoBackOrForward (int num_steps) override;
   void DeleteHistory() override;
   bool IsLoading() override;
   void Reload() override;
@@ -240,6 +244,7 @@ class CefBrowserHostBase : public CefBrowserHost,
   CefRefPtr<CefGeolocationAcess> GetGeolocationPermissions() override;
   CefString Title() override;
   void GetHitData(int& type, CefString& extra_data) override;
+  void SetInitialScale(float scale) override;
   int PageLoadProgress() override;
   float Scale() override;
   void LoadWithDataAndBaseUrl(const CefString& baseUrl,
diff --git a/cef/libcef/browser/extensions/mime_handler_view_guest_delegate.cc b/cef/libcef/browser/extensions/mime_handler_view_guest_delegate.cc
index 49b4114839e8c..50b967484eb37 100644
--- a/cef/libcef/browser/extensions/mime_handler_view_guest_delegate.cc
+++ b/cef/libcef/browser/extensions/mime_handler_view_guest_delegate.cc
@@ -69,7 +69,11 @@ bool CefMimeHandlerViewGuestDelegate::HandleContextMenu(
       AlloyBrowserHostImpl::GetBrowserForContents(owner_web_contents_);
   DCHECK(owner_browser);
 
+#ifdef OS_OHOS
+  return owner_browser->ShowContextMenu(params);
+#else
   return owner_browser->HandleContextMenu(web_contents, params);
+#endif
 }
 
 }  // namespace extensions
diff --git a/cef/libcef/browser/frame_host_impl.cc b/cef/libcef/browser/frame_host_impl.cc
index 423498439968d..715cc271c658d 100644
--- a/cef/libcef/browser/frame_host_impl.cc
+++ b/cef/libcef/browser/frame_host_impl.cc
@@ -10,6 +10,7 @@
 #include "include/cef_v8.h"
 #include "include/test/cef_test_helpers.h"
 #include "libcef/browser/browser_host_base.h"
+#include "libcef/browser/image_impl.h"
 #include "libcef/browser/navigate_params.h"
 #include "libcef/browser/net_service/browser_urlrequest_impl.h"
 #include "libcef/common/cef_messages.h"
@@ -317,6 +318,16 @@ void CefFrameHostImpl::SendTouchEvent(const CefTouchEvent& event) {
   Send(new CefMsg_TouchEvent(MSG_ROUTING_NONE, touchEvent));
 }
 
+void CefFrameHostImpl::SetInitialScale(float scale) {
+  Cef_Blink_Params params;
+  params.initialScale = scale;
+  Send(new CefMsg_Blink(MSG_ROUTING_NONE, params));
+}
+
+void CefFrameHostImpl::GetImageForContextNode() {
+  Send(new CefMsg_GetImageForContextNode(MSG_ROUTING_NONE));
+}
+
 void CefFrameHostImpl::NotifyMoveOrResizeStarted() {
   Send(new CefMsg_MoveOrResizeStarted(MSG_ROUTING_NONE));
 }
@@ -506,6 +517,7 @@ bool CefFrameHostImpl::OnMessageReceived(const IPC::Message& message) {
     IPC_MESSAGE_HANDLER(CefHostMsg_Request, OnRequest)
     IPC_MESSAGE_HANDLER(CefHostMsg_Response, OnResponse)
     IPC_MESSAGE_HANDLER(CefHostMsg_ResponseAck, OnResponseAck)
+    IPC_MESSAGE_HANDLER(CefHostMsg_OnGetImageForContextNode, OnGetImageForContextNode)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
@@ -687,6 +699,30 @@ void CefFrameHostImpl::OnResponseAck(int request_id) {
   response_manager_->RunAckHandler(request_id);
 }
 
+void CefFrameHostImpl::OnGetImageForContextNode(
+  const CefMsg_GetImageForContextNode_Params& params) {
+  CefImageImpl* image_impl = new (std::nothrow) CefImageImpl();
+  if (image_impl != nullptr &&
+      params.image.width() > 0 && params.image.height() > 0) {
+    image_impl->AddBitmap(1.0, params.image);
+  } else {
+    return;
+  }
+  CefRefPtr<CefImage> image(image_impl);
+  CefRefPtr<CefContextMenuHandler> handler = nullptr;
+  auto browser = GetBrowserHostBase();
+  if (!browser) {
+    return;
+  }
+  auto client = browser->GetClient();
+  if (client) {
+    handler = client->GetContextMenuHandler();
+  }
+  if (handler) {
+    handler->OnGetImageForContextNode(image);
+  }
+}
+
 void CefFrameHostImpl::Send(IPC::Message* message) {
   if (!CEF_CURRENTLY_ON_UIT()) {
     CEF_POST_TASK(CEF_UIT,
diff --git a/cef/libcef/browser/frame_host_impl.h b/cef/libcef/browser/frame_host_impl.h
index df9fdbe0c4dd2..af1910be4f9f3 100644
--- a/cef/libcef/browser/frame_host_impl.h
+++ b/cef/libcef/browser/frame_host_impl.h
@@ -12,6 +12,7 @@
 #include <string>
 
 #include "include/cef_frame.h"
+#include "include/cef_image.h"
 #include "libcef/common/response_manager.h"
 
 #include "base/synchronization/lock.h"
@@ -30,9 +31,11 @@ class GURL;
 
 struct Cef_DraggableRegion_Params;
 struct Cef_TouchEvent_Params;
+struct Cef_Blink_Params;
 struct Cef_HitData_Params;
 struct Cef_Request_Params;
 struct Cef_Response_Params;
+struct CefMsg_GetImageForContextNode_Params;
 class CefBrowserInfo;
 class CefBrowserHostBase;
 struct CefNavigateParams;
@@ -94,6 +97,10 @@ class CefFrameHostImpl : public CefFrame {
   // Send the touch point to the rederer to get hitdata.
   void SendTouchEvent(const CefTouchEvent& event);
 
+  void SetInitialScale(float scale);
+
+  void GetImageForContextNode();
+
   // Notification that a move or resize of the renderer's containing window has
   // started. Used on Windows and Linux with the Alloy runtime.
   void NotifyMoveOrResizeStarted();
@@ -171,6 +178,8 @@ class CefFrameHostImpl : public CefFrame {
   void OnRequest(const Cef_Request_Params& params);
   void OnResponse(const Cef_Response_Params& params);
   void OnResponseAck(int request_id);
+  void OnGetImageForContextNode(
+      const CefMsg_GetImageForContextNode_Params& params);
 
   // Send a message to the RenderFrameHost associated with this frame.
   void Send(IPC::Message* message);
diff --git a/cef/libcef/browser/image_impl.h b/cef/libcef/browser/image_impl.h
index 9859f37d772c3..b897d56b5de1c 100644
--- a/cef/libcef/browser/image_impl.h
+++ b/cef/libcef/browser/image_impl.h
@@ -79,9 +79,9 @@ class CefImageImpl : public CefImage {
   // Returns the skia representation of this Image.
   gfx::ImageSkia AsImageSkia() const;
 
- private:
   // Add a bitmap.
   bool AddBitmap(float scale_factor, const SkBitmap& bitmap);
+ private:
 
   // Returns the bitmap that most closely matches |scale_factor| or nullptr if
   // one doesn't exist.
diff --git a/cef/libcef/browser/native/browser_platform_delegate_native_aura.cc b/cef/libcef/browser/native/browser_platform_delegate_native_aura.cc
index 518f677541a49..31d1c25fd2f58 100644
--- a/cef/libcef/browser/native/browser_platform_delegate_native_aura.cc
+++ b/cef/libcef/browser/native/browser_platform_delegate_native_aura.cc
@@ -126,6 +126,14 @@ ui::MouseEvent CefBrowserPlatformDelegateNativeAura::TranslateUiClickEvent(
     case MBT_RIGHT:
       changed_button_flags |= ui::EF_RIGHT_MOUSE_BUTTON;
       break;
+#if defined(OS_OHOS)
+    case MBT_BACK:
+      changed_button_flags |= ui::EF_BACK_MOUSE_BUTTON;
+      break;
+    case MBT_FORWARD:
+      changed_button_flags |= ui::EF_FORWARD_MOUSE_BUTTON;
+      break;
+#endif
     default:
       NOTREACHED();
   }
@@ -206,6 +214,10 @@ int CefBrowserPlatformDelegateNativeAura::TranslateUiEventModifiers(
     result |= ui::EF_MIDDLE_MOUSE_BUTTON;
   if (cef_modifiers & EVENTFLAG_RIGHT_MOUSE_BUTTON)
     result |= ui::EF_RIGHT_MOUSE_BUTTON;
+  if (cef_modifiers & EVENTFLAG_BACK_MOUSE_BUTTON)
+    result |= ui::EF_BACK_MOUSE_BUTTON;
+  if (cef_modifiers & EVENTFLAG_FORWARD_MOUSE_BUTTON)
+    result |= ui::EF_FORWARD_MOUSE_BUTTON;
   if (cef_modifiers & EVENTFLAG_CAPS_LOCK_ON)
     result |= ui::EF_CAPS_LOCK_ON;
   if (cef_modifiers & EVENTFLAG_NUM_LOCK_ON)
diff --git a/cef/libcef/browser/net_database/cef_data_base_impl.cc b/cef/libcef/browser/net_database/cef_data_base_impl.cc
new file mode 100644
index 0000000000000..aa90f983f8e8c
--- /dev/null
+++ b/cef/libcef/browser/net_database/cef_data_base_impl.cc
@@ -0,0 +1,62 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "libcef/browser/net_database/cef_data_base_impl.h"
+
+#include "base/bind.h"
+#include "base/logging.h"
+#include "ohos_adapter_helper.h"
+
+void TransferVector(const std::vector<std::string>& source,
+                    std::vector<CefString>& target) {
+  if (!target.empty())
+    target.clear();
+
+  if (!source.empty()) {
+    std::vector<std::string>::const_iterator it = source.begin();
+    for (; it != source.end(); ++it)
+      target.push_back(*it);
+  }
+}
+
+CefRefPtr<CefDataBase> CefDataBase::GetGlobalDataBase() {
+  CefRefPtr<CefRequestContext> context = CefRequestContext::GetGlobalContext();
+  return context ? context->GetDataBase() : nullptr;
+}
+
+bool CefDataBaseImpl::ExistHttpAuthCredentials() {
+  OHOS::NWeb::OhosWebDataBaseAdapter& databaseAdapter =
+  OHOS::NWeb::OhosAdapterHelper::GetInstance().GetOhosWebDataBaseAdapterInstance();
+  return databaseAdapter.ExistHttpAuthCredentials();
+}
+
+void CefDataBaseImpl::DeleteHttpAuthCredentials() {
+  OHOS::NWeb::OhosWebDataBaseAdapter& databaseAdapter =
+  OHOS::NWeb::OhosAdapterHelper::GetInstance().GetOhosWebDataBaseAdapterInstance();
+  return databaseAdapter.DeleteHttpAuthCredentials();
+}
+
+void CefDataBaseImpl::SaveHttpAuthCredentials(const CefString& host, const CefString& realm,
+  const CefString& username, const char* password) {
+  if (host.empty() || realm.empty() || username.empty() || password == nullptr) {
+    return;
+  }
+  OHOS::NWeb::OhosWebDataBaseAdapter& databaseAdapter =
+  OHOS::NWeb::OhosAdapterHelper::GetInstance().GetOhosWebDataBaseAdapterInstance();
+  return databaseAdapter.SaveHttpAuthCredentials(host, realm, username, password);
+}
+
+void CefDataBaseImpl::GetHttpAuthCredentials(const CefString& host, const CefString& realm,
+  std::vector<CefString>& username_password) {
+  if (host.empty() || realm.empty()) {
+    return;
+  }
+
+  std::vector<std::string> result;
+  OHOS::NWeb::OhosWebDataBaseAdapter& databaseAdapter =
+  OHOS::NWeb::OhosAdapterHelper::GetInstance().GetOhosWebDataBaseAdapterInstance();
+  databaseAdapter.GetHttpAuthCredentials(host, realm, result);
+  TransferVector(result, username_password);
+  return;
+}
\ No newline at end of file
diff --git a/cef/libcef/browser/net_database/cef_data_base_impl.h b/cef/libcef/browser/net_database/cef_data_base_impl.h
new file mode 100644
index 0000000000000..bd9a92c2fd0d0
--- /dev/null
+++ b/cef/libcef/browser/net_database/cef_data_base_impl.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_BROWSER_NET_DATA_BASE_IMPL_H_
+#define CEF_LIBCEF_BROWSER_NET_DATA_BASE_IMPL_H_
+
+#include "libcef/browser/browser_context.h"
+#include "include/cef_data_base.h"
+
+class CefDataBaseImpl : public CefDataBase {
+ public:
+  CefDataBaseImpl() = default;
+
+  bool ExistHttpAuthCredentials() override;
+
+  void DeleteHttpAuthCredentials() override;
+
+  void SaveHttpAuthCredentials(const CefString& host, const CefString& realm,
+    const CefString& username, const char* password) override;
+
+  void GetHttpAuthCredentials(const CefString& host, const CefString& realm,
+    std::vector<CefString>& username_password) override;
+
+ private:
+  IMPLEMENT_REFCOUNTING(CefDataBaseImpl);
+
+  DISALLOW_COPY_AND_ASSIGN(CefDataBaseImpl);
+};
+#endif  // CEF_LIBCEF_BROWSER_NET_DATA_BASE_IMPL_H_
diff --git a/cef/libcef/browser/net_service/login_delegate.cc b/cef/libcef/browser/net_service/login_delegate.cc
index 3aeeb380fa192..0749f23290840 100644
--- a/cef/libcef/browser/net_service/login_delegate.cc
+++ b/cef/libcef/browser/net_service/login_delegate.cc
@@ -5,6 +5,7 @@
 #include "libcef/browser/net_service/login_delegate.h"
 
 #include "libcef/browser/browser_host_base.h"
+#include "libcef/browser/net_database/cef_data_base_impl.h"
 #include "libcef/browser/net_service/browser_urlrequest_impl.h"
 #include "libcef/browser/thread_util.h"
 
@@ -16,11 +17,14 @@
 namespace net_service {
 
 namespace {
+const int USERNAME_PASSWORD_VECTOR_NUM = 2;
 
 class AuthCallbackImpl : public CefAuthCallback {
  public:
-  explicit AuthCallbackImpl(base::WeakPtr<LoginDelegate> delegate)
+  explicit AuthCallbackImpl(base::WeakPtr<LoginDelegate> delegate, const CefString& host, const CefString& realm)
       : delegate_(delegate),
+        host_(host),
+        realm_(realm),
         task_runner_(base::SequencedTaskRunnerHandle::Get()) {}
 
   ~AuthCallbackImpl() override {
@@ -58,8 +62,39 @@ class AuthCallbackImpl : public CefAuthCallback {
     }
   }
 
+  bool IsHttpAuthInfoSaved() override {
+    auto dataBase = CefDataBase::GetGlobalDataBase();
+    if (dataBase == nullptr) {
+      return false;
+    }
+    if (!dataBase->ExistHttpAuthCredentials()) {
+      return false;
+    }
+    std::vector<CefString> usernamePassword;
+	usernamePassword.clear();
+    dataBase->GetHttpAuthCredentials(host_, realm_, usernamePassword);
+    if (usernamePassword.size() < USERNAME_PASSWORD_VECTOR_NUM) {
+      return false;
+    }
+    CefString username = usernamePassword[0];
+    CefString password = usernamePassword[1];
+    if (!task_runner_->RunsTasksInCurrentSequence()) {
+      task_runner_->PostTask(
+          FROM_HERE, base::BindOnce(&AuthCallbackImpl::Continue, this, username,
+                                    password));
+      return true;
+    }
+    if (delegate_) {
+      delegate_->Continue(username, password);
+      delegate_ = nullptr;
+	  return true;
+    }
+    return false;
+  }
  private:
   base::WeakPtr<LoginDelegate> delegate_;
+  CefString host_;
+  CefString realm_;
   scoped_refptr<base::SequencedTaskRunner> task_runner_;
 
   IMPLEMENT_REFCOUNTING(AuthCallbackImpl);
@@ -157,7 +192,7 @@ void LoginDelegate::Start(CefRefPtr<CefBrowserHostBase> browser,
   if (browser || url_request_info) {
     // AuthCallbackImpl is bound to the current thread.
     CefRefPtr<AuthCallbackImpl> callbackImpl =
-        new AuthCallbackImpl(weak_ptr_factory_.GetWeakPtr());
+        new AuthCallbackImpl(weak_ptr_factory_.GetWeakPtr(), auth_info.challenger.host(), auth_info.realm);
 
     // Execute callbacks on the IO thread to maintain the "old"
     // network_delegate callback behaviour.
diff --git a/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc b/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc
index 43d6fd99338d7..cdd7e55249ed2 100644
--- a/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc
+++ b/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc
@@ -597,7 +597,80 @@ class InterceptedRequestHandlerWrapper : public InterceptedRequestHandler {
     }
   }
 
-  void ContinueShouldInterceptRequest(
+ #if defined(OS_OHOS)
+  void GetOhosResourceHandlerResult(
+      int32_t request_id,
+      network::ResourceRequest* request,
+      CefRefPtr<CefResourceHandler> resource_handler,
+      ShouldInterceptRequestResultCallback callback)
+  {
+      CEF_REQUIRE_IOT();
+      RequestState* state = GetState(request_id);
+      if (!state) {
+        std::move(callback).Run(nullptr);
+        return;
+      }
+
+       if (!resource_handler && state->scheme_factory_) {
+        // Does the scheme factory want to handle the request?
+        resource_handler = state->scheme_factory_->Create(
+            init_state_->browser_, init_state_->frame_, request->url.scheme(),
+            state->pending_request_.get());
+      }
+
+      std::unique_ptr<ResourceResponse> resource_response;
+      if (resource_handler) {
+        resource_response = CreateResourceResponse(request_id, resource_handler);
+        DCHECK(resource_response);
+        state->was_custom_handled_ = true;
+      } else {
+        // The request will be handled by the NetworkService. Remove the
+        // "Accept-Language" header here so that it can be re-added in
+        // URLRequestHttpJob::AddExtraHeaders with correct ordering applied.
+      }
+
+      // Continue the request.
+      std::move(callback).Run(std::move(resource_response));
+  }
+
+  void GetOhosResourceHandlerInUiTask(
+      int32_t request_id,
+      network::ResourceRequest* request,
+      ShouldInterceptRequestResultCallback callback)
+  {
+      CEF_REQUIRE_UIT();
+      RequestState* state = GetState(request_id);
+      if (!state) {
+        std::move(callback).Run(nullptr);
+        return;
+      }
+      CefRefPtr<CefResourceHandler> resource_handler;
+
+      if (state->handler_) {
+        // Does the client want to handle the request?
+        resource_handler = state->handler_->GetResourceHandler(
+            init_state_->browser_, init_state_->frame_, state->pending_request_.get());
+      }
+
+      CEF_POST_TASK(CEF_IOT,
+                    base::BindOnce(&InterceptedRequestHandlerWrapper::GetOhosResourceHandlerResult,
+                                  weak_ptr_factory_.GetWeakPtr(), request_id, request,
+                                  resource_handler, std::move(callback)));
+  }
+
+  void GetOhosResourceHandler(
+    int32_t request_id,
+    network::ResourceRequest* request,
+    ShouldInterceptRequestResultCallback callback)
+  {
+      CEF_POST_TASK(CEF_UIT,
+                    base::BindOnce(&InterceptedRequestHandlerWrapper::GetOhosResourceHandlerInUiTask,
+                                  weak_ptr_factory_.GetWeakPtr(), request_id, request,
+                                  std::move(callback)));
+  }
+#endif
+
+ void ContinueShouldInterceptRequest(
       int32_t request_id,
       network::ResourceRequest* request,
       ShouldInterceptRequestResultCallback callback,
@@ -645,6 +718,9 @@ class InterceptedRequestHandlerWrapper : public InterceptedRequestHandler {
         return;
       }
     }
+  #if defined(OS_OHOS)
+    GetOhosResourceHandler(request_id, request, std::move(callback));
+  #else
 
     CefRefPtr<CefResourceHandler> resource_handler;
 
@@ -674,6 +750,7 @@ class InterceptedRequestHandlerWrapper : public InterceptedRequestHandler {
 
     // Continue the request.
     std::move(callback).Run(std::move(resource_response));
+  #endif
   }
 
   void ProcessResponseHeaders(int32_t request_id,
diff --git a/cef/libcef/browser/osr/browser_platform_delegate_osr.cc b/cef/libcef/browser/osr/browser_platform_delegate_osr.cc
index 93abbbee009c5..1938ed67f315c 100644
--- a/cef/libcef/browser/osr/browser_platform_delegate_osr.cc
+++ b/cef/libcef/browser/osr/browser_platform_delegate_osr.cc
@@ -82,6 +82,7 @@ void CefBrowserPlatformDelegateOsr::NotifyBrowserDestroyed() {
     CefRenderWidgetHostViewOSR* view =
         static_cast<CefRenderWidgetHostViewOSR*>(host->GetWidget()->GetView());
     if (view) {
+      LOG(INFO) << "NotifyBrowserDestroyed";
       view->ReleaseCompositor();
     }
   }
diff --git a/cef/libcef/browser/osr/render_widget_host_view_osr.cc b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
index 761e98bba384b..0510a80055694 100644
--- a/cef/libcef/browser/osr/render_widget_host_view_osr.cc
+++ b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
@@ -12,6 +12,7 @@
 #include "libcef/browser/alloy/alloy_browser_host_impl.h"
 #include "libcef/browser/osr/osr_util.h"
 #include "libcef/browser/osr/synthetic_gesture_target_osr.h"
+#include "libcef/browser/osr/touch_selection_controller_client_osr.h"
 #include "libcef/browser/osr/video_consumer_osr.h"
 #include "libcef/browser/thread_util.h"
 
@@ -51,18 +52,41 @@
 #include "ui/events/gesture_detection/motion_event.h"
 #include "ui/gfx/geometry/dip_util.h"
 #include "ui/gfx/geometry/size_conversions.h"
+#include "ui/touch_selection/touch_selection_controller.h"
 
+// static
 std::unordered_map<gfx::AcceleratedWidget, ui::Compositor*>
     CefRenderWidgetHostViewOSR::compositor_map_;
 
-namespace {
+std::unordered_map<gfx::AcceleratedWidget, uint32_t> CefRenderWidgetHostViewOSR::accelerate_widget_map_;
 
+namespace {
 // The maximum number of damage rects to cache for outstanding frame requests
 // (for OnAcceleratedPaint).
 const size_t kMaxDamageRects = 10;
 
 const float kDefaultScaleFactor = 1.0;
 
+#if defined(OS_OHOS)
+blink::mojom::ScreenOrientation ConvertOrientationType(
+  cef_screen_orientation_type_t type) {
+  switch (type) {
+      case cef_screen_orientation_type_t::UNDEFINED:
+        return blink::mojom::ScreenOrientation::kUndefined;
+      case cef_screen_orientation_type_t::PORTRAIT_PRIMARY:
+        return blink::mojom::ScreenOrientation::kPortraitPrimary;
+      case cef_screen_orientation_type_t::LANDSCAPE_PRIMARY:
+        return blink::mojom::ScreenOrientation::kLandscapePrimary;
+      case cef_screen_orientation_type_t::PORTRAIT_SECONDARY:
+        return blink::mojom::ScreenOrientation::kPortraitSecondary;
+      case cef_screen_orientation_type_t::LANDSCAPE_SECONDARY:
+        return blink::mojom::ScreenOrientation::kLandscapeSecondary;
+      default:
+        return blink::mojom::ScreenOrientation::kUndefined;
+  }
+}
+#endif
+
 blink::ScreenInfo ScreenInfoFrom(const CefScreenInfo& src) {
   blink::ScreenInfo screenInfo;
   screenInfo.device_scale_factor = src.device_scale_factor;
@@ -74,7 +98,10 @@ blink::ScreenInfo ScreenInfoFrom(const CefScreenInfo& src) {
   screenInfo.available_rect =
       gfx::Rect(src.available_rect.x, src.available_rect.y,
                 src.available_rect.width, src.available_rect.height);
-
+#if defined(OS_OHOS)
+  screenInfo.orientation_angle = src.angle;
+  screenInfo.orientation_type = ConvertOrientationType(src.orientation);
+#endif
   return screenInfo;
 }
 
@@ -163,8 +190,13 @@ float GetDeviceScaleFactor(AlloyBrowserHostImpl* browser) {
   if (!browser)
     return kDefaultScaleFactor;
 
+#if defined(OS_OHOS)
+  CefScreenInfo screen_info(kDefaultScaleFactor, 0, 0, false, CefRect(),
+                            CefRect(), 0, cef_screen_orientation_type_t::UNDEFINED);
+#else
   CefScreenInfo screen_info(kDefaultScaleFactor, 0, 0, false, CefRect(),
                             CefRect());
+#endif
   CefRefPtr<CefRenderHandler> handler = browser->client()->GetRenderHandler();
   CHECK(handler);
   if (!handler->GetScreenInfo(browser, screen_info))
@@ -192,6 +224,19 @@ ui::ImeTextSpan::UnderlineStyle GetImeUnderlineStyle(
 
 }  // namespace
 
+// Logic copied from RenderWidgetHostViewAura::CreateSelectionController.
+void CefRenderWidgetHostViewOSR::CreateSelectionController() {
+  ui::TouchSelectionController::Config tsc_config;
+  // TODO: need to complete selection controller config
+  tsc_config.max_tap_duration = base::TimeDelta::FromMilliseconds(
+      ui::GestureConfiguration::GetInstance()->long_press_time_in_ms());
+  tsc_config.tap_slop = ui::GestureConfiguration::GetInstance()
+                            ->max_touch_move_in_pixels_for_click();
+  tsc_config.enable_longpress_drag_selection = false;
+  selection_controller_ = std::make_unique<ui::TouchSelectionController>(
+      selection_controller_client_.get(), tsc_config);
+}
+
 CefRenderWidgetHostViewOSR::CefRenderWidgetHostViewOSR(
     SkColor background_color,
     bool use_shared_texture,
@@ -238,8 +283,21 @@ CefRenderWidgetHostViewOSR::CefRenderWidgetHostViewOSR(
 
   auto context_factory = content::GetContextFactory();
 
+#ifdef DISABLE_GPU
+  compositor_.reset(new ui::Compositor(
+      context_factory->AllocateFrameSinkId(), context_factory,
+      base::ThreadTaskRunnerHandle::Get(), false /* enable_pixel_canvas */,
+      use_external_begin_frame));
+  compositor_->SetAcceleratedWidget(gfx::kNullAcceleratedWidget);
+
+  compositor_->SetDelegate(this);
+  compositor_->SetRootLayer(root_layer_.get());
+  compositor_->AddChildFrameSink(GetFrameSinkId());
+#else
+  LOG(INFO) << "compositor construct, widget = " << static_cast<uint32_t>(browser_impl_->GetAcceleratedWidget());
   ui::Compositor* compositor = CefRenderWidgetHostViewOSR::GetCompositor(
       browser_impl_->GetAcceleratedWidget());
+  accelerate_widget_map_[browser_impl_->GetAcceleratedWidget()]++;
   if (!compositor) {
     compositor = new ui::Compositor(
         context_factory->AllocateFrameSinkId(), context_factory,
@@ -249,6 +307,7 @@ CefRenderWidgetHostViewOSR::CefRenderWidgetHostViewOSR(
     CefRenderWidgetHostViewOSR::AddCompositor(
         browser_impl_->GetAcceleratedWidget(), compositor);
   }
+#endif
 
   cursor_manager_.reset(new content::CursorManager(this));
 
@@ -271,6 +330,10 @@ CefRenderWidgetHostViewOSR::CefRenderWidgetHostViewOSR(
     if (!render_widget_host_->is_hidden())
       Show();
   }
+
+  selection_controller_client_ =
+      std::make_unique<CefTouchSelectionControllerClientOSR>(this);
+  CreateSelectionController();
 }
 
 CefRenderWidgetHostViewOSR::~CefRenderWidgetHostViewOSR() {
@@ -287,15 +350,49 @@ CefRenderWidgetHostViewOSR::~CefRenderWidgetHostViewOSR() {
 }
 
 void CefRenderWidgetHostViewOSR::ReleaseCompositor() {
+#ifdef DISABLE_GPU
+  if (!compositor_) {
+    return;  // already released
+  }
+#else
+  if (!browser_impl_) {
+    return;
+  }
+  auto it = accelerate_widget_map_.find(browser_impl_->GetAcceleratedWidget());
+  if (it == accelerate_widget_map_.end()) {
+    return;
+  }
+#endif
   // Marking the DelegatedFrameHost as removed from the window hierarchy is
   // necessary to remove all connections to its old ui::Compositor.
-  if (is_showing_) {
-    delegated_frame_host_->WasHidden(
-        content::DelegatedFrameHost::HiddenCause::kOther);
+
+  if (delegated_frame_host_) {
+    if (is_showing_) {
+      delegated_frame_host_->WasHidden(content::DelegatedFrameHost::HiddenCause::kOther);
+    }
+    delegated_frame_host_->DetachFromCompositor();
+    delegated_frame_host_.reset(nullptr);
   }
-  delegated_frame_host_->DetachFromCompositor();
 
-  delegated_frame_host_.reset(nullptr);
+#ifdef DISABLE_GPU
+  compositor_.reset(nullptr);
+#else
+  LOG(INFO) << "ReleaseCompositor";
+  if(--accelerate_widget_map_[browser_impl_->GetAcceleratedWidget()] == 0) {
+    if (!browser_impl_) {
+      return;
+    }
+    LOG(INFO) << "ReleaseCompositor, widget = " << static_cast<uint32_t>(browser_impl_->GetAcceleratedWidget());
+    auto it = compositor_map_.find(browser_impl_->GetAcceleratedWidget());
+    if (it != compositor_map_.end()) {
+      if (it->second != nullptr) {
+        delete it->second;
+      }
+      compositor_map_.erase(it);
+    }
+    accelerate_widget_map_.erase(browser_impl_->GetAcceleratedWidget());
+  }
+#endif
 }
 
 // Called for full-screen widgets.
@@ -330,10 +427,21 @@ CefRenderWidgetHostViewOSR::GetNativeViewAccessible() {
   return gfx::NativeViewAccessible();
 }
 
-void CefRenderWidgetHostViewOSR::Focus() {}
+void CefRenderWidgetHostViewOSR::Focus() {
+  if (!render_widget_host_)
+    return;
+  content::RenderWidgetHostImpl* widget =
+      content::RenderWidgetHostImpl::From(render_widget_host_);
+  widget->GotFocus();
+  widget->SetActive(true);
+}
 
 bool CefRenderWidgetHostViewOSR::HasFocus() {
-  return false;
+  if (!render_widget_host_)
+    return false;
+  content::RenderWidgetHostImpl* widget =
+      content::RenderWidgetHostImpl::From(render_widget_host_);
+  return widget->is_focused();
 }
 
 bool CefRenderWidgetHostViewOSR::IsSurfaceAvailableForCopy() {
@@ -362,6 +470,7 @@ void CefRenderWidgetHostViewOSR::Show() {
     SynchronizeVisualProperties(cc::DeadlinePolicy::UseDefaultDeadline(),
                                 GetLocalSurfaceId());
   }
+#ifndef DISABLE_GPU
   auto compositor = CefRenderWidgetHostViewOSR::GetCompositor(browser_impl_->GetAcceleratedWidget());
   compositor->SetDelegate(this);
   compositor->SetRootLayer(root_layer_.get());
@@ -371,6 +480,7 @@ void CefRenderWidgetHostViewOSR::Show() {
       content::RenderWidgetHostImpl::From(render_widget_host_);
   if (render_widget_host_impl)
     render_widget_host_impl->SetCompositorForFlingScheduler(compositor);
+#endif
 
   if (render_widget_host_) {
     render_widget_host_->WasShown(
@@ -384,7 +494,11 @@ void CefRenderWidgetHostViewOSR::Show() {
   }
 
   if (delegated_frame_host_) {
+#ifdef DISABLE_GPU
+    delegated_frame_host_->AttachToCompositor(compositor_.get());
+#else
     delegated_frame_host_->AttachToCompositor(compositor);
+#endif
     delegated_frame_host_->WasShown(GetLocalSurfaceId(), GetViewBounds().size(),
                                     /*record_tab_switch_time_request=*/{});
   }
@@ -392,8 +506,13 @@ void CefRenderWidgetHostViewOSR::Show() {
   if (!content::GpuDataManagerImpl::GetInstance()->IsGpuCompositingDisabled()) {
     // Start generating frames when we're visible and at the correct size.
     if (!video_consumer_) {
+#ifdef DISABLE_GPU
+      video_consumer_.reset(new CefVideoConsumerOSR(this));
+      UpdateFrameRate();
+#else
       // video_consumer_.reset(new CefVideoConsumerOSR(this));
       // UpdateFrameRate();
+#endif
     } else {
       video_consumer_->SetActive(true);
     }
@@ -409,6 +528,10 @@ void CefRenderWidgetHostViewOSR::Hide() {
   if (browser_impl_.get())
     browser_impl_->CancelContextMenu();
 
+  if (selection_controller_client_) {
+    selection_controller_client_->CloseQuickMenuAndHideHandles();
+  }
+
   if (video_consumer_) {
     video_consumer_->SetActive(false);
   }
@@ -438,6 +561,11 @@ void CefRenderWidgetHostViewOSR::EnsureSurfaceSynchronizedForWebTest() {
                               base::nullopt);
 }
 
+content::TouchSelectionControllerClientManager*
+CefRenderWidgetHostViewOSR::GetTouchSelectionControllerClientManager() {
+  return selection_controller_client_.get();
+}
+
 gfx::Rect CefRenderWidgetHostViewOSR::GetViewBounds() {
   if (IsPopupWidget())
     return popup_position_;
@@ -473,15 +601,36 @@ void CefRenderWidgetHostViewOSR::SetDisplayFeatureForTesting(
 
 blink::mojom::PointerLockResult CefRenderWidgetHostViewOSR::LockMouse(
     bool request_unadjusted_movement) {
-  return blink::mojom::PointerLockResult::kPermissionDenied;
+  if (is_mouse_locked_) {
+    return blink::mojom::PointerLockResult::kAlreadyLocked;
+  }
+  is_mouse_locked_ = true;
+  return blink::mojom::PointerLockResult::kSuccess;
 }
 
 blink::mojom::PointerLockResult CefRenderWidgetHostViewOSR::ChangeMouseLock(
     bool request_unadjusted_movement) {
-  return blink::mojom::PointerLockResult::kPermissionDenied;
+  if (is_mouse_locked_)
+    return LockMouse(request_unadjusted_movement);
+
+  UnlockMouse();
+  return blink::mojom::PointerLockResult::kSuccess;
 }
 
-void CefRenderWidgetHostViewOSR::UnlockMouse() {}
+void CefRenderWidgetHostViewOSR::UnlockMouse() {
+  if (!is_mouse_locked_) {
+    return;
+  }
+  is_mouse_locked_ = false;
+  if (render_widget_host_) {
+    render_widget_host_->SendMouseLockLost();
+    render_widget_host_->LostMouseLock();
+  }
+}
+
+bool CefRenderWidgetHostViewOSR::IsMouseLocked() {
+  return is_mouse_locked_;
+}
 
 void CefRenderWidgetHostViewOSR::TakeFallbackContentFrom(
     content::RenderWidgetHostView* view) {
@@ -691,8 +840,13 @@ void CefRenderWidgetHostViewOSR::GetScreenInfo(blink::ScreenInfo* results) {
   if (!browser_impl_.get())
     return;
 
+#if defined(OS_OHOS)
+  CefScreenInfo screen_info(kDefaultScaleFactor, 0, 0, false, CefRect(),
+                            CefRect(), 0, cef_screen_orientation_type_t::UNDEFINED);
+#else
   CefScreenInfo screen_info(kDefaultScaleFactor, 0, 0, false, CefRect(),
                             CefRect());
+#endif
 
   CefRefPtr<CefRenderHandler> handler =
       browser_impl_->client()->GetRenderHandler();
@@ -717,6 +871,8 @@ void CefRenderWidgetHostViewOSR::GetScreenInfo(blink::ScreenInfo* results) {
         screen_info.available_rect.height == 0) {
       screen_info.available_rect = screenRect;
     }
+    LOG(INFO) << "CefRenderWidgetHostViewOSR::GetScreenInfo orientation:" << screen_info.orientation;
+    LOG(INFO) << "CefRenderWidgetHostViewOSR::GetScreenInfo angel:" << screen_info.angle;
   }
 
   *results = ScreenInfoFrom(screen_info);
@@ -858,9 +1014,13 @@ const viz::FrameSinkId& CefRenderWidgetHostViewOSR::GetFrameSinkId() const {
 }
 
 viz::FrameSinkId CefRenderWidgetHostViewOSR::GetRootFrameSinkId() {
+#ifdef DISABLE_GPU
+  return compositor_ ? compositor_->frame_sink_id() : viz::FrameSinkId();
+#else
   auto compositor = CefRenderWidgetHostViewOSR::GetCompositor(
       browser_impl_->GetAcceleratedWidget());
   return compositor ? compositor->frame_sink_id() : viz::FrameSinkId();
+#endif
 }
 
 std::unique_ptr<content::SyntheticGestureTarget>
@@ -942,11 +1102,46 @@ void CefRenderWidgetHostViewOSR::OnRenderFrameMetadataChangedAfterActivation(
     root_layer_size_ = root_layer_size;
 
     // Send the notification asynchronously.
+#ifdef DISABLE_GPU
+    CEF_POST_TASK(CEF_UIT, base::Bind(&CefRenderWidgetHostViewOSR::OnRootLayerChanged,
+                  weak_ptr_factory_.GetWeakPtr()));
+#else
     CEF_POST_TASK(CEF_UIT,
                   base::Bind(&CefRenderWidgetHostViewOSR::OnRootLayerChanged,
                              weak_ptr_factory_.GetWeakPtr()));
+#endif
   }
 #endif
+  if (!page_scale_factor_) {
+    // set init page scale factor.
+    page_scale_factor_ = metadata.page_scale_factor;
+    return;
+  }
+  float new_page_scale_factor = metadata.page_scale_factor;
+  if (new_page_scale_factor != page_scale_factor_) {
+    float old_page_scale_factor = page_scale_factor_;
+    page_scale_factor_ = new_page_scale_factor;
+    // Send the notification asynchronously.
+    CEF_POST_TASK(CEF_UIT,
+                  base::Bind(&CefRenderWidgetHostViewOSR::OnScaleChanged,
+                             weak_ptr_factory_.GetWeakPtr(), old_page_scale_factor, new_page_scale_factor));
+  }
+
+  if (metadata.selection.start != selection_start_ ||
+      metadata.selection.end != selection_end_) {
+    selection_start_ = metadata.selection.start;
+    selection_end_ = metadata.selection.end;
+    selection_controller_client_->UpdateClientSelectionBounds(selection_start_,
+                                                              selection_end_);
+  }
+}
+
+void CefRenderWidgetHostViewOSR::OnScaleChanged(float old_page_scale_factor, float nwe_page_scale_factor) {
+  if (browser_impl_.get()) {
+    CefRefPtr<CefDisplayHandler> handler = browser_impl_->client()->GetDisplayHandler();
+    CHECK(handler);
+    handler->OnScaleChanged(browser_impl_.get(), old_page_scale_factor * DEFAULT_SCALE, nwe_page_scale_factor * DEFAULT_SCALE);
+  }
 }
 
 std::unique_ptr<viz::HostDisplayClient>
@@ -960,11 +1155,17 @@ CefRenderWidgetHostViewOSR::CreateHostDisplayClient() {
 bool CefRenderWidgetHostViewOSR::InstallTransparency() {
   if (background_color_ == SK_ColorTRANSPARENT) {
     SetBackgroundColor(background_color_);
+#ifdef DISABLE_GPU
+    if (compositor_) {
+      compositor_->SetBackgroundColor(background_color_);
+    }
+#else
     auto compositor = CefRenderWidgetHostViewOSR::GetCompositor(
         browser_impl_->GetAcceleratedWidget());
     if (compositor) {
       compositor->SetBackgroundColor(background_color_);
     }
+#endif
     return true;
   }
   return false;
@@ -1071,10 +1272,15 @@ void CefRenderWidgetHostViewOSR::SendExternalBeginFrame() {
   if (render_widget_host_)
     render_widget_host_->ProgressFlingIfNeeded(frame_time);
 
+#ifdef DISABLE_GPU
+  if (compositor_) {
+    compositor_->IssueExternalBeginFrame(
+#else
   auto compositor = CefRenderWidgetHostViewOSR::GetCompositor(
       browser_impl_->GetAcceleratedWidget());
   if (compositor) {
     compositor->IssueExternalBeginFrame(
+#endif
         begin_frame_args, /* force= */ true,
         base::BindOnce(&CefRenderWidgetHostViewOSR::OnFrameComplete,
                        weak_ptr_factory_.GetWeakPtr()));
@@ -1090,6 +1296,10 @@ void CefRenderWidgetHostViewOSR::SendKeyEvent(
   TRACE_EVENT0("cef", "CefRenderWidgetHostViewOSR::SendKeyEvent");
   content::RenderWidgetHostImpl* target_host = render_widget_host_;
 
+  if (selection_controller_client_) {
+    selection_controller_client_->CloseQuickMenuAndHideHandles();
+  }
+
   // If there are multiple widgets on the page (such as when there are
   // out-of-process iframes), pick the one that should process this event.
   if (render_widget_host_ && render_widget_host_->delegate()) {
@@ -1118,6 +1328,10 @@ void CefRenderWidgetHostViewOSR::SendMouseEvent(
       browser_impl_->CancelContextMenu();
     }
 
+    if (selection_controller_client_) {
+      selection_controller_client_->CloseQuickMenuAndHideHandles();
+    }
+
     if (popup_host_view_) {
       if (popup_host_view_->popup_position_.Contains(
               event.PositionInWidget().x(), event.PositionInWidget().y())) {
@@ -1180,6 +1394,10 @@ void CefRenderWidgetHostViewOSR::SendMouseWheelEvent(
     if (browser_impl_.get())
       browser_impl_->CancelContextMenu();
 
+    if (selection_controller_client_) {
+      selection_controller_client_->CloseQuickMenuAndHideHandles();
+    }
+
     if (popup_host_view_) {
       if (popup_host_view_->popup_position_.Contains(
               event.PositionInWidget().x(), event.PositionInWidget().y())) {
@@ -1269,8 +1487,14 @@ void CefRenderWidgetHostViewOSR::SendTouchEvent(const CefTouchEvent& event) {
   }
 
   // Update the touch event first.
-  if (!pointer_state_.OnTouch(event))
+  if (!pointer_state_.OnTouch(event)) {
     return;
+  }
+
+  if (selection_controller_->WillHandleTouchEvent(pointer_state_)) {
+    pointer_state_.CleanupRemovedTouchPoints(event);
+    return;
+  }
 
   ui::FilteredGestureProvider::TouchHandlingResult result =
       gesture_provider_.OnTouchEvent(pointer_state_);
@@ -1335,6 +1559,10 @@ void CefRenderWidgetHostViewOSR::SendFocusEvent(bool focus) {
     if (browser_impl_.get())
       browser_impl_->CancelContextMenu();
 
+    if (selection_controller_client_) {
+      selection_controller_client_->CloseQuickMenuAndHideHandles();
+    }
+
     widget->SetActive(false);
     widget->LostFocus();
   }
@@ -1475,6 +1703,13 @@ ui::Layer* CefRenderWidgetHostViewOSR::GetRootLayer() const {
   return root_layer_.get();
 }
 
+ui::TextInputType CefRenderWidgetHostViewOSR::GetTextInputType() {
+  if (text_input_manager_ && text_input_manager_->GetTextInputState())
+    return text_input_manager_->GetTextInputState()->type;
+
+  return ui::TEXT_INPUT_TYPE_NONE;
+}
+
 void CefRenderWidgetHostViewOSR::SetFrameRate() {
   CefRefPtr<AlloyBrowserHostImpl> browser;
   if (parent_host_view_) {
@@ -1494,10 +1729,15 @@ void CefRenderWidgetHostViewOSR::SetFrameRate() {
 
   frame_rate_threshold_us_ = 1000000 / frame_rate;
 
+#ifdef DISABLE_GPU
+  if (compositor_) {
+    compositor_->SetDisplayVSyncParameters(
+#else
   auto compositor = CefRenderWidgetHostViewOSR::GetCompositor(
       browser_impl_->GetAcceleratedWidget());
   if (compositor) {
     compositor->SetDisplayVSyncParameters(
+#endif
         base::TimeTicks::Now(),
         base::TimeDelta::FromMicroseconds(frame_rate_threshold_us_));
   }
@@ -1557,11 +1797,17 @@ bool CefRenderWidgetHostViewOSR::SetRootLayerSize(bool force) {
 
   GetRootLayer()->SetBounds(gfx::Rect(GetViewBounds().size()));
 
+#ifdef DISABLE_GPU
+  if (compositor_) {
+    compositor_local_surface_id_allocator_.GenerateId();
+    compositor_->SetScaleAndSize(
+#else
   auto compositor = CefRenderWidgetHostViewOSR::GetCompositor(
       browser_impl_->GetAcceleratedWidget());
   if (compositor) {
     compositor_local_surface_id_allocator_.GenerateId();
     compositor->SetScaleAndSize(
+#endif
         current_device_scale_factor(), SizeInPixels(),
         compositor_local_surface_id_allocator_.GetCurrentLocalSurfaceId());
   }
@@ -1742,4 +1988,4 @@ ui::Compositor* CefRenderWidgetHostViewOSR::GetCompositor(
     return nullptr;
   }
   return it->second;
-}
\ No newline at end of file
+}
diff --git a/cef/libcef/browser/osr/render_widget_host_view_osr.h b/cef/libcef/browser/osr/render_widget_host_view_osr.h
index 8964e17d5834b..aeca0fbfb9fae 100644
--- a/cef/libcef/browser/osr/render_widget_host_view_osr.h
+++ b/cef/libcef/browser/osr/render_widget_host_view_osr.h
@@ -32,6 +32,7 @@
 #include "content/public/common/widget_type.h"
 #include "ui/base/cursor/cursor.h"
 #include "ui/base/cursor/mojom/cursor_type.mojom-shared.h"
+#include "ui/base/ime/text_input_client.h"
 #include "ui/compositor/compositor.h"
 #include "ui/events/base_event_utils.h"
 #include "ui/events/gesture_detection/filtered_gesture_provider.h"
@@ -47,6 +48,10 @@
 #include "ui/gfx/win/window_impl.h"
 #endif
 
+namespace ui {
+class TouchSelectionController;
+}  // namespace ui
+
 namespace content {
 class DelegatedFrameHost;
 class DelegatedFrameHostClient;
@@ -59,6 +64,7 @@ class CursorManager;
 
 class CefCopyFrameGenerator;
 class CefSoftwareOutputDeviceOSR;
+class CefTouchSelectionControllerClientOSR;
 class CefVideoConsumerOSR;
 class CefWebContentsViewOSR;
 
@@ -116,6 +122,8 @@ class CefRenderWidgetHostViewOSR
   void Hide() override;
   bool IsShowing() override;
   void EnsureSurfaceSynchronizedForWebTest() override;
+  content::TouchSelectionControllerClientManager*
+  GetTouchSelectionControllerClientManager() override;
   gfx::Rect GetViewBounds() override;
   void SetBackgroundColor(SkColor color) override;
   base::Optional<SkColor> GetBackgroundColor() override;
@@ -128,6 +136,7 @@ class CefRenderWidgetHostViewOSR
   blink::mojom::PointerLockResult ChangeMouseLock(
       bool request_unadjusted_movement) override;
   void UnlockMouse() override;
+  bool IsMouseLocked() override;
   void TakeFallbackContentFrom(content::RenderWidgetHostView* view) override;
 
 #if defined(OS_MAC)
@@ -281,6 +290,16 @@ class CefRenderWidgetHostViewOSR
   static void AddCompositor(gfx::AcceleratedWidget widget, ui::Compositor* compositor);
   static ui::Compositor* GetCompositor(gfx::AcceleratedWidget widget);
 
+  ui::TouchSelectionController* selection_controller() const {
+    return selection_controller_.get();
+  }
+
+  CefTouchSelectionControllerClientOSR* selection_controller_client() const {
+    return selection_controller_client_.get();
+  }
+
+  ui::TextInputType GetTextInputType();
+
  private:
   void SetFrameRate();
   bool SetDeviceScaleFactor();
@@ -293,6 +312,9 @@ class CefRenderWidgetHostViewOSR
 
   void CancelWidget();
 
+  // Helper function to create a selection controller.
+  void CreateSelectionController();
+
   void OnScrollOffsetChanged();
 
 #if defined(OS_OHOS)
@@ -341,6 +363,16 @@ class CefRenderWidgetHostViewOSR
   // opaqueness changes.
   void UpdateBackgroundColorFromRenderer(SkColor color);
 
+  void OnScaleChanged(float old_page_scale_factor, float nwe_page_scale_factor);
+
+  // The last selection bounds reported to the view.
+  gfx::SelectionBound selection_start_;
+  gfx::SelectionBound selection_end_;
+
+  std::unique_ptr<CefTouchSelectionControllerClientOSR>
+      selection_controller_client_;
+  std::unique_ptr<ui::TouchSelectionController> selection_controller_;
+
   // The background color of the web content.
   SkColor background_color_;
 
@@ -423,6 +455,12 @@ class CefRenderWidgetHostViewOSR
   DISALLOW_COPY_AND_ASSIGN(CefRenderWidgetHostViewOSR);
 
   static std::unordered_map<gfx::AcceleratedWidget, ui::Compositor*> compositor_map_;
+
+  static std::unordered_map<gfx::AcceleratedWidget, uint32_t> accelerate_widget_map_;
+
+  float page_scale_factor_;
+
+  bool is_mouse_locked_ = false;
 };
 
 #endif  // CEF_LIBCEF_BROWSER_OSR_RENDER_WIDGET_HOST_VIEW_OSR_H_
diff --git a/cef/libcef/browser/osr/touch_handle_drawable_osr.cc b/cef/libcef/browser/osr/touch_handle_drawable_osr.cc
new file mode 100755
index 0000000000000..5c4b2b83ad234
--- /dev/null
+++ b/cef/libcef/browser/osr/touch_handle_drawable_osr.cc
@@ -0,0 +1,129 @@
+// Copyright 2022 The Chromium Embedded Framework Authors.
+// Portions copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "libcef/browser/osr/touch_handle_drawable_osr.h"
+
+#include <cmath>
+
+#include "libcef/browser/osr/render_widget_host_view_osr.h"
+
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace {
+// Copied from touch_handle_drawable_aura.cc
+
+// The distance by which a handle image is offset from the focal point (i.e.
+// text baseline) downwards.
+constexpr int kSelectionHandleVerticalVisualOffset = 2;
+
+// The padding around the selection handle image can be used to extend the
+// handle so that touch events near the selection handle image are
+// targeted to the selection handle.
+constexpr int kSelectionHandlePadding = 0;
+
+}  // namespace
+
+int CefTouchHandleDrawableOSR::counter_ = 0;
+
+CefTouchHandleDrawableOSR::CefTouchHandleDrawableOSR(
+    CefRenderWidgetHostViewOSR* rwhv)
+    : rwhv_(rwhv), id_(counter_++) {}
+
+void CefTouchHandleDrawableOSR::SetEnabled(bool enabled) {
+  if (enabled == enabled_)
+    return;
+
+  enabled_ = enabled;
+
+  CefTouchHandleState touch_handle_state;
+  touch_handle_state.touch_handle_id = id_;
+  touch_handle_state.flags = CEF_THS_FLAG_ENABLED;
+  touch_handle_state.enabled = enabled_;
+  TouchHandleStateChanged(touch_handle_state);
+}
+
+void CefTouchHandleDrawableOSR::SetOrientation(
+    ui::TouchHandleOrientation orientation,
+    bool mirror_vertical,
+    bool mirror_horizontal) {
+  if (orientation == orientation_)
+    return;
+
+  orientation_ = orientation;
+
+  CefSize size;
+  auto browser = rwhv_->browser_impl();
+  auto handler = browser->GetClient()->GetRenderHandler();
+  handler->GetTouchHandleSize(
+      browser.get(), static_cast<cef_horizontal_alignment_t>(orientation_),
+      size);
+
+  const gfx::Size& image_size = gfx::Size(size.width, size.height);
+  int handle_width = image_size.width() + 2 * kSelectionHandlePadding;
+  int handle_height = image_size.height() + 2 * kSelectionHandlePadding;
+  relative_bounds_ =
+      gfx::RectF(-kSelectionHandlePadding,
+                 kSelectionHandleVerticalVisualOffset - kSelectionHandlePadding,
+                 handle_width, handle_height);
+
+  CefTouchHandleState touch_handle_state;
+  touch_handle_state.touch_handle_id = id_;
+  touch_handle_state.flags = CEF_THS_FLAG_ORIENTATION;
+  touch_handle_state.orientation =
+      static_cast<cef_horizontal_alignment_t>(orientation_);
+  touch_handle_state.mirror_vertical = mirror_vertical;
+  touch_handle_state.mirror_horizontal = mirror_horizontal;
+  TouchHandleStateChanged(touch_handle_state);
+}
+
+void CefTouchHandleDrawableOSR::SetOrigin(const gfx::PointF& position) {
+  if (position == origin_position_)
+    return;
+
+  origin_position_ = position;
+
+  CefTouchHandleState touch_handle_state;
+  touch_handle_state.touch_handle_id = id_;
+  touch_handle_state.flags = CEF_THS_FLAG_ORIGIN;
+  touch_handle_state.origin = {static_cast<int>(std::round(position.x())),
+                               static_cast<int>(std::round(position.y()))};
+  TouchHandleStateChanged(touch_handle_state);
+}
+
+void CefTouchHandleDrawableOSR::SetAlpha(float alpha) {
+  if (alpha == alpha_)
+    return;
+
+  alpha_ = alpha;
+
+  CefTouchHandleState touch_handle_state;
+  touch_handle_state.touch_handle_id = id_;
+  touch_handle_state.flags = CEF_THS_FLAG_ALPHA;
+  touch_handle_state.alpha = alpha_;
+  TouchHandleStateChanged(touch_handle_state);
+}
+
+gfx::RectF CefTouchHandleDrawableOSR::GetVisibleBounds() const {
+  gfx::RectF bounds = relative_bounds_;
+  bounds.Offset(origin_position_.x(), origin_position_.y());
+  // TODO: 91.0.4455.0 don't have gfx::InsetsF::TLBR
+//   bounds.Inset(gfx::InsetsF::TLBR(
+//       kSelectionHandlePadding,
+//       kSelectionHandlePadding + kSelectionHandleVerticalVisualOffset,
+//       kSelectionHandlePadding, kSelectionHandlePadding));
+  return bounds;
+}
+
+float CefTouchHandleDrawableOSR::GetDrawableHorizontalPaddingRatio() const {
+  return 0.0f;
+}
+
+void CefTouchHandleDrawableOSR::TouchHandleStateChanged(
+    const CefTouchHandleState& state) {
+  auto browser = rwhv_->browser_impl();
+  auto handler = browser->GetClient()->GetRenderHandler();
+  handler->OnTouchHandleStateChanged(browser.get(), state);
+}
\ No newline at end of file
diff --git a/cef/libcef/browser/osr/touch_handle_drawable_osr.h b/cef/libcef/browser/osr/touch_handle_drawable_osr.h
new file mode 100755
index 0000000000000..b80286912c84c
--- /dev/null
+++ b/cef/libcef/browser/osr/touch_handle_drawable_osr.h
@@ -0,0 +1,59 @@
+// Copyright 2022 The Chromium Embedded Framework Authors.
+// Portions copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_BROWSER_OSR_TOUCH_HANDLE_DRAWABLE_OSR_H_
+#define CEF_LIBCEF_BROWSER_OSR_TOUCH_HANDLE_DRAWABLE_OSR_H_
+
+#include "include/internal/cef_types_wrappers.h"
+
+// #include "base/memory/raw_ptr.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/touch_selection/touch_handle.h"
+#include "ui/touch_selection/touch_handle_orientation.h"
+#include "ui/touch_selection/ui_touch_selection_export.h"
+
+class CefRenderWidgetHostViewOSR;
+
+// Copied from TouchHandleDrawableAura.
+class CefTouchHandleDrawableOSR : public ui::TouchHandleDrawable {
+ public:
+  explicit CefTouchHandleDrawableOSR(CefRenderWidgetHostViewOSR* rwhv);
+
+  CefTouchHandleDrawableOSR(const CefTouchHandleDrawableOSR&) = delete;
+  CefTouchHandleDrawableOSR& operator=(const CefTouchHandleDrawableOSR&) =
+      delete;
+
+ private:
+  // TouchHandleDrawable:
+  void SetEnabled(bool enabled) override;
+  void SetOrientation(ui::TouchHandleOrientation orientation,
+                      bool mirror_vertical,
+                      bool mirror_horizontal) override;
+  void SetOrigin(const gfx::PointF& position) override;
+  void SetAlpha(float alpha) override;
+  gfx::RectF GetVisibleBounds() const override;
+  float GetDrawableHorizontalPaddingRatio() const override;
+
+  // Pass the current touch handle state to the CefRenderHandler.
+  void TouchHandleStateChanged(const CefTouchHandleState& state);
+
+  CefRenderWidgetHostViewOSR* rwhv_;
+
+  float alpha_ = 0.f;
+  static int counter_;
+  bool enabled_ = false;
+  int id_;
+  ui::TouchHandleOrientation orientation_ =
+      ui::TouchHandleOrientation::UNDEFINED;
+
+  // Origin position of the handle set via SetOrigin, in coordinate space of
+  // selection controller client (i.e. handle's parent).
+  gfx::PointF origin_position_;
+
+  // Handle bounds relative to the focal position.
+  gfx::RectF relative_bounds_ = gfx::RectF(0.0F, 0.0F, 24.0F, 24.0F);
+};
+
+#endif
\ No newline at end of file
diff --git a/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc b/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc
new file mode 100755
index 0000000000000..09bab10e798bb
--- /dev/null
+++ b/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc
@@ -0,0 +1,525 @@
+// Copyright 2022 The Chromium Embedded Framework Authors.
+// Portions copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "libcef/browser/osr/touch_selection_controller_client_osr.h"
+
+#include <cmath>
+#include <set>
+
+#include "libcef/browser/osr/render_widget_host_view_osr.h"
+#include "libcef/browser/osr/touch_handle_drawable_osr.h"
+
+#include "base/bind.h"
+#include "content/browser/renderer_host/render_widget_host_delegate.h"
+#include "content/browser/renderer_host/render_widget_host_impl.h"
+#include "content/public/browser/context_menu_params.h"
+#include "content/public/browser/render_view_host.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
+#include "ui/base/pointer/touch_editing_controller.h"
+#include "ui/gfx/geometry/point_conversions.h"
+#include "ui/gfx/geometry/size_conversions.h"
+
+namespace {
+
+// Delay before showing the quick menu, in milliseconds.
+constexpr int kQuickMenuDelayInMs = 100;
+
+constexpr cef_quick_menu_edit_state_flags_t kMenuCommands[] = {
+    QM_EDITFLAG_CAN_ELLIPSIS, QM_EDITFLAG_CAN_CUT, QM_EDITFLAG_CAN_COPY,
+    QM_EDITFLAG_CAN_PASTE};
+
+constexpr int kInvalidCommandId = -1;
+constexpr cef_event_flags_t kEmptyEventFlags =
+    static_cast<cef_event_flags_t>(0);
+
+class CefRunQuickMenuCallbackImpl : public CefRunQuickMenuCallback {
+ public:
+  using Callback = base::OnceCallback<void(int, int)>;
+
+  explicit CefRunQuickMenuCallbackImpl(Callback callback)
+      : callback_(std::move(callback)) {}
+
+  CefRunQuickMenuCallbackImpl(const CefRunQuickMenuCallbackImpl&) = delete;
+  CefRunQuickMenuCallbackImpl& operator=(const CefRunQuickMenuCallbackImpl&) =
+      delete;
+
+  ~CefRunQuickMenuCallbackImpl() {
+    if (!callback_.is_null()) {
+      // The callback is still pending. Cancel it now.
+      if (CEF_CURRENTLY_ON_UIT()) {
+        RunNow(std::move(callback_), kInvalidCommandId, kEmptyEventFlags);
+      } else {
+        CEF_POST_TASK(CEF_UIT,
+                      base::BindOnce(&CefRunQuickMenuCallbackImpl::RunNow,
+                                     std::move(callback_), kInvalidCommandId,
+                                     kEmptyEventFlags));
+      }
+    }
+  }
+
+  void Continue(int command_id, cef_event_flags_t event_flags) override {
+    if (CEF_CURRENTLY_ON_UIT()) {
+      if (!callback_.is_null()) {
+        RunNow(std::move(callback_), command_id, event_flags);
+      }
+    } else {
+      CEF_POST_TASK(CEF_UIT,
+                    base::BindOnce(&CefRunQuickMenuCallbackImpl::Continue, this,
+                                   command_id, event_flags));
+    }
+  }
+
+  void Cancel() override { Continue(kInvalidCommandId, kEmptyEventFlags); }
+
+  void Disconnect() { callback_.Reset(); }
+
+ private:
+  static void RunNow(Callback callback,
+                     int command_id,
+                     cef_event_flags_t event_flags) {
+    CEF_REQUIRE_UIT();
+    std::move(callback).Run(command_id, event_flags);
+  }
+
+  Callback callback_;
+
+  IMPLEMENT_REFCOUNTING(CefRunQuickMenuCallbackImpl);
+};
+
+}  // namespace
+
+CefTouchSelectionControllerClientOSR::CefTouchSelectionControllerClientOSR(
+    CefRenderWidgetHostViewOSR* rwhv)
+    : rwhv_(rwhv),
+      internal_client_(rwhv),
+      active_client_(&internal_client_),
+      active_menu_client_(this),
+      quick_menu_timer_(
+          FROM_HERE,
+          base::TimeDelta::FromMilliseconds(kQuickMenuDelayInMs),
+          base::BindRepeating(
+              &CefTouchSelectionControllerClientOSR::ShowQuickMenu,
+              base::Unretained(this))),
+      weak_ptr_factory_(this) {
+  DCHECK(rwhv_);
+}
+
+CefTouchSelectionControllerClientOSR::~CefTouchSelectionControllerClientOSR() {
+  for (auto& observer : observers_)
+    observer.OnManagerWillDestroy(this);
+}
+
+void CefTouchSelectionControllerClientOSR::CloseQuickMenuAndHideHandles() {
+  CloseQuickMenu();
+  rwhv_->selection_controller()->HideAndDisallowShowingAutomatically();
+}
+
+void CefTouchSelectionControllerClientOSR::OnWindowMoved() {
+  UpdateQuickMenu();
+}
+
+void CefTouchSelectionControllerClientOSR::OnTouchDown() {
+  touch_down_ = true;
+  UpdateQuickMenu();
+}
+
+void CefTouchSelectionControllerClientOSR::OnTouchUp() {
+  touch_down_ = false;
+  UpdateQuickMenu();
+}
+
+void CefTouchSelectionControllerClientOSR::OnScrollStarted() {
+  scroll_in_progress_ = true;
+  rwhv_->selection_controller()->SetTemporarilyHidden(true);
+  UpdateQuickMenu();
+}
+
+void CefTouchSelectionControllerClientOSR::OnScrollCompleted() {
+  scroll_in_progress_ = false;
+  active_client_->DidScroll();
+  rwhv_->selection_controller()->SetTemporarilyHidden(false);
+  UpdateQuickMenu();
+}
+
+bool CefTouchSelectionControllerClientOSR::HandleContextMenu(
+    const content::ContextMenuParams& params) {
+  if ((params.source_type == ui::MENU_SOURCE_LONG_PRESS ||
+       params.source_type == ui::MENU_SOURCE_LONG_TAP) &&
+      params.is_editable && params.selection_text.empty() &&
+      IsQuickMenuAvailable()) {
+    quick_menu_requested_ = true;
+    UpdateQuickMenu();
+    return true;
+  }
+
+  const bool from_touch = params.source_type == ui::MENU_SOURCE_LONG_PRESS ||
+                          params.source_type == ui::MENU_SOURCE_LONG_TAP ||
+                          params.source_type == ui::MENU_SOURCE_TOUCH;
+  if (from_touch && !params.selection_text.empty())
+    return true;
+
+  rwhv_->selection_controller()->HideAndDisallowShowingAutomatically();
+  return false;
+}
+
+void CefTouchSelectionControllerClientOSR::DidStopFlinging() {
+  OnScrollCompleted();
+}
+
+void CefTouchSelectionControllerClientOSR::UpdateClientSelectionBounds(
+    const gfx::SelectionBound& start,
+    const gfx::SelectionBound& end) {
+  UpdateClientSelectionBounds(start, end, &internal_client_, this);
+}
+
+void CefTouchSelectionControllerClientOSR::UpdateClientSelectionBounds(
+    const gfx::SelectionBound& start,
+    const gfx::SelectionBound& end,
+    ui::TouchSelectionControllerClient* client,
+    ui::TouchSelectionMenuClient* menu_client) {
+  if (client != active_client_ &&
+      (start.type() == gfx::SelectionBound::EMPTY || !start.visible()) &&
+      (end.type() == gfx::SelectionBound::EMPTY || !end.visible()) &&
+      (manager_selection_start_.type() != gfx::SelectionBound::EMPTY ||
+       manager_selection_end_.type() != gfx::SelectionBound::EMPTY)) {
+    return;
+  }
+
+  active_client_ = client;
+  active_menu_client_ = menu_client;
+  manager_selection_start_ = start;
+  manager_selection_end_ = end;
+
+  // Notify TouchSelectionController if anything should change here. Only
+  // update if the client is different and not making a change to empty, or
+  // is the same client.
+  GetTouchSelectionController()->OnSelectionBoundsChanged(start, end);
+}
+
+void CefTouchSelectionControllerClientOSR::InvalidateClient(
+    ui::TouchSelectionControllerClient* client) {
+  DCHECK(client != &internal_client_);
+  if (client == active_client_) {
+    active_client_ = &internal_client_;
+    active_menu_client_ = this;
+  }
+}
+
+ui::TouchSelectionController*
+CefTouchSelectionControllerClientOSR::GetTouchSelectionController() {
+  return rwhv_->selection_controller();
+}
+
+void CefTouchSelectionControllerClientOSR::AddObserver(
+    TouchSelectionControllerClientManager::Observer* observer) {
+  observers_.AddObserver(observer);
+}
+
+void CefTouchSelectionControllerClientOSR::RemoveObserver(
+    TouchSelectionControllerClientManager::Observer* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+bool CefTouchSelectionControllerClientOSR::IsQuickMenuAvailable() const {
+  DCHECK(active_menu_client_);
+
+  const auto is_enabled = [this](cef_quick_menu_edit_state_flags_t command) {
+    return active_menu_client_->IsCommandIdEnabled(command);
+  };
+  return std::any_of(std::cbegin(kMenuCommands), std::cend(kMenuCommands),
+                     is_enabled);
+}
+
+void CefTouchSelectionControllerClientOSR::CloseQuickMenu() {
+  if (!quick_menu_running_)
+    return;
+
+  quick_menu_running_ = false;
+
+  auto browser = rwhv_->browser_impl();
+  if (auto handler = browser->client()->GetContextMenuHandler()) {
+    handler->OnQuickMenuDismissed(browser.get(), browser->GetFocusedFrame());
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::ShowQuickMenu() {
+  auto browser = rwhv_->browser_impl();
+  if (auto handler = browser->client()->GetContextMenuHandler()) {
+    gfx::RectF rect =
+        rwhv_->selection_controller()->GetVisibleRectBetweenBounds();
+
+    gfx::PointF origin = rect.origin();
+    gfx::PointF bottom_right = rect.bottom_right();
+    auto client_bounds = gfx::RectF(rwhv_->GetViewBounds());
+    origin.SetToMax(client_bounds.origin());
+    bottom_right.SetToMin(client_bounds.bottom_right());
+    if (origin.x() > bottom_right.x() || origin.y() > bottom_right.y())
+      return;
+
+    gfx::Vector2dF diagonal = bottom_right - origin;
+    gfx::SizeF size(diagonal.x(), diagonal.y());
+
+    int quickmenuflags = 0;
+    for (const auto& command : kMenuCommands) {
+      if (active_menu_client_->IsCommandIdEnabled(command)) {
+        quickmenuflags |= command;
+      }
+    }
+
+    CefRefPtr<CefRunQuickMenuCallbackImpl> callbackImpl(
+        new CefRunQuickMenuCallbackImpl(base::BindOnce(
+            &CefTouchSelectionControllerClientOSR::ExecuteCommand,
+            weak_ptr_factory_.GetWeakPtr())));
+
+    quick_menu_running_ = true;
+    if (!handler->RunQuickMenu(
+            browser, browser->GetFocusedFrame(),
+            {static_cast<int>(std::round(origin.x())),
+             static_cast<int>(std::round(origin.y()))},
+            {static_cast<int>(std::round(size.width())),
+             static_cast<int>(std::round(size.height()))},
+            static_cast<CefContextMenuHandler::QuickMenuEditStateFlags>(
+                quickmenuflags),
+            callbackImpl)) {
+      callbackImpl->Disconnect();
+      CloseQuickMenu();
+    }
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::UpdateQuickMenu() {
+  // Hide the quick menu if there is any. This should happen even if the menu
+  // should be shown again, in order to update its location or content.
+  if (quick_menu_running_) {
+    CloseQuickMenu();
+  } else {
+    quick_menu_timer_.Stop();
+  }
+
+  // Start timer to show quick menu if necessary.
+  if (ShouldShowQuickMenu()) {
+    quick_menu_timer_.Reset();
+  }
+}
+
+bool CefTouchSelectionControllerClientOSR::SupportsAnimation() const {
+  return false;
+}
+
+bool CefTouchSelectionControllerClientOSR::InternalClient::SupportsAnimation()
+    const {
+  NOTREACHED();
+  return false;
+}
+
+void CefTouchSelectionControllerClientOSR::SetNeedsAnimate() {
+  NOTREACHED();
+}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::SetNeedsAnimate() {
+  NOTREACHED();
+}
+
+void CefTouchSelectionControllerClientOSR::MoveCaret(
+    const gfx::PointF& position) {
+  active_client_->MoveCaret(position);
+}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::MoveCaret(
+    const gfx::PointF& position) {
+  if (auto host_delegate = rwhv_->host()->delegate()) {
+    host_delegate->MoveCaret(gfx::ToRoundedPoint(position));
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::MoveRangeSelectionExtent(
+    const gfx::PointF& extent) {
+  active_client_->MoveRangeSelectionExtent(extent);
+}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::
+    MoveRangeSelectionExtent(const gfx::PointF& extent) {
+  if (auto host_delegate = rwhv_->host()->delegate()) {
+    host_delegate->MoveRangeSelectionExtent(gfx::ToRoundedPoint(extent));
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::SelectBetweenCoordinates(
+    const gfx::PointF& base,
+    const gfx::PointF& extent) {
+  active_client_->SelectBetweenCoordinates(base, extent);
+}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::
+    SelectBetweenCoordinates(const gfx::PointF& base,
+                             const gfx::PointF& extent) {
+  if (auto host_delegate = rwhv_->host()->delegate()) {
+    host_delegate->SelectRange(gfx::ToRoundedPoint(base),
+                               gfx::ToRoundedPoint(extent));
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::OnSelectionEvent(
+    ui::SelectionEventType event) {
+  // This function (implicitly) uses active_menu_client_, so we don't go to the
+  // active view for this.
+  switch (event) {
+    case ui::SELECTION_HANDLES_SHOWN:
+      quick_menu_requested_ = true;
+      [[fallthrough]];
+    case ui::INSERTION_HANDLE_SHOWN:
+      UpdateQuickMenu();
+      break;
+    case ui::SELECTION_HANDLES_CLEARED:
+    case ui::INSERTION_HANDLE_CLEARED:
+      quick_menu_requested_ = false;
+      UpdateQuickMenu();
+      break;
+    case ui::SELECTION_HANDLE_DRAG_STARTED:
+    case ui::INSERTION_HANDLE_DRAG_STARTED:
+      handle_drag_in_progress_ = true;
+      UpdateQuickMenu();
+      break;
+    case ui::SELECTION_HANDLE_DRAG_STOPPED:
+    case ui::INSERTION_HANDLE_DRAG_STOPPED:
+      handle_drag_in_progress_ = false;
+      UpdateQuickMenu();
+      break;
+    case ui::SELECTION_HANDLES_MOVED:
+    case ui::INSERTION_HANDLE_MOVED:
+      UpdateQuickMenu();
+      break;
+    case ui::INSERTION_HANDLE_TAPPED:
+      quick_menu_requested_ = !quick_menu_requested_;
+      UpdateQuickMenu();
+      break;
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::OnSelectionEvent(
+    ui::SelectionEventType event) {
+  NOTREACHED();
+}
+
+void CefTouchSelectionControllerClientOSR::OnDragUpdate(
+    const ui::TouchSelectionDraggable::Type type,
+    const gfx::PointF& position) {}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::OnDragUpdate(
+    const ui::TouchSelectionDraggable::Type type,
+    const gfx::PointF& position) {
+  NOTREACHED();
+}
+
+std::unique_ptr<ui::TouchHandleDrawable>
+CefTouchSelectionControllerClientOSR::CreateDrawable() {
+  return std::make_unique<CefTouchHandleDrawableOSR>(rwhv_);
+}
+
+void CefTouchSelectionControllerClientOSR::DidScroll() {}
+
+std::unique_ptr<ui::TouchHandleDrawable>
+CefTouchSelectionControllerClientOSR::InternalClient::CreateDrawable() {
+  NOTREACHED();
+  return nullptr;
+}
+
+void CefTouchSelectionControllerClientOSR::InternalClient::DidScroll() {
+  NOTREACHED();
+}
+
+bool CefTouchSelectionControllerClientOSR::IsCommandIdEnabled(
+    int command_id) const {
+  bool editable = rwhv_->GetTextInputType() != ui::TEXT_INPUT_TYPE_NONE;
+  bool readable = rwhv_->GetTextInputType() != ui::TEXT_INPUT_TYPE_PASSWORD;
+  bool has_selection = !rwhv_->GetSelectedText().empty();
+  switch (command_id) {
+    case QM_EDITFLAG_CAN_ELLIPSIS:
+      return true;  // Always allowed to show the ellipsis button.
+    case QM_EDITFLAG_CAN_CUT:
+      return editable && readable && has_selection;
+    case QM_EDITFLAG_CAN_COPY:
+      return readable && has_selection;
+    case QM_EDITFLAG_CAN_PASTE: {
+      std::u16string result;
+      ui::DataTransferEndpoint data_dst = ui::DataTransferEndpoint(
+          ui::EndpointType::kDefault, /*notify_if_restricted=*/false);
+      ui::Clipboard::GetForCurrentThread()->ReadText(
+          ui::ClipboardBuffer::kCopyPaste, &data_dst, &result);
+      return editable && !result.empty();
+    }
+    default:
+      return false;
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::ExecuteCommand(int command_id,
+                                                          int event_flags) {
+  if (command_id == kInvalidCommandId) {
+    return;
+  }
+
+  if (command_id != QM_EDITFLAG_CAN_ELLIPSIS) {
+    rwhv_->selection_controller()->HideAndDisallowShowingAutomatically();
+  }
+
+  content::RenderWidgetHostDelegate* host_delegate = rwhv_->host()->delegate();
+  if (!host_delegate) {
+    return;
+  }
+
+  auto browser = rwhv_->browser_impl();
+  if (auto handler = browser->client()->GetContextMenuHandler()) {
+    if (handler->OnQuickMenuCommand(
+            browser.get(), browser->GetFocusedFrame(), command_id,
+            static_cast<cef_event_flags_t>(event_flags))) {
+      return;
+    }
+  }
+
+  switch (command_id) {
+    case QM_EDITFLAG_CAN_CUT:
+      host_delegate->Cut();
+      break;
+    case QM_EDITFLAG_CAN_COPY:
+      host_delegate->Copy();
+      break;
+    case QM_EDITFLAG_CAN_PASTE:
+      host_delegate->Paste();
+      break;
+    case QM_EDITFLAG_CAN_ELLIPSIS:
+      CloseQuickMenu();
+      RunContextMenu();
+      break;
+    default:
+      // Invalid command, do nothing.
+      // Also reached when callback is destroyed/cancelled.
+      break;
+  }
+}
+
+void CefTouchSelectionControllerClientOSR::RunContextMenu() {
+  const gfx::RectF anchor_rect =
+      rwhv_->selection_controller()->GetVisibleRectBetweenBounds();
+  const gfx::PointF anchor_point =
+      gfx::PointF(anchor_rect.CenterPoint().x(), anchor_rect.y());
+  rwhv_->host()->ShowContextMenuAtPoint(gfx::ToRoundedPoint(anchor_point),
+                                        ui::MENU_SOURCE_TOUCH_EDIT_MENU);
+
+  // Hide selection handles after getting rect-between-bounds from touch
+  // selection controller; otherwise, rect would be empty and the above
+  // calculations would be invalid.
+  rwhv_->selection_controller()->HideAndDisallowShowingAutomatically();
+}
+
+bool CefTouchSelectionControllerClientOSR::ShouldShowQuickMenu() {
+  return quick_menu_requested_ && !touch_down_ && !scroll_in_progress_ &&
+         !handle_drag_in_progress_ && IsQuickMenuAvailable();
+}
+
+std::u16string CefTouchSelectionControllerClientOSR::GetSelectedText() {
+  return rwhv_->GetSelectedText();
+}
\ No newline at end of file
diff --git a/cef/libcef/browser/osr/touch_selection_controller_client_osr.h b/cef/libcef/browser/osr/touch_selection_controller_client_osr.h
new file mode 100755
index 0000000000000..f1b84b79515f3
--- /dev/null
+++ b/cef/libcef/browser/osr/touch_selection_controller_client_osr.h
@@ -0,0 +1,155 @@
+// Copyright 2022 The Chromium Embedded Framework Authors.
+// Portions copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_BROWSER_OSR_TOUCH_SELECTION_CONTROLLER_CLIENT_OSR_H_
+#define CEF_LIBCEF_BROWSER_OSR_TOUCH_SELECTION_CONTROLLER_CLIENT_OSR_H_
+
+#include <memory>
+
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "base/timer/timer.h"
+#include "content/common/content_export.h"
+#include "content/public/browser/touch_selection_controller_client_manager.h"
+#include "ui/touch_selection/touch_selection_controller.h"
+#include "ui/touch_selection/touch_selection_menu_runner.h"
+
+namespace content {
+struct ContextMenuParams;
+}
+
+class CefRenderWidgetHostViewOSR;
+
+// An implementation of |TouchSelectionControllerClient| to be used in OSR's
+// implementation of touch selection for contents.
+// Copied from TouchSelectionControllerClientAura.
+class CefTouchSelectionControllerClientOSR
+    : public ui::TouchSelectionControllerClient,
+      public ui::TouchSelectionMenuClient,
+      public content::TouchSelectionControllerClientManager {
+ public:
+  explicit CefTouchSelectionControllerClientOSR(
+      CefRenderWidgetHostViewOSR* rwhv);
+
+  CefTouchSelectionControllerClientOSR(
+      const CefTouchSelectionControllerClientOSR&) = delete;
+  CefTouchSelectionControllerClientOSR& operator=(
+      const CefTouchSelectionControllerClientOSR&) = delete;
+
+  ~CefTouchSelectionControllerClientOSR() override;
+
+  void CloseQuickMenuAndHideHandles();
+
+  void OnWindowMoved();
+
+  // Called on first touch down/last touch up to hide/show the quick menu.
+  void OnTouchDown();
+
+  void OnTouchUp();
+
+  // Called when touch scroll starts/completes to hide/show touch handles and
+  // the quick menu.
+  void OnScrollStarted();
+
+  void OnScrollCompleted();
+
+  // Gives an opportunity to the client to handle context menu request and show
+  // the quick menu instead, if appropriate. Returns |true| to indicate that no
+  // further handling is needed.
+  // TODO(mohsen): This is to match Chrome on Android behavior. However, it is
+  // better not to send context menu request from the renderer in this case and
+  // instead decide in the client about showing the quick menu in response to
+  // selection events. (http://crbug.com/548245)
+  bool HandleContextMenu(const content::ContextMenuParams& params);
+
+  void UpdateClientSelectionBounds(const gfx::SelectionBound& start,
+                                   const gfx::SelectionBound& end);
+
+  // TouchSelectionControllerClientManager.
+  void DidStopFlinging() override;
+  void UpdateClientSelectionBounds(
+      const gfx::SelectionBound& start,
+      const gfx::SelectionBound& end,
+      ui::TouchSelectionControllerClient* client,
+      ui::TouchSelectionMenuClient* menu_client) override;
+  void InvalidateClient(ui::TouchSelectionControllerClient* client) override;
+  ui::TouchSelectionController* GetTouchSelectionController() override;
+  void AddObserver(
+      TouchSelectionControllerClientManager::Observer* observer) override;
+  void RemoveObserver(
+      TouchSelectionControllerClientManager::Observer* observer) override;
+
+ private:
+  class EnvEventObserver;
+
+  bool IsQuickMenuAvailable() const;
+  void CloseQuickMenu();
+  void ShowQuickMenu();
+  void UpdateQuickMenu();
+
+  // ui::TouchSelectionControllerClient:
+  bool SupportsAnimation() const override;
+  void SetNeedsAnimate() override;
+  void MoveCaret(const gfx::PointF& position) override;
+  void MoveRangeSelectionExtent(const gfx::PointF& extent) override;
+  void SelectBetweenCoordinates(const gfx::PointF& base,
+                                const gfx::PointF& extent) override;
+  void OnSelectionEvent(ui::SelectionEventType event) override;
+  void OnDragUpdate(const ui::TouchSelectionDraggable::Type type,
+                    const gfx::PointF& position) override;
+  std::unique_ptr<ui::TouchHandleDrawable> CreateDrawable() override;
+  void DidScroll() override;
+
+  // ui::TouchSelectionMenuClient:
+  bool IsCommandIdEnabled(int command_id) const override;
+  void ExecuteCommand(int command_id, int event_flags) override;
+  void RunContextMenu() override;
+  bool ShouldShowQuickMenu() override;
+  std::u16string GetSelectedText() override;
+
+  // Not owned, non-null for the lifetime of this object.
+  CefRenderWidgetHostViewOSR* rwhv_;
+
+  class InternalClient final : public ui::TouchSelectionControllerClient {
+   public:
+    explicit InternalClient(CefRenderWidgetHostViewOSR* rwhv) : rwhv_(rwhv) {}
+    ~InternalClient() final {}
+
+    bool SupportsAnimation() const final;
+    void SetNeedsAnimate() final;
+    void MoveCaret(const gfx::PointF& position) final;
+    void MoveRangeSelectionExtent(const gfx::PointF& extent) final;
+    void SelectBetweenCoordinates(const gfx::PointF& base,
+                                  const gfx::PointF& extent) final;
+    void OnSelectionEvent(ui::SelectionEventType event) final;
+    void OnDragUpdate(const ui::TouchSelectionDraggable::Type type,
+                      const gfx::PointF& position) final;
+    std::unique_ptr<ui::TouchHandleDrawable> CreateDrawable() final;
+    void DidScroll() override;
+
+   private:
+    CefRenderWidgetHostViewOSR* rwhv_;
+  } internal_client_;
+
+  // Keep track of which client interface to use.
+  TouchSelectionControllerClient* active_client_;
+  TouchSelectionMenuClient* active_menu_client_;
+  gfx::SelectionBound manager_selection_start_;
+  gfx::SelectionBound manager_selection_end_;
+
+  base::ObserverList<TouchSelectionControllerClientManager::Observer>
+      observers_;
+
+  base::RetainingOneShotTimer quick_menu_timer_;
+  bool quick_menu_requested_ = false;
+  bool quick_menu_running_ = false;
+  bool touch_down_ = false;
+  bool scroll_in_progress_ = false;
+  bool handle_drag_in_progress_ = false;
+
+  base::WeakPtrFactory<CefTouchSelectionControllerClientOSR> weak_ptr_factory_;
+};
+
+#endif
\ No newline at end of file
diff --git a/cef/libcef/browser/permission/alloy_permission_manager.cc b/cef/libcef/browser/permission/alloy_permission_manager.cc
index 4b24d0612b8ec..38782beb360bf 100644
--- a/cef/libcef/browser/permission/alloy_permission_manager.cc
+++ b/cef/libcef/browser/permission/alloy_permission_manager.cc
@@ -236,13 +236,16 @@ void AlloyPermissionManager::RequestPermissionByType(
     case PermissionType::DISPLAY_CAPTURE:
     case PermissionType::MIDI:
     case PermissionType::SENSORS:
-    case PermissionType::WAKE_LOCK_SCREEN:
     case PermissionType::WAKE_LOCK_SYSTEM:
     default:
       NOTREACHED() << "Invalid PermissionType.";
       pending_request_raw->SetPermissionStatus(permission_type,
                                                PermissionStatus::DENIED);
       break;
+    case PermissionType::WAKE_LOCK_SCREEN:
+      pending_request_raw->SetPermissionStatus(permission_type,
+                                               PermissionStatus::GRANTED);
+      break;
   }
 }
 
diff --git a/cef/libcef/browser/prefs/renderer_prefs.cc b/cef/libcef/browser/prefs/renderer_prefs.cc
index 5eb7b4c927d6e..ef17292929816 100644
--- a/cef/libcef/browser/prefs/renderer_prefs.cc
+++ b/cef/libcef/browser/prefs/renderer_prefs.cc
@@ -372,6 +372,7 @@ void SetCefPrefs(const CefBrowserSettings& cef,
             web.strict_mixed_content_checking);
   SET_STATE(cef.allow_mixed_content_upgrades, web.allow_mixed_content_upgrades);
   SET_STATE(cef.initialize_at_minimum_page_scale, web.initialize_at_minimum_page_scale);
+  web.viewport_meta_enabled = cef.viewport_meta_enabled;
   /* ohos webview end */
 }
 
diff --git a/cef/libcef/browser/request_context_impl.cc b/cef/libcef/browser/request_context_impl.cc
index 47801015d83ba..357e9a6c0b9d8 100644
--- a/cef/libcef/browser/request_context_impl.cc
+++ b/cef/libcef/browser/request_context_impl.cc
@@ -366,6 +366,18 @@ CefRefPtr<CefCookieManager> CefRequestContextImpl::GetCookieManager(
   return cookie_manager.get();
 }
 
+CefRefPtr<CefDataBase> CefRequestContextImpl::GetDataBase() {
+  CefRefPtr<CefDataBaseImpl> data_base = new CefDataBaseImpl();
+  return data_base.get();
+}
+
+CefRefPtr<CefWebStorage> CefRequestContextImpl::GetWebStorage(
+    CefRefPtr<CefCompletionCallback> callback) {
+  CefRefPtr<CefWebStorageImpl> web_storage = new CefWebStorageImpl();
+  InitializeWebStorageInternal(web_storage, callback);
+  return web_storage.get();
+}
+
 bool CefRequestContextImpl::RegisterSchemeHandlerFactory(
     const CefString& scheme_name,
     const CefString& domain_name,
@@ -789,6 +801,20 @@ void CefRequestContextImpl::InitializeCookieManagerInternal(
                         cookie_manager, callback));
 }
 
+void CefRequestContextImpl::InitializeWebStorageInternal(
+    CefRefPtr<CefWebStorageImpl> web_storage,
+    CefRefPtr<CefCompletionCallback> callback) {
+  GetBrowserContext(content::GetUIThreadTaskRunner({}),
+                    base::BindOnce(
+                        [](CefRefPtr<CefWebStorageImpl> web_storage,
+                           CefRefPtr<CefCompletionCallback> callback,
+                           CefBrowserContext::Getter browser_context_getter) {
+                          web_storage->Initialize(browser_context_getter,
+                                                     callback);
+                        },
+                        web_storage, callback));
+}
+
 void CefRequestContextImpl::InitializeMediaRouterInternal(
     CefRefPtr<CefMediaRouterImpl> media_router,
     CefRefPtr<CefCompletionCallback> callback) {
diff --git a/cef/libcef/browser/request_context_impl.h b/cef/libcef/browser/request_context_impl.h
index af09e22e27a54..a997d2f847aea 100644
--- a/cef/libcef/browser/request_context_impl.h
+++ b/cef/libcef/browser/request_context_impl.h
@@ -9,7 +9,9 @@
 #include "include/cef_request_context.h"
 #include "libcef/browser/browser_context.h"
 #include "libcef/browser/media_router/media_router_impl.h"
+#include "libcef/browser/net_database/cef_data_base_impl.h"
 #include "libcef/browser/net_service/cookie_manager_impl.h"
+#include "libcef/browser/storage/web_storage_impl.h"
 #include "libcef/browser/thread_util.h"
 
 class CefBrowserContext;
@@ -59,6 +61,9 @@ class CefRequestContextImpl : public CefRequestContext {
   CefString GetCachePath() override;
   CefRefPtr<CefCookieManager> GetCookieManager(
       CefRefPtr<CefCompletionCallback> callback) override;
+  CefRefPtr<CefDataBase> GetDataBase() override;
+  CefRefPtr<CefWebStorage> GetWebStorage(
+      CefRefPtr<CefCompletionCallback> callback) override;
   bool RegisterSchemeHandlerFactory(
       const CefString& scheme_name,
       const CefString& domain_name,
@@ -163,6 +168,9 @@ class CefRequestContextImpl : public CefRequestContext {
   void InitializeCookieManagerInternal(
       CefRefPtr<CefCookieManagerImpl> cookie_manager,
       CefRefPtr<CefCompletionCallback> callback);
+  void InitializeWebStorageInternal(
+      CefRefPtr<CefWebStorageImpl> web_storage,
+      CefRefPtr<CefCompletionCallback> callback);
   void InitializeMediaRouterInternal(CefRefPtr<CefMediaRouterImpl> media_router,
                                      CefRefPtr<CefCompletionCallback> callback);
 
diff --git a/cef/libcef/browser/storage/web_storage_impl.cc b/cef/libcef/browser/storage/web_storage_impl.cc
new file mode 100644
index 0000000000000..0f963d489040d
--- /dev/null
+++ b/cef/libcef/browser/storage/web_storage_impl.cc
@@ -0,0 +1,346 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "libcef/browser/storage/web_storage_impl.h"
+
+#include <sstream>
+#include "libcef/common/time_util.h"
+
+#include "base/bind.h"
+#include "base/logging.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/storage_partition.h"
+#include "third_party/blink/public/mojom/quota/quota_types.mojom.h"
+#include "url/gurl.h"
+
+class GetOriginsTask : public base::RefCountedThreadSafe<GetOriginsTask> {
+ public:
+  GetOriginsTask(CefWebStorageImpl::GetOriginsCallback callback,
+                    storage::QuotaManager* quota_manager);
+  void Run();
+
+ private:
+  friend class base::RefCountedThreadSafe<GetOriginsTask>;
+  ~GetOriginsTask();
+  void OnOriginsObtained(const std::set<url::Origin>& origins,
+                         blink::mojom::StorageType type);
+  void OnUsageAndQuotaObtained(const url::Origin& origin,
+                               blink::mojom::QuotaStatusCode status_code,
+                               int64_t usage,
+                               int64_t quota);
+  void CheckDone();
+  void DoneOnUIThread();
+
+  CefWebStorageImpl::GetOriginsCallback ui_callback_;
+  scoped_refptr<storage::QuotaManager> quota_manager_;
+  std::vector<std::string> origin_;
+  std::vector<int64_t> usage_;
+  std::vector<int64_t> quota_;
+  size_t num_callbacks_to_wait_;
+  size_t num_callbacks_received_;
+
+  DISALLOW_COPY_AND_ASSIGN(GetOriginsTask);
+};
+
+GetOriginsTask::GetOriginsTask(CefWebStorageImpl::GetOriginsCallback callback,
+    storage::QuotaManager* quota_manager) : ui_callback_(std::move(callback)), quota_manager_(quota_manager) {
+  DCHECK(CEF_CURRENTLY_ON_UIT());
+}
+
+GetOriginsTask::~GetOriginsTask() {}
+
+void GetOriginsTask::Run() {
+  DCHECK(CEF_CURRENTLY_ON_UIT());
+  CEF_POST_TASK(CEF_IOT,
+                base::BindOnce(&storage::QuotaManager::GetOriginsModifiedBetween, quota_manager_,
+                               blink::mojom::StorageType::kTemporary,
+                               base::Time() /* Since beginning of time. */,
+                               base::Time::Max() /* Until the end of times */,
+                               base::BindOnce(&GetOriginsTask::OnOriginsObtained, this)));
+}
+
+void GetOriginsTask::OnOriginsObtained(
+    const std::set<url::Origin>& origins,
+    blink::mojom::StorageType type) {
+  DCHECK(CEF_CURRENTLY_ON_IOT());
+  num_callbacks_to_wait_ = origins.size();
+  num_callbacks_received_ = 0u;
+  for (const url::Origin& origin : origins) {
+    quota_manager_->GetUsageAndQuota(origin, type,
+                                     base::BindOnce(&GetOriginsTask::OnUsageAndQuotaObtained, this, origin));
+  }
+  CheckDone();
+}
+
+void GetOriginsTask::OnUsageAndQuotaObtained(
+    const url::Origin& origin,
+    blink::mojom::QuotaStatusCode status_code,
+    int64_t usage,
+    int64_t quota) {
+  DCHECK(CEF_CURRENTLY_ON_IOT());
+  if (status_code == blink::mojom::QuotaStatusCode::kOk) {
+    origin_.push_back(origin.GetURL().spec());
+    usage_.push_back(usage);
+    quota_.push_back(quota);
+  }
+  ++num_callbacks_received_;
+  CheckDone();
+}
+
+void GetOriginsTask::CheckDone() {
+  DCHECK(CEF_CURRENTLY_ON_IOT());
+  if (num_callbacks_received_ == num_callbacks_to_wait_) {
+    CEF_POST_TASK(CEF_UIT,
+                  base::BindOnce(&GetOriginsTask::DoneOnUIThread, this));
+  } else if (num_callbacks_received_ > num_callbacks_to_wait_) {
+    NOTREACHED();
+  }
+}
+
+// This method is to avoid copying the 3 vector arguments into a bound callback.
+void GetOriginsTask::DoneOnUIThread() {
+  DCHECK(CEF_CURRENTLY_ON_UIT());
+  if (ui_callback_) {
+    std::move(ui_callback_).Run(origin_, usage_, quota_);
+  }
+}
+
+CefBrowserContext* GetBrowserContext(const CefBrowserContext::Getter& getter) {
+  DCHECK(!getter.is_null());
+  // Will return nullptr if the BrowserContext has been destroyed.
+  return getter.Run();
+}
+
+content::StoragePartition* GetStoragePartitionDelegate(CefBrowserContext* browser_context) {
+  CEF_REQUIRE_UIT();
+  return content::BrowserContext::GetDefaultStoragePartition(browser_context->AsBrowserContext());
+}
+
+storage::QuotaManager* GetQuotaManager(CefBrowserContext* browser_context) {
+  CEF_REQUIRE_UIT();
+  return GetStoragePartitionDelegate(browser_context)->GetQuotaManager();
+}
+
+void CefWebStorageImpl::DeleteAllData() {
+  if (!ValidContext()) {
+    StoreOrTriggerUIInitCallback(base::BindOnce(base::IgnoreResult(&CefWebStorageImpl::DeleteAllDataInternal), this));
+    return;
+  }
+  return DeleteAllDataInternal();
+}
+
+void CefWebStorageImpl::DeleteAllDataInternal() {
+  DCHECK(ValidContext());
+  auto browser_context = GetBrowserContext(browser_context_getter_);
+  if (!browser_context) {
+    return;
+  }
+  GetStoragePartitionDelegate(browser_context)->ClearData(
+      // Clear all web storage data except cookies.
+      content::StoragePartition::REMOVE_DATA_MASK_APPCACHE |
+          content::StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS |
+          content::StoragePartition::REMOVE_DATA_MASK_INDEXEDDB |
+          content::StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE |
+          content::StoragePartition::REMOVE_DATA_MASK_WEBSQL,
+      content::StoragePartition::QUOTA_MANAGED_STORAGE_MASK_TEMPORARY, GURL(),
+      base::Time(), base::Time::Max(), base::DoNothing());
+}
+
+void CefWebStorageImpl::DeleteOrigin(const CefString& origin) {
+  GURL gurl = GURL(origin.ToString16());
+  if (!gurl.is_empty() && !gurl.is_valid())
+    return;
+  if (!ValidContext()) {
+    StoreOrTriggerUIInitCallback(
+        base::BindOnce(base::IgnoreResult(&CefWebStorageImpl::DeleteOriginInternal), this, gurl));
+    return;
+  }
+  return DeleteOriginInternal(gurl);
+}
+
+void CefWebStorageImpl::DeleteOriginInternal(const GURL& origin) {
+  DCHECK(ValidContext());
+  DCHECK(origin.is_empty() || origin.is_valid());
+  auto browser_context = GetBrowserContext(browser_context_getter_);
+  if (!browser_context) {
+    LOG(ERROR) << "CefWebStorageImpl::DeleteOriginInternal can not get browser_context.";
+    return;
+  }
+  GetStoragePartitionDelegate(browser_context)->ClearDataForOrigin(
+      // All (temporary) QuotaClient types.
+      content::StoragePartition::REMOVE_DATA_MASK_APPCACHE |
+          content::StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS |
+          content::StoragePartition::REMOVE_DATA_MASK_INDEXEDDB |
+          content::StoragePartition::REMOVE_DATA_MASK_WEBSQL,
+      content::StoragePartition::QUOTA_MANAGED_STORAGE_MASK_TEMPORARY, origin);
+};
+
+void CefWebStorageImpl::GetOrigins(CefRefPtr<CefGetOriginsCallback> callback) {
+  if (!ValidContext()) {
+    StoreOrTriggerUIInitCallback(base::BindOnce(
+        base::IgnoreResult(&CefWebStorageImpl::GetOriginsInternal), this, callback));
+    return;
+  }
+  return GetOriginsInternal(callback);
+}
+
+void CefWebStorageImpl::GetOriginsInternal(CefRefPtr<CefGetOriginsCallback> callback) {
+  DCHECK(ValidContext());
+  auto browser_context = GetBrowserContext(browser_context_getter_);
+  if (!browser_context) {
+    LOG(ERROR) << "CefWebStorageImpl::GetOriginsInternal can not get browser_context.";
+    return;
+  }
+  GetOriginsCallback ui_callback =
+      base::BindOnce(&CefWebStorageImpl::GetOriginsCallbackImpl,
+                     weak_factory_.GetWeakPtr(), callback);
+  base::MakeRefCounted<GetOriginsTask>(std::move(ui_callback),
+                                       GetQuotaManager(browser_context))->Run();
+}
+
+void CefWebStorageImpl::GetOriginQuota(const CefString& origin,
+                                       CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback)
+{
+  if (!ValidContext()) {
+    StoreOrTriggerUIInitCallback(base::BindOnce(
+        base::IgnoreResult(&CefWebStorageImpl::GetOriginUsageAndQuotaInternal), this, origin, true, callback));
+    return;
+  }
+  return GetOriginUsageAndQuotaInternal(origin, true, callback);
+}
+
+void CefWebStorageImpl::GetOriginUsage(const CefString& origin,
+                                       CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback)
+{
+  if (!ValidContext()) {
+    StoreOrTriggerUIInitCallback(base::BindOnce(
+        base::IgnoreResult(&CefWebStorageImpl::GetOriginUsageAndQuotaInternal), this, origin, false, callback));
+    return;
+  }
+  return GetOriginUsageAndQuotaInternal(origin, false, callback);
+}
+
+void CefWebStorageImpl::OnUsageAndQuotaObtained(
+    CefWebStorageImpl::QuotaUsageCallback ui_callback,
+    blink::mojom::QuotaStatusCode status_code,
+    int64_t usage,
+    int64_t quota) {
+  DCHECK(CEF_CURRENTLY_ON_IOT());
+  if (status_code != blink::mojom::QuotaStatusCode::kOk) {
+    usage = 0;
+    quota = 0;
+  }
+  CEF_POST_TASK(CEF_UIT,
+                base::BindOnce(std::move(ui_callback), usage, quota));
+}
+
+void CefWebStorageImpl::GetOriginUsageAndQuotaInternal(
+    const CefString& origin,
+    bool is_quota,
+    CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback)
+{
+  DCHECK(CEF_CURRENTLY_ON_UIT());
+  auto browser_context = GetBrowserContext(browser_context_getter_);
+  if (!browser_context) {
+    LOG(ERROR) << "CefWebStorageImpl::GetOriginsInternal can not get browser_context.";
+    return;
+  }
+  CefWebStorageImpl::QuotaUsageCallback ui_callback =
+      base::BindOnce(&CefWebStorageImpl::CefGetOriginUsageOrQuotaCallbackImpl,
+                     weak_factory_.GetWeakPtr(), callback, is_quota);
+  CEF_POST_TASK(CEF_IOT,
+                base::BindOnce(&storage::QuotaManager::GetUsageAndQuota, GetQuotaManager(browser_context), 
+                url::Origin::Create(GURL(origin.ToString16())),
+                blink::mojom::StorageType::kTemporary,
+                base::BindOnce(&CefWebStorageImpl::OnUsageAndQuotaObtained, this, std::move(ui_callback))));
+}
+
+void RunAsyncCompletionOnUIThread(CefRefPtr<CefCompletionCallback> callback) {
+  if (!callback.get())
+    return;
+  CEF_POST_TASK(CEF_UIT,
+                base::Bind(&CefCompletionCallback::OnComplete, callback.get()));
+}
+
+void CefWebStorageImpl::Initialize(
+    CefBrowserContext::Getter browser_context_getter,
+    CefRefPtr<CefCompletionCallback> callback) {
+  CEF_REQUIRE_UIT();
+  DCHECK(!initialized_);
+  DCHECK(!browser_context_getter.is_null());
+  DCHECK(browser_context_getter_.is_null());
+  browser_context_getter_ = browser_context_getter;
+  initialized_ = true;
+  if (!init_callbacks_.empty()) {
+    for (auto& callback : init_callbacks_) {
+      std::move(callback).Run();
+    }
+    init_callbacks_.clear();
+  }
+  RunAsyncCompletionOnUIThread(callback);
+}
+
+void CefWebStorageImpl::StoreOrTriggerUIInitCallback(
+    base::OnceClosure callback) {
+  if (!CEF_CURRENTLY_ON_UIT()) {
+    CEF_POST_TASK(CEF_UIT,
+                  base::BindOnce(&CefWebStorageImpl::StoreOrTriggerUIInitCallback, this, std::move(callback)));
+    return;
+  }
+  if (initialized_) {
+    std::move(callback).Run();
+  } else {
+    init_callbacks_.emplace_back(std::move(callback));
+  }
+}
+
+bool CefWebStorageImpl::ValidContext() const {
+  return CEF_CURRENTLY_ON_UIT() && initialized_;
+}
+
+void CefWebStorageImpl::GetOriginsCallbackImpl(
+    CefRefPtr<CefGetOriginsCallback> callback,
+    const std::vector<std::string>& origin,
+    const std::vector<int64_t>& usage,
+    const std::vector<int64_t>& quota) {
+  if (!callback.get()) {
+    return;
+  }
+  int32_t nums = origin.size();
+  std::vector<CefString> origins;
+  std::vector<CefString> usages;
+  std::vector<CefString> quotas;
+  std::string res;
+  for (size_t i = 0; i < nums; i++) {
+    origins.push_back(CefString(origin[i]));
+    res = std::to_string(usage[i]);
+    usages.push_back(CefString(res));
+    res = std::to_string(quota[i]);
+    quotas.push_back(CefString(res));
+  }
+
+  callback.get()->OnOrigins(origins);
+  callback.get()->OnQuotas(quotas);
+  callback.get()->OnUsages(usages);
+  callback.get()->OnComplete();
+}
+
+void CefWebStorageImpl::CefGetOriginUsageOrQuotaCallbackImpl(
+    CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback,
+    bool is_quota,
+    int64_t usage,
+    int64_t quota) {
+  if (!callback.get()) {
+    return;
+  }
+  int64_t result = is_quota == true ? quota : usage;
+  callback.get()->OnComplete(result);
+}
+
+// static
+CefRefPtr<CefWebStorage> CefWebStorage::GetGlobalManager(
+    CefRefPtr<CefCompletionCallback> callback) {
+  CefRefPtr<CefRequestContext> context = CefRequestContext::GetGlobalContext();
+  return context ? context->GetWebStorage(callback) : nullptr;
+}
diff --git a/cef/libcef/browser/storage/web_storage_impl.h b/cef/libcef/browser/storage/web_storage_impl.h
new file mode 100644
index 0000000000000..48dcce8342bdd
--- /dev/null
+++ b/cef/libcef/browser/storage/web_storage_impl.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_BROWSER_NET_SERVICE_WEB_STORAGE_IMPL_H_
+#define CEF_LIBCEF_BROWSER_NET_SERVICE_WEB_STORAGE_IMPL_H_
+
+#include <atomic>
+
+#include "include/cef_web_storage.h"
+#include "base/threading/thread.h"
+#include "libcef/browser/browser_context.h"
+#include "libcef/browser/thread_util.h"
+#include "storage/browser/quota/quota_manager.h"
+
+// Implementation of the CefWebStorage interface. May be created on any
+// thread.
+class CefWebStorageImpl : public CefWebStorage {
+ public:
+  CefWebStorageImpl() {}
+  void Initialize(CefBrowserContext::Getter browser_context_getter,
+                  CefRefPtr<CefCompletionCallback> callback);
+  void DeleteAllData() override;
+  void DeleteOrigin(const CefString& origin) override;
+  void GetOrigins(CefRefPtr<CefGetOriginsCallback> callback) override;
+  void GetOriginQuota(const CefString& origin,
+                      CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) override;
+  void GetOriginUsage(const CefString& origin,
+                      CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) override;
+  using GetOriginsCallback = base::OnceCallback<void(const std::vector<std::string>&,
+                                                const std::vector<int64_t>&,
+                                                const std::vector<int64_t>&)>;
+  using QuotaUsageCallback = base::OnceCallback<void(int64_t, int64_t)>;
+  void DeleteAllDataInternal();
+  void DeleteOriginInternal(const GURL& origin);
+  void GetOriginsInternal(CefRefPtr<CefGetOriginsCallback> callback);
+  void GetOriginUsageAndQuotaInternal(const CefString& origin, bool is_quota,
+                                      CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback);
+  void OnUsageAndQuotaObtained(QuotaUsageCallback ui_callback,
+                               blink::mojom::QuotaStatusCode status_code,
+                               int64_t usage,
+                               int64_t quota);
+  bool ValidContext() const;
+  void StoreOrTriggerUIInitCallback(base::OnceClosure callback);
+  void GetOriginsCallbackImpl(CefRefPtr<CefGetOriginsCallback> callback,
+                              const std::vector<std::string>& origin,
+                              const std::vector<int64_t>& usage,
+                              const std::vector<int64_t>& quota);
+  void CefGetOriginUsageOrQuotaCallbackImpl(CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback,
+                                            bool is_quota,
+                                            int64_t usage,
+                                            int64_t quota);
+ private:
+  // Only accessed on the UI thread. Will be non-null after Initialize().
+  CefBrowserContext::Getter browser_context_getter_;
+  bool initialized_ = false;
+  std::vector<base::OnceClosure> init_callbacks_;
+  base::WeakPtrFactory<CefWebStorageImpl> weak_factory_{this};
+  IMPLEMENT_REFCOUNTING(CefWebStorageImpl);
+  DISALLOW_COPY_AND_ASSIGN(CefWebStorageImpl);
+};
+
+#endif  // CEF_LIBCEF_BROWSER_NET_SERVICE_WEB_STORAGE_IMPL_H_
diff --git a/cef/libcef/common/cef_messages.h b/cef/libcef/common/cef_messages.h
index 9065e80cfb9ef..096677e57f2c8 100644
--- a/cef/libcef/common/cef_messages.h
+++ b/cef/libcef/common/cef_messages.h
@@ -9,6 +9,7 @@
 #include <stdint.h>
 
 #include "libcef/common/net/upload_data.h"
+#include "include/cef_image.h"
 
 #include "base/memory/shared_memory_mapping.h"
 #include "base/values.h"
@@ -17,6 +18,8 @@
 #include "ipc/ipc_message_macros.h"
 #include "ui/gfx/ipc/gfx_param_traits.h"
 
+#include "third_party/skia/include/core/SkBitmap.h"
+
 // Singly-included section for enums and custom IPC traits.
 #ifndef CEF_LIBCEF_COMMON_CEF_MESSAGES_H_
 #define CEF_LIBCEF_COMMON_CEF_MESSAGES_H_
@@ -63,6 +66,11 @@ IPC_STRUCT_BEGIN(Cef_TouchEvent_Params)
   IPC_STRUCT_MEMBER(int, height)
 IPC_STRUCT_END()
 
+//Parameters structure for blink factor.
+IPC_STRUCT_BEGIN(Cef_Blink_Params)
+  IPC_STRUCT_MEMBER(float, initialScale)
+IPC_STRUCT_END()
+
 // Parameters structure for a request.
 IPC_STRUCT_BEGIN(Cef_Request_Params)
   // Unique request id to match requests and responses.
@@ -166,6 +174,10 @@ IPC_MESSAGE_ROUTED0(CefMsg_DidStopLoading)
 
 // Tell the renderer that touch event has happened.
 IPC_MESSAGE_ROUTED1(CefMsg_TouchEvent, Cef_TouchEvent_Params)
+
+// Tell the renderer that blink parameters.
+IPC_MESSAGE_ROUTED1(CefMsg_Blink, Cef_Blink_Params)
+
 // Notification that a move or resize of the renderer's containing window has
 // started. Used on Windows and Linux with the Alloy runtime, and was
 // previously handled by RenderViewHost::NotifyMoveOrResizeStarted() prior to
@@ -233,3 +245,20 @@ IPC_MESSAGE_ROUTED1(CefHostMsg_UpdateDraggableRegions,
 
 // Sent by the renderer when the hit data updated.
 IPC_MESSAGE_ROUTED1(CefHostMsg_HitData, Cef_HitData_Params)
+
+// Parameters for a newly created browser window.
+IPC_STRUCT_BEGIN(CefMsg_GetImageForContextNode_Params)
+  IPC_STRUCT_MEMBER(int, width)
+  IPC_STRUCT_MEMBER(int, height)
+  IPC_STRUCT_MEMBER(std::string, image_extension)
+  IPC_STRUCT_MEMBER(SkBitmap, image)
+IPC_STRUCT_END()
+
+// Tells the renderer to request image for context node.
+// IPC_SYNC_MESSAGE_ROUTED0_1(CefMsg_GetImageForContextNode,
+//                            CefMsg_GetImageForContextNode_Params)
+IPC_MESSAGE_ROUTED0(CefMsg_GetImageForContextNode)
+
+// Return context node image to browser
+IPC_MESSAGE_ROUTED1(CefHostMsg_OnGetImageForContextNode,
+                    CefMsg_GetImageForContextNode_Params)
\ No newline at end of file
diff --git a/cef/libcef/renderer/blink_glue.cc b/cef/libcef/renderer/blink_glue.cc
index 67907ccf03640..70b7514d52d02 100644
--- a/cef/libcef/renderer/blink_glue.cc
+++ b/cef/libcef/renderer/blink_glue.cc
@@ -102,6 +102,27 @@ void GoForward(blink::WebView* view) {
   }
 }
 
+void GoBackOrForward(blink::WebView* view, int num_steps) {
+  if (!view)
+    return;
+
+  blink::WebFrame* main_frame = view->MainFrame();
+  if (main_frame && main_frame->IsWebLocalFrame()) {
+    if (num_steps > 0 && view->HistoryForwardListCount() > 0) {
+      blink::Frame* core_frame = blink::WebFrame::ToCoreFrame(*main_frame);
+      blink::To<blink::LocalFrame>(core_frame)
+          ->GetLocalFrameHostRemote()
+          .GoToEntryAtOffset(num_steps, true /* has_user_gesture */);
+    }
+    if (num_steps < 0 && view->HistoryBackListCount() > 0) {
+      blink::Frame* core_frame = blink::WebFrame::ToCoreFrame(*main_frame);
+      blink::To<blink::LocalFrame>(core_frame)
+          ->GetLocalFrameHostRemote()
+          .GoToEntryAtOffset(num_steps, true /* has_user_gesture */);
+    }
+  }
+}
+
 std::string DumpDocumentText(blink::WebLocalFrame* frame) {
   // We use the document element's text instead of the body text here because
   // not all documents have a body, such as XML documents.
diff --git a/cef/libcef/renderer/blink_glue.h b/cef/libcef/renderer/blink_glue.h
index 46fc4f596e204..8e46b70341a72 100644
--- a/cef/libcef/renderer/blink_glue.h
+++ b/cef/libcef/renderer/blink_glue.h
@@ -40,6 +40,7 @@ BLINK_EXPORT bool CanGoForward(blink::WebView* view);
 BLINK_EXPORT void GoBack(blink::WebView* view);
 BLINK_EXPORT void GoForward(blink::WebView* view);
 BLINK_EXPORT bool CanGoBackOrForward(blink::WebView* view, int num_steps);
+BLINK_EXPORT void GoBackOrForward(blink::WebView* view, int num_steps);
 
 // Returns the text of the document element.
 BLINK_EXPORT std::string DumpDocumentText(blink::WebLocalFrame* frame);
diff --git a/cef/libcef/renderer/browser_impl.cc b/cef/libcef/renderer/browser_impl.cc
index b32efcfab2f2b..9fb864ec7b6eb 100644
--- a/cef/libcef/renderer/browser_impl.cc
+++ b/cef/libcef/renderer/browser_impl.cc
@@ -83,6 +83,12 @@ bool CefBrowserImpl::CanGoBackOrForward(int num_steps) {
   return blink_glue::CanGoBackOrForward(GetWebView(), num_steps);
 }
 
+void CefBrowserImpl::GoBackOrForward(int num_steps) {
+  CEF_REQUIRE_RT_RETURN_VOID();
+
+  blink_glue::GoBackOrForward(GetWebView(), num_steps);
+}
+
 void CefBrowserImpl::DeleteHistory() {
   CEF_REQUIRE_RT_RETURN_VOID();
 }
@@ -416,3 +422,17 @@ void CefBrowserImpl::OnLoadingStateChange(bool isLoading) {
     }
   }
 }
+
+#if defined(OS_OHOS)
+void CefBrowserImpl::ReloadOriginalUrl() {
+  CEF_REQUIRE_RT_RETURN_VOID();
+
+  if (GetWebView()) {
+    blink::WebFrame* main_frame = GetWebView()->MainFrame();
+    if (main_frame && main_frame->IsWebLocalFrame()) {
+      main_frame->ToWebLocalFrame()->StartReload(
+          blink::WebFrameLoadType::kReload);
+    }
+  }
+}
+#endif
diff --git a/cef/libcef/renderer/browser_impl.h b/cef/libcef/renderer/browser_impl.h
index b3d5b51b99859..2de16d67aef17 100644
--- a/cef/libcef/renderer/browser_impl.h
+++ b/cef/libcef/renderer/browser_impl.h
@@ -50,10 +50,14 @@ class CefBrowserImpl : public CefBrowser, public blink::WebViewObserver {
   bool CanGoForward() override;
   void GoForward() override;
   bool CanGoBackOrForward(int num_steps) override;
+  void GoBackOrForward(int num_steps) override;
   void DeleteHistory() override;
   bool IsLoading() override;
   void Reload() override;
   void ReloadIgnoreCache() override;
+#if defined(OS_OHOS)
+  void ReloadOriginalUrl() override;
+#endif
   void StopLoad() override;
   int GetIdentifier() override;
   bool IsSame(CefRefPtr<CefBrowser> that) override;
diff --git a/cef/libcef/renderer/frame_impl.cc b/cef/libcef/renderer/frame_impl.cc
index 393ae6f30b468..03af9b56b73b4 100644
--- a/cef/libcef/renderer/frame_impl.cc
+++ b/cef/libcef/renderer/frame_impl.cc
@@ -35,6 +35,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "content/public/renderer/render_view.h"
 #include "content/renderer/render_frame_impl.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/blink/public/mojom/frame/frame.mojom-blink.h"
 #include "third_party/blink/public/platform/web_back_forward_cache_loader_helper.h"
 #include "third_party/blink/public/platform/web_data.h"
@@ -43,14 +44,17 @@
 #include "third_party/blink/public/web/blink.h"
 #include "third_party/blink/public/web/web_document.h"
 #include "third_party/blink/public/web/web_document_loader.h"
+#include "third_party/blink/public/web/web_element.h"
 #include "third_party/blink/public/web/web_element_collection.h"
 #include "third_party/blink/public/web/web_frame_content_dumper.h"
 #include "third_party/blink/public/web/web_frame_widget.h"
 #include "third_party/blink/public/web/web_local_frame.h"
 #include "third_party/blink/public/web/web_navigation_control.h"
+#include "third_party/blink/public/web/web_node.h"
 #include "third_party/blink/public/web/web_script_source.h"
 #include "third_party/blink/public/web/web_view.h"
 
+
 const std::string kAddressPrefix = "geo:0,0?q=";
 const std::string kEmailPrefix = "mailto:";
 const std::string kPhoneNumberPrefix = "tel:";
@@ -368,9 +372,11 @@ bool CefFrameImpl::OnMessageReceived(const IPC::Message& message) {
     IPC_MESSAGE_HANDLER(CefMsg_ResponseAck, OnResponseAck)
     IPC_MESSAGE_HANDLER(CefMsg_LoadRequest, OnLoadRequest)
     IPC_MESSAGE_HANDLER(CefMsg_TouchEvent, SendTouchEvent)
+    IPC_MESSAGE_HANDLER(CefMsg_Blink, SetInitialScale)
     IPC_MESSAGE_HANDLER(CefMsg_DidStopLoading, OnDidStopLoading)
     IPC_MESSAGE_HANDLER(CefMsg_MoveOrResizeStarted, OnMoveOrResizeStarted)
     IPC_MESSAGE_HANDLER(CefMsg_PutZoomingForTextFactor, PutZoomingForTextFactor)
+    IPC_MESSAGE_HANDLER(CefMsg_GetImageForContextNode, GetImageForContextNode)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
@@ -488,6 +494,35 @@ void CefFrameImpl::PopulateHitTestData(const GURL& absolute_link_url,
   }
 }
 
+void CefFrameImpl::GetImageForContextNode() {
+  if (!frame_) {
+    LOG(ERROR) << "GetImageForContextNode frame is nullptr";
+    return;
+  }
+  CefMsg_GetImageForContextNode_Params params;
+  blink::WebNode context_node = frame_->ContextMenuImageNode();
+  std::vector<uint8_t> image_data;
+  gfx::Size original_size;
+  std::string image_extension;
+
+  if (context_node.IsNull() || !context_node.IsElementNode()) {
+    LOG(ERROR) << "GetImageForContextNode image is empty";
+    Send(new CefHostMsg_OnGetImageForContextNode(MSG_ROUTING_NONE, params));
+    return;
+  }
+
+  blink::WebElement web_element = context_node.To<blink::WebElement>();
+  original_size = web_element.GetImageSize();
+
+  SkBitmap image = web_element.ImageContents();
+  image_extension = "." + web_element.ImageExtension();
+  params.width = original_size.width();
+  params.height = original_size.height();
+  params.image = image;
+  params.image_extension = image_extension;
+  Send(new CefHostMsg_OnGetImageForContextNode(MSG_ROUTING_NONE, params));
+}
+
 void CefFrameImpl::OnFocusedNodeChanged(const blink::WebElement& element) {
   Cef_HitData_Params data;
   if (element.IsNull()) {
@@ -506,6 +541,7 @@ void CefFrameImpl::OnFocusedNodeChanged(const blink::WebElement& element) {
   LOG(INFO) << "FocusedHitDataChangeEnd";
   Send(new CefHostMsg_HitData(MSG_ROUTING_NONE, data));
 }
+
 void CefFrameImpl::OnDraggableRegionsChanged() {
   blink::WebVector<blink::WebDraggableRegion> webregions =
       frame_->GetDocument().DraggableRegions();
@@ -685,7 +721,7 @@ void CefFrameImpl::SendTouchEvent(const Cef_TouchEvent_Params& params) {
     return;
   }
   const blink::WebHitTestResult result = webview->HitTestResultForTap(
-      gfx::Point(params.x, params.y), gfx::Size(params.width, params.height));
+    gfx::Point(params.x, params.y), gfx::Size(params.width, params.height));
   Cef_HitData_Params data;
   GURL absolute_image_url = result.AbsoluteImageURL();
   if (!result.UrlElement().IsNull()) {
@@ -700,6 +736,17 @@ void CefFrameImpl::SendTouchEvent(const Cef_TouchEvent_Params& params) {
   Send(new CefHostMsg_HitData(MSG_ROUTING_NONE, data));
 }
 
+void CefFrameImpl::SetInitialScale(const Cef_Blink_Params& params) {
+  auto render_frame = content::RenderFrame::FromWebFrame(frame_);
+  DCHECK(render_frame->IsMainFrame());
+  blink::WebView* webview = render_frame->GetRenderView()->GetWebView();
+  if (!webview) {
+    LOG(INFO) << "SetInitialScale webview is NULL";
+    return;
+  }
+  webview->SetInitialPageScaleOverride(params.initialScale);
+}
+
 void CefFrameImpl::OnMoveOrResizeStarted() {
   if (frame_) {
     auto web_view = frame_->View();
diff --git a/cef/libcef/renderer/frame_impl.h b/cef/libcef/renderer/frame_impl.h
index 2912625df3cdf..d31e7f6ae40ce 100644
--- a/cef/libcef/renderer/frame_impl.h
+++ b/cef/libcef/renderer/frame_impl.h
@@ -33,6 +33,7 @@ class CefBrowserImpl;
 class CefResponseManager;
 struct Cef_HitData_Params;
 struct Cef_TouchEvent_Params;
+struct Cef_Blink_Params;
 struct CefMsg_LoadRequest_Params;
 struct Cef_Request_Params;
 struct Cef_Response_Params;
@@ -94,6 +95,7 @@ class CefFrameImpl : public CefFrame {
   void OnDetached();
 
   blink::WebLocalFrame* web_frame() const { return frame_; }
+  void GetImageForContextNode();
 
  private:
   void ExecuteCommand(const std::string& command);
@@ -113,6 +115,7 @@ class CefFrameImpl : public CefFrame {
   void OnResponseAck(int request_id);
   void OnDidStopLoading();
   void SendTouchEvent(const Cef_TouchEvent_Params& params);
+  void SetInitialScale(const Cef_Blink_Params& params);
   void OnMoveOrResizeStarted();
   void OnLoadRequest(const CefMsg_LoadRequest_Params& params);
   void PutZoomingForTextFactor(float factor);
diff --git a/cef/libcef_dll/cpptoc/auth_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/auth_callback_cpptoc.cc
index c9733c01687ce..a0c64afba0768 100644
--- a/cef/libcef_dll/cpptoc/auth_callback_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/auth_callback_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=7497a44116b3cfc86eb309dc940c91c7cca78353$
+// $hash=1c155d75ccb34c91336d15446c10b7e476f23c44$
 //
 
 #include "libcef_dll/cpptoc/auth_callback_cpptoc.h"
@@ -19,9 +19,9 @@ namespace {
 
 // MEMBER FUNCTIONS - Body may be edited by hand.
 
-void CEF_CALLBACK auth_callback_cont(struct _cef_auth_callback_t* self,
-                                     const cef_string_t* username,
-                                     const cef_string_t* password) {
+void CEF_CALLBACK auth_callback_cont(struct _cef_auth_callback_t *self,
+                                     const cef_string_t *username,
+                                     const cef_string_t *password) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -36,7 +36,7 @@ void CEF_CALLBACK auth_callback_cont(struct _cef_auth_callback_t* self,
                                              CefString(password));
 }
 
-void CEF_CALLBACK auth_callback_cancel(struct _cef_auth_callback_t* self) {
+void CEF_CALLBACK auth_callback_cancel(struct _cef_auth_callback_t *self) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -49,13 +49,31 @@ void CEF_CALLBACK auth_callback_cancel(struct _cef_auth_callback_t* self) {
   CefAuthCallbackCppToC::Get(self)->Cancel();
 }
 
-}  // namespace
+int CEF_CALLBACK
+auth_callback_is_http_auth_info_saved(struct _cef_auth_callback_t *self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+
+  // Execute
+  bool _retval = CefAuthCallbackCppToC::Get(self)->IsHttpAuthInfoSaved();
+
+  // Return type: bool
+  return _retval;
+}
+
+} // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
 
 CefAuthCallbackCppToC::CefAuthCallbackCppToC() {
   GetStruct()->cont = auth_callback_cont;
   GetStruct()->cancel = auth_callback_cancel;
+  GetStruct()->is_http_auth_info_saved = auth_callback_is_http_auth_info_saved;
 }
 
 // DESTRUCTOR - Do not edit by hand.
@@ -65,17 +83,16 @@ CefAuthCallbackCppToC::~CefAuthCallbackCppToC() {
 }
 
 template <>
-CefRefPtr<CefAuthCallback> CefCppToCRefCounted<
-    CefAuthCallbackCppToC,
-    CefAuthCallback,
-    cef_auth_callback_t>::UnwrapDerived(CefWrapperType type,
-                                        cef_auth_callback_t* s) {
+CefRefPtr<CefAuthCallback>
+CefCppToCRefCounted<CefAuthCallbackCppToC, CefAuthCallback,
+                    cef_auth_callback_t>::UnwrapDerived(CefWrapperType type,
+                                                        cef_auth_callback_t
+                                                            *s) {
   NOTREACHED() << "Unexpected class type: " << type;
   return nullptr;
 }
 
 template <>
-CefWrapperType CefCppToCRefCounted<CefAuthCallbackCppToC,
-                                   CefAuthCallback,
+CefWrapperType CefCppToCRefCounted<CefAuthCallbackCppToC, CefAuthCallback,
                                    cef_auth_callback_t>::kWrapperType =
     WT_AUTH_CALLBACK;
diff --git a/cef/libcef_dll/cpptoc/browser_cpptoc.cc b/cef/libcef_dll/cpptoc/browser_cpptoc.cc
index 915e95b93c0db..2f6f6703739c0 100644
--- a/cef/libcef_dll/cpptoc/browser_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/browser_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=a0db7b8177fbabe225af5a0e2db3fc5bc23ddec4$
+// $hash=ca8fa2ae4f113048e5b941eaa0e1dbcfc7cc6a95$
 //
 
 #include "libcef_dll/cpptoc/browser_cpptoc.h"
@@ -117,6 +117,20 @@ int CEF_CALLBACK browser_can_go_back_or_forward(struct _cef_browser_t* self,
   return _retval;
 }
 
+void CEF_CALLBACK browser_go_back_or_forward(struct _cef_browser_t* self,
+                                             int num_steps) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserCppToC::Get(self)->GoBackOrForward(num_steps);
+}
+
 void CEF_CALLBACK browser_delete_history(struct _cef_browser_t* self) {
   shutdown_checker::AssertNotShutdown();
 
@@ -172,6 +186,19 @@ void CEF_CALLBACK browser_reload_ignore_cache(struct _cef_browser_t* self) {
   CefBrowserCppToC::Get(self)->ReloadIgnoreCache();
 }
 
+void CEF_CALLBACK browser_reload_original_url(struct _cef_browser_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserCppToC::Get(self)->ReloadOriginalUrl();
+}
+
 void CEF_CALLBACK browser_stop_load(struct _cef_browser_t* self) {
   shutdown_checker::AssertNotShutdown();
 
@@ -452,10 +479,12 @@ CefBrowserCppToC::CefBrowserCppToC() {
   GetStruct()->can_go_forward = browser_can_go_forward;
   GetStruct()->go_forward = browser_go_forward;
   GetStruct()->can_go_back_or_forward = browser_can_go_back_or_forward;
+  GetStruct()->go_back_or_forward = browser_go_back_or_forward;
   GetStruct()->delete_history = browser_delete_history;
   GetStruct()->is_loading = browser_is_loading;
   GetStruct()->reload = browser_reload;
   GetStruct()->reload_ignore_cache = browser_reload_ignore_cache;
+  GetStruct()->reload_original_url = browser_reload_original_url;
   GetStruct()->stop_load = browser_stop_load;
   GetStruct()->get_identifier = browser_get_identifier;
   GetStruct()->is_same = browser_is_same;
diff --git a/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc b/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
index 7959765ed4738..01b13eb5d46f0 100644
--- a/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=ff0c3692d8878d45dd92ab0da41ccfb481762e26$
+// $hash=9aab494bb0a139672fa13a541a462e2e9967f0b7$
 //
 
 #include "libcef_dll/cpptoc/browser_host_cpptoc.h"
@@ -1147,6 +1147,20 @@ void CEF_CALLBACK browser_host_get_hit_data(struct _cef_browser_host_t* self,
     *type = typeVal;
 }
 
+void CEF_CALLBACK
+browser_host_set_initial_scale(struct _cef_browser_host_t* self, float scale) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->SetInitialScale(scale);
+}
+
 int CEF_CALLBACK
 browser_host_page_load_progress(struct _cef_browser_host_t* self) {
   shutdown_checker::AssertNotShutdown();
@@ -1668,6 +1682,20 @@ browser_host_get_web_debugging_access(struct _cef_browser_host_t* self) {
   return _retval;
 }
 
+void CEF_CALLBACK
+browser_host_get_image_for_context_node(struct _cef_browser_host_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->GetImageForContextNode();
+}
+
 }  // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -1733,6 +1761,7 @@ CefBrowserHostCppToC::CefBrowserHostCppToC() {
       browser_host_unregister_ark_jsfunction;
   GetStruct()->title = browser_host_title;
   GetStruct()->get_hit_data = browser_host_get_hit_data;
+  GetStruct()->set_initial_scale = browser_host_set_initial_scale;
   GetStruct()->page_load_progress = browser_host_page_load_progress;
   GetStruct()->scale = browser_host_scale;
   GetStruct()->load_with_data_and_base_url =
@@ -1763,6 +1792,8 @@ CefBrowserHostCppToC::CefBrowserHostCppToC() {
   GetStruct()->set_native_window = browser_host_set_native_window;
   GetStruct()->set_web_debugging_access = browser_host_set_web_debugging_access;
   GetStruct()->get_web_debugging_access = browser_host_get_web_debugging_access;
+  GetStruct()->get_image_for_context_node =
+      browser_host_get_image_for_context_node;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/cef/libcef_dll/cpptoc/context_menu_handler_cpptoc.cc b/cef/libcef_dll/cpptoc/context_menu_handler_cpptoc.cc
index 9f3981569ee7b..39b0aa416bd51 100644
--- a/cef/libcef_dll/cpptoc/context_menu_handler_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/context_menu_handler_cpptoc.cc
@@ -9,15 +9,17 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=a689271e9c27cfd0d6f6fadb8bb624898f165934$
+// $hash=2ffd9d64102e377f502e3dc9979858553277627d$
 //
 
 #include "libcef_dll/cpptoc/context_menu_handler_cpptoc.h"
 #include "libcef_dll/ctocpp/browser_ctocpp.h"
 #include "libcef_dll/ctocpp/context_menu_params_ctocpp.h"
 #include "libcef_dll/ctocpp/frame_ctocpp.h"
+#include "libcef_dll/ctocpp/image_ctocpp.h"
 #include "libcef_dll/ctocpp/menu_model_ctocpp.h"
 #include "libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h"
+#include "libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.h"
 #include "libcef_dll/shutdown_checker.h"
 
 namespace {
@@ -167,6 +169,132 @@ void CEF_CALLBACK context_menu_handler_on_context_menu_dismissed(
       CefBrowserCToCpp::Wrap(browser), CefFrameCToCpp::Wrap(frame));
 }
 
+int CEF_CALLBACK context_menu_handler_run_quick_menu(
+    struct _cef_context_menu_handler_t* self,
+    cef_browser_t* browser,
+    struct _cef_frame_t* frame,
+    const cef_point_t* location,
+    const cef_size_t* size,
+    cef_quick_menu_edit_state_flags_t edit_state_flags,
+    cef_run_quick_menu_callback_t* callback) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return 0;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame);
+  if (!frame)
+    return 0;
+  // Verify param: location; type: simple_byref_const
+  DCHECK(location);
+  if (!location)
+    return 0;
+  // Verify param: size; type: simple_byref_const
+  DCHECK(size);
+  if (!size)
+    return 0;
+  // Verify param: callback; type: refptr_diff
+  DCHECK(callback);
+  if (!callback)
+    return 0;
+
+  // Translate param: location; type: simple_byref_const
+  CefPoint locationVal = location ? *location : CefPoint();
+  // Translate param: size; type: simple_byref_const
+  CefSize sizeVal = size ? *size : CefSize();
+
+  // Execute
+  bool _retval = CefContextMenuHandlerCppToC::Get(self)->RunQuickMenu(
+      CefBrowserCToCpp::Wrap(browser), CefFrameCToCpp::Wrap(frame), locationVal,
+      sizeVal, edit_state_flags, CefRunQuickMenuCallbackCToCpp::Wrap(callback));
+
+  // Return type: bool
+  return _retval;
+}
+
+int CEF_CALLBACK context_menu_handler_on_quick_menu_command(
+    struct _cef_context_menu_handler_t* self,
+    cef_browser_t* browser,
+    struct _cef_frame_t* frame,
+    int command_id,
+    cef_event_flags_t event_flags) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return 0;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame);
+  if (!frame)
+    return 0;
+
+  // Execute
+  bool _retval = CefContextMenuHandlerCppToC::Get(self)->OnQuickMenuCommand(
+      CefBrowserCToCpp::Wrap(browser), CefFrameCToCpp::Wrap(frame), command_id,
+      event_flags);
+
+  // Return type: bool
+  return _retval;
+}
+
+void CEF_CALLBACK context_menu_handler_on_quick_menu_dismissed(
+    struct _cef_context_menu_handler_t* self,
+    cef_browser_t* browser,
+    struct _cef_frame_t* frame) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame);
+  if (!frame)
+    return;
+
+  // Execute
+  CefContextMenuHandlerCppToC::Get(self)->OnQuickMenuDismissed(
+      CefBrowserCToCpp::Wrap(browser), CefFrameCToCpp::Wrap(frame));
+}
+
+void CEF_CALLBACK context_menu_handler_on_get_image_for_context_node(
+    struct _cef_context_menu_handler_t* self,
+    struct _cef_image_t* image) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: image; type: refptr_diff
+  DCHECK(image);
+  if (!image)
+    return;
+
+  // Execute
+  CefContextMenuHandlerCppToC::Get(self)->OnGetImageForContextNode(
+      CefImageCToCpp::Wrap(image));
+}
+
 }  // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -179,6 +307,13 @@ CefContextMenuHandlerCppToC::CefContextMenuHandlerCppToC() {
       context_menu_handler_on_context_menu_command;
   GetStruct()->on_context_menu_dismissed =
       context_menu_handler_on_context_menu_dismissed;
+  GetStruct()->run_quick_menu = context_menu_handler_run_quick_menu;
+  GetStruct()->on_quick_menu_command =
+      context_menu_handler_on_quick_menu_command;
+  GetStruct()->on_quick_menu_dismissed =
+      context_menu_handler_on_quick_menu_dismissed;
+  GetStruct()->on_get_image_for_context_node =
+      context_menu_handler_on_get_image_for_context_node;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/cef/libcef_dll/cpptoc/data_base_cpptoc.cc b/cef/libcef_dll/cpptoc/data_base_cpptoc.cc
new file mode 100644
index 0000000000000..0b5bfe4d0edad
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/data_base_cpptoc.cc
@@ -0,0 +1,156 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=ab1b05a3df9cb6b15fd2dc5652d4664ec27d76c9$
+//
+
+#include "libcef_dll/cpptoc/data_base_cpptoc.h"
+#include "libcef_dll/transfer_util.h"
+
+// GLOBAL FUNCTIONS - Body may be edited by hand.
+
+CEF_EXPORT cef_data_base_t *cef_data_base_get_global() {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  CefRefPtr<CefDataBase> _retval = CefDataBase::GetGlobalDataBase();
+
+  // Return type: refptr_same
+  return CefDataBaseCppToC::Wrap(_retval);
+}
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK
+data_base_delete_http_auth_credentials(struct _cef_data_base_t *self) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->DeleteHttpAuthCredentials();
+}
+
+int CEF_CALLBACK
+data_base_exist_http_auth_credentials(struct _cef_data_base_t *self) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+
+  // Execute
+  bool _retval = CefDataBaseCppToC::Get(self)->ExistHttpAuthCredentials();
+
+  // Return type: bool
+  return _retval;
+}
+
+void CEF_CALLBACK data_base_save_http_auth_credentials(
+    struct _cef_data_base_t *self, const cef_string_t *host,
+    const cef_string_t *realm, const cef_string_t *username,
+    const char *password) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: host; type: string_byref_const
+  DCHECK(host);
+  if (!host)
+    return;
+  // Verify param: realm; type: string_byref_const
+  DCHECK(realm);
+  if (!realm)
+    return;
+  // Verify param: username; type: string_byref_const
+  DCHECK(username);
+  if (!username)
+    return;
+  // Verify param: password; type: simple_byaddr
+  DCHECK(password);
+  if (!password)
+    return;
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->SaveHttpAuthCredentials(
+      CefString(host), CefString(realm), CefString(username), password);
+}
+
+void CEF_CALLBACK data_base_get_http_auth_credentials(
+    struct _cef_data_base_t *self, const cef_string_t *host,
+    const cef_string_t *realm, cef_string_list_t username_password) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: host; type: string_byref_const
+  DCHECK(host);
+  if (!host)
+    return;
+  // Verify param: realm; type: string_byref_const
+  DCHECK(realm);
+  if (!realm)
+    return;
+  // Verify param: username_password; type: string_vec_byref
+  DCHECK(username_password);
+  if (!username_password)
+    return;
+
+  // Translate param: username_password; type: string_vec_byref
+  std::vector<CefString> username_passwordList;
+  transfer_string_list_contents(username_password, username_passwordList);
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->GetHttpAuthCredentials(
+      CefString(host), CefString(realm), username_passwordList);
+
+  // Restore param: username_password; type: string_vec_byref
+  cef_string_list_clear(username_password);
+  transfer_string_list_contents(username_passwordList, username_password);
+}
+
+} // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefDataBaseCppToC::CefDataBaseCppToC() {
+  GetStruct()->delete_http_auth_credentials =
+      data_base_delete_http_auth_credentials;
+  GetStruct()->exist_http_auth_credentials =
+      data_base_exist_http_auth_credentials;
+  GetStruct()->save_http_auth_credentials =
+      data_base_save_http_auth_credentials;
+  GetStruct()->get_http_auth_credentials = data_base_get_http_auth_credentials;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefDataBaseCppToC::~CefDataBaseCppToC() {}
+
+template <>
+CefRefPtr<CefDataBase>
+CefCppToCRefCounted<CefDataBaseCppToC, CefDataBase,
+                    cef_data_base_t>::UnwrapDerived(CefWrapperType type,
+                                                    cef_data_base_t *s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCppToCRefCounted<CefDataBaseCppToC, CefDataBase,
+                                   cef_data_base_t>::kWrapperType =
+    WT_DATA_BASE;
diff --git a/cef/libcef_dll/cpptoc/data_base_cpptoc.h b/cef/libcef_dll/cpptoc/data_base_cpptoc.h
new file mode 100644
index 0000000000000..170e8b7ad3560
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/data_base_cpptoc.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=556a51c2b0295892b98e2c6f62b27b99eba39286$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_DATA_BASE_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_DATA_BASE_CPPTOC_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include "include/capi/cef_data_base_capi.h"
+#include "include/cef_data_base.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed DLL-side only.
+class CefDataBaseCppToC
+    : public CefCppToCRefCounted<CefDataBaseCppToC, CefDataBase,
+                                 cef_data_base_t> {
+public:
+  CefDataBaseCppToC();
+  virtual ~CefDataBaseCppToC();
+};
+
+#endif // CEF_LIBCEF_DLL_CPPTOC_DATA_BASE_CPPTOC_H_
diff --git a/cef/libcef_dll/cpptoc/display_handler_cpptoc.cc b/cef/libcef_dll/cpptoc/display_handler_cpptoc.cc
index 6f0058a9a1239..0cd2e60578672 100644
--- a/cef/libcef_dll/cpptoc/display_handler_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/display_handler_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=b990f1a9bafcdd5be19363932738a3f2e778e769$
+// $hash=1caf5c5397b32cc691cdae3d06cde4a2cc87badf$
 //
 
 #include "libcef_dll/cpptoc/display_handler_cpptoc.h"
@@ -338,6 +338,29 @@ int CEF_CALLBACK display_handler_on_cursor_change(
   return _retval;
 }
 
+void CEF_CALLBACK
+display_handler_on_scale_changed(struct _cef_display_handler_t* self,
+                                 cef_browser_t* browser,
+                                 float old_page_scale_factor,
+                                 float new_page_scale_factor) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return;
+
+  // Execute
+  CefDisplayHandlerCppToC::Get(self)->OnScaleChanged(
+      CefBrowserCToCpp::Wrap(browser), old_page_scale_factor,
+      new_page_scale_factor);
+}
+
 }  // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -358,6 +381,7 @@ CefDisplayHandlerCppToC::CefDisplayHandlerCppToC() {
   GetStruct()->on_loading_progress_change =
       display_handler_on_loading_progress_change;
   GetStruct()->on_cursor_change = display_handler_on_cursor_change;
+  GetStruct()->on_scale_changed = display_handler_on_scale_changed;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/cef/libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.cc
new file mode 100644
index 0000000000000..3876dba9e89e8
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.cc
@@ -0,0 +1,69 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=8c21d39cfec72fe99c8317906941d00cd3cbf0d0$
+//
+
+#include "libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.h"
+#include "libcef_dll/shutdown_checker.h"
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK get_origin_usage_or_quota_callback_on_complete(
+    struct _cef_get_origin_usage_or_quota_callback_t* self,
+    int64 nums) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefGetOriginUsageOrQuotaCallbackCppToC::Get(self)->OnComplete(nums);
+}
+
+}  // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefGetOriginUsageOrQuotaCallbackCppToC::
+    CefGetOriginUsageOrQuotaCallbackCppToC() {
+  GetStruct()->on_complete = get_origin_usage_or_quota_callback_on_complete;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefGetOriginUsageOrQuotaCallbackCppToC::
+    ~CefGetOriginUsageOrQuotaCallbackCppToC() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+CefRefPtr<CefGetOriginUsageOrQuotaCallback>
+CefCppToCRefCounted<CefGetOriginUsageOrQuotaCallbackCppToC,
+                    CefGetOriginUsageOrQuotaCallback,
+                    cef_get_origin_usage_or_quota_callback_t>::
+    UnwrapDerived(CefWrapperType type,
+                  cef_get_origin_usage_or_quota_callback_t* s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCppToCRefCounted<
+    CefGetOriginUsageOrQuotaCallbackCppToC,
+    CefGetOriginUsageOrQuotaCallback,
+    cef_get_origin_usage_or_quota_callback_t>::kWrapperType =
+    WT_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK;
diff --git a/cef/libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.h b/cef/libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.h
new file mode 100644
index 0000000000000..4d219961ba523
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=6ba873fdbcca40051dd14bd26bc4a4c7a8999b5f$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK_CPPTOC_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_web_storage_capi.h"
+#include "include/cef_web_storage.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed wrapper-side only.
+class CefGetOriginUsageOrQuotaCallbackCppToC
+    : public CefCppToCRefCounted<CefGetOriginUsageOrQuotaCallbackCppToC,
+                                 CefGetOriginUsageOrQuotaCallback,
+                                 cef_get_origin_usage_or_quota_callback_t> {
+ public:
+  CefGetOriginUsageOrQuotaCallbackCppToC();
+  virtual ~CefGetOriginUsageOrQuotaCallbackCppToC();
+};
+
+#endif  // CEF_LIBCEF_DLL_CPPTOC_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK_CPPTOC_H_
diff --git a/cef/libcef_dll/cpptoc/get_origins_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/get_origins_callback_cpptoc.cc
new file mode 100644
index 0000000000000..66d66ad674fe3
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/get_origins_callback_cpptoc.cc
@@ -0,0 +1,149 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=aff05076c3fad1702ba17a27a4e4713ae1593596$
+//
+
+#include "libcef_dll/cpptoc/get_origins_callback_cpptoc.h"
+#include "libcef_dll/shutdown_checker.h"
+#include "libcef_dll/transfer_util.h"
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK
+get_origins_callback_on_origins(struct _cef_get_origins_callback_t* self,
+                                cef_string_list_t origins) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: origins; type: string_vec_byref
+  DCHECK(origins);
+  if (!origins)
+    return;
+
+  // Translate param: origins; type: string_vec_byref
+  std::vector<CefString> originsList;
+  transfer_string_list_contents(origins, originsList);
+
+  // Execute
+  CefGetOriginsCallbackCppToC::Get(self)->OnOrigins(originsList);
+
+  // Restore param: origins; type: string_vec_byref
+  cef_string_list_clear(origins);
+  transfer_string_list_contents(originsList, origins);
+}
+
+void CEF_CALLBACK
+get_origins_callback_on_usages(struct _cef_get_origins_callback_t* self,
+                               cef_string_list_t usages) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: usages; type: string_vec_byref
+  DCHECK(usages);
+  if (!usages)
+    return;
+
+  // Translate param: usages; type: string_vec_byref
+  std::vector<CefString> usagesList;
+  transfer_string_list_contents(usages, usagesList);
+
+  // Execute
+  CefGetOriginsCallbackCppToC::Get(self)->OnUsages(usagesList);
+
+  // Restore param: usages; type: string_vec_byref
+  cef_string_list_clear(usages);
+  transfer_string_list_contents(usagesList, usages);
+}
+
+void CEF_CALLBACK
+get_origins_callback_on_quotas(struct _cef_get_origins_callback_t* self,
+                               cef_string_list_t quotas) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: quotas; type: string_vec_byref
+  DCHECK(quotas);
+  if (!quotas)
+    return;
+
+  // Translate param: quotas; type: string_vec_byref
+  std::vector<CefString> quotasList;
+  transfer_string_list_contents(quotas, quotasList);
+
+  // Execute
+  CefGetOriginsCallbackCppToC::Get(self)->OnQuotas(quotasList);
+
+  // Restore param: quotas; type: string_vec_byref
+  cef_string_list_clear(quotas);
+  transfer_string_list_contents(quotasList, quotas);
+}
+
+void CEF_CALLBACK
+get_origins_callback_on_complete(struct _cef_get_origins_callback_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefGetOriginsCallbackCppToC::Get(self)->OnComplete();
+}
+
+}  // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefGetOriginsCallbackCppToC::CefGetOriginsCallbackCppToC() {
+  GetStruct()->on_origins = get_origins_callback_on_origins;
+  GetStruct()->on_usages = get_origins_callback_on_usages;
+  GetStruct()->on_quotas = get_origins_callback_on_quotas;
+  GetStruct()->on_complete = get_origins_callback_on_complete;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefGetOriginsCallbackCppToC::~CefGetOriginsCallbackCppToC() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+CefRefPtr<CefGetOriginsCallback> CefCppToCRefCounted<
+    CefGetOriginsCallbackCppToC,
+    CefGetOriginsCallback,
+    cef_get_origins_callback_t>::UnwrapDerived(CefWrapperType type,
+                                               cef_get_origins_callback_t* s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCppToCRefCounted<CefGetOriginsCallbackCppToC,
+                                   CefGetOriginsCallback,
+                                   cef_get_origins_callback_t>::kWrapperType =
+    WT_GET_ORIGINS_CALLBACK;
diff --git a/cef/libcef_dll/cpptoc/get_origins_callback_cpptoc.h b/cef/libcef_dll/cpptoc/get_origins_callback_cpptoc.h
new file mode 100644
index 0000000000000..d5318c9e17e80
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/get_origins_callback_cpptoc.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=86239d3281ad43ad93dcbe67a82a713044ab885d$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_GET_ORIGINS_CALLBACK_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_GET_ORIGINS_CALLBACK_CPPTOC_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_web_storage_capi.h"
+#include "include/cef_web_storage.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed wrapper-side only.
+class CefGetOriginsCallbackCppToC
+    : public CefCppToCRefCounted<CefGetOriginsCallbackCppToC,
+                                 CefGetOriginsCallback,
+                                 cef_get_origins_callback_t> {
+ public:
+  CefGetOriginsCallbackCppToC();
+  virtual ~CefGetOriginsCallbackCppToC();
+};
+
+#endif  // CEF_LIBCEF_DLL_CPPTOC_GET_ORIGINS_CALLBACK_CPPTOC_H_
diff --git a/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc b/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc
index 424040a880e77..907f122ea0c5e 100644
--- a/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=f2d63ae1b93668305c70a02fec40da44f9a0ffcd$
+// $hash=6e8b89e48c680cb130518d3a39dfa9521045d828$
 //
 
 #include "libcef_dll/cpptoc/render_handler_cpptoc.h"
@@ -324,6 +324,69 @@ render_handler_on_accelerated_paint(struct _cef_render_handler_t* self,
       CefBrowserCToCpp::Wrap(browser), type, dirtyRectsList, shared_handle);
 }
 
+void CEF_CALLBACK
+render_handler_get_touch_handle_size(struct _cef_render_handler_t* self,
+                                     cef_browser_t* browser,
+                                     cef_horizontal_alignment_t orientation,
+                                     cef_size_t* size) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return;
+  // Verify param: size; type: simple_byref
+  DCHECK(size);
+  if (!size)
+    return;
+
+  // Translate param: size; type: simple_byref
+  CefSize sizeVal = size ? *size : CefSize();
+
+  // Execute
+  CefRenderHandlerCppToC::Get(self)->GetTouchHandleSize(
+      CefBrowserCToCpp::Wrap(browser), orientation, sizeVal);
+
+  // Restore param: size; type: simple_byref
+  if (size)
+    *size = sizeVal;
+}
+
+void CEF_CALLBACK render_handler_on_touch_handle_state_changed(
+    struct _cef_render_handler_t* self,
+    cef_browser_t* browser,
+    const struct _cef_touch_handle_state_t* state) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return;
+  // Verify param: state; type: struct_byref_const
+  DCHECK(state);
+  if (!state)
+    return;
+
+  // Translate param: state; type: struct_byref_const
+  CefTouchHandleState stateObj;
+  if (state)
+    stateObj.Set(*state, false);
+
+  // Execute
+  CefRenderHandlerCppToC::Get(self)->OnTouchHandleStateChanged(
+      CefBrowserCToCpp::Wrap(browser), stateObj);
+}
+
 int CEF_CALLBACK
 render_handler_start_dragging(struct _cef_render_handler_t* self,
                               cef_browser_t* browser,
@@ -526,6 +589,9 @@ CefRenderHandlerCppToC::CefRenderHandlerCppToC() {
   GetStruct()->on_popup_size = render_handler_on_popup_size;
   GetStruct()->on_paint = render_handler_on_paint;
   GetStruct()->on_accelerated_paint = render_handler_on_accelerated_paint;
+  GetStruct()->get_touch_handle_size = render_handler_get_touch_handle_size;
+  GetStruct()->on_touch_handle_state_changed =
+      render_handler_on_touch_handle_state_changed;
   GetStruct()->start_dragging = render_handler_start_dragging;
   GetStruct()->update_drag_cursor = render_handler_update_drag_cursor;
   GetStruct()->on_scroll_offset_changed =
diff --git a/cef/libcef_dll/cpptoc/request_context_cpptoc.cc b/cef/libcef_dll/cpptoc/request_context_cpptoc.cc
index cd3e0f9bb6844..d9ed11e960da7 100644
--- a/cef/libcef_dll/cpptoc/request_context_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/request_context_cpptoc.cc
@@ -9,15 +9,17 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=69c5dc4e787496678696a7aa0f1f5eea80355ea8$
+// $hash=1c9faf9e6cc954e6750cbdb4dd0533659bdab68d$
 //
 
 #include "libcef_dll/cpptoc/request_context_cpptoc.h"
 #include "libcef_dll/cpptoc/cookie_manager_cpptoc.h"
+#include "libcef_dll/cpptoc/data_base_cpptoc.h"
 #include "libcef_dll/cpptoc/dictionary_value_cpptoc.h"
 #include "libcef_dll/cpptoc/extension_cpptoc.h"
 #include "libcef_dll/cpptoc/media_router_cpptoc.h"
 #include "libcef_dll/cpptoc/value_cpptoc.h"
+#include "libcef_dll/cpptoc/web_storage_cpptoc.h"
 #include "libcef_dll/ctocpp/completion_callback_ctocpp.h"
 #include "libcef_dll/ctocpp/extension_handler_ctocpp.h"
 #include "libcef_dll/ctocpp/request_context_handler_ctocpp.h"
@@ -191,6 +193,41 @@ request_context_get_cookie_manager(struct _cef_request_context_t* self,
   return CefCookieManagerCppToC::Wrap(_retval);
 }
 
+cef_data_base_t* CEF_CALLBACK
+request_context_get_data_base(struct _cef_request_context_t* self) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return NULL;
+
+  // Execute
+  CefRefPtr<CefDataBase> _retval =
+      CefRequestContextCppToC::Get(self)->GetDataBase();
+
+  // Return type: refptr_same
+  return CefDataBaseCppToC::Wrap(_retval);
+}
+
+struct _cef_web_storage_t* CEF_CALLBACK
+request_context_get_web_storage(struct _cef_request_context_t* self,
+                                cef_completion_callback_t* callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return NULL;
+  // Unverified params: callback
+
+  // Execute
+  CefRefPtr<CefWebStorage> _retval =
+      CefRequestContextCppToC::Get(self)->GetWebStorage(
+          CefCompletionCallbackCToCpp::Wrap(callback));
+
+  // Return type: refptr_same
+  return CefWebStorageCppToC::Wrap(_retval);
+}
+
 int CEF_CALLBACK request_context_register_scheme_handler_factory(
     struct _cef_request_context_t* self,
     const cef_string_t* scheme_name,
@@ -571,6 +608,8 @@ CefRequestContextCppToC::CefRequestContextCppToC() {
   GetStruct()->get_handler = request_context_get_handler;
   GetStruct()->get_cache_path = request_context_get_cache_path;
   GetStruct()->get_cookie_manager = request_context_get_cookie_manager;
+  GetStruct()->get_data_base = request_context_get_data_base;
+  GetStruct()->get_web_storage = request_context_get_web_storage;
   GetStruct()->register_scheme_handler_factory =
       request_context_register_scheme_handler_factory;
   GetStruct()->clear_scheme_handler_factories =
diff --git a/cef/libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.cc
new file mode 100644
index 0000000000000..477c530ed458b
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=51e850e2768a6ec8ec7d764830d27138334d82ac$
+//
+
+#include "libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.h"
+#include "libcef_dll/shutdown_checker.h"
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK
+run_quick_menu_callback_cont(struct _cef_run_quick_menu_callback_t* self,
+                             int command_id,
+                             cef_event_flags_t event_flags) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefRunQuickMenuCallbackCppToC::Get(self)->Continue(command_id, event_flags);
+}
+
+void CEF_CALLBACK
+run_quick_menu_callback_cancel(struct _cef_run_quick_menu_callback_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefRunQuickMenuCallbackCppToC::Get(self)->Cancel();
+}
+
+}  // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefRunQuickMenuCallbackCppToC::CefRunQuickMenuCallbackCppToC() {
+  GetStruct()->cont = run_quick_menu_callback_cont;
+  GetStruct()->cancel = run_quick_menu_callback_cancel;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefRunQuickMenuCallbackCppToC::~CefRunQuickMenuCallbackCppToC() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+CefRefPtr<CefRunQuickMenuCallback> CefCppToCRefCounted<
+    CefRunQuickMenuCallbackCppToC,
+    CefRunQuickMenuCallback,
+    cef_run_quick_menu_callback_t>::UnwrapDerived(CefWrapperType type,
+                                                  cef_run_quick_menu_callback_t*
+                                                      s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType
+    CefCppToCRefCounted<CefRunQuickMenuCallbackCppToC,
+                        CefRunQuickMenuCallback,
+                        cef_run_quick_menu_callback_t>::kWrapperType =
+        WT_RUN_QUICK_MENU_CALLBACK;
diff --git a/cef/libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.h b/cef/libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.h
new file mode 100644
index 0000000000000..355cfa24d1451
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=b641fe8119fa5ab3e3a635105ca25985dec40bd0$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_RUN_QUICK_MENU_CALLBACK_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_RUN_QUICK_MENU_CALLBACK_CPPTOC_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include "include/capi/cef_context_menu_handler_capi.h"
+#include "include/cef_context_menu_handler.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed DLL-side only.
+class CefRunQuickMenuCallbackCppToC
+    : public CefCppToCRefCounted<CefRunQuickMenuCallbackCppToC,
+                                 CefRunQuickMenuCallback,
+                                 cef_run_quick_menu_callback_t> {
+ public:
+  CefRunQuickMenuCallbackCppToC();
+  virtual ~CefRunQuickMenuCallbackCppToC();
+};
+
+#endif  // CEF_LIBCEF_DLL_CPPTOC_RUN_QUICK_MENU_CALLBACK_CPPTOC_H_
diff --git a/cef/libcef_dll/cpptoc/web_storage_cpptoc.cc b/cef/libcef_dll/cpptoc/web_storage_cpptoc.cc
new file mode 100644
index 0000000000000..5176cd1efbcd8
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/web_storage_cpptoc.cc
@@ -0,0 +1,144 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=959e73af8a9517a5a2381606195efc0fde114317$
+//
+
+#include "libcef_dll/cpptoc/web_storage_cpptoc.h"
+#include "libcef_dll/ctocpp/completion_callback_ctocpp.h"
+#include "libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.h"
+#include "libcef_dll/ctocpp/get_origins_callback_ctocpp.h"
+
+// GLOBAL FUNCTIONS - Body may be edited by hand.
+
+CEF_EXPORT cef_web_storage_t* cef_web_storage_get_global_manager(
+    cef_completion_callback_t* callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: callback
+
+  // Execute
+  CefRefPtr<CefWebStorage> _retval = CefWebStorage::GetGlobalManager(
+      CefCompletionCallbackCToCpp::Wrap(callback));
+
+  // Return type: refptr_same
+  return CefWebStorageCppToC::Wrap(_retval);
+}
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK web_storage_delete_all_data(struct _cef_web_storage_t* self) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefWebStorageCppToC::Get(self)->DeleteAllData();
+}
+
+void CEF_CALLBACK web_storage_delete_origin(struct _cef_web_storage_t* self,
+                                            const cef_string_t* origin) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: origin; type: string_byref_const
+  DCHECK(origin);
+  if (!origin)
+    return;
+
+  // Execute
+  CefWebStorageCppToC::Get(self)->DeleteOrigin(CefString(origin));
+}
+
+void CEF_CALLBACK
+web_storage_get_origins(struct _cef_web_storage_t* self,
+                        struct _cef_get_origins_callback_t* callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Unverified params: callback
+
+  // Execute
+  CefWebStorageCppToC::Get(self)->GetOrigins(
+      CefGetOriginsCallbackCToCpp::Wrap(callback));
+}
+
+void CEF_CALLBACK web_storage_get_origin_quota(
+    struct _cef_web_storage_t* self,
+    const cef_string_t* origin,
+    struct _cef_get_origin_usage_or_quota_callback_t* callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Unverified params: origin, callback
+
+  // Execute
+  CefWebStorageCppToC::Get(self)->GetOriginQuota(
+      CefString(origin),
+      CefGetOriginUsageOrQuotaCallbackCToCpp::Wrap(callback));
+}
+
+void CEF_CALLBACK web_storage_get_origin_usage(
+    struct _cef_web_storage_t* self,
+    const cef_string_t* origin,
+    struct _cef_get_origin_usage_or_quota_callback_t* callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Unverified params: origin, callback
+
+  // Execute
+  CefWebStorageCppToC::Get(self)->GetOriginUsage(
+      CefString(origin),
+      CefGetOriginUsageOrQuotaCallbackCToCpp::Wrap(callback));
+}
+
+}  // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefWebStorageCppToC::CefWebStorageCppToC() {
+  GetStruct()->delete_all_data = web_storage_delete_all_data;
+  GetStruct()->delete_origin = web_storage_delete_origin;
+  GetStruct()->get_origins = web_storage_get_origins;
+  GetStruct()->get_origin_quota = web_storage_get_origin_quota;
+  GetStruct()->get_origin_usage = web_storage_get_origin_usage;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefWebStorageCppToC::~CefWebStorageCppToC() {}
+
+template <>
+CefRefPtr<CefWebStorage>
+CefCppToCRefCounted<CefWebStorageCppToC, CefWebStorage, cef_web_storage_t>::
+    UnwrapDerived(CefWrapperType type, cef_web_storage_t* s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCppToCRefCounted<CefWebStorageCppToC,
+                                   CefWebStorage,
+                                   cef_web_storage_t>::kWrapperType =
+    WT_WEB_STORAGE;
diff --git a/cef/libcef_dll/cpptoc/web_storage_cpptoc.h b/cef/libcef_dll/cpptoc/web_storage_cpptoc.h
new file mode 100644
index 0000000000000..1e1b951eccc99
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/web_storage_cpptoc.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=e96ec830a2f1b20fc1ec99664ce7a2df266b73dc$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_WEB_STORAGE_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_WEB_STORAGE_CPPTOC_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include "include/capi/cef_web_storage_capi.h"
+#include "include/cef_web_storage.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed DLL-side only.
+class CefWebStorageCppToC : public CefCppToCRefCounted<CefWebStorageCppToC,
+                                                       CefWebStorage,
+                                                       cef_web_storage_t> {
+ public:
+  CefWebStorageCppToC();
+  virtual ~CefWebStorageCppToC();
+};
+
+#endif  // CEF_LIBCEF_DLL_CPPTOC_WEB_STORAGE_CPPTOC_H_
diff --git a/cef/libcef_dll/ctocpp/auth_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/auth_callback_ctocpp.cc
index f0acf803ebdf6..70e3952bc4ab4 100644
--- a/cef/libcef_dll/ctocpp/auth_callback_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/auth_callback_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=3ae38c17cba153dbca73496eae905202ac09bfeb$
+// $hash=e7ec4903d06110c27d271a7e946c90231b8d3f08$
 //
 
 #include "libcef_dll/ctocpp/auth_callback_ctocpp.h"
@@ -18,11 +18,11 @@
 // VIRTUAL METHODS - Body may be edited by hand.
 
 NO_SANITIZE("cfi-icall")
-void CefAuthCallbackCToCpp::Continue(const CefString& username,
-                                     const CefString& password) {
+void CefAuthCallbackCToCpp::Continue(const CefString &username,
+                                     const CefString &password) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_auth_callback_t* _struct = GetStruct();
+  cef_auth_callback_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, cont))
     return;
 
@@ -37,7 +37,7 @@ void CefAuthCallbackCToCpp::Continue(const CefString& username,
 NO_SANITIZE("cfi-icall") void CefAuthCallbackCToCpp::Cancel() {
   shutdown_checker::AssertNotShutdown();
 
-  cef_auth_callback_t* _struct = GetStruct();
+  cef_auth_callback_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, cancel))
     return;
 
@@ -47,6 +47,22 @@ NO_SANITIZE("cfi-icall") void CefAuthCallbackCToCpp::Cancel() {
   _struct->cancel(_struct);
 }
 
+NO_SANITIZE("cfi-icall") bool CefAuthCallbackCToCpp::IsHttpAuthInfoSaved() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_auth_callback_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, is_http_auth_info_saved))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  int _retval = _struct->is_http_auth_info_saved(_struct);
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefAuthCallbackCToCpp::CefAuthCallbackCToCpp() {}
@@ -58,17 +74,15 @@ CefAuthCallbackCToCpp::~CefAuthCallbackCToCpp() {
 }
 
 template <>
-cef_auth_callback_t*
-CefCToCppRefCounted<CefAuthCallbackCToCpp,
-                    CefAuthCallback,
+cef_auth_callback_t *
+CefCToCppRefCounted<CefAuthCallbackCToCpp, CefAuthCallback,
                     cef_auth_callback_t>::UnwrapDerived(CefWrapperType type,
-                                                        CefAuthCallback* c) {
+                                                        CefAuthCallback *c) {
   NOTREACHED() << "Unexpected class type: " << type;
   return nullptr;
 }
 
 template <>
-CefWrapperType CefCToCppRefCounted<CefAuthCallbackCToCpp,
-                                   CefAuthCallback,
+CefWrapperType CefCToCppRefCounted<CefAuthCallbackCToCpp, CefAuthCallback,
                                    cef_auth_callback_t>::kWrapperType =
     WT_AUTH_CALLBACK;
diff --git a/cef/libcef_dll/ctocpp/auth_callback_ctocpp.h b/cef/libcef_dll/ctocpp/auth_callback_ctocpp.h
index d8ca62c4576bf..394521381f12d 100644
--- a/cef/libcef_dll/ctocpp/auth_callback_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/auth_callback_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=2e08ff9c5744055783e66c5f5068412c23bdfb6a$
+// $hash=003f0cf00b58615840328c131b118e12e405d25d$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_AUTH_CALLBACK_CTOCPP_H_
@@ -26,16 +26,17 @@
 
 // Wrap a C structure with a C++ class.
 // This class may be instantiated and accessed wrapper-side only.
-class CefAuthCallbackCToCpp : public CefCToCppRefCounted<CefAuthCallbackCToCpp,
-                                                         CefAuthCallback,
-                                                         cef_auth_callback_t> {
- public:
+class CefAuthCallbackCToCpp
+    : public CefCToCppRefCounted<CefAuthCallbackCToCpp, CefAuthCallback,
+                                 cef_auth_callback_t> {
+public:
   CefAuthCallbackCToCpp();
   virtual ~CefAuthCallbackCToCpp();
 
   // CefAuthCallback methods.
-  void Continue(const CefString& username, const CefString& password) OVERRIDE;
+  void Continue(const CefString &username, const CefString &password) OVERRIDE;
   void Cancel() OVERRIDE;
+  bool IsHttpAuthInfoSaved() OVERRIDE;
 };
 
-#endif  // CEF_LIBCEF_DLL_CTOCPP_AUTH_CALLBACK_CTOCPP_H_
+#endif // CEF_LIBCEF_DLL_CTOCPP_AUTH_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/browser_ctocpp.cc b/cef/libcef_dll/ctocpp/browser_ctocpp.cc
index 51faa16e1dd3d..5da9863ef3342 100644
--- a/cef/libcef_dll/ctocpp/browser_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/browser_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=1d64c15697f6087a6931b74f296a37907fbc8dec$
+// $hash=220bf75cb17234a4207417a9b9808c449b84a75f$
 //
 
 #include "libcef_dll/ctocpp/browser_ctocpp.h"
@@ -114,6 +114,19 @@ bool CefBrowserCToCpp::CanGoBackOrForward(int num_steps) {
   return _retval ? true : false;
 }
 
+NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::GoBackOrForward(int num_steps) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, go_back_or_forward))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->go_back_or_forward(_struct, num_steps);
+}
+
 NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::DeleteHistory() {
   shutdown_checker::AssertNotShutdown();
 
@@ -169,6 +182,19 @@ NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::ReloadIgnoreCache() {
   _struct->reload_ignore_cache(_struct);
 }
 
+NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::ReloadOriginalUrl() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, reload_original_url))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->reload_original_url(_struct);
+}
+
 NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::StopLoad() {
   shutdown_checker::AssertNotShutdown();
 
diff --git a/cef/libcef_dll/ctocpp/browser_ctocpp.h b/cef/libcef_dll/ctocpp/browser_ctocpp.h
index 088258f6f0e17..e35719950a18d 100644
--- a/cef/libcef_dll/ctocpp/browser_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/browser_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=02e030f24314da7dc9c9c85b0247b9389730bfaf$
+// $hash=916afe8b283c692464dd27c0e284c898e7f026bf$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_BROWSER_CTOCPP_H_
@@ -42,10 +42,12 @@ class CefBrowserCToCpp
   bool CanGoForward() OVERRIDE;
   void GoForward() OVERRIDE;
   bool CanGoBackOrForward(int num_steps) OVERRIDE;
+  void GoBackOrForward(int num_steps) OVERRIDE;
   void DeleteHistory() OVERRIDE;
   bool IsLoading() OVERRIDE;
   void Reload() OVERRIDE;
   void ReloadIgnoreCache() OVERRIDE;
+  void ReloadOriginalUrl() OVERRIDE;
   void StopLoad() OVERRIDE;
   int GetIdentifier() OVERRIDE;
   bool IsSame(CefRefPtr<CefBrowser> that) OVERRIDE;
diff --git a/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc b/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
index 5f6f8b5d02674..64a476694811a 100644
--- a/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=87bb5126d6b4b3bd34ed78af087e3afd803d2dcd$
+// $hash=40021309c151fae1441f8931dab8a08ff82bf2cf$
 //
 
 #include "libcef_dll/ctocpp/browser_host_ctocpp.h"
@@ -1019,6 +1019,20 @@ void CefBrowserHostCToCpp::GetHitData(int& type, CefString& extra_data) {
   _struct->get_hit_data(_struct, &type, extra_data.GetWritableStruct());
 }
 
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::SetInitialScale(float scale) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, set_initial_scale))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->set_initial_scale(_struct, scale);
+}
+
 NO_SANITIZE("cfi-icall") int CefBrowserHostCToCpp::PageLoadProgress() {
   shutdown_checker::AssertNotShutdown();
 
@@ -1480,6 +1494,19 @@ NO_SANITIZE("cfi-icall") bool CefBrowserHostCToCpp::GetWebDebuggingAccess() {
   return _retval ? true : false;
 }
 
+NO_SANITIZE("cfi-icall") void CefBrowserHostCToCpp::GetImageForContextNode() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_image_for_context_node))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->get_image_for_context_node(_struct);
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefBrowserHostCToCpp::CefBrowserHostCToCpp() {}
diff --git a/cef/libcef_dll/ctocpp/browser_host_ctocpp.h b/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
index bb2fe2c254aa4..96d928e453d48 100644
--- a/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=55f32c914962cf44aa47185731a5049c27887223$
+// $hash=b923449230e8617d5e205097f08f7139d6548971$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_BROWSER_HOST_CTOCPP_H_
@@ -120,6 +120,7 @@ class CefBrowserHostCToCpp : public CefCToCppRefCounted<CefBrowserHostCToCpp,
       const std::vector<CefString>& method_list) OVERRIDE;
   CefString Title() OVERRIDE;
   void GetHitData(int& type, CefString& extra_data) OVERRIDE;
+  void SetInitialScale(float scale) OVERRIDE;
   int PageLoadProgress() OVERRIDE;
   float Scale() OVERRIDE;
   void LoadWithDataAndBaseUrl(const CefString& baseUrl,
@@ -164,6 +165,7 @@ class CefBrowserHostCToCpp : public CefCToCppRefCounted<CefBrowserHostCToCpp,
   void SetNativeWindow(cef_native_window_t window) OVERRIDE;
   void SetWebDebuggingAccess(bool isEnableDebug) OVERRIDE;
   bool GetWebDebuggingAccess() OVERRIDE;
+  void GetImageForContextNode() OVERRIDE;
 };
 
 #endif  // CEF_LIBCEF_DLL_CTOCPP_BROWSER_HOST_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.cc b/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.cc
index 3a765cddb5f38..77fa773593449 100644
--- a/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.cc
@@ -9,15 +9,17 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=7b91234844f040546245a09f4724142efdf929ff$
+// $hash=a33aa7f98c0f55f69ea03d3057529ffd84841590$
 //
 
 #include "libcef_dll/ctocpp/context_menu_handler_ctocpp.h"
 #include "libcef_dll/cpptoc/browser_cpptoc.h"
 #include "libcef_dll/cpptoc/context_menu_params_cpptoc.h"
 #include "libcef_dll/cpptoc/frame_cpptoc.h"
+#include "libcef_dll/cpptoc/image_cpptoc.h"
 #include "libcef_dll/cpptoc/menu_model_cpptoc.h"
 #include "libcef_dll/cpptoc/run_context_menu_callback_cpptoc.h"
+#include "libcef_dll/cpptoc/run_quick_menu_callback_cpptoc.h"
 #include "libcef_dll/shutdown_checker.h"
 
 // VIRTUAL METHODS - Body may be edited by hand.
@@ -169,6 +171,123 @@ void CefContextMenuHandlerCToCpp::OnContextMenuDismissed(
                                      CefFrameCppToC::Wrap(frame));
 }
 
+NO_SANITIZE("cfi-icall")
+bool CefContextMenuHandlerCToCpp::RunQuickMenu(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame,
+    const CefPoint& location,
+    const CefSize& size,
+    QuickMenuEditStateFlags edit_state_flags,
+    CefRefPtr<CefRunQuickMenuCallback> callback) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_context_menu_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, run_quick_menu))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return false;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame.get());
+  if (!frame.get())
+    return false;
+  // Verify param: callback; type: refptr_diff
+  DCHECK(callback.get());
+  if (!callback.get())
+    return false;
+
+  // Execute
+  int _retval = _struct->run_quick_menu(
+      _struct, CefBrowserCppToC::Wrap(browser), CefFrameCppToC::Wrap(frame),
+      &location, &size, edit_state_flags,
+      CefRunQuickMenuCallbackCppToC::Wrap(callback));
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
+NO_SANITIZE("cfi-icall")
+bool CefContextMenuHandlerCToCpp::OnQuickMenuCommand(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame,
+    int command_id,
+    EventFlags event_flags) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_context_menu_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_quick_menu_command))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return false;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame.get());
+  if (!frame.get())
+    return false;
+
+  // Execute
+  int _retval = _struct->on_quick_menu_command(
+      _struct, CefBrowserCppToC::Wrap(browser), CefFrameCppToC::Wrap(frame),
+      command_id, event_flags);
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
+NO_SANITIZE("cfi-icall")
+void CefContextMenuHandlerCToCpp::OnQuickMenuDismissed(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_context_menu_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_quick_menu_dismissed))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame.get());
+  if (!frame.get())
+    return;
+
+  // Execute
+  _struct->on_quick_menu_dismissed(_struct, CefBrowserCppToC::Wrap(browser),
+                                   CefFrameCppToC::Wrap(frame));
+}
+
+NO_SANITIZE("cfi-icall")
+void CefContextMenuHandlerCToCpp::OnGetImageForContextNode(
+    CefRefPtr<CefImage> image) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_context_menu_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_get_image_for_context_node))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: image; type: refptr_diff
+  DCHECK(image.get());
+  if (!image.get())
+    return;
+
+  // Execute
+  _struct->on_get_image_for_context_node(_struct, CefImageCppToC::Wrap(image));
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefContextMenuHandlerCToCpp::CefContextMenuHandlerCToCpp() {}
diff --git a/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.h b/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.h
index badf3a0475911..86499a8d5ed6c 100644
--- a/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/context_menu_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=3dba1df692cc69ba3aab91b989cceb9a7d363858$
+// $hash=a60498bc61002b6dbf16ccf84b77d5535bc3c13e$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_CONTEXT_MENU_HANDLER_CTOCPP_H_
@@ -51,6 +51,19 @@ class CefContextMenuHandlerCToCpp
                             EventFlags event_flags) override;
   void OnContextMenuDismissed(CefRefPtr<CefBrowser> browser,
                               CefRefPtr<CefFrame> frame) override;
+  bool RunQuickMenu(CefRefPtr<CefBrowser> browser,
+                    CefRefPtr<CefFrame> frame,
+                    const CefPoint& location,
+                    const CefSize& size,
+                    QuickMenuEditStateFlags edit_state_flags,
+                    CefRefPtr<CefRunQuickMenuCallback> callback) override;
+  bool OnQuickMenuCommand(CefRefPtr<CefBrowser> browser,
+                          CefRefPtr<CefFrame> frame,
+                          int command_id,
+                          EventFlags event_flags) override;
+  void OnQuickMenuDismissed(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame) override;
+  void OnGetImageForContextNode(CefRefPtr<CefImage> image) override;
 };
 
 #endif  // CEF_LIBCEF_DLL_CTOCPP_CONTEXT_MENU_HANDLER_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/data_base_ctocpp.cc b/cef/libcef_dll/ctocpp/data_base_ctocpp.cc
new file mode 100644
index 0000000000000..7e58bbd44d83f
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/data_base_ctocpp.cc
@@ -0,0 +1,149 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=53c2a75f715e09b94fad1d3b324886e59d428dcc$
+//
+
+#include "libcef_dll/ctocpp/data_base_ctocpp.h"
+#include "libcef_dll/transfer_util.h"
+
+// STATIC METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+CefRefPtr<CefDataBase> CefDataBase::GetGlobalDataBase() {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  cef_data_base_t *_retval = cef_data_base_get_global();
+
+  // Return type: refptr_same
+  return CefDataBaseCToCpp::Wrap(_retval);
+}
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall") void CefDataBaseCToCpp::DeleteHttpAuthCredentials() {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, delete_http_auth_credentials))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->delete_http_auth_credentials(_struct);
+}
+
+NO_SANITIZE("cfi-icall") bool CefDataBaseCToCpp::ExistHttpAuthCredentials() {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, exist_http_auth_credentials))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  int _retval = _struct->exist_http_auth_credentials(_struct);
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
+NO_SANITIZE("cfi-icall")
+void CefDataBaseCToCpp::SaveHttpAuthCredentials(const CefString &host,
+                                                const CefString &realm,
+                                                const CefString &username,
+                                                const char *password) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, save_http_auth_credentials))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: host; type: string_byref_const
+  DCHECK(!host.empty());
+  if (host.empty())
+    return;
+  // Verify param: realm; type: string_byref_const
+  DCHECK(!realm.empty());
+  if (realm.empty())
+    return;
+  // Verify param: username; type: string_byref_const
+  DCHECK(!username.empty());
+  if (username.empty())
+    return;
+  // Verify param: password; type: simple_byaddr
+  DCHECK(password);
+  if (!password)
+    return;
+
+  // Execute
+  _struct->save_http_auth_credentials(_struct, host.GetStruct(),
+                                      realm.GetStruct(), username.GetStruct(),
+                                      password);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefDataBaseCToCpp::GetHttpAuthCredentials(
+    const CefString &host, const CefString &realm,
+    std::vector<CefString> &username_password) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_http_auth_credentials))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: host; type: string_byref_const
+  DCHECK(!host.empty());
+  if (host.empty())
+    return;
+  // Verify param: realm; type: string_byref_const
+  DCHECK(!realm.empty());
+  if (realm.empty())
+    return;
+
+  // Translate param: username_password; type: string_vec_byref
+  cef_string_list_t username_passwordList = cef_string_list_alloc();
+  DCHECK(username_passwordList);
+  if (username_passwordList)
+    transfer_string_list_contents(username_password, username_passwordList);
+
+  // Execute
+  _struct->get_http_auth_credentials(_struct, host.GetStruct(),
+                                     realm.GetStruct(), username_passwordList);
+
+  // Restore param:username_password; type: string_vec_byref
+  if (username_passwordList) {
+    username_password.clear();
+    transfer_string_list_contents(username_passwordList, username_password);
+    cef_string_list_free(username_passwordList);
+  }
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefDataBaseCToCpp::CefDataBaseCToCpp() {}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefDataBaseCToCpp::~CefDataBaseCToCpp() {}
+
+template <>
+cef_data_base_t *
+CefCToCppRefCounted<CefDataBaseCToCpp, CefDataBase,
+                    cef_data_base_t>::UnwrapDerived(CefWrapperType type,
+                                                    CefDataBase *c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCToCppRefCounted<CefDataBaseCToCpp, CefDataBase,
+                                   cef_data_base_t>::kWrapperType =
+    WT_DATA_BASE;
diff --git a/cef/libcef_dll/ctocpp/data_base_ctocpp.h b/cef/libcef_dll/ctocpp/data_base_ctocpp.h
new file mode 100644
index 0000000000000..b2614a28e75c3
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/data_base_ctocpp.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=e6ff148812bffbe2b08efcdda056642b77a392ca$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_DATA_BASE_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_DATA_BASE_CTOCPP_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_data_base_capi.h"
+#include "include/cef_data_base.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+#include <vector>
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed wrapper-side only.
+class CefDataBaseCToCpp
+    : public CefCToCppRefCounted<CefDataBaseCToCpp, CefDataBase,
+                                 cef_data_base_t> {
+public:
+  CefDataBaseCToCpp();
+  virtual ~CefDataBaseCToCpp();
+
+  // CefDataBase methods.
+  void DeleteHttpAuthCredentials() OVERRIDE;
+  bool ExistHttpAuthCredentials() OVERRIDE;
+  void SaveHttpAuthCredentials(const CefString &host, const CefString &realm,
+                               const CefString &username,
+                               const char *password) OVERRIDE;
+  void
+  GetHttpAuthCredentials(const CefString &host, const CefString &realm,
+                         std::vector<CefString> &username_password) OVERRIDE;
+};
+
+#endif // CEF_LIBCEF_DLL_CTOCPP_DATA_BASE_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/display_handler_ctocpp.cc b/cef/libcef_dll/ctocpp/display_handler_ctocpp.cc
index cb7743a77a98c..f203dcaa3f7d0 100644
--- a/cef/libcef_dll/ctocpp/display_handler_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/display_handler_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=98fa3d9e050e833252d3abe3ca7e8fe83154b25f$
+// $hash=1591b970fac6aa5ef75508ba414274aa3d80519c$
 //
 
 #include "libcef_dll/ctocpp/display_handler_ctocpp.h"
@@ -328,6 +328,28 @@ bool CefDisplayHandlerCToCpp::OnCursorChange(
   return _retval ? true : false;
 }
 
+NO_SANITIZE("cfi-icall")
+void CefDisplayHandlerCToCpp::OnScaleChanged(CefRefPtr<CefBrowser> browser,
+                                             float old_page_scale_factor,
+                                             float new_page_scale_factor) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_display_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_scale_changed))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return;
+
+  // Execute
+  _struct->on_scale_changed(_struct, CefBrowserCppToC::Wrap(browser),
+                            old_page_scale_factor, new_page_scale_factor);
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefDisplayHandlerCToCpp::CefDisplayHandlerCToCpp() {}
diff --git a/cef/libcef_dll/ctocpp/display_handler_ctocpp.h b/cef/libcef_dll/ctocpp/display_handler_ctocpp.h
index 35822b73b3296..00042a44aac58 100644
--- a/cef/libcef_dll/ctocpp/display_handler_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/display_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=07af406c978c7eef163785b97dce854126fc6052$
+// $hash=76975e7724177fc4db8a1f45b3f68a8ae359c2d6$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_DISPLAY_HANDLER_CTOCPP_H_
@@ -69,6 +69,9 @@ class CefDisplayHandlerCToCpp
                       CefCursorHandle cursor,
                       cef_cursor_type_t type,
                       const CefCursorInfo& custom_cursor_info) override;
+  void OnScaleChanged(CefRefPtr<CefBrowser> browser,
+                      float old_page_scale_factor,
+                      float new_page_scale_factor) override;
 };
 
 #endif  // CEF_LIBCEF_DLL_CTOCPP_DISPLAY_HANDLER_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.cc
new file mode 100644
index 0000000000000..584b4d086729b
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.cc
@@ -0,0 +1,61 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=070d1f0064cc25f4e3e13d9b2931a4ba1c8341d4$
+//
+
+#include "libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.h"
+#include "libcef_dll/shutdown_checker.h"
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+void CefGetOriginUsageOrQuotaCallbackCToCpp::OnComplete(int64 nums) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_get_origin_usage_or_quota_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_complete))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->on_complete(_struct, nums);
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefGetOriginUsageOrQuotaCallbackCToCpp::
+    CefGetOriginUsageOrQuotaCallbackCToCpp() {}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefGetOriginUsageOrQuotaCallbackCToCpp::
+    ~CefGetOriginUsageOrQuotaCallbackCToCpp() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+cef_get_origin_usage_or_quota_callback_t*
+CefCToCppRefCounted<CefGetOriginUsageOrQuotaCallbackCToCpp,
+                    CefGetOriginUsageOrQuotaCallback,
+                    cef_get_origin_usage_or_quota_callback_t>::
+    UnwrapDerived(CefWrapperType type, CefGetOriginUsageOrQuotaCallback* c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCToCppRefCounted<
+    CefGetOriginUsageOrQuotaCallbackCToCpp,
+    CefGetOriginUsageOrQuotaCallback,
+    cef_get_origin_usage_or_quota_callback_t>::kWrapperType =
+    WT_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK;
diff --git a/cef/libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.h b/cef/libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.h
new file mode 100644
index 0000000000000..e8dc6f55ed97c
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/get_origin_usage_or_quota_callback_ctocpp.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=128e55210f65fe29b0d2d84160fd2a9427bc6429$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK_CTOCPP_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include "include/capi/cef_web_storage_capi.h"
+#include "include/cef_web_storage.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed DLL-side only.
+class CefGetOriginUsageOrQuotaCallbackCToCpp
+    : public CefCToCppRefCounted<CefGetOriginUsageOrQuotaCallbackCToCpp,
+                                 CefGetOriginUsageOrQuotaCallback,
+                                 cef_get_origin_usage_or_quota_callback_t> {
+ public:
+  CefGetOriginUsageOrQuotaCallbackCToCpp();
+  virtual ~CefGetOriginUsageOrQuotaCallbackCToCpp();
+
+  // CefGetOriginUsageOrQuotaCallback methods.
+  void OnComplete(int64 nums) override;
+};
+
+#endif  // CEF_LIBCEF_DLL_CTOCPP_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/get_origins_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/get_origins_callback_ctocpp.cc
new file mode 100644
index 0000000000000..d0240181d2a5c
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/get_origins_callback_ctocpp.cc
@@ -0,0 +1,139 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=c81051ff9ec3bd7b14f89c09f00eea970ed14b14$
+//
+
+#include "libcef_dll/ctocpp/get_origins_callback_ctocpp.h"
+#include "libcef_dll/shutdown_checker.h"
+#include "libcef_dll/transfer_util.h"
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+void CefGetOriginsCallbackCToCpp::OnOrigins(std::vector<CefString>& origins) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_get_origins_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_origins))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Translate param: origins; type: string_vec_byref
+  cef_string_list_t originsList = cef_string_list_alloc();
+  DCHECK(originsList);
+  if (originsList)
+    transfer_string_list_contents(origins, originsList);
+
+  // Execute
+  _struct->on_origins(_struct, originsList);
+
+  // Restore param:origins; type: string_vec_byref
+  if (originsList) {
+    origins.clear();
+    transfer_string_list_contents(originsList, origins);
+    cef_string_list_free(originsList);
+  }
+}
+
+NO_SANITIZE("cfi-icall")
+void CefGetOriginsCallbackCToCpp::OnUsages(std::vector<CefString>& usages) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_get_origins_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_usages))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Translate param: usages; type: string_vec_byref
+  cef_string_list_t usagesList = cef_string_list_alloc();
+  DCHECK(usagesList);
+  if (usagesList)
+    transfer_string_list_contents(usages, usagesList);
+
+  // Execute
+  _struct->on_usages(_struct, usagesList);
+
+  // Restore param:usages; type: string_vec_byref
+  if (usagesList) {
+    usages.clear();
+    transfer_string_list_contents(usagesList, usages);
+    cef_string_list_free(usagesList);
+  }
+}
+
+NO_SANITIZE("cfi-icall")
+void CefGetOriginsCallbackCToCpp::OnQuotas(std::vector<CefString>& quotas) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_get_origins_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_quotas))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Translate param: quotas; type: string_vec_byref
+  cef_string_list_t quotasList = cef_string_list_alloc();
+  DCHECK(quotasList);
+  if (quotasList)
+    transfer_string_list_contents(quotas, quotasList);
+
+  // Execute
+  _struct->on_quotas(_struct, quotasList);
+
+  // Restore param:quotas; type: string_vec_byref
+  if (quotasList) {
+    quotas.clear();
+    transfer_string_list_contents(quotasList, quotas);
+    cef_string_list_free(quotasList);
+  }
+}
+
+NO_SANITIZE("cfi-icall") void CefGetOriginsCallbackCToCpp::OnComplete() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_get_origins_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_complete))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->on_complete(_struct);
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefGetOriginsCallbackCToCpp::CefGetOriginsCallbackCToCpp() {}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefGetOriginsCallbackCToCpp::~CefGetOriginsCallbackCToCpp() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+cef_get_origins_callback_t* CefCToCppRefCounted<
+    CefGetOriginsCallbackCToCpp,
+    CefGetOriginsCallback,
+    cef_get_origins_callback_t>::UnwrapDerived(CefWrapperType type,
+                                               CefGetOriginsCallback* c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCToCppRefCounted<CefGetOriginsCallbackCToCpp,
+                                   CefGetOriginsCallback,
+                                   cef_get_origins_callback_t>::kWrapperType =
+    WT_GET_ORIGINS_CALLBACK;
diff --git a/cef/libcef_dll/ctocpp/get_origins_callback_ctocpp.h b/cef/libcef_dll/ctocpp/get_origins_callback_ctocpp.h
new file mode 100644
index 0000000000000..b2edbb96bfd1d
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/get_origins_callback_ctocpp.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=308fccc205e0e4ac146d6affbe48559dc1a27a5a$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_GET_ORIGINS_CALLBACK_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_GET_ORIGINS_CALLBACK_CTOCPP_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include <vector>
+#include "include/capi/cef_web_storage_capi.h"
+#include "include/cef_web_storage.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed DLL-side only.
+class CefGetOriginsCallbackCToCpp
+    : public CefCToCppRefCounted<CefGetOriginsCallbackCToCpp,
+                                 CefGetOriginsCallback,
+                                 cef_get_origins_callback_t> {
+ public:
+  CefGetOriginsCallbackCToCpp();
+  virtual ~CefGetOriginsCallbackCToCpp();
+
+  // CefGetOriginsCallback methods.
+  void OnOrigins(std::vector<CefString>& origins) override;
+  void OnUsages(std::vector<CefString>& usages) override;
+  void OnQuotas(std::vector<CefString>& quotas) override;
+  void OnComplete() override;
+};
+
+#endif  // CEF_LIBCEF_DLL_CTOCPP_GET_ORIGINS_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc b/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc
index 2840c8e45541d..cd3865ff3a864 100644
--- a/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=c49c659f1eb3f77224ec5a1bb68b2c1b1cd0d955$
+// $hash=99c2bfaa0dfb40df1c6aef46582bebb0350888b5$
 //
 
 #include "libcef_dll/ctocpp/render_handler_ctocpp.h"
@@ -265,6 +265,51 @@ void CefRenderHandlerCToCpp::OnAcceleratedPaint(CefRefPtr<CefBrowser> browser,
     delete[] dirtyRectsList;
 }
 
+NO_SANITIZE("cfi-icall")
+void CefRenderHandlerCToCpp::GetTouchHandleSize(
+    CefRefPtr<CefBrowser> browser,
+    cef_horizontal_alignment_t orientation,
+    CefSize& size) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_render_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_touch_handle_size))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return;
+
+  // Execute
+  _struct->get_touch_handle_size(_struct, CefBrowserCppToC::Wrap(browser),
+                                 orientation, &size);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefRenderHandlerCToCpp::OnTouchHandleStateChanged(
+    CefRefPtr<CefBrowser> browser,
+    const CefTouchHandleState& state) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_render_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_touch_handle_state_changed))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return;
+
+  // Execute
+  _struct->on_touch_handle_state_changed(
+      _struct, CefBrowserCppToC::Wrap(browser), &state);
+}
+
 NO_SANITIZE("cfi-icall")
 bool CefRenderHandlerCToCpp::StartDragging(CefRefPtr<CefBrowser> browser,
                                            CefRefPtr<CefDragData> drag_data,
diff --git a/cef/libcef_dll/ctocpp/render_handler_ctocpp.h b/cef/libcef_dll/ctocpp/render_handler_ctocpp.h
index dfeed9cc6e8ed..f299ceef1a7ac 100644
--- a/cef/libcef_dll/ctocpp/render_handler_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/render_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=be7d8da1b315dfa07566846d90b95848fae0f83b$
+// $hash=03e40f836e421eb3b4074b4c2efed287f4f39401$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_RENDER_HANDLER_CTOCPP_H_
@@ -57,6 +57,11 @@ class CefRenderHandlerCToCpp
                           PaintElementType type,
                           const RectList& dirtyRects,
                           void* shared_handle) override;
+  void GetTouchHandleSize(CefRefPtr<CefBrowser> browser,
+                          cef_horizontal_alignment_t orientation,
+                          CefSize& size) override;
+  void OnTouchHandleStateChanged(CefRefPtr<CefBrowser> browser,
+                                 const CefTouchHandleState& state) override;
   bool StartDragging(CefRefPtr<CefBrowser> browser,
                      CefRefPtr<CefDragData> drag_data,
                      DragOperationsMask allowed_ops,
diff --git a/cef/libcef_dll/ctocpp/request_context_ctocpp.cc b/cef/libcef_dll/ctocpp/request_context_ctocpp.cc
index c1297f2a0590d..ac22cd057ab40 100644
--- a/cef/libcef_dll/ctocpp/request_context_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/request_context_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=856dc903108cc2e295f4ddc67f820d36a1896472$
+// $hash=e3ea60786acfb0510d510f00cc023f57baf00279$
 //
 
 #include "libcef_dll/ctocpp/request_context_ctocpp.h"
@@ -19,10 +19,12 @@
 #include "libcef_dll/cpptoc/resolve_callback_cpptoc.h"
 #include "libcef_dll/cpptoc/scheme_handler_factory_cpptoc.h"
 #include "libcef_dll/ctocpp/cookie_manager_ctocpp.h"
+#include "libcef_dll/ctocpp/data_base_ctocpp.h"
 #include "libcef_dll/ctocpp/dictionary_value_ctocpp.h"
 #include "libcef_dll/ctocpp/extension_ctocpp.h"
 #include "libcef_dll/ctocpp/media_router_ctocpp.h"
 #include "libcef_dll/ctocpp/value_ctocpp.h"
+#include "libcef_dll/ctocpp/web_storage_ctocpp.h"
 #include "libcef_dll/transfer_util.h"
 
 // STATIC METHODS - Body may be edited by hand.
@@ -184,6 +186,40 @@ CefRefPtr<CefCookieManager> CefRequestContextCToCpp::GetCookieManager(
   return CefCookieManagerCToCpp::Wrap(_retval);
 }
 
+NO_SANITIZE("cfi-icall")
+CefRefPtr<CefDataBase> CefRequestContextCToCpp::GetDataBase() {
+  cef_request_context_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_data_base))
+    return nullptr;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  cef_data_base_t* _retval = _struct->get_data_base(_struct);
+
+  // Return type: refptr_same
+  return CefDataBaseCToCpp::Wrap(_retval);
+}
+
+NO_SANITIZE("cfi-icall")
+CefRefPtr<CefWebStorage> CefRequestContextCToCpp::GetWebStorage(
+    CefRefPtr<CefCompletionCallback> callback) {
+  cef_request_context_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_web_storage))
+    return nullptr;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: callback
+
+  // Execute
+  cef_web_storage_t* _retval = _struct->get_web_storage(
+      _struct, CefCompletionCallbackCppToC::Wrap(callback));
+
+  // Return type: refptr_same
+  return CefWebStorageCToCpp::Wrap(_retval);
+}
+
 NO_SANITIZE("cfi-icall")
 bool CefRequestContextCToCpp::RegisterSchemeHandlerFactory(
     const CefString& scheme_name,
diff --git a/cef/libcef_dll/ctocpp/request_context_ctocpp.h b/cef/libcef_dll/ctocpp/request_context_ctocpp.h
index a8abb88cefefd..67d7a7714acde 100644
--- a/cef/libcef_dll/ctocpp/request_context_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/request_context_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=e0837e0c338f59260e5c52a490edfbbb82490e01$
+// $hash=8e0f90454e2018acc3d7297708d9835b1364e9a6$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_REQUEST_CONTEXT_CTOCPP_H_
@@ -47,6 +47,9 @@ class CefRequestContextCToCpp
   CefString GetCachePath() OVERRIDE;
   CefRefPtr<CefCookieManager> GetCookieManager(
       CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
+  CefRefPtr<CefDataBase> GetDataBase() OVERRIDE;
+  CefRefPtr<CefWebStorage> GetWebStorage(
+      CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
   bool RegisterSchemeHandlerFactory(
       const CefString& scheme_name,
       const CefString& domain_name,
diff --git a/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.cc
index dede7b1aaba35..4e82c15bcdfa5 100644
--- a/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=f77743d285768c21bd89b9955d47176ef52f1e1a$
+// $hash=427fe84b74eec6346d7da729cba2fdf52d1c0fd7$
 //
 
 #include "libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h"
@@ -19,7 +19,7 @@
 
 NO_SANITIZE("cfi-icall")
 void CefRunContextMenuCallbackCToCpp::Continue(int command_id,
-                                               EventFlags event_flags) {
+                                               cef_event_flags_t event_flags) {
   shutdown_checker::AssertNotShutdown();
 
   cef_run_context_menu_callback_t* _struct = GetStruct();
diff --git a/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h b/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h
index 58ed604c565d6..9b5cf62bedd4b 100644
--- a/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/run_context_menu_callback_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=837fb72b6eccf8e7048e1ba8017846b261a4c3b2$
+// $hash=2d9ffbbb8db3f996878918c063498d0514e5f811$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_RUN_CONTEXT_MENU_CALLBACK_CTOCPP_H_
@@ -35,7 +35,7 @@ class CefRunContextMenuCallbackCToCpp
   virtual ~CefRunContextMenuCallbackCToCpp();
 
   // CefRunContextMenuCallback methods.
-  void Continue(int command_id, EventFlags event_flags) OVERRIDE;
+  void Continue(int command_id, cef_event_flags_t event_flags) OVERRIDE;
   void Cancel() OVERRIDE;
 };
 
diff --git a/cef/libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.cc
new file mode 100644
index 0000000000000..095624f724b13
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.cc
@@ -0,0 +1,73 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=c0d516016a14eeed0c73bde99e2495ae691c2326$
+//
+
+#include "libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.h"
+#include "libcef_dll/shutdown_checker.h"
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+void CefRunQuickMenuCallbackCToCpp::Continue(int command_id,
+                                             cef_event_flags_t event_flags) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_run_quick_menu_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, cont))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->cont(_struct, command_id, event_flags);
+}
+
+NO_SANITIZE("cfi-icall") void CefRunQuickMenuCallbackCToCpp::Cancel() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_run_quick_menu_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, cancel))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->cancel(_struct);
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefRunQuickMenuCallbackCToCpp::CefRunQuickMenuCallbackCToCpp() {}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefRunQuickMenuCallbackCToCpp::~CefRunQuickMenuCallbackCToCpp() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+cef_run_quick_menu_callback_t* CefCToCppRefCounted<
+    CefRunQuickMenuCallbackCToCpp,
+    CefRunQuickMenuCallback,
+    cef_run_quick_menu_callback_t>::UnwrapDerived(CefWrapperType type,
+                                                  CefRunQuickMenuCallback* c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType
+    CefCToCppRefCounted<CefRunQuickMenuCallbackCToCpp,
+                        CefRunQuickMenuCallback,
+                        cef_run_quick_menu_callback_t>::kWrapperType =
+        WT_RUN_QUICK_MENU_CALLBACK;
diff --git a/cef/libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.h b/cef/libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.h
new file mode 100644
index 0000000000000..d0be62f219511
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/run_quick_menu_callback_ctocpp.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=2e04b91141de4ae6ce610603cca40deac83607bf$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_RUN_QUICK_MENU_CALLBACK_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_RUN_QUICK_MENU_CALLBACK_CTOCPP_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_context_menu_handler_capi.h"
+#include "include/cef_context_menu_handler.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed wrapper-side only.
+class CefRunQuickMenuCallbackCToCpp
+    : public CefCToCppRefCounted<CefRunQuickMenuCallbackCToCpp,
+                                 CefRunQuickMenuCallback,
+                                 cef_run_quick_menu_callback_t> {
+ public:
+  CefRunQuickMenuCallbackCToCpp();
+  virtual ~CefRunQuickMenuCallbackCToCpp();
+
+  // CefRunQuickMenuCallback methods.
+  void Continue(int command_id, cef_event_flags_t event_flags) OVERRIDE;
+  void Cancel() OVERRIDE;
+};
+
+#endif  // CEF_LIBCEF_DLL_CTOCPP_RUN_QUICK_MENU_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/web_storage_ctocpp.cc b/cef/libcef_dll/ctocpp/web_storage_ctocpp.cc
new file mode 100644
index 0000000000000..e7bb033dc83dd
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/web_storage_ctocpp.cc
@@ -0,0 +1,138 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=4b81eb5261e185b3360dd7de90e5f97dcb6aef86$
+//
+
+#include "libcef_dll/ctocpp/web_storage_ctocpp.h"
+#include "libcef_dll/cpptoc/completion_callback_cpptoc.h"
+#include "libcef_dll/cpptoc/get_origin_usage_or_quota_callback_cpptoc.h"
+#include "libcef_dll/cpptoc/get_origins_callback_cpptoc.h"
+
+// STATIC METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+CefRefPtr<CefWebStorage> CefWebStorage::GetGlobalManager(
+    CefRefPtr<CefCompletionCallback> callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: callback
+
+  // Execute
+  cef_web_storage_t* _retval = cef_web_storage_get_global_manager(
+      CefCompletionCallbackCppToC::Wrap(callback));
+
+  // Return type: refptr_same
+  return CefWebStorageCToCpp::Wrap(_retval);
+}
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall") void CefWebStorageCToCpp::DeleteAllData() {
+  cef_web_storage_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, delete_all_data))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->delete_all_data(_struct);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefWebStorageCToCpp::DeleteOrigin(const CefString& origin) {
+  cef_web_storage_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, delete_origin))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: origin; type: string_byref_const
+  DCHECK(!origin.empty());
+  if (origin.empty())
+    return;
+
+  // Execute
+  _struct->delete_origin(_struct, origin.GetStruct());
+}
+
+NO_SANITIZE("cfi-icall")
+void CefWebStorageCToCpp::GetOrigins(
+    CefRefPtr<CefGetOriginsCallback> callback) {
+  cef_web_storage_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_origins))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: callback
+
+  // Execute
+  _struct->get_origins(_struct, CefGetOriginsCallbackCppToC::Wrap(callback));
+}
+
+NO_SANITIZE("cfi-icall")
+void CefWebStorageCToCpp::GetOriginQuota(
+    const CefString& origin,
+    CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) {
+  cef_web_storage_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_origin_quota))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: origin, callback
+
+  // Execute
+  _struct->get_origin_quota(
+      _struct, origin.GetStruct(),
+      CefGetOriginUsageOrQuotaCallbackCppToC::Wrap(callback));
+}
+
+NO_SANITIZE("cfi-icall")
+void CefWebStorageCToCpp::GetOriginUsage(
+    const CefString& origin,
+    CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) {
+  cef_web_storage_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_origin_usage))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: origin, callback
+
+  // Execute
+  _struct->get_origin_usage(
+      _struct, origin.GetStruct(),
+      CefGetOriginUsageOrQuotaCallbackCppToC::Wrap(callback));
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefWebStorageCToCpp::CefWebStorageCToCpp() {}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefWebStorageCToCpp::~CefWebStorageCToCpp() {}
+
+template <>
+cef_web_storage_t*
+CefCToCppRefCounted<CefWebStorageCToCpp, CefWebStorage, cef_web_storage_t>::
+    UnwrapDerived(CefWrapperType type, CefWebStorage* c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType CefCToCppRefCounted<CefWebStorageCToCpp,
+                                   CefWebStorage,
+                                   cef_web_storage_t>::kWrapperType =
+    WT_WEB_STORAGE;
diff --git a/cef/libcef_dll/ctocpp/web_storage_ctocpp.h b/cef/libcef_dll/ctocpp/web_storage_ctocpp.h
new file mode 100644
index 0000000000000..29d75fefa8453
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/web_storage_ctocpp.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=9e2a6ae7224c1b6dd0630c31a98977b6ebaa6d7e$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_WEB_STORAGE_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_WEB_STORAGE_CTOCPP_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_web_storage_capi.h"
+#include "include/cef_web_storage.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed wrapper-side only.
+class CefWebStorageCToCpp : public CefCToCppRefCounted<CefWebStorageCToCpp,
+                                                       CefWebStorage,
+                                                       cef_web_storage_t> {
+ public:
+  CefWebStorageCToCpp();
+  virtual ~CefWebStorageCToCpp();
+
+  // CefWebStorage methods.
+  void DeleteAllData() OVERRIDE;
+  void DeleteOrigin(const CefString& origin) OVERRIDE;
+  void GetOrigins(CefRefPtr<CefGetOriginsCallback> callback) OVERRIDE;
+  void GetOriginQuota(
+      const CefString& origin,
+      CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) OVERRIDE;
+  void GetOriginUsage(
+      const CefString& origin,
+      CefRefPtr<CefGetOriginUsageOrQuotaCallback> callback) OVERRIDE;
+};
+
+#endif  // CEF_LIBCEF_DLL_CTOCPP_WEB_STORAGE_CTOCPP_H_
diff --git a/cef/libcef_dll/wrapper/libcef_dll_dylib.cc b/cef/libcef_dll/wrapper/libcef_dll_dylib.cc
index 1158ab5b75196..e3bef7842ff2f 100644
--- a/cef/libcef_dll/wrapper/libcef_dll_dylib.cc
+++ b/cef/libcef_dll/wrapper/libcef_dll_dylib.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=63f62b21e8d9e400f6e19f11f93ddb3f838e7620$
+// $hash=b5129238c81c9c991368987898827afec6db2e91$
 //
 
 #include <dlfcn.h>
@@ -20,6 +20,7 @@
 #include "include/capi/cef_command_line_capi.h"
 #include "include/capi/cef_cookie_capi.h"
 #include "include/capi/cef_crash_util_capi.h"
+#include "include/capi/cef_data_base_capi.h"
 #include "include/capi/cef_drag_data_capi.h"
 #include "include/capi/cef_file_util_capi.h"
 #include "include/capi/cef_image_capi.h"
@@ -47,6 +48,7 @@
 #include "include/capi/cef_values_capi.h"
 #include "include/capi/cef_waitable_event_capi.h"
 #include "include/capi/cef_web_plugin_capi.h"
+#include "include/capi/cef_web_storage_capi.h"
 #include "include/capi/cef_xml_reader_capi.h"
 #include "include/capi/cef_zip_reader_capi.h"
 #include "include/capi/test/cef_test_helpers_capi.h"
@@ -204,6 +206,7 @@ typedef struct _cef_cookie_manager_t* (
 typedef int (*cef_cookie_manager_create_cef_cookie_ptr)(const cef_string_t*,
                                                         const cef_string_t*,
                                                         struct _cef_cookie_t*);
+typedef struct _cef_data_base_t* (*cef_data_base_get_global_ptr)();
 typedef struct _cef_drag_data_t* (*cef_drag_data_create_ptr)();
 typedef struct _cef_image_t* (*cef_image_create_ptr)();
 typedef struct _cef_media_router_t* (*cef_media_router_get_global_ptr)(
@@ -286,6 +289,8 @@ typedef struct _cef_dictionary_value_t* (*cef_dictionary_value_create_ptr)();
 typedef struct _cef_list_value_t* (*cef_list_value_create_ptr)();
 typedef struct _cef_waitable_event_t* (*cef_waitable_event_create_ptr)(int,
                                                                        int);
+typedef struct _cef_web_storage_t* (*cef_web_storage_get_global_manager_ptr)(
+    struct _cef_completion_callback_t*);
 typedef struct _cef_xml_reader_t* (*cef_xml_reader_create_ptr)(
     struct _cef_stream_reader_t*,
     cef_xml_encoding_type_t,
@@ -582,6 +587,7 @@ struct libcef_pointers {
   cef_cookie_manager_get_global_manager_ptr
       cef_cookie_manager_get_global_manager;
   cef_cookie_manager_create_cef_cookie_ptr cef_cookie_manager_create_cef_cookie;
+  cef_data_base_get_global_ptr cef_data_base_get_global;
   cef_drag_data_create_ptr cef_drag_data_create;
   cef_image_create_ptr cef_image_create;
   cef_media_router_get_global_ptr cef_media_router_get_global;
@@ -629,6 +635,7 @@ struct libcef_pointers {
   cef_dictionary_value_create_ptr cef_dictionary_value_create;
   cef_list_value_create_ptr cef_list_value_create;
   cef_waitable_event_create_ptr cef_waitable_event_create;
+  cef_web_storage_get_global_manager_ptr cef_web_storage_get_global_manager;
   cef_xml_reader_create_ptr cef_xml_reader_create;
   cef_zip_reader_create_ptr cef_zip_reader_create;
   cef_translator_test_create_ptr cef_translator_test_create;
@@ -798,6 +805,7 @@ int libcef_init_pointers(const char* path) {
   INIT_ENTRY(cef_command_line_get_global);
   INIT_ENTRY(cef_cookie_manager_get_global_manager);
   INIT_ENTRY(cef_cookie_manager_create_cef_cookie);
+  INIT_ENTRY(cef_data_base_get_global);
   INIT_ENTRY(cef_drag_data_create);
   INIT_ENTRY(cef_image_create);
   INIT_ENTRY(cef_media_router_get_global);
@@ -843,6 +851,7 @@ int libcef_init_pointers(const char* path) {
   INIT_ENTRY(cef_dictionary_value_create);
   INIT_ENTRY(cef_list_value_create);
   INIT_ENTRY(cef_waitable_event_create);
+  INIT_ENTRY(cef_web_storage_get_global_manager);
   INIT_ENTRY(cef_xml_reader_create);
   INIT_ENTRY(cef_zip_reader_create);
   INIT_ENTRY(cef_translator_test_create);
@@ -1320,6 +1329,10 @@ int cef_cookie_manager_create_cef_cookie(const cef_string_t* url,
                                                                 cef_cookie);
 }
 
+NO_SANITIZE("cfi-icall") struct _cef_data_base_t* cef_data_base_get_global() {
+  return g_libcef_pointers.cef_data_base_get_global();
+}
+
 NO_SANITIZE("cfi-icall") struct _cef_drag_data_t* cef_drag_data_create() {
   return g_libcef_pointers.cef_drag_data_create();
 }
@@ -1574,6 +1587,12 @@ struct _cef_waitable_event_t* cef_waitable_event_create(
                                                      initially_signaled);
 }
 
+NO_SANITIZE("cfi-icall")
+struct _cef_web_storage_t* cef_web_storage_get_global_manager(
+    struct _cef_completion_callback_t* callback) {
+  return g_libcef_pointers.cef_web_storage_get_global_manager(callback);
+}
+
 NO_SANITIZE("cfi-icall")
 struct _cef_xml_reader_t* cef_xml_reader_create(
     struct _cef_stream_reader_t* stream,
diff --git a/cef/libcef_dll/wrapper_types.h b/cef/libcef_dll/wrapper_types.h
index eb0eb8371ef00..de44445587d2f 100644
--- a/cef/libcef_dll/wrapper_types.h
+++ b/cef/libcef_dll/wrapper_types.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=9ed6ec0a8c3e23163d32a47dc35933b6602d8470$
+// $hash=a1f17c16c7766c3e7268dd8878005cc144f58829$
 //
 
 #ifndef CEF_LIBCEF_DLL_WRAPPER_TYPES_H_
@@ -47,6 +47,7 @@ enum CefWrapperType {
   WT_DOMDOCUMENT,
   WT_DOMNODE,
   WT_DOMVISITOR,
+  WT_DATA_BASE,
   WT_DELETE_COOKIES_CALLBACK,
   WT_DEV_TOOLS_MESSAGE_OBSERVER,
   WT_DIALOG_HANDLER,
@@ -69,6 +70,8 @@ enum CefWrapperType {
   WT_FRAME,
   WT_GEOLOCATION_ACESS,
   WT_GET_EXTENSION_RESOURCE_CALLBACK,
+  WT_GET_ORIGIN_USAGE_OR_QUOTA_CALLBACK,
+  WT_GET_ORIGINS_CALLBACK,
   WT_IMAGE,
   WT_JSDIALOG_CALLBACK,
   WT_JSDIALOG_HANDLER,
@@ -125,6 +128,7 @@ enum CefWrapperType {
   WT_RESPONSE_FILTER,
   WT_RUN_CONTEXT_MENU_CALLBACK,
   WT_RUN_FILE_DIALOG_CALLBACK,
+  WT_RUN_QUICK_MENU_CALLBACK,
   WT_SSLINFO,
   WT_SSLSTATUS,
   WT_SCHEME_HANDLER_FACTORY,
@@ -171,6 +175,7 @@ enum CefWrapperType {
   WT_WEB_PLUGIN_INFO,
   WT_WEB_PLUGIN_INFO_VISITOR,
   WT_WEB_PLUGIN_UNSTABLE_CALLBACK,
+  WT_WEB_STORAGE,
   WT_WINDOW,
   WT_WINDOW_DELEGATE,
   WT_WRITE_HANDLER,
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index 37117db7fcf12..21440d4f9495c 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -792,6 +792,7 @@ static_library("extensions") {
     "//chrome/browser/safe_browsing",
     "//chrome/browser/web_applications",
     "//chrome/browser/web_applications/components",
+    "//components/security_interstitials/content:security_interstitial_page",
     "//components/site_engagement/core/mojom:mojo_bindings",
     "//components/webapps/browser",
 
diff --git a/chrome/browser/extensions/api/debugger/debugger_api.cc b/chrome/browser/extensions/api/debugger/debugger_api.cc
index 429f16cc38f9c..56e2a22db5ec6 100644
--- a/chrome/browser/extensions/api/debugger/debugger_api.cc
+++ b/chrome/browser/extensions/api/debugger/debugger_api.cc
@@ -37,6 +37,7 @@
 #include "chrome/browser/ui/webui/chrome_web_ui_controller_factory.h"
 #include "chrome/common/chrome_switches.h"
 #include "content/public/browser/browser_task_traits.h"
+#include "components/security_interstitials/content/security_interstitial_tab_helper.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/devtools_agent_host.h"
 #include "content/public/browser/notification_service.h"
@@ -125,6 +126,14 @@ bool ExtensionMayAttachToWebContents(const Extension& extension,
                                      WebContents& web_contents,
                                      Profile* profile,
                                      std::string* error) {
+  security_interstitials::SecurityInterstitialTabHelper*
+      security_interstitial_tab_helper = security_interstitials::
+          SecurityInterstitialTabHelper::FromWebContents(&web_contents);
+  if (security_interstitial_tab_helper &&
+      security_interstitial_tab_helper->IsDisplayingInterstitial()) {
+    *error = debugger_api_constants::kRestrictedError;
+    return false;
+  }
   // This is *not* redundant to the checks below, as
   // web_contents.GetLastCommittedURL() may be different from
   // web_contents.GetMainFrame()->GetLastCommittedURL(), with the
diff --git a/chrome/browser/extensions/api/debugger/debugger_apitest.cc b/chrome/browser/extensions/api/debugger/debugger_apitest.cc
index 44bcd6b136d20..51a2156d26ed8 100644
--- a/chrome/browser/extensions/api/debugger/debugger_apitest.cc
+++ b/chrome/browser/extensions/api/debugger/debugger_apitest.cc
@@ -24,9 +24,15 @@
 #include "chrome/test/base/ui_test_utils.h"
 #include "components/infobars/core/infobar.h"
 #include "components/infobars/core/infobar_delegate.h"
+#include "components/security_interstitials/content/security_interstitial_controller_client.h"
+#include "components/security_interstitials/content/security_interstitial_page.h"
+#include "components/security_interstitials/content/security_interstitial_tab_helper.h"
+#include "components/security_interstitials/content/settings_page_helper.h"
+#include "components/security_interstitials/core/metrics_helper.h"
 #include "components/sessions/content/session_tab_helper.h"
 #include "content/public/test/browser_test.h"
 #include "content/public/test/browser_test_utils.h"
+#include "content/public/test/mock_navigation_handle.h"
 #include "extensions/browser/extension_function.h"
 #include "extensions/common/extension.h"
 #include "extensions/common/extension_builder.h"
@@ -50,6 +56,9 @@ class DebuggerApiTest : public ExtensionApiTest {
   // to succeed.
   testing::AssertionResult RunAttachFunction(const GURL& url,
                                              const std::string& expected_error);
+  testing::AssertionResult RunAttachFunction(
+      const content::WebContents* web_contents,
+      const std::string& expected_error);
 
   const Extension* extension() const { return extension_.get(); }
   base::CommandLine* command_line() const { return command_line_; }
@@ -97,9 +106,13 @@ void DebuggerApiTest::SetUpOnMainThread() {
 testing::AssertionResult DebuggerApiTest::RunAttachFunction(
     const GURL& url, const std::string& expected_error) {
   ui_test_utils::NavigateToURL(browser(), url);
-  content::WebContents* web_contents =
-      browser()->tab_strip_model()->GetActiveWebContents();
+  return RunAttachFunction(browser()->tab_strip_model()->GetActiveWebContents(),
+                           expected_error);
+}
 
+testing::AssertionResult DebuggerApiTest::RunAttachFunction(
+    const content::WebContents* web_contents,
+    const std::string& expected_error) {
   // Attach by tabId.
   int tab_id = sessions::SessionTabHelper::IdForTab(web_contents).id();
   std::string debugee_by_tab = base::StringPrintf("{\"tabId\": %d}", tab_id);
@@ -209,6 +222,59 @@ IN_PROC_BROWSER_TEST_F(DebuggerApiTest,
   EXPECT_TRUE(RunExtensionTest("debugger_file_access")) << message_;
 }
 
+class TestInterstitialPage
+    : public security_interstitials::SecurityInterstitialPage {
+ public:
+  TestInterstitialPage(content::WebContents* web_contents,
+                       const GURL& request_url)
+      : SecurityInterstitialPage(
+            web_contents,
+            request_url,
+            std::make_unique<
+                security_interstitials::SecurityInterstitialControllerClient>(
+                web_contents,
+                CreateTestMetricsHelper(web_contents),
+                nullptr,
+                base::i18n::GetConfiguredLocale(),
+                GURL(),
+                /* settings_page_helper*/ nullptr)) {}
+
+  ~TestInterstitialPage() override = default;
+  void OnInterstitialClosing() override {}
+
+ protected:
+  void PopulateInterstitialStrings(base::Value* load_time_data) override {}
+
+  std::unique_ptr<security_interstitials::MetricsHelper>
+  CreateTestMetricsHelper(content::WebContents* web_contents) {
+    security_interstitials::MetricsHelper::ReportDetails report_details;
+    report_details.metric_prefix = "test_blocking_page";
+    return std::make_unique<security_interstitials::MetricsHelper>(
+        GURL(), report_details, nullptr);
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(DebuggerApiTest,
+                       DebuggerNotAllowedOnSecirutyInterstitials) {
+  content::WebContents* web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  std::unique_ptr<content::MockNavigationHandle> navigation_handle =
+      std::make_unique<content::MockNavigationHandle>(
+          GURL("https://google.com/"), web_contents->GetMainFrame());
+  navigation_handle->set_has_committed(true);
+  navigation_handle->set_is_same_document(false);
+  EXPECT_TRUE(RunAttachFunction(web_contents, ""));
+
+  security_interstitials::SecurityInterstitialTabHelper::AssociateBlockingPage(
+      navigation_handle.get(),
+      std::make_unique<TestInterstitialPage>(web_contents, GURL()));
+  security_interstitials::SecurityInterstitialTabHelper::FromWebContents(
+      web_contents)
+      ->DidFinishNavigation(navigation_handle.get());
+
+  EXPECT_TRUE(RunAttachFunction(web_contents, "Cannot attach to this target."));
+}
+
 IN_PROC_BROWSER_TEST_F(DebuggerApiTest, InfoBar) {
   int tab_id = sessions::SessionTabHelper::IdForTab(
                    browser()->tab_strip_model()->GetActiveWebContents())
diff --git a/chrome/browser/ui/toolbar/media_router_action_controller.cc b/chrome/browser/ui/toolbar/media_router_action_controller.cc
index 9c506973a92aa..b3a1b91dc90bd 100644
--- a/chrome/browser/ui/toolbar/media_router_action_controller.cc
+++ b/chrome/browser/ui/toolbar/media_router_action_controller.cc
@@ -21,9 +21,7 @@ MediaRouterActionController::MediaRouterActionController(Profile* profile)
           profile,
           media_router::MediaRouterFactory::GetApiForBrowserContext(profile)) {}
 
-MediaRouterActionController::~MediaRouterActionController() {
-  DCHECK_EQ(dialog_count_, 0u);
-}
+MediaRouterActionController::~MediaRouterActionController() = default;
 
 // static
 bool MediaRouterActionController::IsActionShownByPolicy(Profile* profile) {
diff --git a/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.cc b/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.cc
index b64eaf262f901..cc8556fd6a778 100644
--- a/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.cc
+++ b/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.cc
@@ -124,14 +124,15 @@ bool MediaRouterDialogControllerViews::IsShowingMediaRouterDialog() const {
 void MediaRouterDialogControllerViews::Reset() {
   // If |ui_| is null, Reset() has already been called.
   if (ui_) {
-    if (IsShowingMediaRouterDialog() && GetActionController())
+    if (GetActionController())
       GetActionController()->OnDialogHidden();
     ui_.reset();
     MediaRouterDialogController::Reset();
   }
 }
 
-void MediaRouterDialogControllerViews::OnWidgetClosing(views::Widget* widget) {
+void MediaRouterDialogControllerViews::OnWidgetDestroying(
+    views::Widget* widget) {
   DCHECK(scoped_widget_observations_.IsObservingSource(widget));
   if (ui_)
     ui_->LogMediaSinkStatus();
diff --git a/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.h b/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.h
index 40f19f2894428..bf438f4833502 100644
--- a/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.h
+++ b/chrome/browser/ui/views/media_router/media_router_dialog_controller_views.h
@@ -40,7 +40,7 @@ class MediaRouterDialogControllerViews
   void Reset() override;
 
   // views::WidgetObserver:
-  void OnWidgetClosing(views::Widget* widget) override;
+  void OnWidgetDestroying(views::Widget* widget) override;
 
   // Sets a callback to be called whenever a dialog is created.
   void SetDialogCreationCallbackForTesting(base::RepeatingClosure callback);
diff --git a/chrome/browser/ui/views/media_router/media_router_dialog_controller_views_browsertest.cc b/chrome/browser/ui/views/media_router/media_router_dialog_controller_views_browsertest.cc
index a8fee9a09696d..b20537794e64c 100644
--- a/chrome/browser/ui/views/media_router/media_router_dialog_controller_views_browsertest.cc
+++ b/chrome/browser/ui/views/media_router/media_router_dialog_controller_views_browsertest.cc
@@ -7,6 +7,7 @@
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/views/global_media_controls/media_dialog_view.h"
 #include "chrome/browser/ui/views/media_router/cast_dialog_view.h"
 #include "chrome/browser/ui/views/media_router/media_router_dialog_controller_views.h"
 #include "chrome/test/base/in_process_browser_test.h"
@@ -14,6 +15,8 @@
 #include "content/public/test/browser_test.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/page_transition_types.h"
+#include "ui/views/test/widget_test.h"
+#include "ui/views/widget/native_widget_private.h"
 #include "ui/views/widget/widget.h"
 
 using content::WebContents;
@@ -26,6 +29,7 @@ class MediaRouterDialogControllerViewsTest : public InProcessBrowserTest {
   ~MediaRouterDialogControllerViewsTest() override = default;
 
   void OpenMediaRouterDialog();
+  void CloseWebContents();
 
  protected:
   WebContents* initiator_;
@@ -51,6 +55,10 @@ void MediaRouterDialogControllerViewsTest::OpenMediaRouterDialog() {
   ASSERT_TRUE(dialog_controller_->IsShowingMediaRouterDialog());
 }
 
+void MediaRouterDialogControllerViewsTest::CloseWebContents() {
+  initiator_->Close();
+}
+
 // Create/Get a media router dialog for initiator.
 IN_PROC_BROWSER_TEST_F(MediaRouterDialogControllerViewsTest,
                        OpenCloseMediaRouterDialog) {
@@ -63,4 +71,22 @@ IN_PROC_BROWSER_TEST_F(MediaRouterDialogControllerViewsTest,
   EXPECT_EQ(CastDialogView::GetCurrentDialogWidget(), nullptr);
 }
 
+// Regression test for crbug.com/1308341.
+IN_PROC_BROWSER_TEST_F(MediaRouterDialogControllerViewsTest,
+                       MediaBubbleClosedByPlatform) {
+  OpenMediaRouterDialog();
+  base::RunLoop().RunUntilIdle();
+  views::Widget* widget = CastDialogView::GetCurrentDialogWidget();
+  ASSERT_TRUE(widget);
+  EXPECT_TRUE(widget->HasObserver(dialog_controller_));
+  // The media bubble usually will close itself on deactivation, but
+  // crbug.com/1308341 shows a state where the browser is not responsive
+  // to activation change. Simulate that.
+  CastDialogView::GetInstance()->set_close_on_deactivate(false);
+  views::test::WidgetDestroyedWaiter waiter(widget);
+  widget->native_widget_private()->Close();
+  waiter.Wait();
+  CloseWebContents();
+}
+
 }  // namespace media_router
diff --git a/chrome/browser/ui/views/media_router/media_router_ui_browsertest.cc b/chrome/browser/ui/views/media_router/media_router_ui_browsertest.cc
index 190cbc6ec350d..ef254708fb390 100644
--- a/chrome/browser/ui/views/media_router/media_router_ui_browsertest.cc
+++ b/chrome/browser/ui/views/media_router/media_router_ui_browsertest.cc
@@ -18,6 +18,7 @@
 #include "chrome/browser/ui/toolbar/media_router_action_controller.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/media_router/app_menu_test_api.h"
+#include "chrome/browser/ui/views/media_router/cast_dialog_view.h"
 #include "chrome/browser/ui/views/media_router/cast_toolbar_button.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_view.h"
 #include "chrome/common/url_constants.h"
@@ -33,6 +34,7 @@
 #include "content/public/test/test_utils.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/events/base_event_utils.h"
+#include "ui/views/test/widget_test.h"
 #include "ui/views/widget/widget.h"
 
 namespace media_router {
@@ -116,7 +118,10 @@ IN_PROC_BROWSER_TEST_F(MediaRouterUIBrowserTest, OpenDialogFromContextMenu) {
   menu.ExecuteCommand(IDC_ROUTE_MEDIA, 0);
   EXPECT_TRUE(dialog_controller->IsShowingMediaRouterDialog());
 
+  views::test::WidgetDestroyedWaiter waiter(
+      CastDialogView::GetCurrentDialogWidget());
   dialog_controller->HideMediaRouterDialog();
+  waiter.Wait();
   EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
 }
 
@@ -133,8 +138,11 @@ IN_PROC_BROWSER_TEST_F(MediaRouterUIBrowserTest, OpenDialogFromAppMenu) {
   app_menu_test_api->ExecuteCommand(IDC_ROUTE_MEDIA);
   EXPECT_TRUE(dialog_controller->IsShowingMediaRouterDialog());
 
+  views::test::WidgetDestroyedWaiter waiter(
+      CastDialogView::GetCurrentDialogWidget());
   dialog_controller->HideMediaRouterDialog();
   EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
+  waiter.Wait();
 }
 
 // TODO(crbug.com/1004635) Disabled due to flake on Windows and Linux
@@ -156,8 +164,12 @@ IN_PROC_BROWSER_TEST_F(MediaRouterUIBrowserTest,
 
   dialog_controller->ShowMediaRouterDialog(MediaRouterDialogOpenOrigin::PAGE);
   EXPECT_TRUE(ToolbarIconExists());
+
+  views::test::WidgetDestroyedWaiter waiter(
+      CastDialogView::GetCurrentDialogWidget());
   // Clicking on the toolbar icon should hide both the dialog and the icon.
   PressToolbarIcon();
+  waiter.Wait();
   EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
   EXPECT_FALSE(ToolbarIconExists());
 
@@ -254,21 +266,32 @@ IN_PROC_BROWSER_TEST_F(MediaRouterUIBrowserTest,
   EXPECT_TRUE(dialog_controller->IsShowingMediaRouterDialog());
 
   // Reload the browser and wait.
-  content::TestNavigationObserver reload_observer(
-      browser()->tab_strip_model()->GetActiveWebContents());
-  chrome::Reload(browser(), WindowOpenDisposition::CURRENT_TAB);
-  reload_observer.Wait();
+   {
+    views::test::WidgetDestroyedWaiter waiter(
+        CastDialogView::GetCurrentDialogWidget());
+    content::TestNavigationObserver reload_observer(
+        browser()->tab_strip_model()->GetActiveWebContents());
+    chrome::Reload(browser(), WindowOpenDisposition::CURRENT_TAB);
+    reload_observer.Wait();
+
+    waiter.Wait();
+    // The reload should have closed the dialog.
+    EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
+  }
 
-  // The reload should have closed the dialog.
-  EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
   PressToolbarIcon();
   EXPECT_TRUE(dialog_controller->IsShowingMediaRouterDialog());
 
-  // Navigate away.
-  ui_test_utils::NavigateToURL(browser(), GURL("about:blank"));
+   {
+    views::test::WidgetDestroyedWaiter waiter(
+        CastDialogView::GetCurrentDialogWidget());
+    // Navigate away.
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GURL("about:blank")));
 
-  // The navigation should have closed the dialog.
-  EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
+    // The navigation should have closed the dialog.
+    waiter.Wait();
+    EXPECT_FALSE(dialog_controller->IsShowingMediaRouterDialog());
+  }
   SetAlwaysShowActionPref(false);
 }
 
diff --git a/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_browsertest.cc b/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_browsertest.cc
index 9cfdcd25f64fd..8a336cd03fbbe 100644
--- a/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_browsertest.cc
+++ b/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_browsertest.cc
@@ -23,10 +23,13 @@
 #include "chrome/browser/web_applications/components/web_application_info.h"
 #include "chrome/browser/web_applications/test/web_app_icon_test_utils.h"
 #include "chrome/test/base/in_process_browser_test.h"
+#include "components/keep_alive_registry/keep_alive_types.h"
+#include "components/keep_alive_registry/scoped_keep_alive.h"
 #include "content/public/test/browser_test.h"
 #include "content/public/test/browser_test_utils.h"
 #include "content/public/test/test_utils.h"
 #include "extensions/browser/extension_dialog_auto_confirm.h"
+#include "ui/gfx/native_widget_types.h"
 
 using web_app::AppId;
 
@@ -134,6 +137,47 @@ IN_PROC_BROWSER_TEST_F(WebAppUninstallDialogViewBrowserTest,
   EXPECT_TRUE(was_uninstalled);
 }
 
+#if BUILDFLAG(IS_MAC)
+// https://crbug.com/1224161
+#define MAYBE_UninstallOnCancelShutdownBrowser \
+  DISABLED_UninstallOnCancelShutdownBrowser
+#else
+#define MAYBE_UninstallOnCancelShutdownBrowser UninstallOnCancelShutdownBrowser
+#endif
+IN_PROC_BROWSER_TEST_F(WebAppUninstallDialogViewBrowserTest,
+                       MAYBE_UninstallOnCancelShutdownBrowser) {
+  extensions::ScopedTestDialogAutoConfirm auto_confirm(
+      extensions::ScopedTestDialogAutoConfirm::CANCEL);
+  AppId app_id = InstallTestWebApp(browser()->profile());
+
+  std::unique_ptr<web_app::WebAppUninstallDialog> dialog(
+      web_app::WebAppUninstallDialog::Create(browser()->profile(),
+                                             gfx::kNullNativeWindow));
+
+  base::RunLoop().RunUntilIdle();
+
+  base::RunLoop run_loop;
+  bool was_uninstalled = true;
+  // ScopedKeepAlive is used by `UninstallWebAppWithDialogFromStartupSwitch`.
+  // ScopedKeepAlive's destruction triggers browser shutdown when there is no
+  // open window. This verifies the destruction doesn't race with the dialog
+  // shutdown itself.
+  std::unique_ptr<ScopedKeepAlive> scoped_keep_alive =
+      std::make_unique<ScopedKeepAlive>(KeepAliveOrigin::WEB_APP_UNINSTALL,
+                                        KeepAliveRestartOption::DISABLED);
+
+  chrome::CloseWindow(browser());
+
+  dialog->ConfirmUninstall(app_id, webapps::WebappUninstallSource::kAppMenu,
+                           base::BindLambdaForTesting([&](bool uninstalled) {
+                             was_uninstalled = uninstalled;
+                             scoped_keep_alive.reset();
+                             run_loop.Quit();
+                           }));
+  run_loop.Run();
+  EXPECT_FALSE(was_uninstalled);
+}
+
 IN_PROC_BROWSER_TEST_F(WebAppUninstallDialogViewBrowserTest,
                        TestDialogUserFlow_Cancel) {
   extensions::ScopedTestDialogAutoConfirm auto_confirm(
diff --git a/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_view.cc b/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_view.cc
index 67ef38f9478ea..3cd064cdab731 100644
--- a/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_view.cc
+++ b/chrome/browser/ui/views/web_apps/web_app_uninstall_dialog_view.cc
@@ -141,9 +141,7 @@ void WebAppUninstallDialogDelegateView::OnDialogAccepted() {
 void WebAppUninstallDialogDelegateView::OnDialogCanceled() {
   UMA_HISTOGRAM_ENUMERATION("Webapp.UninstallDialogAction",
                             HistogramCloseAction::kCancelled);
-
-  if (dialog_)
-    std::exchange(dialog_, nullptr)->UninstallCancelled();
+  // `dialog_->UninstallCancelled()` is handled in the destructor.
 }
 
 gfx::ImageSkia WebAppUninstallDialogDelegateView::GetWindowIcon() {
diff --git a/chromecast/graphics/accessibility/fullscreen_magnification_controller.cc b/chromecast/graphics/accessibility/fullscreen_magnification_controller.cc
index 1412290bed774..baed03da3b8f3 100644
--- a/chromecast/graphics/accessibility/fullscreen_magnification_controller.cc
+++ b/chromecast/graphics/accessibility/fullscreen_magnification_controller.cc
@@ -101,7 +101,10 @@ FullscreenMagnificationController::FullscreenMagnificationController(
       this, gesture_provider_client_.get());
 }
 
-FullscreenMagnificationController::~FullscreenMagnificationController() {}
+FullscreenMagnificationController::~FullscreenMagnificationController() {
+  // Destroy `gesture_provider_` before `gesture_provider_client_`.
+  gesture_provider_.reset();
+}
 
 void FullscreenMagnificationController::SetEnabled(bool enabled) {
   if (is_enabled_ == enabled)
diff --git a/components/safe_browsing/core/resources/download_file_types.asciipb b/components/safe_browsing/core/resources/download_file_types.asciipb
index 114499d5e44b3..1074b7d091ae7 100644
--- a/components/safe_browsing/core/resources/download_file_types.asciipb
+++ b/components/safe_browsing/core/resources/download_file_types.asciipb
@@ -8,7 +8,7 @@
 ##
 ## Top level settings
 ##
-version_id: 43
+version_id: 50
 sampled_ping_probability: 0.01
 max_archived_binaries_to_report: 10
 default_file_type {
@@ -1743,7 +1743,16 @@ file_types {
     auto_open_hint: DISALLOW_AUTO_OPEN
   }
 }
-
+file_types {
+  extension: "inetloc"
+  uma_value: 397
+  ping_setting: FULL_PING
+  platform_settings {
+    platform: PLATFORM_MAC
+    danger_level: DANGEROUS
+    auto_open_hint: DISALLOW_AUTO_OPEN
+  }
+}
 # VBScript files. May open with Windows Script Host and execute with
 # user privileges.
 file_types {
diff --git a/content/browser/devtools/protocol/devtools_protocol_browsertest.cc b/content/browser/devtools/protocol/devtools_protocol_browsertest.cc
index dfeab9ee4c130..613ae49aed478 100644
--- a/content/browser/devtools/protocol/devtools_protocol_browsertest.cc
+++ b/content/browser/devtools/protocol/devtools_protocol_browsertest.cc
@@ -472,7 +472,8 @@ class CaptureScreenshotTest : public DevToolsProtocolTest {
       bool from_surface,
       const gfx::RectF& clip = gfx::RectF(),
       float clip_scale = 0,
-      bool capture_beyond_viewport = false) {
+      bool capture_beyond_viewport = false,
+      bool expect_error = false) {
     std::unique_ptr<base::DictionaryValue> params(new base::DictionaryValue());
     params->SetString("format", encoding == ENCODING_PNG ? "png" : "jpeg");
     params->SetInteger("quality", 100);
@@ -492,16 +493,24 @@ class CaptureScreenshotTest : public DevToolsProtocolTest {
     }
     SendCommand("Page.captureScreenshot", std::move(params));
 
-    std::string base64;
-    EXPECT_TRUE(result_->GetString("data", &base64));
     std::unique_ptr<SkBitmap> result_bitmap;
-    if (encoding == ENCODING_PNG) {
-      result_bitmap.reset(new SkBitmap());
-      EXPECT_TRUE(DecodePNG(base64, result_bitmap.get()));
+    if (expect_error) {
+      EXPECT_THAT(error_, base::test::DictionaryHasValue(
+                              "code", base::Value(static_cast<int>(
+                                          crdtp::DispatchCode::SERVER_ERROR))));
     } else {
-      result_bitmap = DecodeJPEG(base64);
+      std::string base64;
+      EXPECT_TRUE(result_->GetString("data", &base64));
+      if (encoding == ScreenshotEncoding::ENCODING_PNG) {
+        result_bitmap = std::make_unique<SkBitmap>();
+        EXPECT_TRUE(DecodePNG(base64, result_bitmap.get()));
+      } else if (encoding == ScreenshotEncoding::ENCODING_JPEG) {
+        result_bitmap = DecodeJPEG(base64);
+      } else {
+        // Decode not implemented.
+      }
+      EXPECT_TRUE(result_bitmap);
     }
-    EXPECT_TRUE(result_bitmap);
     return result_bitmap;
   }
 
@@ -600,6 +609,10 @@ class CaptureScreenshotTest : public DevToolsProtocolTest {
     SendCommand("Emulation.clearDeviceMetricsOverride", nullptr);
   }
 
+  bool MayAttachToBrowser() override { return may_attach_to_browser_; }
+
+  bool may_attach_to_browser_ = true;
+
  private:
 #if !defined(OS_ANDROID)
   void SetUp() override {
@@ -948,6 +961,17 @@ IN_PROC_BROWSER_TEST_F(CaptureScreenshotTest, TransparentScreenshots) {
 #endif  // !defined(OS_ANDROID)
 }
 
+IN_PROC_BROWSER_TEST_F(CaptureScreenshotTest,
+                       OnlyScreenshotsFromSurfaceWhenUnsafeNotAllowed) {
+  may_attach_to_browser_ = false;
+  shell()->LoadURL(GURL("about:blank"));
+  EXPECT_TRUE(WaitForLoadStop(shell()->web_contents()));
+  Attach();
+
+  CaptureScreenshot(ScreenshotEncoding::ENCODING_PNG, false, gfx::RectF(), 0, true,
+                    true);
+}
+
 #if defined(OS_ANDROID)
 // Disabled, see http://crbug.com/469947.
 IN_PROC_BROWSER_TEST_F(DevToolsProtocolTest, DISABLED_SynthesizePinchGesture) {
diff --git a/content/browser/devtools/protocol/page_handler.cc b/content/browser/devtools/protocol/page_handler.cc
index 554b129494cab..7b7719648da4b 100644
--- a/content/browser/devtools/protocol/page_handler.cc
+++ b/content/browser/devtools/protocol/page_handler.cc
@@ -184,7 +184,8 @@ bool CanExecuteGlobalCommands(
 
 PageHandler::PageHandler(EmulationHandler* emulation_handler,
                          BrowserHandler* browser_handler,
-                         bool allow_file_access)
+                         bool allow_file_access,
+                         bool may_capture_screenshots_not_from_surface)
     : DevToolsDomainHandler(Page::Metainfo::domainName),
       enabled_(false),
       screencast_enabled_(false),
@@ -200,7 +201,9 @@ PageHandler::PageHandler(EmulationHandler* emulation_handler,
       last_surface_size_(gfx::Size()),
       host_(nullptr),
       emulation_handler_(emulation_handler),
-      browser_handler_(browser_handler) {
+      browser_handler_(browser_handler),
+      may_capture_screenshots_not_from_surface_(
+          may_capture_screenshots_not_from_surface) {
   bool create_video_consumer = true;
 #ifdef OS_ANDROID
   // Video capture doesn't work on Android WebView. Use CopyFromSurface instead.
@@ -715,6 +718,11 @@ void PageHandler::CaptureScreenshot(
 
   // We don't support clip/emulation when capturing from window, bail out.
   if (!from_surface.fromMaybe(true)) {
+    if (!may_capture_screenshots_not_from_surface_) {
+      callback->sendFailure(
+          Response::ServerError("Only screenshots from surface are allowed."));
+      return;
+    }
     widget_host->GetSnapshotFromBrowser(
         base::BindOnce(&PageHandler::ScreenshotCaptured,
                        weak_factory_.GetWeakPtr(), std::move(callback),
diff --git a/content/browser/devtools/protocol/page_handler.h b/content/browser/devtools/protocol/page_handler.h
index be667cb7da784..e5507b97181b2 100644
--- a/content/browser/devtools/protocol/page_handler.h
+++ b/content/browser/devtools/protocol/page_handler.h
@@ -65,7 +65,8 @@ class PageHandler : public DevToolsDomainHandler,
  public:
   PageHandler(EmulationHandler* emulation_handler,
               BrowserHandler* browser_handler,
-              bool allow_file_access);
+              bool allow_file_access,
+              bool may_capture_screenshots_not_from_surface);
   ~PageHandler() override;
 
   static std::vector<PageHandler*> EnabledForWebContents(
@@ -238,6 +239,7 @@ class PageHandler : public DevToolsDomainHandler,
   RenderFrameHostImpl* host_;
   EmulationHandler* emulation_handler_;
   BrowserHandler* browser_handler_;
+  const bool may_capture_screenshots_not_from_surface_;
 
   std::unique_ptr<Page::Frontend> frontend_;
 
diff --git a/content/browser/devtools/render_frame_devtools_agent_host.cc b/content/browser/devtools/render_frame_devtools_agent_host.cc
index 2bbe13752c446..7dc7937b90801 100644
--- a/content/browser/devtools/render_frame_devtools_agent_host.cc
+++ b/content/browser/devtools/render_frame_devtools_agent_host.cc
@@ -331,7 +331,8 @@ bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session,
       GetId(), GetRendererChannel(), session->GetRootSession()));
   session->AddHandler(std::make_unique<protocol::PageHandler>(
       emulation_handler_ptr, browser_handler_ptr,
-      session->GetClient()->MayReadLocalFiles()));
+      session->GetClient()->MayReadLocalFiles(),
+      session->GetClient()->MayAttachToBrowser()));
   session->AddHandler(std::make_unique<protocol::SecurityHandler>());
   if (!frame_tree_node_ || !frame_tree_node_->parent()) {
     session->AddHandler(std::make_unique<protocol::TracingHandler>(
diff --git a/content/browser/file_system_access/file_system_access_directory_handle_impl.cc b/content/browser/file_system_access/file_system_access_directory_handle_impl.cc
index b386fe1dca1b7..19abb01eb5489 100644
--- a/content/browser/file_system_access/file_system_access_directory_handle_impl.cc
+++ b/content/browser/file_system_access/file_system_access_directory_handle_impl.cc
@@ -409,10 +409,13 @@ namespace {
 bool IsShellIntegratedExtension(const base::FilePath::StringType& extension) {
   base::FilePath::StringType extension_lower = base::ToLowerASCII(extension);
 
-  // .lnk files may be used to execute arbitrary code (see
-  // https://nvd.nist.gov/vuln/detail/CVE-2010-2568).
-  if (extension_lower == FILE_PATH_LITERAL("lnk"))
+  // .lnk and .scf files may be used to execute arbitrary code (see
+  // https://nvd.nist.gov/vuln/detail/CVE-2010-2568 and
+  // https://crbug.com/1227995, respectively).
+  if (extension_lower == FILE_PATH_LITERAL("lnk") ||
+      extension_lower == FILE_PATH_LITERAL("scf")) {
     return true;
+  }
 
   // Setting a file's extension to a CLSID may conceal its actual file type on
   // some Windows versions (see https://nvd.nist.gov/vuln/detail/CVE-2004-0420).
diff --git a/content/browser/file_system_access/file_system_access_manager_impl.cc b/content/browser/file_system_access/file_system_access_manager_impl.cc
index a47eceba374b2..a64d8f47cbeb7 100644
--- a/content/browser/file_system_access/file_system_access_manager_impl.cc
+++ b/content/browser/file_system_access/file_system_access_manager_impl.cc
@@ -480,6 +480,16 @@ void FileSystemAccessManagerImpl::SetDefaultPathAndShowPicker(
                                   suggested_name, std::string(), std::string())
           : base::FilePath();
 
+  auto suggested_extension = suggested_name_path.Extension();
+  // Our version of `IsShellIntegratedExtension()` is more stringent than
+  // the version used in `net::GenerateFileName()`. See
+  // `FileSystemChooser::IsShellIntegratedExtension()` for details.
+  if (FileSystemChooser::IsShellIntegratedExtension(suggested_extension)) {
+    suggested_extension = FILE_PATH_LITERAL("download");
+    suggested_name_path =
+        suggested_name_path.ReplaceExtension(suggested_extension);
+  }
+
   FileSystemChooser::Options file_system_chooser_options(
       GetSelectFileDialogType(options), GetAndMoveAcceptsTypesInfo(options),
       std::move(default_directory), std::move(suggested_name_path));
diff --git a/content/browser/file_system_access/file_system_chooser.cc b/content/browser/file_system_access/file_system_chooser.cc
index fa4c151286a2c..dc02983400070 100644
--- a/content/browser/file_system_access/file_system_chooser.cc
+++ b/content/browser/file_system_access/file_system_chooser.cc
@@ -71,30 +71,6 @@ base::FilePath::StringType GetLastExtension(
              : extension;
 }
 
-// Returns whether the specified extension receives special handling by the
-// Windows shell.
-bool IsShellIntegratedExtension(const base::FilePath::StringType& extension) {
-  // TODO(https://crbug.com/1154757): Figure out some way to unify this with
-  // net::IsSafePortablePathComponent, with the result probably ending up in
-  // base/i18n/file_util_icu.h.
-  base::FilePath::StringType extension_lower = base::ToLowerASCII(extension);
-
-  // .lnk files may be used to execute arbitrary code (see
-  // https://nvd.nist.gov/vuln/detail/CVE-2010-2568). .local files are used by
-  // Windows to determine which DLLs to load for an application.
-  if ((extension_lower == FILE_PATH_LITERAL("local")) ||
-      (extension_lower == FILE_PATH_LITERAL("lnk")))
-    return true;
-
-  // Setting a file's extension to a CLSID may conceal its actual file type on
-  // some Windows versions (see https://nvd.nist.gov/vuln/detail/CVE-2004-0420).
-  if (!extension_lower.empty() &&
-      (extension_lower.front() == FILE_PATH_LITERAL('{')) &&
-      (extension_lower.back() == FILE_PATH_LITERAL('}')))
-    return true;
-  return false;
-}
-
 // Extension validation primarily takes place in the renderer. This checks for a
 // subset of invalid extensions in the event the renderer is compromised.
 bool IsInvalidExtension(base::FilePath::StringType& extension) {
@@ -102,7 +78,7 @@ bool IsInvalidExtension(base::FilePath::StringType& extension) {
   auto extension16 = base::UTF8ToUTF16(component8.c_str());
 
   return !base::i18n::IsFilenameLegal(extension16) ||
-         IsShellIntegratedExtension(GetLastExtension(extension));
+	 FileSystemChooser::IsShellIntegratedExtension(extension);
 }
 
 // Converts the accepted mime types and extensions from |option| into a list
@@ -289,6 +265,40 @@ void FileSystemChooser::CreateAndShow(
       /*params=*/nullptr);
 }
 
+// static
+bool FileSystemChooser::IsShellIntegratedExtension(
+    const base::FilePath::StringType& extension) {
+  // TODO(https://crbug.com/1154757): Figure out some way to unify this with
+  // net::IsSafePortablePathComponent, with the result probably ending up in
+  // base/i18n/file_util_icu.h.
+  // - For the sake of consistency across platforms, we sanitize '.lnk' and
+  //   '.local' files on all platforms (not just Windows)
+  // - There are some extensions (i.e. '.scf') we would like to sanitize which
+  //   `net::GenerateFileName()` does not
+  base::FilePath::StringType extension_lower =
+      base::ToLowerASCII(GetLastExtension(extension));
+
+  // .lnk and .scf files may be used to execute arbitrary code (see
+  // https://nvd.nist.gov/vuln/detail/CVE-2010-2568 and
+  // https://crbug.com/1227995, respectively). .local files are used by Windows
+  // to determine which DLLs to load for an application.
+  if ((extension_lower == FILE_PATH_LITERAL("lnk")) ||
+      (extension_lower == FILE_PATH_LITERAL("local")) ||
+      (extension_lower == FILE_PATH_LITERAL("scf"))) {
+    return true;
+  }
+
+  // Setting a file's extension to a CLSID may conceal its actual file type on
+  // some Windows versions (see https://nvd.nist.gov/vuln/detail/CVE-2004-0420).
+  if (!extension_lower.empty() &&
+      (extension_lower.front() == FILE_PATH_LITERAL('{')) &&
+      (extension_lower.back() == FILE_PATH_LITERAL('}'))) {
+    return true;
+  }
+
+  return false;
+}
+
 FileSystemChooser::FileSystemChooser(ui::SelectFileDialog::Type type,
                                      ResultCallback callback,
                                      base::ScopedClosureRunner fullscreen_block)
diff --git a/content/browser/file_system_access/file_system_chooser.h b/content/browser/file_system_access/file_system_chooser.h
index 8b672a278222f..fdb6012ca5c41 100644
--- a/content/browser/file_system_access/file_system_chooser.h
+++ b/content/browser/file_system_access/file_system_chooser.h
@@ -68,6 +68,12 @@ class CONTENT_EXPORT FileSystemChooser : public ui::SelectFileDialog::Listener {
                             ResultCallback callback,
                             base::ScopedClosureRunner fullscreen_block);
 
+  // Returns whether the specified extension receives special handling by the
+  // Windows shell. These extensions should be sanitized before being shown in
+  // the "save as" file picker.
+  static bool IsShellIntegratedExtension(
+      const base::FilePath::StringType& extension);
+
   FileSystemChooser(ui::SelectFileDialog::Type type,
                     ResultCallback callback,
                     base::ScopedClosureRunner fullscreen_block);
diff --git a/content/browser/file_system_access/file_system_chooser_browsertest.cc b/content/browser/file_system_access/file_system_chooser_browsertest.cc
index 72ff09ab098d3..f65ef61e4cb85 100644
--- a/content/browser/file_system_access/file_system_chooser_browsertest.cc
+++ b/content/browser/file_system_access/file_system_chooser_browsertest.cc
@@ -1321,22 +1321,28 @@ IN_PROC_BROWSER_TEST_F(FileSystemChooserBrowserTest, SuggestedName) {
   name_infos.push_back({"not_matching.jpg", ListValueOf(".txt"), false,
                         "not_matching.jpg", false});
 
-#if defined(OS_WIN)
-  // ".local" and ".lnk" extensions should be sanitized on Windows.
+  // ".lnk", ".local", and ".scf" extensions should be sanitized.
   name_infos.push_back({"dangerous_extension.local", ListValueOf(".local"),
                         true, "dangerous_extension.download", false});
   name_infos.push_back({"dangerous_extension.lnk", ListValueOf(".lnk"), true,
                         "dangerous_extension.download", false});
-#else
-  // ".local" and ".lnk" extensions should be allowed on other OSes.
-  // TODO(https://crbug.com/1154757): `expected_exclude_accept_all_option` is
-  // false here because ".local" and ".lnk" extensions are not allowed in
-  // `accepts`, but are only sanitized by net::GenerateSafeFileName on Windows.
-  name_infos.push_back({"dangerous_extension.local", ListValueOf(".local"),
-                        true, "dangerous_extension.local", false});
-  name_infos.push_back({"dangerous_extension.lnk", ListValueOf(".lnk"), true,
-                        "dangerous_extension.lnk", false});
-#endif
+  name_infos.push_back({"dangerous_extension.scf", ListValueOf(".scf"), true,
+                        "dangerous_extension.download", false});
+  // Compound extensions ending in a dangerous extension should be sanitized.
+  name_infos.push_back({"dangerous_extension.png.local", ListValueOf(".local"),
+                        true, "dangerous_extension.png.download", false});
+  name_infos.push_back({"dangerous_extension.png.lnk", ListValueOf(".lnk"),
+                        true, "dangerous_extension.png.download", false});
+  name_infos.push_back({"dangerous_extension.png.scf", ListValueOf(".scf"),
+                        true, "dangerous_extension.png.download", false});
+  // Compound extensions not ending in a dangerous extension should not be
+  // sanitized.
+  name_infos.push_back({"dangerous_extension.local.png", ListValueOf(".png"),
+                        true, "dangerous_extension.local.png", true});
+  name_infos.push_back({"dangerous_extension.lnk.png", ListValueOf(".png"),
+                        true, "dangerous_extension.lnk.png", true});
+  name_infos.push_back({"dangerous_extension.scf.png", ListValueOf(".png"),
+                        true, "dangerous_extension.scf.png", true});
   // Invalid characters should be sanitized.
   name_infos.push_back({R"(inv*l:d\\charבאמת!a<ters🤓.txt)",
                         ListValueOf(".txt"), true,
diff --git a/content/browser/file_system_access/file_system_chooser_unittest.cc b/content/browser/file_system_access/file_system_chooser_unittest.cc
index 1a590252fe118..e684acb8d4c29 100644
--- a/content/browser/file_system_access/file_system_chooser_unittest.cc
+++ b/content/browser/file_system_access/file_system_chooser_unittest.cc
@@ -189,7 +189,7 @@ TEST_F(FileSystemChooserTest, IgnoreShellIntegratedExtensions) {
   accepts.emplace_back(blink::mojom::ChooseFileSystemEntryAcceptsOption::New(
       base::ASCIIToUTF16(""), std::vector<std::string>({}),
       std::vector<std::string>(
-          {"lnk", "foo.lnk", "foo.bar.local", "text", "local"})));
+          {"lnk", "foo.lnk", "foo.bar.local", "text", "local", "scf"})));
   SyncShowDialog(std::move(accepts), /*include_accepts_all=*/false);
 
   ASSERT_TRUE(dialog_params.file_types);
diff --git a/content/browser/media/ohos/ohos_media_player_renderer.cc b/content/browser/media/ohos/ohos_media_player_renderer.cc
index 54db096c887a4..965ffc4a15e55 100644
--- a/content/browser/media/ohos/ohos_media_player_renderer.cc
+++ b/content/browser/media/ohos/ohos_media_player_renderer.cc
@@ -62,13 +62,10 @@ void OHOSMediaPlayerRenderer::CreateMediaPlayer(
       url_params.top_frame_origin, user_agent,
       false,  // hide_url_log
       this, url_params.allow_credentials, url_params.is_hls));
+  init_cb_ = std::move(init_cb);
   int32_t ret = media_player_->Initialize();
-  if (ret == 0) {
-    UpdateVolume();
-    std::move(init_cb).Run(media::PIPELINE_OK);
-    initialized_ = true;
-  } else {
-    std::move(init_cb).Run(media::PIPELINE_ERROR_INITIALIZATION_FAILED);
+  if (ret != 0) {
+    std::move(init_cb_).Run(media::PIPELINE_ERROR_INITIALIZATION_FAILED);
   }
 }
 
@@ -180,6 +177,16 @@ void OHOSMediaPlayerRenderer::OnVideoSizeChanged(int width, int height) {
   }
 }
 
+void OHOSMediaPlayerRenderer::OnPlayerPrepared(int status) {
+  if (status == 0) {
+    UpdateVolume();
+    std::move(init_cb_).Run(media::PIPELINE_OK);
+    initialized_ = true;
+  } else {
+    std::move(init_cb_).Run(media::PIPELINE_ERROR_INITIALIZATION_FAILED);
+  }
+}
+
 void OHOSMediaPlayerRenderer::SetVolume(float volume) {
   volume_ = volume;
   UpdateVolume();
diff --git a/content/browser/media/ohos/ohos_media_player_renderer.h b/content/browser/media/ohos/ohos_media_player_renderer.h
index 21753d6ccd008..ff0fb383557d4 100644
--- a/content/browser/media/ohos/ohos_media_player_renderer.h
+++ b/content/browser/media/ohos/ohos_media_player_renderer.h
@@ -67,6 +67,7 @@ class CONTENT_EXPORT OHOSMediaPlayerRenderer
   void OnPlaybackComplete() override;
   void OnError(int error) override;
   void OnVideoSizeChanged(int width, int height) override;
+  void OnPlayerPrepared(int status) override;
 
   // media::mojom::MediaPlayerRendererExtension implementation.
   //
@@ -107,6 +108,8 @@ class CONTENT_EXPORT OHOSMediaPlayerRenderer
 
   mojo::Receiver<MediaPlayerRendererExtension> renderer_extension_receiver_;
 
+  media::PipelineStatusCallback init_cb_;
+
   // NOTE: Weak pointers must be invalidated before all other member variables.
   base::WeakPtrFactory<OHOSMediaPlayerRenderer> weak_factory_{this};
 
diff --git a/content/browser/site_per_process_browsertest.cc b/content/browser/site_per_process_browsertest.cc
index a80839b889f17..49cdb80fd0acf 100644
--- a/content/browser/site_per_process_browsertest.cc
+++ b/content/browser/site_per_process_browsertest.cc
@@ -10229,8 +10229,8 @@ IN_PROC_BROWSER_TEST_P(
 #else
 #define MAYBE_CrossProcessInertSubframe CrossProcessInertSubframe
 #endif
-// Tests that when a frame contains a modal <dialog> element, out-of-process
-// iframe children cannot take focus, because they are inert.
+// Tests that when an out-of-process iframe becomes inert due to a modal
+// <dialog> element, the contents of the iframe can still take focus.
 IN_PROC_BROWSER_TEST_P(SitePerProcessBrowserTest,
                        MAYBE_CrossProcessInertSubframe) {
   // This uses a(b,b) instead of a(b) to preserve the b.com process even when
@@ -10271,15 +10271,15 @@ IN_PROC_BROWSER_TEST_P(SitePerProcessBrowserTest,
 
   std::string focused_element;
 
-  // Attempt to change focus in the inert subframe. This should fail.
+  // Attempt to change focus in the inert subframe. This should work.
   // The setTimeout ensures that the inert bit can propagate before the
   // test JS code runs.
-  EXPECT_TRUE(ExecuteScriptAndExtractString(
-      iframe_node,
-      "window.setTimeout(() => {text2.focus();"
-      "domAutomationController.send(document.activeElement.id);}, 0)",
-      &focused_element));
-  EXPECT_EQ("", focused_element);
+  EXPECT_EQ(
+      "text2",
+      EvalJs(iframe_node,
+             "window.setTimeout(() => {text2.focus();"
+             "domAutomationController.send(document.activeElement.id);}, 0)",
+             EXECUTE_SCRIPT_USE_MANUAL_REPLY));
 
   // Navigate the child frame to another site, so that it moves into a new
   // process.
@@ -10297,16 +10297,15 @@ IN_PROC_BROWSER_TEST_P(SitePerProcessBrowserTest,
       "document.body.innerHTML = '<input id=\"text1\"> <input id=\"text2\">';"
       "text1.focus();"));
 
-  // Verify that inertness was preserved across the navigation.
-  EXPECT_TRUE(ExecuteScriptAndExtractString(
-      iframe_node,
-      "text2.focus();"
-      "domAutomationController.send(document.activeElement.id);",
-      &focused_element));
-  EXPECT_EQ("", focused_element);
+  // Verify we can still set focus after the navigation.
+  EXPECT_EQ("text2",
+            EvalJs(iframe_node,
+                   "text2.focus();"
+                   "domAutomationController.send(document.activeElement.id);",
+                   EXECUTE_SCRIPT_USE_MANUAL_REPLY));
 
   // Navigate the subframe back into its parent process to verify that the
-  // new local frame remains inert.
+  // new local frame remains non-inert.
   GURL same_site_url(embedded_test_server()->GetURL("a.com", "/title1.html"));
   EXPECT_TRUE(NavigateToURLFromRenderer(iframe_node, same_site_url));
 
@@ -10316,13 +10315,101 @@ IN_PROC_BROWSER_TEST_P(SitePerProcessBrowserTest,
       "document.body.innerHTML = '<input id=\"text1\"> <input id=\"text2\">';"
       "text1.focus();"));
 
-  // Verify that inertness was preserved across the navigation.
-  EXPECT_TRUE(ExecuteScriptAndExtractString(
-      iframe_node,
-      "text2.focus();"
-      "domAutomationController.send(document.activeElement.id);",
-      &focused_element));
-  EXPECT_EQ("", focused_element);
+  // Verify we can still set focus after the navigation.
+  EXPECT_EQ("text2",
+            EvalJs(iframe_node,
+                   "text2.focus();"
+                   "domAutomationController.send(document.activeElement.id);",
+                   EXECUTE_SCRIPT_USE_MANUAL_REPLY));
+}
+
+// Tests that IsInert frame flag is correctly updated and propagated.
+IN_PROC_BROWSER_TEST_P(SitePerProcessBrowserTest,
+                       CrossProcessIsInertPropagation) {
+  base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
+      switches::kEnableBlinkFeatures, "InertAttribute");
+  GURL main_url(embedded_test_server()->GetURL(
+      "a.com", "/cross_site_iframe_factory.html?a(b(c))"));
+  EXPECT_TRUE(NavigateToURL(shell(), main_url));
+
+  FrameTreeNode* frame_a =
+      static_cast<WebContentsImpl*>(shell()->web_contents())
+          ->GetPrimaryFrameTree()
+          .root();
+  ASSERT_EQ(1U, frame_a->child_count());
+  FrameTreeNode* frame_b = frame_a->child_at(0);
+  ASSERT_EQ(1U, frame_b->child_count());
+  FrameTreeNode* frame_c = frame_b->child_at(0);
+  RenderFrameProxyHost* proxy_b = frame_b->render_manager()->GetProxyToParent();
+  RenderFrameProxyHost* proxy_c = frame_c->render_manager()->GetProxyToParent();
+
+  auto waitForInertPropagated = [&]() {
+    // Force layout. This recomputes the element styles so that the <iframe>
+    // gets the updated ComputedStyle::IsInert() flag. This triggers an update
+    // of the associated RenderFrameProxyHost::IsInertForTesting().
+    for (FrameTreeNode* frame : {frame_a, frame_b, frame_c})
+      ExecuteScriptAsync(frame, "document.body.offsetLeft");
+
+    // Propagating the inert flag requires sending messages in between the
+    // browser and the renderers. Since they are using the same mojo interfaces
+    // as ExecJs, waiting for an browser<->renderer roundtrip using ExecJs
+    // should be enough to guarantee it has been propagate.
+    for (FrameTreeNode* frame : {frame_a, frame_b, frame_c})
+      EXPECT_TRUE(ExecJs(frame, "'Done'"));
+  };
+
+  waitForInertPropagated();
+  EXPECT_FALSE(proxy_b->IsInertForTesting());
+  EXPECT_FALSE(proxy_c->IsInertForTesting());
+
+  // Make b inert, this should also make c inert.
+  EXPECT_TRUE(ExecJs(frame_a, "document.body.inert = true;"));
+  waitForInertPropagated();
+  EXPECT_TRUE(proxy_b->IsInertForTesting());
+  EXPECT_TRUE(proxy_c->IsInertForTesting());
+
+  // Make b non-inert, this should also make c non-inert.
+  EXPECT_TRUE(ExecJs(frame_a, "document.body.inert = false;"));
+  waitForInertPropagated();
+  EXPECT_FALSE(proxy_b->IsInertForTesting());
+  EXPECT_FALSE(proxy_c->IsInertForTesting());
+
+  // Make c inert.
+  EXPECT_TRUE(ExecJs(frame_b, "document.body.inert = true;"));
+  waitForInertPropagated();
+  EXPECT_FALSE(proxy_b->IsInertForTesting());
+  EXPECT_TRUE(proxy_c->IsInertForTesting());
+
+  // Make b inert, c should continue being inert.
+  EXPECT_TRUE(ExecJs(frame_a, "document.body.inert = true;"));
+  waitForInertPropagated();
+  EXPECT_TRUE(proxy_b->IsInertForTesting());
+  EXPECT_TRUE(proxy_c->IsInertForTesting());
+
+  // Try to make c non-inert, it should still be inert due to b.
+  EXPECT_TRUE(ExecJs(frame_b, "document.body.inert = false;"));
+  waitForInertPropagated();
+  EXPECT_TRUE(proxy_b->IsInertForTesting());
+  EXPECT_TRUE(proxy_c->IsInertForTesting());
+
+  // Make b non-inert, this should also make c non-inert.
+  EXPECT_TRUE(ExecJs(frame_a, "document.body.inert = false;"));
+  waitForInertPropagated();
+  EXPECT_FALSE(proxy_b->IsInertForTesting());
+  EXPECT_FALSE(proxy_c->IsInertForTesting());
+
+  // Make b anc inert.
+  EXPECT_TRUE(ExecJs(frame_a, "document.body.inert = true;"));
+  EXPECT_TRUE(ExecJs(frame_b, "document.body.inert = true;"));
+  waitForInertPropagated();
+  EXPECT_TRUE(proxy_b->IsInertForTesting());
+  EXPECT_TRUE(proxy_c->IsInertForTesting());
+
+  // Make b non-inert, c should continue being inert.
+  EXPECT_TRUE(ExecJs(frame_a, "document.body.inert = false;"));
+  waitForInertPropagated();
+  EXPECT_FALSE(proxy_b->IsInertForTesting());
+  EXPECT_TRUE(proxy_c->IsInertForTesting());
 }
 
 // Check that main frames for the same site rendering in unrelated tabs start
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index e3a917934210f..4b082de10d3e1 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -1600,6 +1600,14 @@ void WebContentsImpl::SetUserAgentOverride(
     return;
   }
 
+#if defined(OS_OHOS)
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch(switches::kForBrowser)) {
+    UpdateOverridingUserAgent();
+  }
+#endif
+
   should_override_user_agent_in_new_tabs_ = override_in_new_tabs;
 
   renderer_preferences_.user_agent_override = ua_override;
@@ -3997,10 +4005,6 @@ SessionStorageNamespaceMap WebContentsImpl::GetSessionStorageNamespaceMap() {
   return GetController().GetSessionStorageNamespaceMap();
 }
 
-FrameTree* WebContentsImpl::GetFrameTree() {
-  return &frame_tree_;
-}
-
 bool WebContentsImpl::IsOverridingUserAgent() {
   return GetController().GetVisibleEntry() &&
          GetController().GetVisibleEntry()->GetIsOverridingUserAgent();
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index 8cd27c343ac4a..ad513676249e8 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -323,7 +323,11 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
 
   // Returns the primary FrameTree for this WebContents (as opposed to the
   // ones held by MPArch features like Prerender or Portal).
-  FrameTree* GetFrameTree();
+  FrameTree& GetPrimaryFrameTree() { return frame_tree_; }
+  // Deprecated.
+  // TODO(https://crbug.com/1251094): Remove once callers have been migrated to
+  // the above.
+  FrameTree* GetFrameTree() { return &GetPrimaryFrameTree(); }
 
   // Whether the initial empty page of this view has been accessed by another
   // page, making it unsafe to show the pending URL. Always false after the
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index a4836d8c97a21..a8e6cc4550661 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -975,6 +975,7 @@ const char kEnableSpeechDispatcher[] = "enable-speech-dispatcher";
 const char kEnableMultiRendererProcess[] = "enable-multi-renderer-process";
 const char kForTest[] = "for-test";
 const char kBundleInstallationDir[] = "bundle-installation-dir";
+const char kForBrowser[] = "--for-browser";
 #endif
 
 #if defined(OS_WIN)
diff --git a/content/public/common/content_switches.h b/content/public/common/content_switches.h
index 13286c752ba33..7dcf81463b99a 100644
--- a/content/public/common/content_switches.h
+++ b/content/public/common/content_switches.h
@@ -273,6 +273,7 @@ CONTENT_EXPORT extern const char kEnableSpeechDispatcher[];
 CONTENT_EXPORT extern const char kEnableMultiRendererProcess[];
 CONTENT_EXPORT extern const char kForTest[];
 CONTENT_EXPORT extern const char kBundleInstallationDir[];
+CONTENT_EXPORT extern const char kForBrowser[];
 #endif
 
 #if defined(OS_WIN)
diff --git a/media/base/ohos/ohos_media_player_bridge.cc b/media/base/ohos/ohos_media_player_bridge.cc
index fc4c0a086a522..9000caac7bf33 100644
--- a/media/base/ohos/ohos_media_player_bridge.cc
+++ b/media/base/ohos/ohos_media_player_bridge.cc
@@ -11,6 +11,9 @@
 
 namespace media {
 
+static constexpr int PLAYER_INIT_OK = 0;
+static constexpr int PLAYER_INIT_ERROR = -1;
+
 OHOSMediaPlayerBridge::OHOSMediaPlayerBridge(
     const GURL& url,
     const GURL& site_for_cookies,
@@ -32,7 +35,15 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
     return -1;
   }
   task_runner_ = base::ThreadTaskRunnerHandle::Get();
+  if (task_runner_ == nullptr) {
+    LOG(ERROR) << "media task runner failed";
+    return -1;
+  }
   player_ = OHOS::Media::PlayerFactory::CreatePlayer();
+  if (player_ == nullptr) {
+    LOG(ERROR) << "media create player failed";
+    return -1;
+  }
   std::shared_ptr<OHOSMediaPlayerCallback> media_player_callback =
       std::make_shared<OHOSMediaPlayerCallback>(task_runner_,
                                                 weak_factory_.GetWeakPtr());
@@ -44,17 +55,17 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
   if (url_.SchemeIsFile()) {
     ret = SetFdSource(url_.GetContent());
   } else {
-    if (url_.spec().rfind("https", 0) == std::string::npos) {
-      ret = player_->SetSource(url_.spec());
-    } else {
-      ret = -1;
-    }
+    ret = player_->SetSource(url_.spec());
   }
   if (ret != 0) {
     LOG(ERROR) << "SetSource error::ret=" << ret;
     return ret;
   }
   consumer_surface_ = OHOS::Surface::CreateSurfaceAsConsumer();
+  if (consumer_surface_ == nullptr) {
+    LOG(ERROR) << "media create surface failed";
+    return -1;
+  }
   listener_ = new OHOSMediaPlayerListener(
       task_runner_, weak_factory_.GetWeakPtr(), consumer_surface_);
   consumer_surface_->RegisterConsumerListener(listener_);
@@ -66,7 +77,7 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
     LOG(ERROR) << "SetVideoSurface error::ret=" << ret;
     return ret;
   }
-  ret = player_->Prepare();
+  ret = player_->PrepareAsync();
   if (ret != 0) {
     LOG(ERROR) << "Prepare error::ret=" << ret << " url=" << url_.spec();
     return ret;
@@ -75,7 +86,8 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
 }
 
 void OHOSMediaPlayerBridge::Start() {
-  if (player_ && player_state_ != OHOS::Media::PLAYER_STARTED) {
+  if (player_ && is_player_prepared_ &&
+      player_state_ != OHOS::Media::PLAYER_STARTED) {
     int32_t ret = player_->Play();
     if (ret != 0) {
       LOG(ERROR) << "Play error::ret=" << ret;
@@ -187,6 +199,16 @@ void OHOSMediaPlayerBridge::OnSeekDone() {
 void OHOSMediaPlayerBridge::OnPlayerStateUpdate(
     OHOS::Media::PlayerStates player_state) {
   player_state_ = player_state;
+  if (player_state == OHOS::Media::PLAYER_PREPARED) {
+    is_player_prepared_ = true;
+    client_->OnPlayerPrepared(PLAYER_INIT_OK);
+  } else if (player_state == OHOS::Media::PLAYER_STATE_ERROR ||
+             player_state == OHOS::Media::PLAYER_IDLE ||
+             player_state == OHOS::Media::PLAYER_INITIALIZED ||
+             player_state == OHOS::Media::PLAYER_PREPARING) {
+    is_player_prepared_ = false;
+    client_->OnPlayerPrepared(PLAYER_INIT_ERROR);
+  }
 }
 
 void OHOSMediaPlayerBridge::OnBufferAvailable(
diff --git a/media/base/ohos/ohos_media_player_bridge.h b/media/base/ohos/ohos_media_player_bridge.h
index 631af9c93eb63..84afaea19baf2 100644
--- a/media/base/ohos/ohos_media_player_bridge.h
+++ b/media/base/ohos/ohos_media_player_bridge.h
@@ -39,6 +39,8 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
 
     // Called when video size has changed.
     virtual void OnVideoSizeChanged(int width, int height) = 0;
+
+    virtual void OnPlayerPrepared(int status) = 0;
   };
 
   enum MediaErrorType {
@@ -87,6 +89,7 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
   Client* client_;
   GURL url_;
   bool seeking_ = false;
+  bool is_player_prepared_ = false;
   base::TimeDelta pending_seek_;
   OHOS::Media::PlayerStates player_state_;
   base::WeakPtrFactory<OHOSMediaPlayerBridge> weak_factory_{this};
diff --git a/media/media_options.gni b/media/media_options.gni
index 8081db082b273..40c6e09c5a4ee 100644
--- a/media/media_options.gni
+++ b/media/media_options.gni
@@ -52,7 +52,7 @@ declare_args() {
   # Enable usage of FFmpeg within the media library. Used for most software
   # based decoding, demuxing, and sometimes optimized FFTs. If disabled,
   # implementors must provide their own demuxers and decoders.
-  media_use_ffmpeg = false
+  media_use_ffmpeg = true
 
   # Enable usage of libvpx within the media library. Used for software based
   # decoding of VP9 and VP8A type content.
diff --git a/net/base/network_change_notifier.cc b/net/base/network_change_notifier.cc
index f385822f1d488..fa565f8bb0379 100644
--- a/net/base/network_change_notifier.cc
+++ b/net/base/network_change_notifier.cc
@@ -34,11 +34,11 @@
 #include "net/base/network_change_notifier_win.h"
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
+#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
 #include "net/base/network_change_notifier_linux.h"
 #elif defined(OS_APPLE)
 #include "net/base/network_change_notifier_mac.h"
-#elif BUILDFLAG(IS_CHROMEOS_ASH) || defined(OS_ANDROID)
+#elif BUILDFLAG(IS_CHROMEOS_ASH) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include "net/base/network_change_notifier_posix.h"
 #elif defined(OS_FUCHSIA)
 #include "net/base/network_change_notifier_fuchsia.h"
@@ -235,7 +235,7 @@ std::unique_ptr<NetworkChangeNotifier> NetworkChangeNotifier::CreateIfNeeded(
       std::make_unique<NetworkChangeNotifierWin>();
   network_change_notifier->WatchForAddressChange();
   return network_change_notifier;
-#elif defined(OS_ANDROID)
+#elif defined(OS_ANDROID) || defined(OS_OHOS)
   // Fallback to use NetworkChangeNotifierPosix if NetworkChangeNotifierFactory
   // is not set. Currently used for tests and when running network
   // service in a separate process.
@@ -244,7 +244,7 @@ std::unique_ptr<NetworkChangeNotifier> NetworkChangeNotifier::CreateIfNeeded(
 #elif BUILDFLAG(IS_CHROMEOS_ASH)
   return std::make_unique<NetworkChangeNotifierPosix>(initial_type,
                                                       initial_subtype);
-#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
+#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
   return std::make_unique<NetworkChangeNotifierLinux>(
       std::unordered_set<std::string>());
 #elif defined(OS_APPLE)
diff --git a/net/base/network_change_notifier_posix.cc b/net/base/network_change_notifier_posix.cc
index 45328dc2d08c1..c3e483425b73c 100644
--- a/net/base/network_change_notifier_posix.cc
+++ b/net/base/network_change_notifier_posix.cc
@@ -18,6 +18,68 @@
 #include "net/android/network_change_notifier_android.h"
 #endif
 
+namespace {
+#if defined(OS_OHOS)
+net::NetworkChangeNotifier::ConnectionType ConvertOhosConnTypeToNetBaseConnType(
+  const OHOS::NWeb::NetConnectType& netConnectType) {
+  return static_cast<net::NetworkChangeNotifier::ConnectionType>(netConnectType);
+}
+
+net::NetworkChangeNotifier::ConnectionSubtype ConvertOhosConnSubtypeToNetBaseConnSubtype(
+  const OHOS::NWeb::NetConnectSubtype& subtype) {
+  return static_cast<net::NetworkChangeNotifier::ConnectionSubtype>(subtype);
+}
+
+class NetConnCallbackImpl : public OHOS::NWeb::NetConnCallback {
+public:
+  NetConnCallbackImpl(net::NetworkChangeNotifierPosix* network_change_notifier_posix) :
+    network_change_notifier_posix_(network_change_notifier_posix) {}
+  virtual ~NetConnCallbackImpl() = default;
+  int32_t NetAvailable() override;
+  int32_t NetCapabilitiesChange(const OHOS::NWeb::NetConnectType& netConnectType,
+                                const OHOS::NWeb::NetConnectSubtype& netConnectSubtype) override;
+  int32_t NetConnectionPropertiesChange() override;
+  int32_t NetUnavailable() override;
+private:
+  net::NetworkChangeNotifierPosix* network_change_notifier_posix_ = nullptr;
+};
+
+int32_t NetConnCallbackImpl::NetAvailable() {
+  return 0;
+}
+
+int32_t NetConnCallbackImpl::NetCapabilitiesChange(const OHOS::NWeb::NetConnectType& netConnectType,
+                                                   const OHOS::NWeb::NetConnectSubtype& netConnectSubtype) {
+  if (network_change_notifier_posix_) {
+    network_change_notifier_posix_->OnConnectionChanged(ConvertOhosConnTypeToNetBaseConnType(netConnectType));
+    network_change_notifier_posix_->OnConnectionSubtypeChanged(ConvertOhosConnTypeToNetBaseConnType(netConnectType),
+      ConvertOhosConnSubtypeToNetBaseConnSubtype(netConnectSubtype));
+  }
+  return 0;
+}
+
+int32_t NetConnCallbackImpl::NetConnectionPropertiesChange() {
+  if (network_change_notifier_posix_) {
+    network_change_notifier_posix_->OnDNSChanged();
+    network_change_notifier_posix_->OnIPAddressChanged();
+  }
+  return 0;
+}
+
+int32_t NetConnCallbackImpl::NetUnavailable() {
+  if (network_change_notifier_posix_) {
+    network_change_notifier_posix_->OnConnectionChanged(net::NetworkChangeNotifier::ConnectionType::CONNECTION_NONE);
+    network_change_notifier_posix_->OnConnectionSubtypeChanged(
+      net::NetworkChangeNotifier::ConnectionType::CONNECTION_NONE,
+      net::NetworkChangeNotifier::ConnectionSubtype::SUBTYPE_NONE);
+  }
+  return 0;
+}
+
+std::shared_ptr<NetConnCallbackImpl> g_net_connect_callback = nullptr;
+#endif
+}
+
 namespace net {
 
 NetworkChangeNotifierPosix::NetworkChangeNotifierPosix(
@@ -34,12 +96,33 @@ NetworkChangeNotifierPosix::NetworkChangeNotifierPosix(
     : NetworkChangeNotifier(NetworkChangeCalculatorParamsPosix(),
                             system_dns_config_notifier),
       connection_type_(initial_connection_type),
+#if defined(OS_OHOS)
+      ohos_net_conn_adapter_(OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateNetConnectAdapter()),
+#endif
       max_bandwidth_mbps_(
           NetworkChangeNotifier::GetMaxBandwidthMbpsForConnectionSubtype(
-              initial_connection_subtype)) {}
+              initial_connection_subtype)) {
+#if defined(OS_OHOS)
+  g_net_connect_callback = std::make_shared<NetConnCallbackImpl>(this);
+  if (ohos_net_conn_adapter_) {
+    int32_t ret = ohos_net_conn_adapter_->RegisterNetConnCallback(g_net_connect_callback);
+    if (ret != 0) {
+      LOG(ERROR) << "register ohos net connect callback failed.";
+    }
+  }
+#endif
+}
 
 NetworkChangeNotifierPosix::~NetworkChangeNotifierPosix() {
   ClearGlobalPointer();
+#if defined(OS_OHOS)
+  if (ohos_net_conn_adapter_) {
+    int32_t ret = ohos_net_conn_adapter_->UnregisterNetConnCallback(g_net_connect_callback);
+    if (ret != 0) {
+      LOG(ERROR) << "unregister ohos net connect callback failed.";
+    }
+  }
+#endif
 }
 
 void NetworkChangeNotifierPosix::OnDNSChanged() {
diff --git a/net/base/network_change_notifier_posix.h b/net/base/network_change_notifier_posix.h
index d8e38934d0244..6a664e8165392 100644
--- a/net/base/network_change_notifier_posix.h
+++ b/net/base/network_change_notifier_posix.h
@@ -16,6 +16,9 @@
 #include "base/threading/thread_checker.h"
 #include "net/base/net_export.h"
 #include "net/base/network_change_notifier.h"
+#if defined(OS_OHOS)
+#include "ohos_adapter_helper.h"
+#endif
 
 namespace net {
 
@@ -72,6 +75,11 @@ class NET_EXPORT NetworkChangeNotifierPosix : public NetworkChangeNotifier {
   mutable base::Lock lock_;
   NetworkChangeNotifier::ConnectionType
       connection_type_;        // Guarded by |lock_|.
+
+#if defined(OS_OHOS)
+  std::unique_ptr<OHOS::NWeb::NetConnectAdapter> ohos_net_conn_adapter_;
+#endif
+
   double max_bandwidth_mbps_;  // Guarded by |lock_|.
 };
 
diff --git a/ohos_nweb/BUILD.gn b/ohos_nweb/BUILD.gn
index 1fd2aea892ae5..ce1eae4b7873f 100644
--- a/ohos_nweb/BUILD.gn
+++ b/ohos_nweb/BUILD.gn
@@ -49,11 +49,16 @@ config("cef_nweb_config") {
     "ipc_core.z",
     "inputmethod_ability.z",
     "accesstoken_sdk.z",
+    "nweb_ohos_adapter.z"
   ]
 
   defines = [
     "USING_CHROMIUM_INCLUDES",
   ]
+
+  if (product_name == "rk3568") {
+    defines += [ "DEFAULT_PORTRAIT" ]
+  }
 }
 
 component("cef_nweb") {
@@ -64,7 +69,15 @@ component("cef_nweb") {
   sources = [
     "src/cef_delegate/nweb_application.h",
     "src/cef_delegate/nweb_application.cc",
+    "src/cef_delegate/nweb_context_menu_params_impl.h",
+    "src/cef_delegate/nweb_context_menu_params_impl.cc",
+    "src/cef_delegate/nweb_data_base_delegate.cc",
+    "src/cef_delegate/nweb_data_base_delegate.h",
+    "src/cef_delegate/nweb_display_listener.h",
+    "src/cef_delegate/nweb_display_listener.cc",
+    "src/cef_delegate/nweb_input_delegate.h",
     "src/cef_delegate/nweb_input_delegate.cc",
+    "src/cef_delegate/nweb_inputevent_handler.h",
     "src/cef_delegate/nweb_handler_delegate.h",
     "src/cef_delegate/nweb_handler_delegate.cc",
     "src/cef_delegate/nweb_delegate.cc",
@@ -77,6 +90,8 @@ component("cef_nweb") {
     "src/cef_delegate/nweb_file_selector_params_impl.cc",
     "src/cef_delegate/nweb_js_dialog_result_impl.cc",
     "src/cef_delegate/nweb_js_dialog_result_impl.h",
+    "src/cef_delegate/nweb_js_http_auth_result_impl.cc",
+    "src/cef_delegate/nweb_js_http_auth_result_impl.h",
     "src/cef_delegate/nweb_geolocation_callback.h",
     "src/cef_delegate/nweb_geolocation_callback.cc",
     "src/cef_delegate/nweb_preference_delegate.h",
@@ -88,12 +103,16 @@ component("cef_nweb") {
     "src/cef_delegate/nweb_inputmethod_client.h",
     "src/cef_delegate/nweb_access_request_delegate.cc",
     "src/cef_delegate/nweb_access_request_delegate.h",
+    "src/cef_delegate/nweb_web_storage_delegate.cc",
+    "src/cef_delegate/nweb_web_storage_delegate.h",
   ]
 
   deps = [
     "//base:base",
     "//cef:libweb_engine",
     "//cef:libcef_dll_wrapper",
+    "//ui/events/keycodes:x11",
+    "//content/public/common:static_switches",
   ]
 }
 
@@ -106,7 +125,7 @@ config("nweb_config") {
     "USE_CEF",
   ]
 
-  if (product_name == "rk3568") {
+  if (gpu_switch == "off") {
     defines += [ "GPU_RK3568" ]
   }
 
@@ -128,8 +147,10 @@ component("nweb_sources") {
     "include/nweb_access_request.h",
     "include/nweb_console_log.h",
     "include/nweb_cookie_manager.h",
+    "include/nweb_download_callback.h",
     "include/nweb_geolocation_callback_interface.h",
     "include/nweb_js_dialog_result.h",
+    "include/nweb_js_http_auth_result.h",
     "include/nweb_value_callback.h",
     "include/nweb_preference_delegate.h",
     "include/nweb_handler.h",
@@ -139,6 +160,8 @@ component("nweb_sources") {
     "src/nweb_cookie_manager_delegate_interface.h",
     "src/nweb_cookie_manager_impl.cc",
     "src/nweb_cookie_manager_impl.h",
+    "src/nweb_data_base_impl.cc",
+    "src/nweb_data_base_impl.h",
     "src/nweb_delegate_interface.h",
     "src/nweb_delegate_adapter.h",
     "src/nweb_delegate_adapter.cc",
@@ -154,6 +177,8 @@ component("nweb_sources") {
     "src/nweb_url_resource_error_impl.hh",
     "src/nweb_inputmethod_handler.cc",
     "src/nweb_inputmethod_handler.h",
+    "src/nweb_web_storage_impl.cc",
+    "src/nweb_web_storage_impl.h",
   ]
 
   deps = [
@@ -169,6 +194,7 @@ component("nweb_sources") {
 shared_library("libnweb_adapter") {
   deps = [
     ":nweb_sources",
+    #"//ohos_nweb_ex:nweb_ex",
   ]
 }
 
diff --git a/ohos_nweb/include/nweb.h b/ohos_nweb/include/nweb.h
index 8c93edb7ba272..5f05192a4adf4 100755
--- a/ohos_nweb/include/nweb.h
+++ b/ohos_nweb/include/nweb.h
@@ -67,6 +67,10 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
     virtual void OnContinue() const = 0;
     virtual void OnDestroy() = 0;
 
+    /* focus event */
+    virtual void OnFocus() const = 0;
+    virtual void OnBlur() const = 0;
+
     /* event interface */
     virtual void OnTouchPress(int32_t id, double x, double y) = 0;
     virtual void OnTouchRelease(int32_t id, double x = 0, double y = 0) = 0;
@@ -74,6 +78,8 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
     virtual void OnTouchCancel() = 0;
     virtual void OnNavigateBack() = 0;
     virtual bool SendKeyEvent(int32_t keyCode, int32_t keyAction) = 0;
+    virtual void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY);
+    virtual void SendMouseEvent(int x, int y, int button, int action);
 
     /**
      * Loads the given URL.
@@ -115,6 +121,11 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      *
      */
     virtual void NavigateForward() const = 0;
+    /**
+     * Goes to the history item that is the number of steps away from the current item.
+     *
+     */
+    virtual void NavigateBackOrForward(int step) const = 0;
     /**
      * Delete back and forward history list.
      */
@@ -133,7 +144,16 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      *
      */
     virtual void Zoom(float zoomFactor) const = 0;
-
+    /**
+     * Performs a zooming in operation in this NWeb.
+     *
+     */
+    virtual bool ZoomIn() const = 0;
+    /**
+     * Performs a zooming out operation in this NWeb.
+     *
+     */
+    virtual bool ZoomOut() const = 0;
     /**
      * Stops the current load.
      *
@@ -164,6 +184,12 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      * settings This value cannot be null.
      */
     virtual const std::shared_ptr<NWebPreference> GetPreference() const = 0;
+    /**
+     * Gets the web id.
+     *
+     * @return the web id
+     */
+    virtual unsigned int GetWebId() const = 0;
     /**
      * Gets the last hit test result.
      *
@@ -178,6 +204,14 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      *
      */
     virtual void PutBackgroundColor(int color) const = 0;
+
+    /**
+     * Sets the initla scale for the page.
+     *
+     * @param scale float: the initla scale of the page.
+     *
+     */
+    virtual void InitialScale(float scale) const = 0;
     /**
      * Sets the NWebDownloadCallback that will receive download event.
      * This will replace the current handler.
diff --git a/ohos_nweb/include/nweb_context_menu_params.h b/ohos_nweb/include/nweb_context_menu_params.h
new file mode 100644
index 0000000000000..725458b5e101d
--- /dev/null
+++ b/ohos_nweb/include/nweb_context_menu_params.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_CONTEXT_MENU_PARAMS_H
+#define NWEB_CONTEXT_MENU_PARAMS_H
+
+#include <string>
+
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebContextMenuParams {
+public:
+    enum ContextMenuTypeFlags {
+        CM_TF_NONE = 0,
+        CM_TF_PAGE = 1 << 0,
+        CM_TF_FRAME = 1 << 1,
+        CM_TF_LINK = 1 << 2,
+        CM_TF_MEDIA = 1 << 3,
+        CM_TF_SELECTION = 1 << 4,
+        CM_TF_EDITABLE = 1 << 5,
+    };
+
+    enum ContextMenuMediaType {
+        CM_MT_NONE,
+        CM_MT_IMAGE,
+        CM_MT_VIDEO,
+        CM_MT_AUDIO,
+        CM_MT_FILE,
+        CM_MT_PLUGIN,
+    };
+
+    enum ContextMenuEditStateFlags {
+        CM_ES_NONE = 0,
+        CM_ES_CAN_UNDO = 1 << 0,
+        CM_ES_CAN_REDO = 1 << 1,
+        CM_ES_CAN_CUT = 1 << 2,
+        CM_ES_CAN_COPY = 1 << 3,
+        CM_ES_CAN_PASTE = 1 << 4,
+        CM_ES_CAN_DELETE = 1 << 5,
+        CM_ES_CAN_SELECT_ALL = 1 << 6,
+        CM_ES_CAN_TRANSLATE = 1 << 7,
+    };
+
+    virtual ~NWebContextMenuParams() = default;
+
+    virtual int32_t GetXCoord() = 0;
+
+    virtual int32_t GetYCoord() = 0;
+
+    virtual int32_t GetContextMenuTypeFlags() = 0;
+
+    virtual bool HasImageContents() = 0;
+
+    virtual std::string GetTitleText() = 0;
+
+    virtual std::string GetPageUrl() = 0;
+
+    virtual ContextMenuMediaType GetMediaType() = 0;
+
+    virtual bool IsEditable() = 0;
+
+    virtual int32_t GetEditStateFlags() = 0;
+};
+
+class OHOS_NWEB_EXPORT NWebQuickMenuParams {
+public:
+    enum QuickMenuEditStateFlags {
+        QM_EF_NONE = 0,
+        QM_EF_CAN_ELLIPSIS = 1 << 0,
+        QM_EF_CAN_CUT = 1 << 1,
+        QM_EF_CAN_COPY = 1 << 2,
+        QM_EF_CAN_PASTE = 1 << 3,
+    };
+
+    virtual ~NWebQuickMenuParams() = default;
+
+    virtual int32_t GetXCoord() = 0;
+
+    virtual int32_t GetYCoord() = 0;
+
+    virtual int32_t GetWidth() = 0;
+
+    virtual int32_t GetHeight() = 0;
+
+    virtual int32_t GetEditStateFlags() = 0;
+};
+
+enum MenuEventFlags {
+    EF_NONE = 0,
+    EF_CAPS_LOCK_ON = 1 << 0,
+    EF_SHIFT_DOWN = 1 << 1,
+    EF_CONTROL_DOWN = 1 << 2,
+    EF_ALT_DOWN = 1 << 3,
+    EF_LEFT_MOUSE_BUTTON = 1 << 4,
+    EF_MIDDLE_MOUSE_BUTTON = 1 << 5,
+    EF_RIGHT_MOUSE_BUTTON = 1 << 6,
+};
+
+class OHOS_NWEB_EXPORT NWebContextMenuCallback {
+public:
+    virtual ~NWebContextMenuCallback() = default;
+
+    virtual void Continue(int32_t commandId, MenuEventFlags flag) = 0;
+
+    virtual void Cancel() = 0;
+};
+
+class OHOS_NWEB_EXPORT NWebQuickMenuCallback {
+public:
+    virtual ~NWebQuickMenuCallback() = default;
+    
+    virtual void Continue(int32_t commandId, MenuEventFlags flag) = 0;
+    
+    virtual void Cancel() = 0;
+};
+}
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/include/nweb_data_base.h b/ohos_nweb/include/nweb_data_base.h
new file mode 100644
index 0000000000000..98249200b394d
--- /dev/null
+++ b/ohos_nweb/include/nweb_data_base.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_DATA_BASE_H
+#define NWEB_DATA_BASE_H
+
+#include <memory>
+#include <string>
+
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebDataBase {
+public:
+    NWebDataBase() = default;
+
+    virtual ~NWebDataBase() = default;
+
+    /**
+     * @brief Get whether instances holds any http authentication credentials.
+     *
+     * @return true if instances saved any http authentication credentials.
+     */
+    virtual bool ExistHttpAuthCredentials() const = 0;
+
+    /**
+     * @brief clear all saved authentication credentials.
+     *
+     */
+    virtual void DeleteHttpAuthCredentials() = 0;
+
+    /**
+     * @brief save http authentication credentials.
+     *
+     * @param host the host to which the credentials apply.
+     * @param realm the realm to which the credentials apply.
+     * @param username the username.
+     * @param password the password.
+     */
+    virtual void SaveHttpAuthCredentials(const std::string& host, const std::string& realm,
+        const std::string& username, const char* password) = 0;
+
+    /**
+     * @brief get username and password.
+     *
+     * @param host the host to which the credentials apply.
+     * @param realm the realm to which the credentials apply.
+     * @return return an array containing username and password.
+     */
+    virtual std::vector<std::string> GetHttpAuthCredentials(const std::string& host,
+        const std::string& realm) const = 0;
+};
+} // namespace OHOS::NWeb
+
+#endif  // NWEB_DATA_BASE_H
diff --git a/ohos_nweb/include/nweb_handler.h b/ohos_nweb/include/nweb_handler.h
index 89e8bc49d7e38..a2a45c970c3fd 100644
--- a/ohos_nweb/include/nweb_handler.h
+++ b/ohos_nweb/include/nweb_handler.h
@@ -21,12 +21,14 @@
 #include <string>
 #include <vector>
 
-#include "nweb_access_request.h"
 #include "nweb.h"
+#include "nweb_access_request.h"
 #include "nweb_console_log.h"
+#include "nweb_context_menu_params.h"
 #include "nweb_file_selector_params.h"
 #include "nweb_geolocation_callback_interface.h"
 #include "nweb_js_dialog_result.h"
+#include "nweb_js_http_auth_result.h"
 #include "nweb_url_resource_error.h"
 #include "nweb_url_resource_request.h"
 #include "nweb_url_resource_response.h"
@@ -290,7 +292,7 @@ public:
      * confirm that the user closed the window.
      * @return To show a custom dialog, the app should return true.
      */
-    virtual bool OnPromptDialogByJs(const std::string& url,
+    virtual bool OnPromptDialogByJS(const std::string& url,
                                     const std::string& message,
                                     const std::string& defaultValue,
                                     std::shared_ptr<NWebJSDialogResult> result) {
@@ -359,6 +361,28 @@ public:
                                     std::shared_ptr<NWebFileSelectorParams> params) {
         return false;
     }
+
+    virtual void OnScaleChanged(float oldScaleFactor, float newScaleFactor) {}
+
+    virtual bool RunContextMenu(std::shared_ptr<NWebContextMenuParams> params,
+                                std::shared_ptr<NWebContextMenuCallback> callback) {
+        return false;
+    }
+
+    virtual void OnContextMenuDismissed() {}
+
+    virtual bool RunQuickMenu(std::shared_ptr<NWebQuickMenuParams> params,
+                              std::shared_ptr<NWebQuickMenuCallback> callback) {
+        return false;
+    }
+
+    virtual void OnQuickMenuDismissed() {}
+
+    virtual bool OnHttpAuthRequestByJS(std::shared_ptr<NWebJSHttpAuthResult> result,
+                                       const std::string& host,
+                                       const std::string& realm) {
+        return false;
+    }
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_js_http_auth_result.h b/ohos_nweb/include/nweb_js_http_auth_result.h
new file mode 100755
index 0000000000000..be58adceb5db3
--- /dev/null
+++ b/ohos_nweb/include/nweb_js_http_auth_result.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NWEB_JS_HTTP_AUTH_RESULT_H
+#define NWEB_JS_HTTP_AUTH_RESULT_H
+
+#include <string>
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebJSHttpAuthResult {
+public:
+    virtual ~NWebJSHttpAuthResult() = default;
+    /**
+     * @brief Handle a confirmation response from the user.
+     */
+    virtual bool Confirm(std::string &userName, std::string &pwd) = 0;
+    /**
+     * @brief Handle the result if the user cancelled the dialog.
+     */
+    virtual void Cancel() = 0;
+    /**
+     * @brief Handle a IsHttpAuthInfoSaved response from the user.
+     */
+    virtual bool IsHttpAuthInfoSaved() = 0;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/include/nweb_url_resource_response.h b/ohos_nweb/include/nweb_url_resource_response.h
index f5755c54e81be..c0743d2430fea 100644
--- a/ohos_nweb/include/nweb_url_resource_response.h
+++ b/ohos_nweb/include/nweb_url_resource_response.h
@@ -179,7 +179,7 @@ private:
     int status_code_ = 200;
     std::string reason_phrase_;
     std::map<std::string, std::string> response_headers_;
-    std::string& input_stream_;
+    std::string input_stream_;
 };
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/ohos_nweb/include/nweb_web_storage.h b/ohos_nweb/include/nweb_web_storage.h
new file mode 100644
index 0000000000000..b380b7d3fbb7b
--- /dev/null
+++ b/ohos_nweb/include/nweb_web_storage.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_COOKIE_MANAGER_H
+#define NWEB_COOKIE_MANAGER_H
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "nweb_export.h"
+#include "nweb_value_callback.h"
+
+namespace OHOS::NWeb {
+class NWebWebStorageOrigin;
+using NWebGetOriginsCallback = NWebValueCallback<std::vector<NWebWebStorageOrigin>>;
+class OHOS_NWEB_EXPORT NWebWebStorage {
+public:
+    NWebWebStorage() = default;
+
+    virtual ~NWebWebStorage() = default;
+
+    virtual void DeleteAllData() = 0;
+    virtual void DeleteOrigin(const std::string& origin) = 0;
+    virtual void GetOrigins(std::shared_ptr<NWebGetOriginsCallback> callback) = 0;
+    virtual std::vector<NWebWebStorageOrigin> GetOrigins() = 0;
+    virtual void GetOriginQuota(const std::string& origin,
+                              std::shared_ptr<NWebValueCallback<long>> callback) = 0;
+    virtual long GetOriginQuota(const std::string& origin) = 0;
+    virtual void GetOriginUsage(const std::string& origin,
+                              std::shared_ptr<NWebValueCallback<long>> callback) = 0;
+    virtual long GetOriginUsage(const std::string& origin) = 0;
+};
+
+class OHOS_NWEB_EXPORT NWebWebStorageOrigin {
+public:
+    NWebWebStorageOrigin() = default;
+    ~NWebWebStorageOrigin() = default;
+    void SetOrigin(const std::string& origin) { origin_ = origin; }
+    void SetQuota(long quota) { quota_ = quota; }
+    void SetUsage(long usage) { usage_ = usage; }
+    std::string GetOrigin() { return origin_; }
+    long GetQuota() { return quota_; }
+    long GetUsage() { return usage_;}
+
+private:
+    std::string origin_;
+    int64_t quota_;
+    int64_t usage_;
+};
+}
+
+#endif  // NWebWebStorage
diff --git a/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc
new file mode 100644
index 0000000000000..81a7c77e493b5
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <unordered_map>
+
+#include "nweb_context_menu_params_impl.h"
+
+#include "nweb_context_menu_params.h"
+
+using namespace OHOS::NWeb;
+
+namespace {
+using CmTf = NWebContextMenuParams::ContextMenuTypeFlags;
+using CmMt = NWebContextMenuParams::ContextMenuMediaType;
+using CmEf = NWebContextMenuParams::ContextMenuEditStateFlags;
+using QmEf = NWebQuickMenuParams::QuickMenuEditStateFlags;
+
+const std::unordered_map<int, int> kCmTypeFlagMap = {
+  {CM_TYPEFLAG_NONE, CmTf::CM_TF_NONE},
+  {CM_TYPEFLAG_PAGE, CmTf::CM_TF_PAGE},
+  {CM_TYPEFLAG_FRAME, CmTf::CM_TF_FRAME},
+  {CM_TYPEFLAG_LINK, CmTf::CM_TF_LINK},
+  {CM_TYPEFLAG_MEDIA, CmTf::CM_TF_MEDIA},
+  {CM_TYPEFLAG_SELECTION, CmTf::CM_TF_SELECTION},
+  {CM_TYPEFLAG_EDITABLE, CmTf::CM_TF_EDITABLE},
+};
+
+const std::unordered_map<int, int> kCmMediaTypeMap = {
+  {CM_MEDIATYPE_NONE, CmMt::CM_MT_NONE},
+  {CM_MEDIATYPE_IMAGE, CmMt::CM_MT_IMAGE},
+  {CM_MEDIATYPE_VIDEO, CmMt::CM_MT_VIDEO},
+  {CM_MEDIATYPE_AUDIO, CmMt::CM_MT_AUDIO},
+  {CM_MEDIATYPE_FILE, CmMt::CM_MT_FILE},
+  {CM_MEDIATYPE_PLUGIN, CmMt::CM_MT_PLUGIN},
+};
+
+const std::unordered_map<int, int> kCmEditStateFlagsMap = {
+  {CM_EDITFLAG_NONE, CmEf::CM_ES_NONE},
+  {CM_EDITFLAG_CAN_UNDO, CmEf::CM_ES_CAN_UNDO},
+  {CM_EDITFLAG_CAN_REDO, CmEf::CM_ES_CAN_REDO},
+  {CM_EDITFLAG_CAN_CUT, CmEf::CM_ES_CAN_CUT},
+  {CM_EDITFLAG_CAN_COPY, CmEf::CM_ES_CAN_COPY},
+  {CM_EDITFLAG_CAN_PASTE, CmEf::CM_ES_CAN_PASTE},
+  {CM_EDITFLAG_CAN_DELETE, CmEf::CM_ES_CAN_DELETE},
+  {CM_EDITFLAG_CAN_SELECT_ALL, CmEf::CM_ES_CAN_SELECT_ALL},
+  {CM_EDITFLAG_CAN_TRANSLATE, CmEf::CM_ES_CAN_TRANSLATE},
+};
+
+const std::unordered_map<int, int> kQmEditStateFlagsMap = {
+  {QM_EDITFLAG_NONE, QmEf::QM_EF_NONE},
+  {QM_EDITFLAG_CAN_ELLIPSIS, QmEf::QM_EF_CAN_ELLIPSIS},
+  {QM_EDITFLAG_CAN_CUT, QmEf::QM_EF_CAN_CUT},
+  {QM_EDITFLAG_CAN_COPY, QmEf::QM_EF_CAN_COPY},
+  {QM_EDITFLAG_CAN_PASTE, QmEf::QM_EF_CAN_PASTE},
+};
+
+const std::unordered_map<int, int> KMenuEventFlagsMap = {
+  {EF_NONE, EVENTFLAG_NONE},
+  {EF_CAPS_LOCK_ON, EVENTFLAG_CAPS_LOCK_ON},
+  {EF_SHIFT_DOWN, EVENTFLAG_SHIFT_DOWN},
+  {EF_CONTROL_DOWN, EVENTFLAG_CONTROL_DOWN},
+  {EF_ALT_DOWN, EVENTFLAG_ALT_DOWN},
+  {EF_LEFT_MOUSE_BUTTON, EVENTFLAG_LEFT_MOUSE_BUTTON},
+  {EF_MIDDLE_MOUSE_BUTTON, EVENTFLAG_MIDDLE_MOUSE_BUTTON},
+  {EF_RIGHT_MOUSE_BUTTON, EVENTFLAG_RIGHT_MOUSE_BUTTON},
+};
+
+int32_t ConvertMenuFlags(int32_t value,
+  const std::unordered_map<int, int> &flags_map) {
+  int32_t result = 0;
+  for (auto& kv : flags_map) {
+    if ((kv.first & value) != 0) {
+      result |= kv.second;
+    }
+  }
+  return result;
+}
+
+CmMt ConvertContextMenuMediaType(
+  CefContextMenuParams::MediaType value) {
+  std::unordered_map<int, int>::const_iterator iter = 
+    kCmMediaTypeMap.find(static_cast<int32_t>(value));
+  if (iter != kCmMediaTypeMap.end()) {
+    return static_cast<CmMt>(iter->second);
+  }
+  return CmMt::CM_MT_NONE;
+}
+}
+
+namespace OHOS::NWeb {
+NWebContextMenuParamsImpl::NWebContextMenuParamsImpl(
+  CefRefPtr<CefContextMenuParams> params) : params_(params) {}
+
+int32_t NWebContextMenuParamsImpl::GetXCoord() {
+  if (params_ != nullptr) {
+    return params_->GetXCoord();
+  }
+  return -1;
+}
+
+int32_t NWebContextMenuParamsImpl::GetYCoord() {
+  if (params_ != nullptr) {
+    return params_->GetYCoord();
+  }
+  return -1;
+}
+
+int32_t NWebContextMenuParamsImpl::GetContextMenuTypeFlags() {
+  if (params_ != nullptr) {
+    return ConvertMenuFlags(params_->GetTypeFlags(), kCmTypeFlagMap);
+  }
+  return 0;
+}
+
+bool NWebContextMenuParamsImpl::HasImageContents() {
+  if (params_ != nullptr) {
+    return params_->HasImageContents();
+  }
+  return false;
+}
+
+std::string NWebContextMenuParamsImpl::GetTitleText() {
+  if (params_ != nullptr) {
+    return params_->GetTitleText();
+  }
+  return std::string();
+}
+
+std::string NWebContextMenuParamsImpl::GetPageUrl() {
+  if (params_ != nullptr) {
+    return params_->GetPageUrl();
+  }
+  return std::string();
+}
+
+CmMt NWebContextMenuParamsImpl::GetMediaType() {
+  if (params_ != nullptr) {
+    return ConvertContextMenuMediaType(params_->GetMediaType());
+  }
+  return CmMt::CM_MT_NONE;
+}
+
+bool NWebContextMenuParamsImpl::IsEditable() {
+  if (params_ != nullptr) {
+    return params_->HasImageContents();
+  }
+  return params_->IsEditable();
+}
+
+int32_t NWebContextMenuParamsImpl::GetEditStateFlags() {
+  if (params_ != nullptr) {
+    return ConvertMenuFlags(params_->GetEditStateFlags(), kCmEditStateFlagsMap);
+  }
+  return 0;
+}
+
+NWebQuickMenuParamsImpl::NWebQuickMenuParamsImpl(
+  int32_t x, int32_t y, int32_t width, int32_t height, int32_t flags)
+  : x_(x), y_(y), width_(width), height_(height),
+    edit_flags_(ConvertMenuFlags(flags, kQmEditStateFlagsMap)) {}
+
+int32_t NWebQuickMenuParamsImpl::GetXCoord() {
+  return x_;
+}
+
+int32_t NWebQuickMenuParamsImpl::GetYCoord() {
+  return y_;
+}
+
+int32_t NWebQuickMenuParamsImpl::GetWidth() {
+  return width_;
+}
+
+int32_t NWebQuickMenuParamsImpl::GetHeight() {
+  return height_;
+}
+
+int32_t NWebQuickMenuParamsImpl::GetEditStateFlags() {
+  return edit_flags_;
+}
+
+NWebContextMenuCallbackImpl::NWebContextMenuCallbackImpl(
+  CefRefPtr<CefRunContextMenuCallback> callback) : callback_(callback) {}
+
+void NWebContextMenuCallbackImpl::Continue(
+  int32_t commandId, MenuEventFlags flag) {
+  if (callback_ != nullptr) {
+    int32_t event_flag = 
+      ConvertMenuFlags(static_cast<int32_t>(flag), KMenuEventFlagsMap);
+    callback_->Continue(commandId,
+                        static_cast<cef_event_flags_t>(event_flag));
+  }
+}
+
+void NWebContextMenuCallbackImpl::Cancel() {
+  if (callback_ != nullptr) {
+    callback_->Cancel();
+  }
+}
+
+NWebQuickMenuCallbackImpl::NWebQuickMenuCallbackImpl(
+  CefRefPtr<CefRunQuickMenuCallback> callback) : callback_(callback) {}
+
+void NWebQuickMenuCallbackImpl::Continue(
+  int32_t commandId, MenuEventFlags flag) {
+  if (callback_ != nullptr) {
+    int32_t event_flag = 
+      ConvertMenuFlags(static_cast<int32_t>(flag), KMenuEventFlagsMap);
+    callback_->Continue(commandId,
+                        static_cast<cef_event_flags_t>(event_flag));
+  }
+}
+
+void NWebQuickMenuCallbackImpl::Cancel() {
+  if (callback_ != nullptr) {
+    callback_->Cancel();
+  }
+}
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h
new file mode 100644
index 0000000000000..67a277e72fb22
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_CONTEXT_MENU_PARAMS_IMPL_H
+#define NWEB_CONTEXT_MENU_PARAMS_IMPL_H
+
+#include "nweb_context_menu_params.h"
+
+#include "cef/include/cef_context_menu_handler.h"
+
+namespace OHOS::NWeb {
+class NWebContextMenuParamsImpl : public NWebContextMenuParams {
+ public:
+  explicit NWebContextMenuParamsImpl(
+      CefRefPtr<CefContextMenuParams> params);
+  int32_t GetXCoord() override;
+  int32_t GetYCoord() override;
+  int32_t GetContextMenuTypeFlags() override;
+  bool HasImageContents() override;
+  std::string GetTitleText() override;
+  std::string GetPageUrl() override;
+  ContextMenuMediaType GetMediaType() override;
+  bool IsEditable() override;
+  int32_t GetEditStateFlags() override;
+
+ private:
+  CefRefPtr<CefContextMenuParams> params_;
+};
+
+class NWebQuickMenuParamsImpl : public NWebQuickMenuParams {
+ public:
+  NWebQuickMenuParamsImpl(
+    int32_t x, int32_t y, int32_t width, int32_t height, int32_t flags);
+  int32_t GetXCoord() override;
+  int32_t GetYCoord() override;
+  int32_t GetWidth() override;
+  int32_t GetHeight() override;
+  int32_t GetEditStateFlags() override;
+
+ private:
+  int32_t x_;
+  int32_t y_;
+  int32_t width_;
+  int32_t height_;
+  int32_t edit_flags_;
+};
+
+class NWebContextMenuCallbackImpl : public NWebContextMenuCallback {
+ public:
+  explicit NWebContextMenuCallbackImpl(
+    CefRefPtr<CefRunContextMenuCallback> callback);
+  void Continue(int32_t commandId, MenuEventFlags flag) override;
+  void Cancel() override;
+ private:
+  CefRefPtr<CefRunContextMenuCallback> callback_;
+};
+
+class NWebQuickMenuCallbackImpl : public NWebQuickMenuCallback {
+ public:
+  explicit NWebQuickMenuCallbackImpl(
+    CefRefPtr<CefRunQuickMenuCallback> callback);
+  void Continue(int32_t commandId, MenuEventFlags flag) override;
+  void Cancel() override;
+ private:
+  CefRefPtr<CefRunQuickMenuCallback> callback_;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
index 3870cdb3a7fe2..18084ffe5b7fa 100644
--- a/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
@@ -133,7 +133,6 @@ class ReturnCookieVisitor : public CefCookieVisitor {
       }
       return true;
     }
-    deleteCookie = !cookie.has_expires ? delete_session_ : false;
     cookies_.push_back(cookie);
     return true;
   }
@@ -154,7 +153,6 @@ class ReturnCookieVisitor : public CefCookieVisitor {
   std::string ReturnCookieLine() const { return cookie_line_; }
 
  private:
-  bool delete_session_;
   std::shared_ptr<WaitableEvent> event_;
   std::string cookie_line_;
   std::vector<CefCookie> cookies_;
diff --git a/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc
new file mode 100644
index 0000000000000..6ff1f635af9de
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "nweb_data_base_delegate.h"
+
+#include <vector>
+
+#include "base/logging.h"
+
+namespace OHOS::NWeb {
+
+CefRefPtr<CefDataBase> NWebDataBaseDelegate::GetGlobalCefDataBase() {
+  if (data_base_ == nullptr) {
+    data_base_ = CefDataBase::GetGlobalDataBase();
+  }
+  return data_base_;
+}
+
+bool NWebDataBaseDelegate::ExistHttpAuthCredentials() {
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return false;
+  }
+  return data_base->ExistHttpAuthCredentials();
+}
+
+void NWebDataBaseDelegate::DeleteHttpAuthCredentials() {
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return;
+  }
+  data_base->DeleteHttpAuthCredentials();
+}
+
+void NWebDataBaseDelegate::SaveHttpAuthCredentials(const std::string& host, 
+  const std::string& realm,
+  const std::string& username, const char* password) {
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return;
+  }
+  return data_base->SaveHttpAuthCredentials(host, realm,username, password);
+}
+
+std::vector<std::string> NWebDataBaseDelegate::GetHttpAuthCredentials(const std::string& host, const std::string& realm) {
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return {};
+  }
+
+  std::vector<CefString> method_vector;
+  data_base->GetHttpAuthCredentials(host, realm, method_vector);
+
+  std::vector<std::string> username_password;
+  for (std::string value : method_vector) {
+    username_password.push_back(value);
+  }
+  return username_password;
+}
+
+bool NWebDataBaseDelegate::ExistFormData() {
+  return false;
+}
+
+void NWebDataBaseDelegate::ClearFormData() {
+  return;
+}
+
+}  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h
new file mode 100644
index 0000000000000..70fa3303f66b4
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_DATA_BASE_DELEGATE_H
+#define NWEB_DATA_BASE_DELEGATE_H
+
+#include <string>
+
+#include "cef_data_base.h"
+#include "cef/include/cef_base.h"
+
+namespace OHOS::NWeb {
+class NWebDataBaseDelegate {
+ public:
+  NWebDataBaseDelegate() = default;
+
+  ~NWebDataBaseDelegate() = default;
+
+  bool ExistHttpAuthCredentials();
+
+  void DeleteHttpAuthCredentials();
+
+  void SaveHttpAuthCredentials(const std::string& host, const std::string& realm,
+    const std::string& username, const char* password);
+
+  std::vector<std::string> GetHttpAuthCredentials(const std::string& host, const std::string& realm);
+
+  bool ExistFormData();
+
+  void ClearFormData();
+
+ private:
+  CefRefPtr<CefDataBase> GetGlobalCefDataBase();
+
+  CefRefPtr<CefDataBase> data_base_ = nullptr;
+};
+}  // namespace OHOS::NWeb
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_delegate.cc
index 4a47e77222920..654fe5694a896 100755
--- a/ohos_nweb/src/cef_delegate/nweb_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_delegate.cc
@@ -25,6 +25,9 @@
 #include "nweb_preference_delegate.h"
 
 namespace OHOS::NWeb {
+
+static const float maxZoomFactor = 10.0;
+
 class JavaScriptResultCallbackImpl : public CefJavaScriptResultCallback {
  public:
   JavaScriptResultCallbackImpl(
@@ -46,19 +49,51 @@ class JavaScriptResultCallbackImpl : public CefJavaScriptResultCallback {
 NWebDelegate::NWebDelegate(int argc, const char* argv[])
     : argc_(argc), argv_(argv) {}
 
+NWebDelegate::~NWebDelegate() {
+  if (display_listener_ != nullptr &&
+      display_manager_adapter_ != nullptr) {
+    display_manager_adapter_->UnregisterDisplayListener(display_listener_);
+  }
+}
+
 bool NWebDelegate::Init(void* window) {
   preference_delegate_ = std::make_shared<NWebPreferenceDelegate>();
 
+  display_manager_adapter_ =
+    OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
+  if (display_manager_adapter_ == nullptr) {
+    return false;
+  }
+
+  display_listener_ =
+    std::make_shared<DisplayScreenListener>(shared_from_this());
+  if (display_listener_ == nullptr) {
+    return false;
+  }
+
+  if (!display_manager_adapter_->RegisterDisplayListener(display_listener_)) {
+    LOG(ERROR) << "jcz RegisterDisplayListener failed";
+    return false;
+  }
+
   render_handler_ = NWebRenderHandler::Create();
   if (render_handler_ == nullptr) {
+    display_manager_adapter_->UnregisterDisplayListener(display_listener_);
     return false;
   }
 
   event_handler_ = NWebEventHandler::Create();
   if (event_handler_ == nullptr) {
+    display_manager_adapter_->UnregisterDisplayListener(display_listener_);
     return false;
   }
 
+  std::shared_ptr<DisplayAdapter> display =
+    display_manager_adapter_->GetDefaultDisplay();
+  if (display != nullptr) {
+    NotifyScreenInfoChanged(display->GetRotation(), display->GetOrientation());
+  }
+
   std::string url_for_init = "";
   InitializeCef(url_for_init, window);
 
@@ -66,16 +101,16 @@ bool NWebDelegate::Init(void* window) {
 }
 
 void NWebDelegate::OnDestroy(bool is_close_all) {
+  if (display_listener_ != nullptr &&
+      display_manager_adapter_ != nullptr) {
+    display_manager_adapter_->UnregisterDisplayListener(display_listener_);
+  }
   if (handler_delegate_ != nullptr) {
     handler_delegate_->OnDestroy();
   }
   if (preference_delegate_ != nullptr) {
     preference_delegate_->OnDestroy();
   }
-  if (is_close_all) {
-    LOG(INFO) << "ready to shutdown";
-    CefShutdown();
-  }
 }
 
 void NWebDelegate::RegisterDownLoadListener(
@@ -155,6 +190,30 @@ bool NWebDelegate::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
   return retVal;
 }
 
+void NWebDelegate::SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) {
+  if (event_handler_ != nullptr) {
+    event_handler_->SendMouseWheelEvent(x, y, deltaX, deltaY);
+  }
+}
+
+void NWebDelegate::SendMouseEvent(int x, int y, int button, int action) {
+  if (event_handler_ != nullptr) {
+    event_handler_->SendMouseEvent(x, y, button, action);
+  }
+}
+
+void NWebDelegate::NotifyScreenInfoChanged(
+  RotationType rotation,
+  OrientationType orientation) {
+  if (render_handler_ != nullptr) {
+    render_handler_->SetOrientation(rotation, orientation);
+    auto browser = GetBrowser();
+    if (browser != nullptr && browser->GetHost() != nullptr) {
+      browser->GetHost()->NotifyScreenInfoChanged();
+    }
+  }
+}
+
 std::shared_ptr<NWebPreference> NWebDelegate::GetPreference() const {
   return preference_delegate_;
 }
@@ -206,6 +265,13 @@ void NWebDelegate::NavigateForward() const {
   }
 }
 
+void NWebDelegate::NavigateBackOrForward(int step) const {
+  LOG(INFO) << "NWebDelegate::NavigateBackOrForward";
+  if (GetBrowser().get()) {
+    GetBrowser()->GoBackOrForward(step);
+  }
+}
+
 void NWebDelegate::DeleteNavigateHistory() {
   LOG(INFO) << "NWebDelegate::DeleteNavigateHistory";
   if (GetBrowser().get()) {
@@ -220,6 +286,13 @@ void NWebDelegate::Reload() const {
   }
 }
 
+void NWebDelegate::ReloadOriginalUrl() const {
+  LOG(INFO) << "NWebDelegate::ReloadOriginalUrl";
+  if (GetBrowser().get()) {
+    GetBrowser()->ReloadOriginalUrl();
+  }
+}
+
 void NWebDelegate::Zoom(float zoomFactor) const {
   LOG(INFO) << "NWebDelegate::Zoom";
   if (GetBrowser().get()) {
@@ -228,6 +301,52 @@ void NWebDelegate::Zoom(float zoomFactor) const {
   }
 }
 
+bool NWebDelegate::ZoomIn() const {
+  LOG(INFO) << "NWebDelegate::ZoomIn";
+  if (!GetBrowser().get()) {
+    return false;
+  }
+  double curFactor = GetBrowser()->GetHost()->GetZoomLevel();
+  if (zoom_in_factor_ + curFactor > maxZoomFactor) {
+    return false;
+  }
+  GetBrowser()->GetHost()->SetZoomLevel(zoom_in_factor_ + curFactor);
+  return true;
+}
+
+bool NWebDelegate::ZoomOut() const {
+  LOG(INFO) << "NWebDelegate::ZoomOut";
+  if (!GetBrowser().get()) {
+    return false;
+  }
+  double curFactor = GetBrowser()->GetHost()->GetZoomLevel();
+  if (zoom_in_factor_ + curFactor < 0) {
+    return false;
+  }
+  GetBrowser()->GetHost()->SetZoomLevel(zoom_out_factor_ + curFactor);
+  return true;
+}
+
+bool NWebDelegate::SetZoomInFactor(float factor)
+{
+  LOG(INFO) << "NWebDelegate::SetZoomInFactor";
+  if (factor <= 0) {
+    return false;
+  }
+  zoom_in_factor_ = factor;
+  return true;
+}
+
+bool NWebDelegate::SetZoomOutFactor(float factor)
+{
+  LOG(INFO) << "NWebDelegate::SetZoomOutFactor";
+  if (factor >= 0) {
+    return false;
+  }
+  zoom_out_factor_ = factor;
+  return true;
+}
+
 void NWebDelegate::Stop() const {
   LOG(INFO) << "NWebDelegate::Stop";
   if (GetBrowser().get()) {
@@ -262,6 +381,17 @@ void NWebDelegate::PutBackgroundColor(int color) const {
   }
 }
 
+void NWebDelegate::InitialScale(float scale) const {
+  LOG(INFO) << "NWebDelegate::InitialScale";
+  if (scale == intial_scale_) {
+    return;
+  }
+
+  if (GetBrowser().get()) {
+    GetBrowser()->GetHost()->SetInitialScale(scale);
+  }
+}
+
 void NWebDelegate::OnPause() {
   LOG(INFO) << "NWebDelegate::OnPause";
   if (!GetBrowser().get()) {
@@ -485,4 +615,22 @@ void NWebDelegate::RegisterNWebJavaScriptCallBack(
   }
   handler_delegate_->RegisterNWebJavaScriptCallBack(callback);
 }
-}  // namespace OHOS::NWeb
\ No newline at end of file
+
+void NWebDelegate::OnFocus() const {
+  LOG(INFO) << "NWebDelegate::OnFocus";
+  if (!GetBrowser().get()) {
+    return;
+  }
+
+  GetBrowser()->GetHost()->SendFocusEvent(true);
+}
+
+void NWebDelegate::OnBlur() const {
+  LOG(INFO) << "NWebDelegate::OnBlur";
+  if (!GetBrowser().get()) {
+    return;
+  }
+
+  GetBrowser()->GetHost()->SendFocusEvent(false);
+}
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_delegate.h b/ohos_nweb/src/cef_delegate/nweb_delegate.h
index 63ad48c690a29..43e74826868ba 100755
--- a/ohos_nweb/src/cef_delegate/nweb_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_delegate.h
@@ -21,17 +21,19 @@
 #include "cef/include/cef_command_line.h"
 #include "nweb_application.h"
 #include "nweb_delegate_interface.h"
+#include "nweb_display_listener.h"
 #include "nweb_event_handler.h"
 #include "nweb_handler_delegate.h"
 #include "nweb_inputmethod_client.h"
 #include "nweb_render_handler.h"
+#include "ohos_adapter_helper.h"
 
 namespace OHOS::NWeb {
 class NWebDelegate : public NWebDelegateInterface,
                         public virtual CefRefCount {
  public:
   NWebDelegate(int argc, const char* argv[]);
-  ~NWebDelegate() = default;
+  ~NWebDelegate();
   bool Init(void* window);
 
   bool IsReady() override;
@@ -52,6 +54,10 @@ class NWebDelegate : public NWebDelegateInterface,
   void OnTouchMove(int32_t id, double x, double y) override;
   void OnTouchCancel() override;
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction) override;
+  void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) override;
+  void SendMouseEvent(int x, int y, int button, int action) override;
+  void NotifyScreenInfoChanged(RotationType rotation,
+                               OrientationType orientation) override;
 
   void Load(const std::string& url) override;
   bool IsNavigatebackwardAllowed() const override;
@@ -59,15 +65,20 @@ class NWebDelegate : public NWebDelegateInterface,
   bool CanNavigateBackOrForward(int num_steps) const override;
   void NavigateBack() const override;
   void NavigateForward() const override;
+  void NavigateBackOrForward(int32_t step) const override;
   void DeleteNavigateHistory() override;
   void Reload() const override;
+  void ReloadOriginalUrl() const override;
   void Zoom(float zoomFactor) const override;
+  bool ZoomIn() const override;
+  bool ZoomOut() const override;
   void Stop() const override;
   void ExecuteJavaScript(const std::string& code) const override;
   void ExecuteJavaScript(
       const std::string& code,
       std::shared_ptr<NWebValueCallback<std::string>> callback) const override;
   void PutBackgroundColor(int color) const override;
+  void InitialScale(float scale) const override;
   void OnPause() override;
   void OnContinue() override;
   std::shared_ptr<NWebPreference> GetPreference() const override;
@@ -96,7 +107,10 @@ class NWebDelegate : public NWebDelegateInterface,
 
   void RegisterNWebJavaScriptCallBack(
       std::shared_ptr<NWebJavaScriptResultCallBack> callback) override;
-
+  void OnFocus() const override;
+  void OnBlur() const override;
+  bool SetZoomInFactor(float factor);
+  bool SetZoomOutFactor(float factor);
  public:
   int argc_;
   const char** argv_;
@@ -108,13 +122,19 @@ class NWebDelegate : public NWebDelegateInterface,
   void RequestVisitedHistory();
 
  private:
+  float zoom_in_factor_ = 2.0;
+  float zoom_out_factor_ = -2.0;
+  float intial_scale_ = 0;
   bool has_requested_visited_history = false;
   CefRefPtr<NWebApplication> nweb_app_ = nullptr;
   CefRefPtr<NWebHandlerDelegate> handler_delegate_ = nullptr;
   CefRefPtr<NWebRenderHandler> render_handler_ = nullptr;
   std::shared_ptr<NWebEventHandler> event_handler_ = nullptr;
   std::shared_ptr<NWebPreferenceDelegate> preference_delegate_ = nullptr;
-
+  std::unique_ptr<OHOS::NWeb::DisplayManagerAdapter>
+    display_manager_adapter_ = nullptr;
+  std::shared_ptr<OHOS::NWeb::DisplayScreenListener>
+    display_listener_ = nullptr;
   // Members only accessed on the main thread.
   bool hidden_ = false;
 };
diff --git a/ohos_nweb/src/cef_delegate/nweb_display_listener.cc b/ohos_nweb/src/cef_delegate/nweb_display_listener.cc
new file mode 100644
index 0000000000000..037d93ad61a5c
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_display_listener.cc
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_display_listener.h"
+
+#include "base/logging.h"
+
+namespace OHOS::NWeb {
+DisplayScreenListener::DisplayScreenListener(
+  std::shared_ptr<NWebDelegateInterface> nweb)
+  : nweb_(nweb) {
+  display_manager_adapter_ =
+    OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
+}
+
+void DisplayScreenListener::OnCreate(DisplayId id) {}
+
+void DisplayScreenListener::OnDestroy(DisplayId id) {}
+
+void DisplayScreenListener::OnChange(DisplayId id) {
+  if (display_manager_adapter_ == nullptr) {
+    LOG(ERROR) << "display manager adapter is nullptr";
+    return;
+  }
+
+  if (id == display_manager_adapter_->GetDefaultDisplayId()) {
+    std::shared_ptr<DisplayAdapter> display =
+      display_manager_adapter_->GetDefaultDisplay();
+    if (nweb_ != nullptr && display != nullptr) {
+      nweb_->NotifyScreenInfoChanged(display->GetRotation(), display->GetOrientation());
+    } else {
+      LOG(ERROR) << "notify screen info change failed";
+    }
+  }
+}
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_display_listener.h b/ohos_nweb/src/cef_delegate/nweb_display_listener.h
new file mode 100644
index 0000000000000..c6d958d364054
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_display_listener.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_DISPLAY_LISTENER_H
+#define NWEB_DISPLAY_LISTENER_H
+
+#include <memory>
+
+#include "nweb_impl.h"
+#include "ohos_adapter_helper.h"
+
+namespace OHOS::NWeb {
+class DisplayScreenListener : public DisplayListenerAdapter {
+ public:
+  explicit DisplayScreenListener(
+      std::shared_ptr<NWebDelegateInterface> nweb);
+  ~DisplayScreenListener() = default;
+  void OnCreate(DisplayId id) override;
+  void OnDestroy(DisplayId id) override;
+  void OnChange(DisplayId id) override;
+ private:
+  std::shared_ptr<NWebDelegateInterface> nweb_;
+  std::unique_ptr<DisplayManagerAdapter>
+    display_manager_adapter_;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_event_handler.cc b/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
index 99d1b5f0e7232..2b02a41cfbacd 100644
--- a/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
@@ -20,6 +20,9 @@
 #include "cef/include/internal/cef_types.h"
 #include "cef/include/internal/cef_types_wrappers.h"
 
+#include "ui/events/keycodes/keyboard_code_conversion_x.h"
+#include "ui/events/keycodes/keysym_to_unicode.h"
+
 namespace OHOS::NWeb {
 // static
 std::shared_ptr<NWebEventHandler> NWebEventHandler::Create() {
@@ -86,12 +89,66 @@ void NWebEventHandler::OnTouchCancel() {
 bool NWebEventHandler::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
   CefKeyEvent keyEvent;
   input_delegate_.SetModifiers(keyCode, keyAction);
-  keyEvent.windows_key_code = NWebInputDelegate::CefConverter("keycode", keyCode);
-  keyEvent.type = static_cast<cef_key_event_type_t>(NWebInputDelegate::CefConverter("keyaction", keyAction));
+  keyEvent.windows_key_code =
+      NWebInputDelegate::CefConverter("keycode", keyCode);
+  keyEvent.type = static_cast<cef_key_event_type_t>(
+      NWebInputDelegate::CefConverter("keyaction", keyAction));
   keyEvent.modifiers = input_delegate_.GetModifiers();
+  keyEvent.is_system_key = false;
+  keyEvent.native_key_code =
+      NWebInputDelegate::CefConverter("keyscancode", keyCode);
+  ui::KeyboardCode key_code =
+      static_cast<ui::KeyboardCode>(keyEvent.windows_key_code);
+  int keysym = ui::XKeysymForWindowsKeyCode(
+      key_code, keyEvent.modifiers & EVENTFLAG_SHIFT_DOWN);
+  char16_t character = ui::GetUnicodeCharacterFromXKeySym(keysym);
+  keyEvent.character = keyEvent.unmodified_character = character;
   if (browser_ && browser_->GetHost()) {
     browser_->GetHost()->SendKeyEvent(keyEvent);
   }
+
+  if (keyEvent.type == KEYEVENT_RAWKEYDOWN) {
+    keyEvent.type = KEYEVENT_CHAR;
+    if (browser_ && browser_->GetHost()) {
+      browser_->GetHost()->SendKeyEvent(keyEvent);
+    }
+  }
+
   return false;
 }
+
+void NWebEventHandler::SendMouseWheelEvent(double x,
+                                           double y,
+                                           double deltaX,
+                                           double deltaY) {
+  CefMouseEvent mouseEvent;
+  mouseEvent.x = x;
+  mouseEvent.y = y;
+  mouseEvent.modifiers = input_delegate_.GetModifiers();
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendMouseWheelEvent(
+        mouseEvent, deltaX * input_delegate_.GetMouseWheelRatio(),
+        deltaY * input_delegate_.GetMouseWheelRatio());
+  }
+}
+
+void NWebEventHandler::SendMouseEvent(int x, int y, int button, int action) {
+  CefMouseEvent mouseEvent;
+  mouseEvent.x = x;
+  mouseEvent.y = y;
+  cef_mouse_button_type_t buttonType = static_cast<cef_mouse_button_type_t>(
+      NWebInputDelegate::CefConverter("mousebutton", button));
+  mouseEvent.modifiers = input_delegate_.GetModifiers(buttonType);
+
+  if (browser_ && browser_->GetHost()) {
+    if (NWebInputDelegate::IsMouseDown(action)) {
+      browser_->GetHost()->SendMouseClickEvent(mouseEvent, buttonType, false,
+                                               1);
+    } else if (NWebInputDelegate::IsMouseUp(action)) {
+      browser_->GetHost()->SendMouseClickEvent(mouseEvent, buttonType, true, 1);
+    } else if (NWebInputDelegate::IsMouseMove(action)) {
+      browser_->GetHost()->SendMouseMoveEvent(mouseEvent, false);
+    }
+  }
+}
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_event_handler.h b/ohos_nweb/src/cef_delegate/nweb_event_handler.h
index 0ef2e92f3e0a6..963202633b2af 100644
--- a/ohos_nweb/src/cef_delegate/nweb_event_handler.h
+++ b/ohos_nweb/src/cef_delegate/nweb_event_handler.h
@@ -18,6 +18,7 @@
 
 #include "cef/include/cef_client.h"
 #include "nweb_input_delegate.h"
+#include "nweb_inputmethod_handler.h"
 
 namespace OHOS::NWeb {
 class NWebEventHandler {
@@ -36,8 +37,11 @@ class NWebEventHandler {
   void OnTouchCancel();
   void OnKeyBack();
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction);
+  void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY);
+  void SendMouseEvent(int x, int y, int button, int action);
 
  private:
+  bool IsCharInputEvent(CefKeyEvent& keyEvent);
   CefRefPtr<CefBrowser> browser_ = nullptr;
   NWebInputDelegate input_delegate_;
 };
diff --git a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
index 04dc120990181..3daf76d7ab25f 100755
--- a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
@@ -24,9 +24,11 @@
 #include "cef/include/wrapper/cef_closure_task.h"
 #include "cef/include/wrapper/cef_helpers.h"
 #include "nweb_access_request_delegate.h"
+#include "nweb_context_menu_params_impl.h"
 #include "nweb_file_selector_params_impl.h"
 #include "nweb_geolocation_callback.h"
 #include "nweb_js_dialog_result_impl.h"
+#include "nweb_js_http_auth_result_impl.h"
 #include "nweb_resource_handler.h"
 #include "nweb_url_resource_error_impl.h"
 #include "nweb_url_resource_request_impl.h"
@@ -218,6 +220,10 @@ CefRefPtr<CefDialogHandler> NWebHandlerDelegate::GetDialogHandler() {
   return this;
 }
 
+CefRefPtr<CefContextMenuHandler> NWebHandlerDelegate::GetContextMenuHandler() {
+  return this;
+}
+
 bool NWebHandlerDelegate::OnProcessMessageReceived(
     CefRefPtr<CefBrowser> browser,
     CefRefPtr<CefFrame> frame,
@@ -330,6 +336,9 @@ void NWebHandlerDelegate::OnLoadStart(CefRefPtr<CefBrowser> browser,
                                       CefRefPtr<CefFrame> frame,
                                       TransitionType transition_type) {
   LOG(INFO) << "NWebHandlerDelegate::OnLoadStart";
+  if (frame == nullptr || !frame->IsMain()) {
+    return;
+  }
   if (browser != nullptr && browser->GetHost() != nullptr) {
     browser->GetHost()->SetFocus(true);
   }
@@ -451,13 +460,13 @@ bool NWebHandlerDelegate::OnBeforeBrowse(CefRefPtr<CefBrowser> browser,
                                          bool is_redirect) {
   LOG(INFO) << "NWebHandlerDelegate::OnBeforeBrowse";
   (void)(browser);
-  (void)(request);
+  (void)(frame);
   (void)(user_gesture);
   (void)(is_redirect);
 
   if (nweb_handler_ != nullptr) {
     return nweb_handler_->OnHandleInterceptUrlLoading(
-        frame->GetURL().ToString());
+        request->GetURL().ToString());
   }
   return false;
 }
@@ -511,6 +520,26 @@ void NWebHandlerDelegate::OnRenderProcessTerminated(CefRefPtr<CefBrowser> browse
   LOG(INFO) << "render process exit, reason = " << static_cast<int>(reason);
   nweb_handler_->OnRenderExited(reason);
 }
+
+bool NWebHandlerDelegate::GetAuthCredentials(
+    CefRefPtr<CefBrowser> browser,
+    const CefString& origin_url,
+    bool isProxy,
+    const CefString& host,
+    int port,
+    const CefString& realm,
+    const CefString& scheme,
+    CefRefPtr<CefAuthCallback> callback)
+{
+  CEF_REQUIRE_IO_THREAD();
+  LOG(INFO) << "NWebHandlerDelegate: GetAuthCredentials";
+  std::shared_ptr<NWebJSHttpAuthResult> js_result = std::make_shared<NWebJSHttpAuthResultImpl>(callback);
+  if (nweb_handler_ != nullptr) {
+    return nweb_handler_->OnHttpAuthRequestByJS(js_result, host, realm);
+  }
+  return false;
+}
+
 /* CefRequestHandler methods end */
 
 /* CefDownloadHandler methods begin */
@@ -561,7 +590,6 @@ CefRefPtr<CefResourceHandler> NWebHandlerDelegate::GetResourceHandler(
     CefRefPtr<CefBrowser> browser,
     CefRefPtr<CefFrame> frame,
     CefRefPtr<CefRequest> request) {
-  LOG(INFO) << "NWebHandlerDelegate::GetResourceHandler";
   if (!request) {
     LOG(ERROR) << "NWebHandlerDelegate::GetResourceHandler request is null";
     return nullptr;
@@ -646,6 +674,15 @@ bool NWebHandlerDelegate::OnConsoleMessage(CefRefPtr<CefBrowser> browser,
   }
   return false;
 }
+
+void NWebHandlerDelegate::OnScaleChanged(CefRefPtr<CefBrowser> browser,
+                                         float old_page_scale_factor,
+                                         float new_page_scale_factor) {
+  if (nweb_handler_ != nullptr) {
+    LOG(INFO) << "OnScaleChanged new scale: " << new_page_scale_factor << " old scale: " << old_page_scale_factor;
+    nweb_handler_->OnScaleChanged(old_page_scale_factor, new_page_scale_factor);
+  }
+}
 /* CefDisplayHandler method end */
 
 /* CefFocusHandler method begin */
@@ -720,7 +757,7 @@ bool NWebHandlerDelegate::OnJSDialog(CefRefPtr<CefBrowser> browser,
       return nweb_handler_->OnConfirmDialogByJS(origin_url, message_text,
                                                 js_result);
     case JSDIALOGTYPE_PROMPT:
-      return nweb_handler_->OnPromptDialogByJs(origin_url, message_text,
+      return nweb_handler_->OnPromptDialogByJS(origin_url, message_text,
                                                default_prompt_text, js_result);
     default:
       break;
@@ -787,6 +824,95 @@ bool NWebHandlerDelegate::OnFileDialog(
 }
 /* CefDialogHandler method end */
 
+/* CefContextMenuHandler method begin */
+void NWebHandlerDelegate::OnBeforeContextMenu(
+  CefRefPtr<CefBrowser> browser,
+  CefRefPtr<CefFrame> frame,
+  CefRefPtr<CefContextMenuParams> params,
+  CefRefPtr<CefMenuModel> model) {
+  LOG(INFO) << "NWebHandlerDelegate::OnBeforeContextMenu";
+}
+
+void NWebHandlerDelegate::OnGetImageForContextNode(
+  CefRefPtr<CefImage> image) {
+  if (image != nullptr &&
+      image->GetWidth() > 0 && image->GetHeight() > 0) {
+    // TODO: Copy or other operation    
+  } else {
+    LOG(WARNING) << "OnGetImageForContextNode image is invalid";
+  }
+}
+
+bool NWebHandlerDelegate::RunContextMenu(
+  CefRefPtr<CefBrowser> browser,
+  CefRefPtr<CefFrame> frame,
+  CefRefPtr<CefContextMenuParams> params,
+  CefRefPtr<CefMenuModel> model,
+  CefRefPtr<CefRunContextMenuCallback> callback) {
+  if (nweb_handler_ == nullptr) {
+    return false;
+  }
+  std::shared_ptr<NWebContextMenuParams> nweb_param =
+    std::make_shared<NWebContextMenuParamsImpl>(params);
+  std::shared_ptr<NWebContextMenuCallback> nweb_callback =
+    std::make_shared<NWebContextMenuCallbackImpl>(callback);
+  return nweb_handler_->RunContextMenu(nweb_param, nweb_callback);
+}
+
+bool NWebHandlerDelegate::OnContextMenuCommand(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame,
+    CefRefPtr<CefContextMenuParams> params,
+  int command_id,
+  CefContextMenuHandler::EventFlags event_flags) {
+  // TODO: Execute commands such as copy paste etc.
+  return false;
+}
+
+void NWebHandlerDelegate::OnContextMenuDismissed(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame) {
+  if (nweb_handler_ != nullptr) {
+    nweb_handler_->OnContextMenuDismissed();
+  }
+}
+
+bool NWebHandlerDelegate::RunQuickMenu(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame,
+    const CefPoint& location,
+    const CefSize& size,
+    CefContextMenuHandler::QuickMenuEditStateFlags edit_state_flags,
+    CefRefPtr<CefRunQuickMenuCallback> callback) {
+  if (nweb_handler_ == nullptr) {
+    return false;
+  }
+  std::shared_ptr<NWebQuickMenuParams> nweb_param =
+    std::make_shared<NWebQuickMenuParamsImpl>(location.x, location.y,
+      size.width, size.height, edit_state_flags);
+  std::shared_ptr<NWebQuickMenuCallback> nweb_callback =
+    std::make_shared<NWebQuickMenuCallbackImpl>(callback);
+  return nweb_handler_->RunQuickMenu(nweb_param, nweb_callback);
+}
+
+bool NWebHandlerDelegate::OnQuickMenuCommand(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame,
+    int command_id,
+    CefContextMenuHandler::EventFlags event_flags) {
+  // TODO: Execute commands such as copy paste etc.
+  return false;
+}
+
+void NWebHandlerDelegate::OnQuickMenuDismissed(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame) {
+  if (nweb_handler_ != nullptr) {
+    nweb_handler_->OnQuickMenuDismissed();
+  }
+}
+/* CefContextMenuHandler method end */
+
 const std::vector<std::string> NWebHandlerDelegate::GetVisitedHistory() {
   if (nweb_handler_ != nullptr) {
     return nweb_handler_->VisitedUrlHistory();
diff --git a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
index b977a6be0698c..0a3920c156aa0 100755
--- a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
@@ -49,7 +49,8 @@ class NWebHandlerDelegate : public CefClient,
                             public CefFocusHandler,
                             public CefPermissionRequest,
                             public CefJSDialogHandler,
-                            public CefDialogHandler {
+                            public CefDialogHandler,
+                            public CefContextMenuHandler {
  public:
   static CefRefPtr<NWebHandlerDelegate> Create(
       std::shared_ptr<NWebPreferenceDelegate> preference_delegate,
@@ -86,6 +87,7 @@ class NWebHandlerDelegate : public CefClient,
   CefRefPtr<CefPermissionRequest> GetPermissionRequest() override;
   CefRefPtr<CefJSDialogHandler> GetJSDialogHandler() override;
   CefRefPtr<CefDialogHandler> GetDialogHandler() override;
+  CefRefPtr<CefContextMenuHandler> GetContextMenuHandler() override;
   virtual bool OnProcessMessageReceived(
       CefRefPtr<CefBrowser> browser,
       CefRefPtr<CefFrame> frame,
@@ -175,6 +177,15 @@ class NWebHandlerDelegate : public CefClient,
 
   void OnRenderProcessTerminated(CefRefPtr<CefBrowser> browser,
                                  TerminationStatus status) override;
+
+  bool GetAuthCredentials(CefRefPtr<CefBrowser> browser,
+                          const CefString& origin_url,
+                          bool isProxy,
+                          const CefString& host,
+                          int port,
+                          const CefString& realm,
+                          const CefString& scheme,
+                          CefRefPtr<CefAuthCallback> callback) override;
   /* CefRequestHandler methods end */
 
   /* CefDownloadHandler methods begin */
@@ -215,6 +226,9 @@ class NWebHandlerDelegate : public CefClient,
                         const CefString& message,
                         const CefString& source,
                         int line) override;
+  void OnScaleChanged(CefRefPtr<CefBrowser> browser,
+                      float old_page_scale_factor,
+                      float new_page_scale_factor) override;
   /* CefDisplayHandler method end */
 
   /* CefFocusHandler method begin */
@@ -257,6 +271,38 @@ class NWebHandlerDelegate : public CefClient,
                     CefRefPtr<CefFileDialogCallback> callback) override;
   /* CefDialogHandler method end */
 
+  /* CefContextMenuHandler method begin */
+  void OnBeforeContextMenu(CefRefPtr<CefBrowser> browser,
+                           CefRefPtr<CefFrame> frame,
+                           CefRefPtr<CefContextMenuParams> params,
+                           CefRefPtr<CefMenuModel> model) override;
+  bool RunContextMenu(CefRefPtr<CefBrowser> browser,
+                      CefRefPtr<CefFrame> frame,
+                      CefRefPtr<CefContextMenuParams> params,
+                      CefRefPtr<CefMenuModel> model,
+                      CefRefPtr<CefRunContextMenuCallback> callback) override;
+  void OnGetImageForContextNode(CefRefPtr<CefImage> image) override;
+  bool OnContextMenuCommand(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            CefRefPtr<CefContextMenuParams> params,
+                            int command_id,
+                            CefContextMenuHandler::EventFlags event_flags) override;
+  void OnContextMenuDismissed(CefRefPtr<CefBrowser> browser,
+                              CefRefPtr<CefFrame> frame) override;
+  bool RunQuickMenu(CefRefPtr<CefBrowser> browser,
+                    CefRefPtr<CefFrame> frame,
+                    const CefPoint& location,
+                    const CefSize& size,
+                    CefContextMenuHandler::QuickMenuEditStateFlags edit_state_flags,
+                    CefRefPtr<CefRunQuickMenuCallback> callback) override;
+  bool OnQuickMenuCommand(CefRefPtr<CefBrowser> browser,
+                          CefRefPtr<CefFrame> frame,
+                          int command_id,
+                          CefContextMenuHandler::EventFlags event_flags) override;
+  void OnQuickMenuDismissed(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame) override;
+  /* CefContextMenuHandler method end */
+
   const std::vector<std::string> GetVisitedHistory();
 
  private:
diff --git a/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
index 50b80661fd543..815aed01f535c 100644
--- a/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
@@ -14,82 +14,267 @@
  */
 
 #include "nweb_input_delegate.h"
+#include "cef/include/base/cef_logging.h"
 #include "cef/include/internal/cef_types_wrappers.h"
+#include "nweb_inputmethod_handler.h"
 
 using namespace OHOS::NWeb;
+using namespace OHOS::MMI;
 const int32_t KEY_DOWN = 0;
 const int32_t KEY_UP = 1;
+const int32_t LEFT_BUTTON = 1;
+const int32_t RIGHT_BUTTON = 2;
+const int32_t MIDDLE_BUTTON = 4;
+const int32_t BACK_BUTTON = 8;
+const int32_t FORWARD_BUTTON = 16;
 
-const std::unordered_map<int, int>keycodeConverter = {
-  {OHOS::MMI::KeyEvent::KEYCODE_0, ui::VKEY_0},
-  {OHOS::MMI::KeyEvent::KEYCODE_1, ui::VKEY_1},
-  {OHOS::MMI::KeyEvent::KEYCODE_2, ui::VKEY_2},
-  {OHOS::MMI::KeyEvent::KEYCODE_3, ui::VKEY_3},
-  {OHOS::MMI::KeyEvent::KEYCODE_4, ui::VKEY_4},
-  {OHOS::MMI::KeyEvent::KEYCODE_5, ui::VKEY_5},
-  {OHOS::MMI::KeyEvent::KEYCODE_6, ui::VKEY_6},
-  {OHOS::MMI::KeyEvent::KEYCODE_7, ui::VKEY_7},
-  {OHOS::MMI::KeyEvent::KEYCODE_8, ui::VKEY_8},
-  {OHOS::MMI::KeyEvent::KEYCODE_9, ui::VKEY_9},
-  {OHOS::MMI::KeyEvent::KEYCODE_A, ui::VKEY_A},
-  {OHOS::MMI::KeyEvent::KEYCODE_B, ui::VKEY_B},
-  {OHOS::MMI::KeyEvent::KEYCODE_C, ui::VKEY_C},
-  {OHOS::MMI::KeyEvent::KEYCODE_D, ui::VKEY_D},
-  {OHOS::MMI::KeyEvent::KEYCODE_E, ui::VKEY_E},
-  {OHOS::MMI::KeyEvent::KEYCODE_F, ui::VKEY_F},
-  {OHOS::MMI::KeyEvent::KEYCODE_G, ui::VKEY_G},
-  {OHOS::MMI::KeyEvent::KEYCODE_H, ui::VKEY_H},
-  {OHOS::MMI::KeyEvent::KEYCODE_I, ui::VKEY_I},
-  {OHOS::MMI::KeyEvent::KEYCODE_J, ui::VKEY_J},
-  {OHOS::MMI::KeyEvent::KEYCODE_K, ui::VKEY_K},
-  {OHOS::MMI::KeyEvent::KEYCODE_L, ui::VKEY_L},
-  {OHOS::MMI::KeyEvent::KEYCODE_M, ui::VKEY_M},
-  {OHOS::MMI::KeyEvent::KEYCODE_N, ui::VKEY_N},
-  {OHOS::MMI::KeyEvent::KEYCODE_O, ui::VKEY_O},
-  {OHOS::MMI::KeyEvent::KEYCODE_P, ui::VKEY_P},
-  {OHOS::MMI::KeyEvent::KEYCODE_Q, ui::VKEY_Q},
-  {OHOS::MMI::KeyEvent::KEYCODE_R, ui::VKEY_R},
-  {OHOS::MMI::KeyEvent::KEYCODE_S, ui::VKEY_S},
-  {OHOS::MMI::KeyEvent::KEYCODE_T, ui::VKEY_T},
-  {OHOS::MMI::KeyEvent::KEYCODE_U, ui::VKEY_U},
-  {OHOS::MMI::KeyEvent::KEYCODE_V, ui::VKEY_V},
-  {OHOS::MMI::KeyEvent::KEYCODE_W, ui::VKEY_W},
-  {OHOS::MMI::KeyEvent::KEYCODE_X, ui::VKEY_X},
-  {OHOS::MMI::KeyEvent::KEYCODE_Y, ui::VKEY_Y},
-  {OHOS::MMI::KeyEvent::KEYCODE_Z, ui::VKEY_Z},
-  {OHOS::MMI::KeyEvent::KEYCODE_SHIFT_LEFT, ui::VKEY_SHIFT},
-  {OHOS::MMI::KeyEvent::KEYCODE_SHIFT_RIGHT, ui::VKEY_SHIFT},
-  {OHOS::MMI::KeyEvent::KEYCODE_TAB, ui::VKEY_TAB},
-  {OHOS::MMI::KeyEvent::KEYCODE_SPACE, ui::VKEY_SPACE},
-  {OHOS::MMI::KeyEvent::KEYCODE_ENTER, ui::VKEY_RETURN},
-  {OHOS::MMI::KeyEvent::KEYCODE_DEL, ui::VKEY_DELETE},
-  {OHOS::MMI::KeyEvent::KEYCODE_CTRL_LEFT, ui::VKEY_CONTROL},
-  {OHOS::MMI::KeyEvent::KEYCODE_CTRL_RIGHT, ui::VKEY_CONTROL},
-  {OHOS::MMI::KeyEvent::KEYCODE_F1, ui::VKEY_F1},
-  {OHOS::MMI::KeyEvent::KEYCODE_F2, ui::VKEY_F2},
-  {OHOS::MMI::KeyEvent::KEYCODE_F3, ui::VKEY_F3},
-  {OHOS::MMI::KeyEvent::KEYCODE_F4, ui::VKEY_F4},
-  {OHOS::MMI::KeyEvent::KEYCODE_F5, ui::VKEY_F5},
-  {OHOS::MMI::KeyEvent::KEYCODE_F6, ui::VKEY_F6},
-  {OHOS::MMI::KeyEvent::KEYCODE_F7, ui::VKEY_F7},
-  {OHOS::MMI::KeyEvent::KEYCODE_F8, ui::VKEY_F8},
-  {OHOS::MMI::KeyEvent::KEYCODE_F9, ui::VKEY_F9},
-  {OHOS::MMI::KeyEvent::KEYCODE_F10, ui::VKEY_F10},
-  {OHOS::MMI::KeyEvent::KEYCODE_F11, ui::VKEY_F11},
-  {OHOS::MMI::KeyEvent::KEYCODE_F12, ui::VKEY_F12},
+const std::unordered_map<int, int> keycodeConverter = {
+    {KeyEvent::KEYCODE_0, ui::VKEY_0},
+    {KeyEvent::KEYCODE_1, ui::VKEY_1},
+    {KeyEvent::KEYCODE_2, ui::VKEY_2},
+    {KeyEvent::KEYCODE_3, ui::VKEY_3},
+    {KeyEvent::KEYCODE_4, ui::VKEY_4},
+    {KeyEvent::KEYCODE_5, ui::VKEY_5},
+    {KeyEvent::KEYCODE_6, ui::VKEY_6},
+    {KeyEvent::KEYCODE_7, ui::VKEY_7},
+    {KeyEvent::KEYCODE_8, ui::VKEY_8},
+    {KeyEvent::KEYCODE_9, ui::VKEY_9},
+    {KeyEvent::KEYCODE_A, ui::VKEY_A},
+    {KeyEvent::KEYCODE_B, ui::VKEY_B},
+    {KeyEvent::KEYCODE_C, ui::VKEY_C},
+    {KeyEvent::KEYCODE_D, ui::VKEY_D},
+    {KeyEvent::KEYCODE_E, ui::VKEY_E},
+    {KeyEvent::KEYCODE_F, ui::VKEY_F},
+    {KeyEvent::KEYCODE_G, ui::VKEY_G},
+    {KeyEvent::KEYCODE_H, ui::VKEY_H},
+    {KeyEvent::KEYCODE_I, ui::VKEY_I},
+    {KeyEvent::KEYCODE_J, ui::VKEY_J},
+    {KeyEvent::KEYCODE_K, ui::VKEY_K},
+    {KeyEvent::KEYCODE_L, ui::VKEY_L},
+    {KeyEvent::KEYCODE_M, ui::VKEY_M},
+    {KeyEvent::KEYCODE_N, ui::VKEY_N},
+    {KeyEvent::KEYCODE_O, ui::VKEY_O},
+    {KeyEvent::KEYCODE_P, ui::VKEY_P},
+    {KeyEvent::KEYCODE_Q, ui::VKEY_Q},
+    {KeyEvent::KEYCODE_R, ui::VKEY_R},
+    {KeyEvent::KEYCODE_S, ui::VKEY_S},
+    {KeyEvent::KEYCODE_T, ui::VKEY_T},
+    {KeyEvent::KEYCODE_U, ui::VKEY_U},
+    {KeyEvent::KEYCODE_V, ui::VKEY_V},
+    {KeyEvent::KEYCODE_W, ui::VKEY_W},
+    {KeyEvent::KEYCODE_X, ui::VKEY_X},
+    {KeyEvent::KEYCODE_Y, ui::VKEY_Y},
+    {KeyEvent::KEYCODE_Z, ui::VKEY_Z},
+    {KeyEvent::KEYCODE_SHIFT_LEFT, ui::VKEY_SHIFT},
+    {KeyEvent::KEYCODE_SHIFT_RIGHT, ui::VKEY_SHIFT},
+    {KeyEvent::KEYCODE_TAB, ui::VKEY_TAB},
+    {KeyEvent::KEYCODE_SPACE, ui::VKEY_SPACE},
+    {KeyEvent::KEYCODE_ENTER, ui::VKEY_RETURN},
+    {KeyEvent::KEYCODE_NUMPAD_ENTER, ui::VKEY_RETURN},
+    {KeyEvent::KEYCODE_DEL, ui::VKEY_BACK},
+    {KeyEvent::KEYCODE_FORWARD_DEL, ui::VKEY_DELETE},
+    {KeyEvent::KEYCODE_CTRL_LEFT, ui::VKEY_CONTROL},
+    {KeyEvent::KEYCODE_CTRL_RIGHT, ui::VKEY_CONTROL},
+    {KeyEvent::KEYCODE_ALT_LEFT, ui::VKEY_MENU},
+    {KeyEvent::KEYCODE_ALT_RIGHT, ui::VKEY_MENU},
+    {KeyEvent::KEYCODE_ESCAPE, ui::VKEY_ESCAPE},
+    {KeyEvent::KEYCODE_F1, ui::VKEY_F1},
+    {KeyEvent::KEYCODE_F2, ui::VKEY_F2},
+    {KeyEvent::KEYCODE_F3, ui::VKEY_F3},
+    {KeyEvent::KEYCODE_F4, ui::VKEY_F4},
+    {KeyEvent::KEYCODE_F5, ui::VKEY_F5},
+    {KeyEvent::KEYCODE_F6, ui::VKEY_F6},
+    {KeyEvent::KEYCODE_F7, ui::VKEY_F7},
+    {KeyEvent::KEYCODE_F8, ui::VKEY_F8},
+    {KeyEvent::KEYCODE_F9, ui::VKEY_F9},
+    {KeyEvent::KEYCODE_F10, ui::VKEY_F10},
+    {KeyEvent::KEYCODE_F11, ui::VKEY_F11},
+    {KeyEvent::KEYCODE_F12, ui::VKEY_F12},
+    {KeyEvent::KEYCODE_PAGE_UP, ui::VKEY_PRIOR},
+    {KeyEvent::KEYCODE_PAGE_DOWN, ui::VKEY_NEXT},
+    {KeyEvent::KEYCODE_MOVE_HOME, ui::VKEY_HOME},
+    {KeyEvent::KEYCODE_MOVE_END, ui::VKEY_END},
+    {KeyEvent::KEYCODE_MINUS, ui::VKEY_OEM_MINUS},
+    {KeyEvent::KEYCODE_EQUALS, ui::VKEY_OEM_PLUS},
+    {KeyEvent::KEYCODE_LEFT_BRACKET, ui::VKEY_OEM_4},
+    {KeyEvent::KEYCODE_RIGHT_BRACKET, ui::VKEY_OEM_6},
+    {KeyEvent::KEYCODE_SEMICOLON, ui::VKEY_OEM_1},
+    {KeyEvent::KEYCODE_APOSTROPHE, ui::VKEY_OEM_7},
+    {KeyEvent::KEYCODE_GRAVE, ui::VKEY_OEM_3},
+    {KeyEvent::KEYCODE_BACKSLASH, ui::VKEY_OEM_5},
+    {KeyEvent::KEYCODE_COMMA, ui::VKEY_OEM_COMMA},
+    {KeyEvent::KEYCODE_PERIOD, ui::VKEY_OEM_PERIOD},
+    {KeyEvent::KEYCODE_SLASH, ui::VKEY_OEM_2},
+    {KeyEvent::KEYCODE_NUMPAD_MULTIPLY, ui::VKEY_MULTIPLY},
+    {KeyEvent::KEYCODE_CAPS_LOCK, ui::VKEY_CAPITAL},
+    {KeyEvent::KEYCODE_NUM_LOCK, ui::VKEY_NUMLOCK},
+    {KeyEvent::KEYCODE_SCROLL_LOCK, ui::VKEY_SCROLL},
+    {KeyEvent::KEYCODE_NUMPAD_0, ui::VKEY_NUMPAD0},
+    {KeyEvent::KEYCODE_NUMPAD_1, ui::VKEY_NUMPAD1},
+    {KeyEvent::KEYCODE_NUMPAD_2, ui::VKEY_NUMPAD2},
+    {KeyEvent::KEYCODE_NUMPAD_3, ui::VKEY_NUMPAD3},
+    {KeyEvent::KEYCODE_NUMPAD_4, ui::VKEY_NUMPAD4},
+    {KeyEvent::KEYCODE_NUMPAD_5, ui::VKEY_NUMPAD5},
+    {KeyEvent::KEYCODE_NUMPAD_6, ui::VKEY_NUMPAD6},
+    {KeyEvent::KEYCODE_NUMPAD_7, ui::VKEY_NUMPAD7},
+    {KeyEvent::KEYCODE_NUMPAD_8, ui::VKEY_NUMPAD8},
+    {KeyEvent::KEYCODE_NUMPAD_9, ui::VKEY_NUMPAD9},
+    {KeyEvent::KEYCODE_NUMPAD_SUBTRACT, ui::VKEY_SUBTRACT},
+    {KeyEvent::KEYCODE_NUMPAD_ADD, ui::VKEY_ADD},
+    {KeyEvent::KEYCODE_NUMPAD_DOT, ui::VKEY_DECIMAL},
+    {KeyEvent::KEYCODE_NUMPAD_DIVIDE, ui::VKEY_DIVIDE},
+    {KeyEvent::KEYCODE_SYSRQ, ui::VKEY_SNAPSHOT},
+    {KeyEvent::KEYCODE_INSERT, ui::VKEY_INSERT},
+    {KeyEvent::KEYCODE_BREAK, ui::VKEY_PAUSE},
+    {KeyEvent::KEYCODE_META_LEFT, ui::VKEY_LWIN},
+    {KeyEvent::KEYCODE_META_RIGHT, ui::VKEY_RWIN},
+    {KeyEvent::KEYCODE_DPAD_UP, ui::VKEY_UP},
+    {KeyEvent::KEYCODE_DPAD_DOWN, ui::VKEY_DOWN},
+    {KeyEvent::KEYCODE_DPAD_LEFT, ui::VKEY_LEFT},
+    {KeyEvent::KEYCODE_DPAD_RIGHT, ui::VKEY_RIGHT},
 };
 
 const std::unordered_map<int, int> keyactionConverter = {
-  {KEY_UP, KEYEVENT_KEYUP},
-  {KEY_DOWN, KEYEVENT_KEYDOWN},
+    {KEY_UP, KEYEVENT_KEYUP},
+    {KEY_DOWN, KEYEVENT_RAWKEYDOWN},
 };
 
-const std::unordered_map<std::string, std::unordered_map<int, int>> keyValueConverter = {
-  {"keycode", keycodeConverter},
-  {"keyaction", keyactionConverter},
+const std::unordered_map<int, int> mousebuttonConverter = {
+    {LEFT_BUTTON, MBT_LEFT},       {RIGHT_BUTTON, MBT_RIGHT},
+    {MIDDLE_BUTTON, MBT_MIDDLE},   {BACK_BUTTON, MBT_BACK},
+    {FORWARD_BUTTON, MBT_FORWARD},
 };
 
-bool NWebInputDelegate::KeyValueConvert(const std::string keyValue, std::unordered_map<int, int>& map) {
+const std::unordered_map<int, int> keyScanCodeConverter = {
+    {KeyEvent::KEYCODE_ESCAPE, ScanKeyCode::ESCAPE_SCAN_CODE},
+    {KeyEvent::KEYCODE_1, ScanKeyCode::DIGIT1_SCAN_CODE},
+    {KeyEvent::KEYCODE_2, ScanKeyCode::DIGIT2_SCAN_CODE},
+    {KeyEvent::KEYCODE_3, ScanKeyCode::DIGIT3_SCAN_CODE},
+    {KeyEvent::KEYCODE_4, ScanKeyCode::DIGIT4_SCAN_CODE},
+    {KeyEvent::KEYCODE_5, ScanKeyCode::DIGIT5_SCAN_CODE},
+    {KeyEvent::KEYCODE_6, ScanKeyCode::DIGIT6_SCAN_CODE},
+    {KeyEvent::KEYCODE_7, ScanKeyCode::DIGIT7_SCAN_CODE},
+    {KeyEvent::KEYCODE_8, ScanKeyCode::DIGIT8_SCAN_CODE},
+    {KeyEvent::KEYCODE_9, ScanKeyCode::DIGIT9_SCAN_CODE},
+    {KeyEvent::KEYCODE_0, ScanKeyCode::DIGIT0_SCAN_CODE},
+    {KeyEvent::KEYCODE_MINUS, ScanKeyCode::MINUS_SCAN_CODE},
+    {KeyEvent::KEYCODE_EQUALS, ScanKeyCode::EQUAL_SCAN_CODE},
+    {KeyEvent::KEYCODE_DEL, ScanKeyCode::BACKSPACE_SCAN_CODE},
+    {KeyEvent::KEYCODE_TAB, ScanKeyCode::TAB_SCAN_CODE},
+    {KeyEvent::KEYCODE_W, ScanKeyCode::KEYW_SCAN_CODE},
+    {KeyEvent::KEYCODE_Q, ScanKeyCode::KEYQ_SCAN_CODE},
+    {KeyEvent::KEYCODE_E, ScanKeyCode::KEYE_SCAN_CODE},
+    {KeyEvent::KEYCODE_R, ScanKeyCode::KEYR_SCAN_CODE},
+    {KeyEvent::KEYCODE_T, ScanKeyCode::KEYT_SCAN_CODE},
+    {KeyEvent::KEYCODE_Y, ScanKeyCode::KEYY_SCAN_CODE},
+    {KeyEvent::KEYCODE_U, ScanKeyCode::KEYU_SCAN_CODE},
+    {KeyEvent::KEYCODE_I, ScanKeyCode::KEYI_SCAN_CODE},
+    {KeyEvent::KEYCODE_O, ScanKeyCode::KEYO_SCAN_CODE},
+    {KeyEvent::KEYCODE_P, ScanKeyCode::KEYP_SCAN_CODE},
+    {KeyEvent::KEYCODE_LEFT_BRACKET, ScanKeyCode::BRACKETLEFT_SCAN_CODE},
+    {KeyEvent::KEYCODE_RIGHT_BRACKET, ScanKeyCode::BRACKETRIGHT_SCAN_CODE},
+    {KeyEvent::KEYCODE_ENTER, ScanKeyCode::ENTER_SCAN_CODE},
+    {KeyEvent::KEYCODE_CTRL_LEFT, ScanKeyCode::CONTROLLEFT_SCAN_CODE},
+    {KeyEvent::KEYCODE_A, ScanKeyCode::KEYA_SCAN_CODE},
+    {KeyEvent::KEYCODE_S, ScanKeyCode::KEYS_SCAN_CODE},
+    {KeyEvent::KEYCODE_D, ScanKeyCode::KEYD_SCAN_CODE},
+    {KeyEvent::KEYCODE_F, ScanKeyCode::KEYF_SCAN_CODE},
+    {KeyEvent::KEYCODE_G, ScanKeyCode::KEYG_SCAN_CODE},
+    {KeyEvent::KEYCODE_H, ScanKeyCode::KEYH_SCAN_CODE},
+    {KeyEvent::KEYCODE_J, ScanKeyCode::KEYJ_SCAN_CODE},
+    {KeyEvent::KEYCODE_K, ScanKeyCode::KEYK_SCAN_CODE},
+    {KeyEvent::KEYCODE_L, ScanKeyCode::KEYL_SCAN_CODE},
+    {KeyEvent::KEYCODE_SEMICOLON, ScanKeyCode::SEMICOLON_SCAN_CODE},
+    {KeyEvent::KEYCODE_APOSTROPHE, ScanKeyCode::QUOTE_SCAN_CODE},
+    {KeyEvent::KEYCODE_GRAVE, ScanKeyCode::BACKQUOTE_SCAN_CODE},
+    {KeyEvent::KEYCODE_SHIFT_LEFT, ScanKeyCode::SHIFTLEFT_SCAN_CODE},
+    {KeyEvent::KEYCODE_BACKSLASH, ScanKeyCode::BACKSLASH_SCAN_CODE},
+    {KeyEvent::KEYCODE_Z, ScanKeyCode::KEYZ_SCAN_CODE},
+    {KeyEvent::KEYCODE_X, ScanKeyCode::KEYX_SCAN_CODE},
+    {KeyEvent::KEYCODE_C, ScanKeyCode::KEYC_SCAN_CODE},
+    {KeyEvent::KEYCODE_V, ScanKeyCode::KEYV_SCAN_CODE},
+    {KeyEvent::KEYCODE_B, ScanKeyCode::KEYB_SCAN_CODE},
+    {KeyEvent::KEYCODE_N, ScanKeyCode::KEYN_SCAN_CODE},
+    {KeyEvent::KEYCODE_M, ScanKeyCode::KEYM_SCAN_CODE},
+    {KeyEvent::KEYCODE_COMMA, ScanKeyCode::COMMA_SCAN_CODE},
+    {KeyEvent::KEYCODE_PERIOD, ScanKeyCode::PERIOD_SCAN_CODE},
+    {KeyEvent::KEYCODE_SLASH, ScanKeyCode::SLASH_SCAN_CODE},
+    {KeyEvent::KEYCODE_SHIFT_RIGHT, ScanKeyCode::SHIFTRIGHT_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_MULTIPLY, ScanKeyCode::NUMPADMULTIPLY_SCAN_CODE},
+    {KeyEvent::KEYCODE_ALT_LEFT, ScanKeyCode::ALTLEFT_SCAN_CODE},
+    {KeyEvent::KEYCODE_SPACE, ScanKeyCode::SPACE_SCAN_CODE},
+    {KeyEvent::KEYCODE_CAPS_LOCK, ScanKeyCode::CAPSLOCK_SCAN_CODE},
+    {KeyEvent::KEYCODE_F1, ScanKeyCode::F1_SCAN_CODE},
+    {KeyEvent::KEYCODE_F2, ScanKeyCode::F2_SCAN_CODE},
+    {KeyEvent::KEYCODE_F3, ScanKeyCode::F3_SCAN_CODE},
+    {KeyEvent::KEYCODE_F4, ScanKeyCode::F4_SCAN_CODE},
+    {KeyEvent::KEYCODE_F5, ScanKeyCode::F5_SCAN_CODE},
+    {KeyEvent::KEYCODE_F6, ScanKeyCode::F6_SCAN_CODE},
+    {KeyEvent::KEYCODE_F7, ScanKeyCode::F7_SCAN_CODE},
+    {KeyEvent::KEYCODE_F8, ScanKeyCode::F8_SCAN_CODE},
+    {KeyEvent::KEYCODE_F9, ScanKeyCode::F9_SCAN_CODE},
+    {KeyEvent::KEYCODE_F10, ScanKeyCode::F10_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUM_LOCK, ScanKeyCode::NUMLOCK_SCAN_CODE},
+    {KeyEvent::KEYCODE_SCROLL_LOCK, ScanKeyCode::SCROLLLOCK_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_7, ScanKeyCode::NUMPAD7_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_8, ScanKeyCode::NUMPAD8_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_9, ScanKeyCode::NUMPAD9_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_SUBTRACT, ScanKeyCode::NUMPADSUBTRACT_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_4, ScanKeyCode::NUMPAD4_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_5, ScanKeyCode::NUMPAD5_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_6, ScanKeyCode::NUMPAD6_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_ADD, ScanKeyCode::NUMPADADD_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_1, ScanKeyCode::NUMPAD1_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_2, ScanKeyCode::NUMPAD2_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_3, ScanKeyCode::NUMPAD3_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_0, ScanKeyCode::NUMPAD0_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_DOT, ScanKeyCode::NUMPADDECIMAL_SCAN_CODE},
+    {KeyEvent::KEYCODE_F11, ScanKeyCode::F11_SCAN_CODE},
+    {KeyEvent::KEYCODE_F12, ScanKeyCode::F12_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_ENTER, ScanKeyCode::NUMPADENTER_SCAN_CODE},
+    {KeyEvent::KEYCODE_CTRL_RIGHT, ScanKeyCode::CONTROLRIGHT_SCAN_CODE},
+    {KeyEvent::KEYCODE_NUMPAD_DIVIDE, ScanKeyCode::NUMPADDIVIDE_SCAN_CODE},
+    {KeyEvent::KEYCODE_SYSRQ, ScanKeyCode::PRINTSCREEN_SCAN_CODE},
+    {KeyEvent::KEYCODE_ALT_RIGHT, ScanKeyCode::ALTRIGHT_SCAN_CODE},
+    {KeyEvent::KEYCODE_DPAD_UP, ScanKeyCode::UP_SCAN_CODE},
+    {KeyEvent::KEYCODE_DPAD_LEFT, ScanKeyCode::LEFT_SCAN_CODE},
+    {KeyEvent::KEYCODE_DPAD_RIGHT, ScanKeyCode::RIGHT_SCAN_CODE},
+    {KeyEvent::KEYCODE_DPAD_DOWN, ScanKeyCode::DOWN_SCAN_CODE},
+    {KeyEvent::KEYCODE_PAGE_UP, ScanKeyCode::PAGE_UP_SCAN_CODE},
+    {KeyEvent::KEYCODE_PAGE_DOWN, ScanKeyCode::PAGE_DOWN_SCAN_CODE},
+    {KeyEvent::KEYCODE_MOVE_HOME, ScanKeyCode::HOME_SCAN_CODE},
+    {KeyEvent::KEYCODE_MOVE_END, ScanKeyCode::END_SCAN_CODE},
+    {KeyEvent::KEYCODE_INSERT, ScanKeyCode::INSERT_SCAN_CODE},
+    {KeyEvent::KEYCODE_FORWARD_DEL, ScanKeyCode::DELETE_SCAN_CODE},
+    {KeyEvent::KEYCODE_BREAK, ScanKeyCode::PAUSE_SCAN_CODE},
+    {KeyEvent::KEYCODE_META_LEFT, ScanKeyCode::METALEFT_SCAN_CODE},
+    {KeyEvent::KEYCODE_META_RIGHT, ScanKeyCode::METARIGHT_SCAN_CODE},
+};
+
+const std::unordered_map<std::string, std::unordered_map<int, int>>
+    keyValueConverter = {
+        {"keycode", keycodeConverter},
+        {"keyaction", keyactionConverter},
+        {"mousebutton", mousebuttonConverter},
+        {"keyscancode", keyScanCodeConverter},
+};
+
+NWebInputDelegate::NWebInputDelegate() {
+  keyEventHandle_.RegistInputEvent(KeyEvent::KEYCODE_CTRL_LEFT, KEY_DOWN,
+                                   false);
+  keyEventHandle_.RegistInputEvent(KeyEvent::KEYCODE_CTRL_RIGHT, KEY_DOWN,
+                                   false);
+  keyEventHandle_.RegistInputEvent(KeyEvent::KEYCODE_SHIFT_LEFT, KEY_DOWN,
+                                   false);
+  keyEventHandle_.RegistInputEvent(KeyEvent::KEYCODE_SHIFT_RIGHT, KEY_DOWN,
+                                   false);
+  keyEventHandle_.RegistInputEvent(KeyEvent::KEYCODE_ALT_LEFT, KEY_DOWN, false);
+  keyEventHandle_.RegistInputEvent(KeyEvent::KEYCODE_ALT_RIGHT, KEY_DOWN,
+                                   false);
+}
+
+bool NWebInputDelegate::KeyValueConvert(const std::string keyValue,
+                                        std::unordered_map<int, int>& map) {
   auto itKeyValue = keyValueConverter.find(keyValue);
   if (itKeyValue == keyValueConverter.end()) {
     return false;
@@ -122,25 +307,49 @@ int NWebInputDelegate::OhosConverter(const std::string keyValue, int input) {
   return item->first;
 }
 
-void NWebInputDelegate::SetModifiers(int keyCode, int keyAction)
-{
-  if ((keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_LEFT ||
-       keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_RIGHT) &&
-       keyCTL_ == true && keyAction == KEY_UP) {
-    keyCTL_ = false;
-  }
+void NWebInputDelegate::SetModifiers(int keyCode, int keyAction) {
+  keyEventHandle_.SetInputEvent(keyCode, keyAction);
+}
 
-  if ((keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_LEFT ||
-       keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_RIGHT) &&
-       keyCTL_ == false && keyAction == KEY_DOWN) {
-    keyCTL_ = true;
+uint32_t NWebInputDelegate::GetModifiers() {
+  uint32_t result = 0;
+  if (keyEventHandle_.GetInputEvent(KeyEvent::KEYCODE_CTRL_LEFT) ||
+      keyEventHandle_.GetInputEvent(KeyEvent::KEYCODE_CTRL_RIGHT)) {
+    result |= EVENTFLAG_CONTROL_DOWN;
+  }
+  if (keyEventHandle_.GetInputEvent(KeyEvent::KEYCODE_SHIFT_LEFT) ||
+      keyEventHandle_.GetInputEvent(KeyEvent::KEYCODE_SHIFT_RIGHT)) {
+    result |= EVENTFLAG_SHIFT_DOWN;
   }
+  if (keyEventHandle_.GetInputEvent(KeyEvent::KEYCODE_ALT_LEFT) ||
+      keyEventHandle_.GetInputEvent(KeyEvent::KEYCODE_ALT_RIGHT)) {
+    result |= EVENTFLAG_ALT_DOWN;
+  }
+  return result;
 }
 
-unsigned int NWebInputDelegate::GetModifiers()
-{
-  if (keyCTL_ == true) {
-    return (0 | EVENTFLAG_CONTROL_DOWN);
+uint32_t NWebInputDelegate::GetModifiers(cef_mouse_button_type_t button) {
+  uint32_t result = GetModifiers();
+
+  switch (button) {
+    case MBT_LEFT:
+      result |= EVENTFLAG_LEFT_MOUSE_BUTTON;
+      break;
+    case MBT_MIDDLE:
+      result |= EVENTFLAG_MIDDLE_MOUSE_BUTTON;
+      break;
+    case MBT_RIGHT:
+      result |= EVENTFLAG_RIGHT_MOUSE_BUTTON;
+      break;
+    case MBT_BACK:
+      result |= EVENTFLAG_BACK_MOUSE_BUTTON;
+      break;
+    case MBT_FORWARD:
+      result |= EVENTFLAG_FORWARD_MOUSE_BUTTON;
+      break;
+    default:
+      LOG(INFO) << "invalid button type " << button;
+      break;
   }
-  return 0;
-}
\ No newline at end of file
+  return result;
+}
diff --git a/ohos_nweb/src/cef_delegate/nweb_input_delegate.h b/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
index da5b1e1c263a9..0c4ca7f169f20 100644
--- a/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
@@ -17,21 +17,41 @@
 #define NWEB_KEYCODE_INTERFACE_H
 
 #include <unordered_map>
+#include <vector>
+#include "cef/include/internal/cef_types.h"
 #include "key_event.h"
+#include "nweb_inputevent_handler.h"
 #include "ui/events/keycodes/keyboard_codes_posix.h"
 
 namespace OHOS::NWeb {
+enum MouseAction { PRESS = 1, RELEASE = 2, MOVE = 3 };
+
 class NWebInputDelegate {
  public:
+  NWebInputDelegate();
   virtual ~NWebInputDelegate() = default;
   static int CefConverter(const std::string keyValue, int input);
   static int OhosConverter(const std::string keyValue, int input);
   void SetModifiers(int keyCode, int keyAction);
-  unsigned int GetModifiers();
+  uint32_t GetModifiers();
+  uint32_t GetModifiers(cef_mouse_button_type_t button);
+  static inline bool IsMouseDown(int action) {
+    return action == MouseAction::PRESS;
+  }
+  static inline bool IsMouseUp(int action) {
+    return action == MouseAction::RELEASE;
+  }
+  static inline bool IsMouseMove(int action) {
+    return action == MouseAction::MOVE;
+  }
+  void SetMouseWheelRatio(float ratio) { mouseWheelRatio_ = ratio; }
+  float GetMouseWheelRatio() { return mouseWheelRatio_; }
 
  private:
-  static bool KeyValueConvert(const std::string keyValue, std::unordered_map<int, int>& map);
-  bool keyCTL_ = false;
+  static bool KeyValueConvert(const std::string keyValue,
+                              std::unordered_map<int, int>& map);
+  NWebInputEventHandle<int, int> keyEventHandle_;
+  float mouseWheelRatio_ = -5.0;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/src/cef_delegate/nweb_inputevent_handler.h b/ohos_nweb/src/cef_delegate/nweb_inputevent_handler.h
new file mode 100644
index 0000000000000..d531308ad18ce
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_inputevent_handler.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_INPUTEVENT_HANDLER_H
+#define NWEB_INPUTEVENT_HANDLER_H
+
+#include <vector>
+
+namespace OHOS::NWeb {
+template<typename EeventType, typename ConditionType>
+class NWebInputEventHandle {
+ public:
+  virtual ~NWebInputEventHandle() = default;
+  void RegistInputEvent(EeventType event, ConditionType condition, bool defaultResult) {
+    event_.push_back(event);
+    condition_.push_back(condition);
+    result_.push_back(defaultResult);
+  }
+
+  void SetInputEvent(EeventType event, ConditionType condition) {
+    for (size_t i = 0; i < event_.size(); i++) {
+      if (event == event_[i]) {
+        result_[i] = (condition == condition_[i]);
+      }
+    }
+  }
+
+  bool GetInputEvent(EeventType event) {
+    for (size_t i = 0; i < event_.size(); i++) {
+      if (event == event_[i])
+        return result_[i];
+    }
+    return false;
+  }
+
+ private:
+  std::vector<EeventType> event_;
+  std::vector<ConditionType> condition_;
+  //result will be true when condition.
+  std::vector<bool> result_;
+};
+}  // namespace OHOS::NWeb
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_js_http_auth_result_impl.cc b/ohos_nweb/src/cef_delegate/nweb_js_http_auth_result_impl.cc
new file mode 100755
index 0000000000000..8607ac0088d9b
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_js_http_auth_result_impl.cc
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_js_http_auth_result_impl.h"
+
+using namespace OHOS::NWeb;
+
+NWebJSHttpAuthResultImpl::NWebJSHttpAuthResultImpl(CefRefPtr<CefAuthCallback> callback)
+  : callback_(callback) {}
+
+bool NWebJSHttpAuthResultImpl::Confirm(std::string &userName, std::string &pwd) {
+  if (callback_ != nullptr) {
+    callback_->Continue(CefString(userName), CefString(pwd));
+    return true;
+  }
+  return false;
+}
+
+bool NWebJSHttpAuthResultImpl::IsHttpAuthInfoSaved() {
+  if (callback_ != nullptr) {
+    return callback_->IsHttpAuthInfoSaved();
+  }
+  return false;
+}
+
+void NWebJSHttpAuthResultImpl::Cancel() {
+  if (callback_ != nullptr) {
+    callback_->Cancel();
+  }
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_js_http_auth_result_impl.h b/ohos_nweb/src/cef_delegate/nweb_js_http_auth_result_impl.h
new file mode 100755
index 0000000000000..13e9602c9aed3
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_js_http_auth_result_impl.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_JS_HTTP_AUTH_RESULT_IMPL_H
+#define NWEB_JS_HTTP_AUTH_RESULT_IMPL_H
+
+#include "nweb_js_http_auth_result.h"
+#include "cef/include/cef_auth_callback.h"
+
+namespace OHOS::NWeb {
+class NWebJSHttpAuthResultImpl : public NWebJSHttpAuthResult {
+ public:
+  NWebJSHttpAuthResultImpl() = default;
+  explicit NWebJSHttpAuthResultImpl(CefRefPtr<CefAuthCallback> callback);
+  ~NWebJSHttpAuthResultImpl() = default;
+  bool Confirm(std::string &userName, std::string &pwd) override;
+  void Cancel() override;
+  bool IsHttpAuthInfoSaved() override;
+ private:
+  CefRefPtr<CefAuthCallback> callback_;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
index e2250a7ef00fb..3c7e41cae5cfd 100644
--- a/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
@@ -18,6 +18,7 @@
 #include <accesstoken_kit.h>
 #include <ipc_skeleton.h>
 #include "base/logging.h"
+#include "cef/include/cef_command_line.h"
 #include "cef/include/internal/cef_string.h"
 #include "cef/include/internal/cef_string_types.h"
 #include "cef/include/internal/cef_string_wrappers.h"
@@ -26,7 +27,9 @@
 #include "cef/libcef/browser/net_service/net_helpers.h"
 
 #include "base/feature_list.h"
+#include "content/public/common/content_switches.h"
 #include "net/base/load_flags.h"
+#include "ohos_nweb/src/cef_delegate/nweb_application.h"
 
 namespace OHOS::NWeb {
 int ConvertCacheMode(NWebPreference::CacheModeFlag flag) {
@@ -141,6 +144,13 @@ void NWebPreferenceDelegate::ComputeBrowserSettings(
   browser_settings.geolocation_enabled = GeolocationAllowed();
   browser_settings.supports_double_tap_zoom = ZoomingfunctionEnabled();
   browser_settings.supports_multi_touch_zoom = ZoomingfunctionEnabled();
+  CefRefPtr<CefCommandLine> command_line =
+      CefCommandLine::GetGlobalCommandLine();
+  if (command_line->HasSwitch(::switches::kForBrowser)) {
+    bool is_win = (UserAgent().find("Windows NT") >= 0) &&
+        (UserAgent().find("Win64") >= 0 || UserAgent().find("WOW64") >= 0);
+    browser_settings.viewport_meta_enabled = !is_win;
+  }
 }
 
 void NWebPreferenceDelegate::SetBrowserSettingsToNetHelpers() {
@@ -367,6 +377,10 @@ std::string NWebPreferenceDelegate::DefaultTextEncodingFormat() {
 }
 
 std::string NWebPreferenceDelegate::DefaultUserAgent() {
+  if (!browser_) {
+    LOG(ERROR) << "get DefaultUserAgent failed, browser is null";
+    return "";
+  }
   std::string ua = browser_->GetHost()->DefaultUserAgent();
   return ua;
 }
diff --git a/ohos_nweb/src/cef_delegate/nweb_render_handler.cc b/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
index b61d89831b526..ec58add1c1a32 100644
--- a/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
@@ -21,6 +21,72 @@
 
 #include "base/logging.h"
 
+namespace {
+cef_screen_orientation_type_t ConvertOrientationType(
+  OHOS::NWeb::OrientationType type) {
+  switch (type) {
+#if defined(DEFAULT_PORTRAIT)
+    case OHOS::NWeb::OrientationType::UNSPECIFIED:
+      return cef_screen_orientation_type_t::PORTRAIT_PRIMARY;
+    case OHOS::NWeb::OrientationType::VERTICAL:
+      return cef_screen_orientation_type_t::PORTRAIT_PRIMARY;
+    case OHOS::NWeb::OrientationType::HORIZONTAL:
+      return cef_screen_orientation_type_t::LANDSCAPE_SECONDARY;
+    case OHOS::NWeb::OrientationType::REVERSE_VERTICAL:
+      return cef_screen_orientation_type_t::PORTRAIT_SECONDARY;
+    case OHOS::NWeb::OrientationType::REVERSE_HORIZONTAL:
+      return cef_screen_orientation_type_t::LANDSCAPE_PRIMARY;
+#else
+    case OHOS::NWeb::OrientationType::UNSPECIFIED:
+      return cef_screen_orientation_type_t::LANDSCAPE_PRIMARY;
+    case OHOS::NWeb::OrientationType::VERTICAL:
+      return cef_screen_orientation_type_t::PORTRAIT_PRIMARY;
+    case OHOS::NWeb::OrientationType::HORIZONTAL:
+      return cef_screen_orientation_type_t::LANDSCAPE_PRIMARY;
+    case OHOS::NWeb::OrientationType::REVERSE_VERTICAL:
+      return cef_screen_orientation_type_t::PORTRAIT_SECONDARY;
+    case OHOS::NWeb::OrientationType::REVERSE_HORIZONTAL:
+      return cef_screen_orientation_type_t::LANDSCAPE_SECONDARY;
+#endif
+    // Now ohos platform don't hava sensor orientation.
+    // Will be support later.
+    case OHOS::NWeb::OrientationType::SENSOR:
+    case OHOS::NWeb::OrientationType::SENSOR_VERTICAL:
+    case OHOS::NWeb::OrientationType::SENSOR_HORIZONTAL:
+      return cef_screen_orientation_type_t::UNDEFINED;
+    default:
+      return cef_screen_orientation_type_t::UNDEFINED;
+  }
+}
+
+uint16_t ConvertRotationAngel(OHOS::NWeb::RotationType type) {
+  // Notice: 90 and 270 is reverse.
+  switch (type) {
+#if defined(DEFAULT_PORTRAIT)
+    case OHOS::NWeb::RotationType::ROTATION_0:
+      return 0;
+    case OHOS::NWeb::RotationType::ROTATION_90:
+      return 270;
+    case OHOS::NWeb::RotationType::ROTATION_180:
+      return 180;
+    case OHOS::NWeb::RotationType::ROTATION_270:
+      return 90;
+#else
+    case OHOS::NWeb::RotationType::ROTATION_0:
+      return 90;
+    case OHOS::NWeb::RotationType::ROTATION_90:
+      return 0;
+    case OHOS::NWeb::RotationType::ROTATION_180:
+      return 270;
+    case OHOS::NWeb::RotationType::ROTATION_270:
+      return 180;
+#endif
+    default:
+      return 0;
+  }
+}
+}
+
 namespace OHOS::NWeb {
 // static
 CefRefPtr<NWebRenderHandler> NWebRenderHandler::Create() {
@@ -56,6 +122,19 @@ void NWebRenderHandler::GetViewRect(CefRefPtr<CefBrowser> browser,
   return;
 }
 
+void NWebRenderHandler::SetOrientation(RotationType rotation,
+                                       OrientationType orientation) {
+  rotation_ = rotation;
+  orientation_ = orientation;
+}
+
+bool NWebRenderHandler::GetScreenInfo(CefRefPtr<CefBrowser> browser,
+                                      CefScreenInfo& screen_info) {
+  screen_info.orientation = ConvertOrientationType(orientation_);
+  screen_info.angle = ConvertRotationAngel(rotation_);
+  return true;
+}
+
 void NWebRenderHandler::OnPaint(CefRefPtr<CefBrowser> browser,
                                 PaintElementType type,
                                 const RectList& dirty_rects,
diff --git a/ohos_nweb/src/cef_delegate/nweb_render_handler.h b/ohos_nweb/src/cef_delegate/nweb_render_handler.h
index 20d735e83af79..fd6c3eb8c82d8 100644
--- a/ohos_nweb/src/cef_delegate/nweb_render_handler.h
+++ b/ohos_nweb/src/cef_delegate/nweb_render_handler.h
@@ -19,6 +19,7 @@
 #include <functional>
 #include <memory>
 #include "cef/include/cef_render_handler.h"
+#include "display_manager_adapter.h"
 #include "nweb_inputmethod_client.h"
 
 namespace OHOS::NWeb {
@@ -30,12 +31,15 @@ class NWebRenderHandler : public CefRenderHandler {
 
   void RegisterRenderCb(std::function<void(const char*)> render_update_cb);
   void Resize(uint32_t width, uint32_t height);
+  void SetOrientation(RotationType rotation, OrientationType orientation);
   int ContentHeight();
   void SetInputMethodClient(CefRefPtr<NWebInputMethodClient> client);
 
   /* CefRenderHandler method begin */
   virtual void GetViewRect(CefRefPtr<CefBrowser> browser,
                            CefRect& rect) override;
+  bool GetScreenInfo(CefRefPtr<CefBrowser> browser,
+                     CefScreenInfo& screen_info) override;
   virtual void OnPaint(CefRefPtr<CefBrowser> browser,
                        PaintElementType type,
                        const RectList& dirty_rects,
@@ -67,6 +71,8 @@ class NWebRenderHandler : public CefRenderHandler {
   CefRefPtr<NWebInputMethodClient> inputmethod_client_ = nullptr;
   uint32_t width_ = 0;
   uint32_t height_ = 0;
+  RotationType rotation_ = RotationType::ROTATION_0;
+  OrientationType orientation_ = OrientationType::UNSPECIFIED;
   int content_height_ = 0;
   int content_width_ = 0;
 };
diff --git a/ohos_nweb/src/cef_delegate/nweb_web_storage_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_web_storage_delegate.cc
new file mode 100644
index 0000000000000..8ce8be4f527c9
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_web_storage_delegate.cc
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_web_storage_delegate.h"
+#include <memory>
+#include <thread>
+#include <vector>
+#include "base/logging.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/time/time.h"
+#include "cef/include/cef_waitable_event.h"
+#include "cef/libcef/common/time_util.h"
+#include "url/gurl.h"
+
+using namespace OHOS::NWeb;
+using base::WaitableEvent;
+
+namespace {
+class WebStorageCompletionCallback : public CefCompletionCallback {
+ public:
+  WebStorageCompletionCallback(
+      std::shared_ptr<WaitableEvent> event,
+      std::shared_ptr<NWebValueCallback<bool>> callback)
+      : event_(event), callback_(callback) {}
+  void OnComplete() override {
+    if (event_ != nullptr) {
+      event_->Signal();
+    }
+    if (callback_ != nullptr) {
+      callback_->OnReceiveValue(true);
+    }
+  }
+
+ private:
+  std::shared_ptr<WaitableEvent> event_;
+  std::shared_ptr<NWebValueCallback<bool>> callback_;
+  IMPLEMENT_REFCOUNTING(WebStorageCompletionCallback);
+  DISALLOW_COPY_AND_ASSIGN(WebStorageCompletionCallback);
+};
+
+class GetOriginsCallback : public CefGetOriginsCallback {
+ public:
+  GetOriginsCallback(std::shared_ptr<WaitableEvent> event,
+    std::shared_ptr<NWebGetOriginsCallback> callback)
+    : event_(event), callback_(callback) {}
+  void OnComplete() override {
+    NWebWebStorageOrigin items;
+    for (size_t i = 0; i < origins_.size(); i++) {
+      items.SetOrigin(origins_[i]);
+      items.SetQuota(quotas_[i]);
+      items.SetUsage(usages_[i]);
+      results_.push_back(items);
+    }
+    if (event_ != nullptr) {
+      event_->Signal();
+    }
+    if (callback_ != nullptr) {
+      callback_->OnReceiveValue(results_);
+    }
+  }
+
+  void OnOrigins(std::vector<CefString>& origins) override {
+    for (size_t i = 0; i < origins.size(); i++) {
+      std::string origin = origins[i].ToString();
+      origins_.push_back(origin);
+    }
+  }
+
+  void OnUsages(std::vector<CefString>& usages) override {
+    for (size_t i = 0; i < usages.size(); i++) {
+      long usage = atol(usages[i].ToString().c_str());
+      usages_.push_back(usage);
+    }
+  }
+
+  void OnQuotas(std::vector<CefString>& quotas) override {
+    for (size_t i = 0; i < quotas.size(); i++) {
+      long quota = atol(quotas[i].ToString().c_str());
+      quotas_.push_back(quota);
+    }
+  }
+
+  std::vector<NWebWebStorageOrigin> GetWebStorageOrigin() const { return results_; }
+
+ private:
+  std::shared_ptr<WaitableEvent> event_;
+  std::shared_ptr<NWebGetOriginsCallback> callback_;
+  std::vector<std::string> origins_;
+  std::vector<long> usages_;
+  std::vector<long> quotas_;
+  std::vector<NWebWebStorageOrigin> results_;
+
+  IMPLEMENT_REFCOUNTING(GetOriginsCallback);
+  DISALLOW_COPY_AND_ASSIGN(GetOriginsCallback);
+};
+
+class GetOriginUsageOrQuotaCallback : public CefGetOriginUsageOrQuotaCallback {
+ public:
+  GetOriginUsageOrQuotaCallback(std::shared_ptr<WaitableEvent> event,
+    std::shared_ptr<NWebValueCallback<long>> callback)
+    : event_(event), callback_(callback), nums_(-1) {}
+  void OnComplete(int64 nums) override {
+    nums_ = nums;
+    if (event_ != nullptr) {
+      event_->Signal();
+    }
+    if (callback_ != nullptr) {
+      callback_->OnReceiveValue(nums_);
+    }
+  }
+
+  long GetUsageOrQuota() const { return nums_; }
+
+ private:
+  std::shared_ptr<WaitableEvent> event_;
+  std::shared_ptr<NWebValueCallback<long>> callback_;
+  long nums_;
+
+  IMPLEMENT_REFCOUNTING(GetOriginUsageOrQuotaCallback);
+  DISALLOW_COPY_AND_ASSIGN(GetOriginUsageOrQuotaCallback);
+};
+}
+
+namespace OHOS::NWeb {
+CefRefPtr<CefWebStorage>
+NWebWebStorageDelegate::GetGlobalWebStorage() {
+  if (!web_storage_) {
+    web_storage_ = CefWebStorage::GetGlobalManager(nullptr);
+  }
+  return web_storage_;
+}
+
+void NWebWebStorageDelegate::DeleteAllData() {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return;
+  }
+  web_storage->DeleteAllData();
+}
+
+void NWebWebStorageDelegate::DeleteOrigin(const std::string& origin) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return;
+  }
+  web_storage->DeleteOrigin(origin);
+}
+
+void NWebWebStorageDelegate::GetOrigins(std::shared_ptr<NWebGetOriginsCallback> callback) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return;
+  }
+  web_storage->GetOrigins(new GetOriginsCallback(nullptr, callback));
+}
+
+void NWebWebStorageDelegate::GetOrigins(std::vector<NWebWebStorageOrigin>& origins) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return;
+  }
+  std::shared_ptr<base::WaitableEvent> completion =
+      std::make_shared<base::WaitableEvent>(
+        base::WaitableEvent::ResetPolicy::AUTOMATIC,
+        base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<GetOriginsCallback> callback = new GetOriginsCallback(completion, nullptr);
+  web_storage->GetOrigins(callback);
+  completion->Wait();
+  origins = callback->GetWebStorageOrigin();
+}
+
+void NWebWebStorageDelegate::GetOriginQuota(const std::string& origin,
+                            std::shared_ptr<NWebValueCallback<long>> callback) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return;
+  }
+  web_storage->GetOriginQuota(CefString(origin), new GetOriginUsageOrQuotaCallback(nullptr, callback));
+}
+
+long NWebWebStorageDelegate::GetOriginQuota(const std::string& origin) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return -1;
+  }
+  std::shared_ptr<base::WaitableEvent> completion =
+      std::make_shared<base::WaitableEvent>(
+        base::WaitableEvent::ResetPolicy::AUTOMATIC,
+        base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<GetOriginUsageOrQuotaCallback> callback = new GetOriginUsageOrQuotaCallback(completion, nullptr);
+  web_storage->GetOriginQuota(CefString(origin), callback);
+  completion->Wait();
+  return callback->GetUsageOrQuota();
+}
+
+void NWebWebStorageDelegate::GetOriginUsage(const std::string& origin,
+                            std::shared_ptr<NWebValueCallback<long>> callback) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return;
+  }
+  web_storage->GetOriginUsage(CefString(origin), new GetOriginUsageOrQuotaCallback(nullptr, callback));
+}
+
+long NWebWebStorageDelegate::GetOriginUsage(const std::string& origin) {
+  CefRefPtr<CefWebStorage> web_storage = GetGlobalWebStorage();
+  if (web_storage == nullptr) {
+    return -1;
+  }
+  std::shared_ptr<base::WaitableEvent> completion =
+      std::make_shared<base::WaitableEvent>(
+        base::WaitableEvent::ResetPolicy::AUTOMATIC,
+        base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<GetOriginUsageOrQuotaCallback> callback = new GetOriginUsageOrQuotaCallback(completion, nullptr);
+  web_storage->GetOriginUsage(CefString(origin), callback);
+  completion->Wait();
+  return callback->GetUsageOrQuota();
+}
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_web_storage_delegate.h b/ohos_nweb/src/cef_delegate/nweb_web_storage_delegate.h
new file mode 100644
index 0000000000000..6f2e96d836418
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_web_storage_delegate.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_COOKIE_MANAGER_DELEGATE_H
+#define NWEB_COOKIE_MANAGER_DELEGATE_H
+
+#include "cef/include/cef_base.h"
+#include "cef/include/cef_web_storage.h"
+#include "nweb_web_storage_delegate_interface.h"
+#include "nweb_value_callback.h"
+
+namespace OHOS::NWeb {
+class NWebWebStorageDelegate : public NWebWebStorageDelegateInterface {
+ public:
+  NWebWebStorageDelegate() = default;
+  ~NWebWebStorageDelegate() = default;
+
+  void DeleteAllData() override;
+  void DeleteOrigin(const std::string& origin) override;
+  void GetOrigins(std::shared_ptr<NWebGetOriginsCallback> callback) override;
+  void GetOrigins(std::vector<NWebWebStorageOrigin>& origins) override;
+  void GetOriginQuota(const std::string& origin,
+                              std::shared_ptr<NWebValueCallback<long>> callback) override;
+  long GetOriginQuota(const std::string& origin) override;
+  void GetOriginUsage(const std::string& origin,
+                              std::shared_ptr<NWebValueCallback<long>> callback) override;
+  long GetOriginUsage(const std::string& origin) override;
+ private:
+  CefRefPtr<CefWebStorage> GetGlobalWebStorage();
+  CefRefPtr<CefWebStorage> web_storage_ = nullptr;
+};
+}  // namespace OHOS::NWeb
+#endif
diff --git a/ohos_nweb/src/nweb_data_base_impl.cc b/ohos_nweb/src/nweb_data_base_impl.cc
new file mode 100644
index 0000000000000..b7f27bf58c663
--- /dev/null
+++ b/ohos_nweb/src/nweb_data_base_impl.cc
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_data_base_impl.h"
+#include "nweb_data_base_delegate.h"
+#include "nweb_hilog.h"
+
+using namespace OHOS::NWeb;
+
+extern "C" OHOS_NWEB_EXPORT NWebDataBase* GetDataBase() {
+  WVLOG_I("webdatabase get nweb data base instance");
+  static NWebDataBaseImpl instance;
+  return &instance;
+}
+
+namespace OHOS::NWeb {
+NWebDataBaseImpl::NWebDataBaseImpl() {
+#if defined(USE_CEF)
+  delegate_ = std::make_shared<NWebDataBaseDelegate>();
+#endif
+}
+
+bool NWebDataBaseImpl::ExistHttpAuthCredentials() const {
+  if (delegate_ != nullptr) {
+    return delegate_->ExistHttpAuthCredentials();
+  }
+  return false;
+}
+
+void NWebDataBaseImpl::DeleteHttpAuthCredentials() {
+  if (delegate_ != nullptr) {
+    delegate_->DeleteHttpAuthCredentials();
+  }
+}
+
+void NWebDataBaseImpl::SaveHttpAuthCredentials(const std::string& host, const std::string& realm,
+  const std::string& username, const char* password) {
+  if (delegate_ != nullptr) {
+    return delegate_->SaveHttpAuthCredentials(host, realm, username, password);
+  }
+}
+
+std::vector<std::string> NWebDataBaseImpl::GetHttpAuthCredentials(const std::string& host,
+  const std::string& realm) const {
+  if (delegate_ != nullptr) {
+    return delegate_->GetHttpAuthCredentials(host, realm);
+  }
+  return {};
+}
+
+bool NWebDataBaseImpl::ExistFormData() const {
+  if (delegate_ != nullptr) {
+    return delegate_->ExistFormData();
+  }
+  return false;
+}
+
+void NWebDataBaseImpl::ClearFormData() {
+  if (delegate_ != nullptr) {
+    return delegate_->ClearFormData();
+  }
+  return;
+}
+
+}  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/ohos_nweb/src/nweb_data_base_impl.h b/ohos_nweb/src/nweb_data_base_impl.h
new file mode 100644
index 0000000000000..767193c56f337
--- /dev/null
+++ b/ohos_nweb/src/nweb_data_base_impl.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_DATA_BASE_IMPL_H
+#define NWEB_DATA_BASE_IMPL_H
+
+#include "nweb_data_base.h"
+#include "nweb_data_base_delegate.h"
+
+namespace OHOS::NWeb {
+
+class NWebDataBaseImpl : public NWebDataBase {
+ public:
+  NWebDataBaseImpl();
+
+  ~NWebDataBaseImpl() = default;
+
+  bool ExistHttpAuthCredentials() const override;
+
+  void DeleteHttpAuthCredentials() override;
+
+  void SaveHttpAuthCredentials(const std::string& host, const std::string& realm,
+    const std::string& username, const char* password) override;
+
+  std::vector<std::string> GetHttpAuthCredentials(const std::string& host,
+    const std::string& realm) const override;
+
+  bool ExistFormData() const;
+
+  void ClearFormData();
+
+ private:
+  std::shared_ptr<NWebDataBaseDelegate> delegate_;
+};
+
+}
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/nweb_delegate_interface.h b/ohos_nweb/src/nweb_delegate_interface.h
index f3f659e2a7641..e5aa0065917a4 100755
--- a/ohos_nweb/src/nweb_delegate_interface.h
+++ b/ohos_nweb/src/nweb_delegate_interface.h
@@ -19,11 +19,14 @@
 #include <functional>
 #include <string>
 #include "cef_delegate/nweb_inputmethod_client.h"
+#include "display_manager_adapter.h"
 #include "nweb_download_callback.h"
 #include "nweb_preference.h"
 #include "nweb_handler.h"
+
 namespace OHOS::NWeb {
-class NWebDelegateInterface {
+class NWebDelegateInterface
+  : public std::enable_shared_from_this<NWebDelegateInterface>{
  public:
   virtual ~NWebDelegateInterface() = default;
 
@@ -44,6 +47,10 @@ class NWebDelegateInterface {
   virtual void OnTouchMove(int32_t id, double x, double y) = 0;
   virtual void OnTouchCancel() = 0;
   virtual bool SendKeyEvent(int32_t keyCode, int32_t keyAction) = 0;
+  virtual void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) = 0;
+  virtual void SendMouseEvent(int x, int y, int button, int action) = 0;
+  virtual void NotifyScreenInfoChanged(RotationType rotation,
+                                       OrientationType orientation) = 0;
 
   virtual void Load(const std::string& url) = 0;
   virtual bool IsNavigatebackwardAllowed() const = 0;
@@ -51,15 +58,20 @@ class NWebDelegateInterface {
   virtual bool CanNavigateBackOrForward(int numSteps) const = 0;
   virtual void NavigateBack() const = 0;
   virtual void NavigateForward() const = 0;
+  virtual void NavigateBackOrForward(int32_t step) const = 0;
   virtual void DeleteNavigateHistory() = 0;
   virtual void Reload() const = 0;
+  virtual void ReloadOriginalUrl() const = 0;
   virtual void Zoom(float zoomFactor) const = 0;
+  virtual bool ZoomIn() const = 0;
+  virtual bool ZoomOut() const = 0;
   virtual void Stop() const = 0;
   virtual void ExecuteJavaScript(const std::string& code) const = 0;
   virtual void ExecuteJavaScript(
       const std::string& code,
       std::shared_ptr<NWebValueCallback<std::string>> callback) const = 0;
   virtual void PutBackgroundColor(int color) const = 0;
+  virtual void InitialScale(float scale) const = 0;
   virtual void OnPause() = 0;
   virtual void OnContinue() = 0;
   virtual std::shared_ptr<NWebPreference> GetPreference() const = 0;
@@ -87,6 +99,8 @@ class NWebDelegateInterface {
       const std::vector<std::string>& method_list) const = 0;
   virtual void RegisterNWebJavaScriptCallBack(
       std::shared_ptr<NWebJavaScriptResultCallBack> callback) = 0;
+  virtual void OnFocus() const = 0;
+  virtual void OnBlur() const = 0;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/src/nweb_impl.cc b/ohos_nweb/src/nweb_impl.cc
index 60804d852317f..ee7dc97585dad 100755
--- a/ohos_nweb/src/nweb_impl.cc
+++ b/ohos_nweb/src/nweb_impl.cc
@@ -21,6 +21,8 @@
 #include <map>
 #include <string>
 #include <thread>
+
+#include "base/lazy_instance.h"
 #include "nweb_delegate_adapter.h"
 #include "nweb_export.h"
 #include "nweb_handler.h"
@@ -30,6 +32,9 @@ namespace {
 uint32_t g_nweb_count = 0;
 const uint32_t kSurfaceMaxWidth = 7680;
 const uint32_t kSurfaceMaxHeight = 7680;
+
+// For NWebEx
+bool g_browser_service_api_enabled = false;
 }
 
 using namespace OHOS::NWeb;
@@ -55,7 +60,41 @@ extern "C" OHOS_NWEB_EXPORT NWeb* CreateNWeb(
 }
 
 namespace OHOS::NWeb {
-NWebImpl::NWebImpl(uint32_t id) : nweb_id_(id) {}
+
+// For NWebEx
+typedef std::unordered_map<int32_t, NWebImpl*> NWebMap;
+base::LazyInstance<NWebMap>::DestructorAtExit g_nweb_map =
+    LAZY_INSTANCE_INITIALIZER;
+
+base::LazyInstance<std::vector<std::string>>::DestructorAtExit g_browser_args =
+    LAZY_INSTANCE_INITIALIZER;
+
+NWebImpl* NWebImpl::FromID(int32_t nweb_id) {
+  NWebMap* map = g_nweb_map.Pointer();
+  auto it = map->find(nweb_id);
+  return it == map->end() ? nullptr : it->second;
+}
+
+void NWebImpl::InitBrowserServiceApi(std::vector<std::string>& browser_args) {
+  auto args = g_browser_args.Pointer();
+  args->clear();
+  for (const std::string& arg : browser_args) {
+    args->push_back(arg);
+  }
+  g_browser_service_api_enabled = true;
+}
+
+bool NWebImpl::GetBrowserServiceApiEnabled() {
+  return g_browser_service_api_enabled;
+}
+
+NWebImpl::NWebImpl(uint32_t id) : nweb_id_(id) {
+  g_nweb_map.Get().emplace(id, this);
+}
+
+NWebImpl::~NWebImpl() {
+  g_nweb_map.Get().erase(nweb_id_);
+}
 
 bool NWebImpl::Init(const NWebCreateInfo& create_info) {
   output_handler_ = NWebOutputHandler::Create(
@@ -81,6 +120,7 @@ bool NWebImpl::Init(const NWebCreateInfo& create_info) {
 }
 
 void NWebImpl::OnDestroy() {
+  WVLOG_I("NWebImpl::OnDestroy");
   if (g_nweb_count == 0) {
     return;
   }
@@ -91,6 +131,7 @@ void NWebImpl::OnDestroy() {
   }
   if (input_handler_ != nullptr) {
     input_handler_->OnDestroy();
+    input_handler_ = nullptr;
   }
 }
 
@@ -156,6 +197,12 @@ bool NWebImpl::InitWebEngine(const NWebCreateInfo& create_info) {
 
 void NWebImpl::InitWebEngineArgs(const NWebInitArgs& init_args) {
   web_engine_args_.clear();
+
+  auto args = g_browser_args.Get();
+  for (const std::string& arg : args) {
+    web_engine_args_.emplace_back(arg);
+  }
+
   web_engine_args_.emplace_back("/system/bin/web_render");
   web_engine_args_.emplace_back("--in-process-gpu");
   web_engine_args_.emplace_back("--disable-dev-shm-usage");
@@ -259,6 +306,20 @@ bool NWebImpl::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
   return input_handler_->SendKeyEvent(keyCode, keyAction);
 }
 
+void NWebImpl::SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) {
+  if (input_handler_ == nullptr) {
+    return;
+  }
+  input_handler_->SendMouseWheelEvent(x, y, deltaX, deltaY);
+}
+
+void NWebImpl::SendMouseEvent(int x, int y, int button, int action) {
+  if (input_handler_ == nullptr) {
+    return;
+  }
+  input_handler_->SendMouseEvent(x, y, button, action);
+}
+
 void NWebImpl::Load(const std::string& url) const {
   if (nweb_delegate_ == nullptr || output_handler_ == nullptr) {
     return;
@@ -308,6 +369,13 @@ void NWebImpl::NavigateForward() const {
   nweb_delegate_->NavigateForward();
 }
 
+void NWebImpl::NavigateBackOrForward(int step) const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->NavigateBackOrForward(step);
+}
+
 void NWebImpl::DeleteNavigateHistory() {
   if (nweb_delegate_ == nullptr) {
     return;
@@ -329,6 +397,20 @@ void NWebImpl::Zoom(float zoomFactor) const {
   nweb_delegate_->Zoom(zoomFactor);
 }
 
+bool NWebImpl::ZoomIn() const {
+  if (nweb_delegate_ == nullptr) {
+    return false;
+  }
+  return nweb_delegate_->ZoomIn();
+}
+
+bool NWebImpl::ZoomOut() const {
+  if (nweb_delegate_ == nullptr) {
+    return false;
+  }
+  return nweb_delegate_->ZoomOut();
+}
+
 void NWebImpl::Stop() const {
   if (nweb_delegate_ == nullptr) {
     return;
@@ -350,13 +432,20 @@ void NWebImpl::PutBackgroundColor(int color) const {
   nweb_delegate_->PutBackgroundColor(color);
 }
 
+void NWebImpl::InitialScale(float scale) const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->InitialScale(scale);
+}
+
 void NWebImpl::OnPause() const {
   if (nweb_delegate_ == nullptr) {
     return;
   }
   nweb_delegate_->OnPause();
   if (inputmethod_handler_ == nullptr) {
-      return;
+    return;
   }
   inputmethod_handler_->HideTextInput();
 }
@@ -382,6 +471,10 @@ std::string NWebImpl::Title() {
   return nweb_delegate_->Title();
 }
 
+uint32_t NWebImpl::GetWebId() const {
+  return nweb_id_;
+}
+
 HitTestResult NWebImpl::GetHitTestResult() const {
   return nweb_delegate_->GetHitTestResult();
 }
@@ -470,4 +563,31 @@ void NWebImpl::ExecuteJavaScript(
   }
   nweb_delegate_->ExecuteJavaScript(code, callback);
 }
+
+void NWebImpl::OnFocus() const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->OnFocus();
+}
+
+void NWebImpl::OnBlur() const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->OnBlur();
+  if (inputmethod_handler_ == nullptr) {
+    return;
+  }
+  inputmethod_handler_->HideTextInput();
+}
+
+void NWebImpl::ReloadOriginalUrl() const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+
+  nweb_delegate_->ReloadOriginalUrl();
+}
+
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/nweb_impl.h b/ohos_nweb/src/nweb_impl.h
index 65daaffe87c02..4d606c4888ab1 100755
--- a/ohos_nweb/src/nweb_impl.h
+++ b/ohos_nweb/src/nweb_impl.h
@@ -31,7 +31,7 @@ namespace OHOS::NWeb {
 class NWebImpl : public NWeb {
  public:
   NWebImpl(uint32_t id);
-  ~NWebImpl() = default;
+  ~NWebImpl();
 
   bool Init(const NWebCreateInfo& create_info);
   void OnDestroy() override;
@@ -44,6 +44,8 @@ class NWebImpl : public NWeb {
   void OnTouchCancel() override;
   void OnNavigateBack() override;
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction) override;
+  void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) override;
+  void SendMouseEvent(int x, int y, int button, int action) override;
 
   // public api
   void Load(const std::string& url) const override;
@@ -52,15 +54,19 @@ class NWebImpl : public NWeb {
   bool CanNavigateBackOrForward(int numSteps) const override;
   void NavigateBack() const override;
   void NavigateForward() const override;
+  void NavigateBackOrForward(int step) const override;
   void DeleteNavigateHistory() override;
   void Reload() const override;
   void Zoom(float zoomFactor) const override;
+  bool ZoomIn() const override;
+  bool ZoomOut() const override;
   void Stop() const override;
   void ExecuteJavaScript(const std::string& code) const override;
   void ExecuteJavaScript(
       const std::string& code,
       std::shared_ptr<NWebValueCallback<std::string>> callback) const override;
   void PutBackgroundColor(int color) const override;
+  void InitialScale(float scale) const override;
   void OnPause() const override;
   void OnContinue() const override;
   const std::shared_ptr<NWebPreference> GetPreference() const override;
@@ -69,6 +75,7 @@ class NWebImpl : public NWeb {
   void SetNWebHandler(std::shared_ptr<NWebHandler> handler) override;
   const std::shared_ptr<NWebHandler> GetNWebHandler() const override;
   std::string Title() override;
+  uint32_t GetWebId() const override;
   HitTestResult GetHitTestResult() const override;
   int PageLoadProgress() override;
   int ContentHeight() override;
@@ -91,6 +98,14 @@ class NWebImpl : public NWeb {
       const std::vector<std::string>& method_list) override;
   void SetNWebJavaScriptResultCallBack(
       std::shared_ptr<NWebJavaScriptResultCallBack> callback) override;
+  void OnFocus() const override;
+  void OnBlur() const override;
+
+  // For NWebEx
+  static NWebImpl* FromID(int32_t nweb_id);
+  void ReloadOriginalUrl() const;
+  static void InitBrowserServiceApi(std::vector<std::string>& browser_args);
+  static bool GetBrowserServiceApiEnabled();
 
  private:
   void ProcessInitArgs(const NWebInitArgs& init_args);
diff --git a/ohos_nweb/src/nweb_input_handler.cc b/ohos_nweb/src/nweb_input_handler.cc
index 0708fb360ea09..a7d4acc023464 100644
--- a/ohos_nweb/src/nweb_input_handler.cc
+++ b/ohos_nweb/src/nweb_input_handler.cc
@@ -101,6 +101,20 @@ bool NWebInputHandler::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
   return nweb_delegate_->SendKeyEvent(keyCode, keyAction);
 }
 
+void NWebInputHandler::SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->SendMouseWheelEvent(x, y, deltaX, deltaY);
+}
+
+void NWebInputHandler::SendMouseEvent(int x, int y, int button, int action) {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->SendMouseEvent(x, y, button, action);
+}
+
 void NWebInputHandler::CheckSlideNavigation(int16_t start_x, int16_t end_x) {
   if (nweb_delegate_ == nullptr) {
     return;
diff --git a/ohos_nweb/src/nweb_input_handler.h b/ohos_nweb/src/nweb_input_handler.h
index 3351edbf94683..e371e77ad8c2c 100644
--- a/ohos_nweb/src/nweb_input_handler.h
+++ b/ohos_nweb/src/nweb_input_handler.h
@@ -40,6 +40,8 @@ class NWebInputHandler {
   void OnTouchCancel();
   void OnNavigateBack();
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction);
+  void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY);
+  void SendMouseEvent(int x, int y, int button, int action);
 
  private:
   void CheckSlideNavigation(int16_t start_x, int16_t end_x);
diff --git a/ohos_nweb/src/nweb_inputmethod_handler.cc b/ohos_nweb/src/nweb_inputmethod_handler.cc
index 08e9f6ecac41d..8c221788180e8 100644
--- a/ohos_nweb/src/nweb_inputmethod_handler.cc
+++ b/ohos_nweb/src/nweb_inputmethod_handler.cc
@@ -24,16 +24,24 @@
 #include "cef/include/cef_task.h"
 #include "content/public/browser/browser_thread.h"
 #include "libcef/browser/thread_util.h"
+#include "ui/events/keycodes/keyboard_codes_posix.h"
 
 namespace OHOS::NWeb {
+using namespace OHOS::MiscServices;
+
+static constexpr char16_t DEL_CHAR = 127;
+
 class OnTextChangedListenerImpl
-    : public OHOS::MiscServices::OnTextChangedListener {
+    : public OnTextChangedListener {
  public:
   OnTextChangedListenerImpl(NWebInputMethodHandler* handler)
       : handler_(handler) {}
 
   // All following listenser callbacks should invoke call on UI thread
   void InsertText(const std::u16string& text) override {
+    if (text.size() == 1 && text.front() == '\n') {
+      return;
+    }
     handler_->InsertText(text);
   }
 
@@ -45,17 +53,18 @@ class OnTextChangedListenerImpl
     handler_->DeleteBackward(length);
   }
 
-  void SendKeyEventFromInputMethod(
-      const OHOS::MiscServices::KeyEvent& event) override {
+  void SendKeyEventFromInputMethod(const KeyEvent& event) override {
     LOG(INFO) << "NWebInputMethodHandler::SendKeyEventFromInputMethod";
   }
 
-  void SendKeyboardInfo(const OHOS::MiscServices::KeyboardInfo& info) override {
+  void SendKeyboardInfo(const KeyboardInfo& info) override {
     auto status = info.GetKeyboardStatus();
-    if (status == OHOS::MiscServices::KeyboardStatus::SHOW) {
+    if (status == KeyboardStatus::SHOW) {
       handler_->SetIMEStatus(true);
-    } else if (status == OHOS::MiscServices::KeyboardStatus::HIDE) {
+    } else if (status == KeyboardStatus::HIDE) {
       handler_->SetIMEStatus(false);
+    } else if (status == KeyboardStatus::NONE) {
+      handler_->SendEnterKeyEvent();
     }
   }
 
@@ -63,8 +72,12 @@ class OnTextChangedListenerImpl
     handler_->SetIMEStatus(status);
   }
 
-  void MoveCursor(const OHOS::MiscServices::Direction direction) override {
-    LOG(INFO) << "NWebInputMethodHandler::MoveCursor";
+  void MoveCursor(const Direction direction) override {
+    if (direction == Direction::NONE) {
+      LOG(ERROR) << "NWebInputMethodHandler::MoveCursor got none direction";
+      return;
+    }
+    handler_->MoveCursor(direction);
   }
 
  private:
@@ -98,7 +111,7 @@ void NWebInputMethodHandler::Attach(CefRefPtr<CefBrowser> browser) {
   if (inputmethod_listener_ == nullptr) {
     inputmethod_listener_ = new OnTextChangedListenerImpl(this);
   }
-  OHOS::MiscServices::InputMethodController::GetInstance()->Attach(inputmethod_listener_);
+  InputMethodController::GetInstance()->Attach(inputmethod_listener_);
 }
 
 void NWebInputMethodHandler::ShowTextInput() {
@@ -107,7 +120,7 @@ void NWebInputMethodHandler::ShowTextInput() {
 
 void NWebInputMethodHandler::HideTextInput() {
   LOG(INFO) << "NWebInputMethodHandler::HideTextInput " << ime_shown_;
-  OHOS::MiscServices::InputMethodController::GetInstance()->HideTextInput();
+  InputMethodController::GetInstance()->HideTextInput();
 }
 
 void NWebInputMethodHandler::OnTextSelectionChanged(
@@ -124,6 +137,10 @@ void NWebInputMethodHandler::OnTextSelectionChanged(
   selected_to_ = selected_range.to;
   ime_text_composing_ = false;
   composing_text_.clear();
+
+  std::lock_guard<std::mutex> lock(textSelectMutex_);
+  isTextSelectReady_ = true;
+  textSelectCv_.notify_all();
 }
 
 void NWebInputMethodHandler::SetIMEStatus(bool status) {
@@ -135,7 +152,19 @@ void NWebInputMethodHandler::SetIMEStatus(bool status) {
 }
 
 void NWebInputMethodHandler::InsertText(const std::u16string& text) {
+  if (text.empty()) {
+    LOG(ERROR) << "insert text empty!";
+    return;
+  }
+
   if (browser_ != nullptr && browser_->GetHost() != nullptr) {
+    std::unique_lock<std::mutex> lock(textSelectMutex_);
+    bool isNormal = textSelectCv_.wait_for(lock, std::chrono::seconds(1), [this] { return isTextSelectReady_; });
+    if (!isNormal) {
+        LOG(ERROR) << "InsertText wait_for timeout";
+    }
+    isTextSelectReady_ = false;
+
     CefRefPtr<CefTask> insert_task = new InputMethodTask(base::Bind(
         &NWebInputMethodHandler::InsertTextHandlerOnUI, this, std::move(text)));
     browser_->GetHost()->PostTaskToUIThread(insert_task);
@@ -152,6 +181,13 @@ void NWebInputMethodHandler::DeleteBackward(int32_t length) {
 
 void NWebInputMethodHandler::DeleteForward(int32_t length) {
   if (browser_ != nullptr && browser_->GetHost() != nullptr) {
+    std::unique_lock<std::mutex> lock(textSelectMutex_);
+    bool isNormal = textSelectCv_.wait_for(lock, std::chrono::seconds(1), [this] { return isTextSelectReady_; });
+    if (!isNormal) {
+        LOG(ERROR) << "DeleteForward wait_for timeout";
+    }
+    isTextSelectReady_ = false;
+
     CefRefPtr<CefTask> delete_task = new InputMethodTask(base::Bind(
         &NWebInputMethodHandler::DeleteForwardHandlerOnUI, this, length));
     browser_->GetHost()->PostTaskToUIThread(delete_task);
@@ -196,7 +232,26 @@ void NWebInputMethodHandler::InsertTextHandlerOnUI(const std::u16string& text) {
 }
 
 void NWebInputMethodHandler::DeleteBackwardHandlerOnUI(int32_t length) {
-  LOG(INFO) << "DeleteBackwardHandlerOnUI unimplement" << length;
+  CefKeyEvent keyEvent;
+  keyEvent.windows_key_code = ui::VKEY_DELETE;
+  keyEvent.native_key_code = static_cast<int>(ScanKeyCode::DELETE_SCAN_CODE);
+  keyEvent.modifiers = 0;
+  keyEvent.is_system_key = false;
+  keyEvent.character = keyEvent.unmodified_character = DEL_CHAR;
+
+  if (!browser_ || !browser_->GetHost()) {
+    LOG(ERROR) << "delete backward browser get failed";
+    return;
+  }
+
+  for (int32_t i = 0; i < length; i++) {
+    keyEvent.type = KEYEVENT_RAWKEYDOWN;
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+    keyEvent.type = KEYEVENT_CHAR;
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+  keyEvent.type = KEYEVENT_KEYUP;
+  browser_->GetHost()->SendKeyEvent(keyEvent);
 }
 
 void NWebInputMethodHandler::DeleteForwardHandlerOnUI(int32_t length) {
@@ -232,4 +287,74 @@ void NWebInputMethodHandler::DeleteForwardHandlerOnUI(int32_t length) {
     browser_->GetHost()->ImeCommitText(result, replace_range, 0);
   }
 }
+
+void NWebInputMethodHandler::SendEnterKeyEvent() {
+  CefKeyEvent keyEvent;
+  keyEvent.windows_key_code = ui::VKEY_RETURN;
+  keyEvent.native_key_code = static_cast<int>(ScanKeyCode::ENTER_SCAN_CODE);
+
+  keyEvent.type = KEYEVENT_KEYDOWN;
+  keyEvent.character = '\r';
+  keyEvent.modifiers = 0;
+  keyEvent.is_system_key = false;
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+
+  keyEvent.type = KEYEVENT_CHAR;
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+
+  keyEvent.type = KEYEVENT_KEYUP;
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+}
+
+void NWebInputMethodHandler::MoveCursor(const Direction direction)
+{
+  LOG(INFO) << "NWebInputMethodHandler::MoveCursor called";
+  CefKeyEvent keyEvent;
+
+  switch (direction)
+  {
+    case Direction::UP: {
+      keyEvent.windows_key_code = ui::VKEY_UP;
+      keyEvent.native_key_code = static_cast<int>(ScanKeyCode::UP_SCAN_CODE);
+      break;
+    }
+    case Direction::LEFT: {
+      keyEvent.windows_key_code = ui::VKEY_LEFT;
+      keyEvent.native_key_code = static_cast<int>(ScanKeyCode::LEFT_SCAN_CODE);
+      break;
+    }
+    case Direction::RIGHT: {
+      keyEvent.windows_key_code = ui::VKEY_RIGHT;
+      keyEvent.native_key_code = static_cast<int>(ScanKeyCode::RIGHT_SCAN_CODE);
+      break;
+    }
+    case Direction::DOWN: {
+      keyEvent.windows_key_code = ui::VKEY_DOWN;
+      keyEvent.native_key_code = static_cast<int>(ScanKeyCode::DOWN_SCAN_CODE);
+      break;
+    }
+    default: {
+      LOG(ERROR) << "invalid direction";
+      return;
+    }
+  }
+
+  keyEvent.type = KEYEVENT_KEYDOWN;
+  keyEvent.modifiers = 0;
+  keyEvent.is_system_key = false;
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+
+  keyEvent.type = KEYEVENT_KEYUP;
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+}
 }  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/ohos_nweb/src/nweb_inputmethod_handler.h b/ohos_nweb/src/nweb_inputmethod_handler.h
index 9cb6c7c62f471..289c542bc9a5d 100644
--- a/ohos_nweb/src/nweb_inputmethod_handler.h
+++ b/ohos_nweb/src/nweb_inputmethod_handler.h
@@ -15,7 +15,8 @@
 
 #ifndef OHOS_NWEB_SRC_NWEB_INPUTMETHOD_HANDLER_H_
 #define OHOS_NWEB_SRC_NWEB_INPUTMETHOD_HANDLER_H_
-
+#include <condition_variable>
+#include <chrono>
 #include "input_method_controller.h"
 
 #include "cef_delegate/nweb_inputmethod_client.h"
@@ -36,6 +37,8 @@ class NWebInputMethodHandler : public NWebInputMethodClient {
   void InsertText(const std::u16string& text);
   void DeleteBackward(int32_t length);
   void DeleteForward(int32_t length);
+  void SendEnterKeyEvent();
+  void MoveCursor(const OHOS::MiscServices::Direction direction);
 
  private:
   void SetIMEStatusOnUI(bool status);
@@ -50,11 +53,129 @@ class NWebInputMethodHandler : public NWebInputMethodClient {
   std::u16string composing_text_;
   int selected_from_;
   int selected_to_;
-  OHOS::sptr<OHOS::MiscServices::OnTextChangedListener> inputmethod_listener_ = nullptr;
+  OHOS::sptr<OHOS::MiscServices::OnTextChangedListener> inputmethod_listener_ =
+      nullptr;
+
+  bool isTextSelectReady_ = true;
+  std::mutex textSelectMutex_;
+  std::condition_variable textSelectCv_;
 
   IMPLEMENT_REFCOUNTING(NWebInputMethodHandler);
   DISALLOW_COPY_AND_ASSIGN(NWebInputMethodHandler);
 };
-} // namespace OHOS::NWeb
+
+enum ScanKeyCode {
+  ESCAPE_SCAN_CODE = 0x009,
+  DIGIT1_SCAN_CODE = 0x00A,
+  DIGIT2_SCAN_CODE = 0x00B,
+  DIGIT3_SCAN_CODE = 0x00C,
+  DIGIT4_SCAN_CODE = 0x00D,
+  DIGIT5_SCAN_CODE = 0x00E,
+  DIGIT6_SCAN_CODE = 0x00F,
+  DIGIT7_SCAN_CODE = 0x010,
+  DIGIT8_SCAN_CODE = 0x011,
+  DIGIT9_SCAN_CODE = 0x012,
+  DIGIT0_SCAN_CODE = 0x013,
+  MINUS_SCAN_CODE = 0x014,
+  EQUAL_SCAN_CODE = 0x015,
+  BACKSPACE_SCAN_CODE = 0x016,
+  TAB_SCAN_CODE = 0x0017,
+  KEYQ_SCAN_CODE = 0x0018,
+  KEYW_SCAN_CODE = 0x0019,
+  KEYE_SCAN_CODE = 0x001A,
+  KEYR_SCAN_CODE = 0x001B,
+  KEYT_SCAN_CODE = 0x001C,
+  KEYY_SCAN_CODE = 0x001D,
+  KEYU_SCAN_CODE = 0x001E,
+  KEYI_SCAN_CODE = 0x001F,
+  KEYO_SCAN_CODE = 0x0020,
+  KEYP_SCAN_CODE = 0x0021,
+  BRACKETLEFT_SCAN_CODE = 0x0022,
+  BRACKETRIGHT_SCAN_CODE = 0x0023,
+  ENTER_SCAN_CODE = 0x0024,
+  CONTROLLEFT_SCAN_CODE = 0x0025,
+  KEYA_SCAN_CODE = 0x0026,
+  KEYS_SCAN_CODE = 0x0027,
+  KEYD_SCAN_CODE = 0x0028,
+  KEYF_SCAN_CODE = 0x0029,
+  KEYG_SCAN_CODE = 0x002A,
+  KEYH_SCAN_CODE = 0x002B,
+  KEYJ_SCAN_CODE = 0x002C,
+  KEYK_SCAN_CODE = 0x002D,
+  KEYL_SCAN_CODE = 0x002E,
+  SEMICOLON_SCAN_CODE = 0x002F,
+  QUOTE_SCAN_CODE = 0x0030,
+  BACKQUOTE_SCAN_CODE = 0x0031,
+  SHIFTLEFT_SCAN_CODE = 0x0032,
+  BACKSLASH_SCAN_CODE = 0x0033,
+  KEYZ_SCAN_CODE = 0x0034,
+  KEYX_SCAN_CODE = 0x0035,
+  KEYC_SCAN_CODE = 0x0036,
+  KEYV_SCAN_CODE = 0x0037,
+  KEYB_SCAN_CODE = 0x0038,
+  KEYN_SCAN_CODE = 0x0039,
+  KEYM_SCAN_CODE = 0x003A,
+  COMMA_SCAN_CODE = 0x003B,
+  PERIOD_SCAN_CODE = 0x003C,
+  SLASH_SCAN_CODE = 0x003D,
+  SHIFTRIGHT_SCAN_CODE = 0x003E,
+  NUMPADMULTIPLY_SCAN_CODE = 0x003F,
+  ALTLEFT_SCAN_CODE = 0x0040,
+  SPACE_SCAN_CODE = 0x0041,
+  CAPSLOCK_SCAN_CODE = 0x0042,
+  F1_SCAN_CODE = 0x0043,
+  F2_SCAN_CODE = 0x0044,
+  F3_SCAN_CODE = 0x0045,
+  F4_SCAN_CODE = 0x0046,
+  F5_SCAN_CODE = 0x0047,
+  F6_SCAN_CODE = 0x0048,
+  F7_SCAN_CODE = 0x0049,
+  F8_SCAN_CODE = 0x004A,
+  F9_SCAN_CODE = 0x004B,
+  F10_SCAN_CODE = 0x004C,
+  NUMLOCK_SCAN_CODE = 0x004D,
+  SCROLLLOCK_SCAN_CODE = 0x004E,
+  NUMPAD7_SCAN_CODE = 0x004F,
+  NUMPAD8_SCAN_CODE = 0x0050,
+  NUMPAD9_SCAN_CODE = 0x0051,
+  NUMPADSUBTRACT_SCAN_CODE = 0x0052,
+  NUMPAD4_SCAN_CODE = 0x0053,
+  NUMPAD5_SCAN_CODE = 0x0054,
+  NUMPAD6_SCAN_CODE = 0x0055,
+  NUMPADADD_SCAN_CODE = 0x0056,
+  NUMPAD1_SCAN_CODE = 0x0057,
+  NUMPAD2_SCAN_CODE = 0x0058,
+  NUMPAD3_SCAN_CODE = 0x0059,
+  NUMPAD0_SCAN_CODE = 0x005A,
+  NUMPADDECIMAL_SCAN_CODE = 0x005B,
+  INTLBACKSLASH_SCAN_CODE = 0x005E,
+  F11_SCAN_CODE = 0x005F,
+  F12_SCAN_CODE = 0x0060,
+  INTLRO_SCAN_CODE = 0x0061,
+  CONVERT_SCAN_CODE = 0x0064,
+  KANAMODE_SCAN_CODE = 0x0065,
+  NONCONVERT_SCAN_CODE = 0x0066,
+  NUMPADENTER_SCAN_CODE = 0x0068,
+  CONTROLRIGHT_SCAN_CODE = 0x0069,
+  NUMPADDIVIDE_SCAN_CODE = 0x006A,
+  PRINTSCREEN_SCAN_CODE = 0x006B,
+  ALTRIGHT_SCAN_CODE = 0x006C,
+  HOME_SCAN_CODE = 0x006E,
+  UP_SCAN_CODE = 0x006F,
+  PAGE_UP_SCAN_CODE = 0x0070,
+  LEFT_SCAN_CODE = 0x0071,
+  RIGHT_SCAN_CODE = 0x0072,
+  END_SCAN_CODE = 0x0073,
+  DOWN_SCAN_CODE = 0x0074,
+  PAGE_DOWN_SCAN_CODE = 0x0075,
+  INSERT_SCAN_CODE = 0x0076,
+  DELETE_SCAN_CODE = 0x0077,
+  NUMPADEQUAL_SCAN_CODE = 0x007D,
+  PAUSE_SCAN_CODE = 0x007F,
+  NUMPADCOMMA_SCAN_CODE = 0x0081,
+  METALEFT_SCAN_CODE = 0x0085,
+  METARIGHT_SCAN_CODE = 0x0086,
+};
+}  // namespace OHOS::NWeb
 
 #endif  // OHOS_NWEB_SRC_NWEB_INPUTMETHOD_HANDLER_H_
\ No newline at end of file
diff --git a/ohos_nweb/src/nweb_web_storage_delegate_interface.h b/ohos_nweb/src/nweb_web_storage_delegate_interface.h
new file mode 100644
index 0000000000000..f8dfae2cd6cde
--- /dev/null
+++ b/ohos_nweb/src/nweb_web_storage_delegate_interface.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_WEB_STORAGE_DELEGATE_INTERFACE_H
+#define NWEB_WEB_STORAGE_DELEGATE_INTERFACE_H
+
+#include <memory>
+#include <string>
+#include <vector>
+#include "nweb_value_callback.h"
+#include "nweb_web_storage.h"
+
+namespace OHOS::NWeb {
+using NWebGetOriginsCallback = NWebValueCallback<std::vector<NWebWebStorageOrigin>>;
+class NWebWebStorageDelegateInterface {
+ public:
+  virtual ~NWebWebStorageDelegateInterface() = default;
+  virtual void DeleteAllData() = 0;
+  virtual void DeleteOrigin(const std::string& origin) = 0;
+  virtual void GetOrigins(std::shared_ptr<NWebGetOriginsCallback> callback) = 0;
+  virtual void GetOrigins(std::vector<NWebWebStorageOrigin>& origins) = 0;
+  virtual void GetOriginQuota(const std::string& origin,
+                              std::shared_ptr<NWebValueCallback<long>> callback) = 0;
+  virtual long GetOriginQuota(const std::string& origin) = 0;
+  virtual void GetOriginUsage(const std::string& origin,
+                              std::shared_ptr<NWebValueCallback<long>> callback) = 0;
+  virtual long GetOriginUsage(const std::string& origin) = 0;
+};
+}  // namespace OHOS::NWeb
+#endif
diff --git a/ohos_nweb/src/nweb_web_storage_impl.cc b/ohos_nweb/src/nweb_web_storage_impl.cc
new file mode 100644
index 0000000000000..ba8d0bdf7f1d4
--- /dev/null
+++ b/ohos_nweb/src/nweb_web_storage_impl.cc
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_web_storage_impl.h"
+#include "nweb_web_storage_delegate.h"
+#include "nweb_hilog.h"
+
+using namespace OHOS::NWeb;
+
+extern "C" OHOS_NWEB_EXPORT NWebWebStorage* GetWebStorage() {
+  WVLOG_I("GetWebStorage");
+  static NWebWebStorageImpl web_storage;
+  return &web_storage;
+}
+
+namespace OHOS::NWeb {
+NWebWebStorageImpl::NWebWebStorageImpl() {
+#if defined(USE_CEF)
+  delegate_ = std::make_shared<NWebWebStorageDelegate>();
+#endif
+}
+
+void NWebWebStorageImpl::DeleteAllData() {
+  if (delegate_ != nullptr) {
+    delegate_->DeleteAllData();
+  }
+}
+
+void NWebWebStorageImpl::DeleteOrigin(const std::string& origin) {
+  if (delegate_ != nullptr) {
+    delegate_->DeleteOrigin(origin);
+  }
+}
+
+void NWebWebStorageImpl::GetOrigins(std::shared_ptr<NWebGetOriginsCallback> callback) {
+  if (delegate_ != nullptr) {
+    delegate_->GetOrigins(callback);
+  }
+}
+
+std::vector<NWebWebStorageOrigin> NWebWebStorageImpl::GetOrigins() {
+  std::vector<NWebWebStorageOrigin> origins;
+  if (delegate_ != nullptr) {
+    delegate_->GetOrigins(origins);
+  }
+  return origins;
+}
+
+void NWebWebStorageImpl::GetOriginQuota(const std::string& origin,
+    std::shared_ptr<NWebValueCallback<long>> callback) {
+  if (delegate_ != nullptr) {
+    delegate_->GetOriginQuota(origin, callback);
+  }
+}
+
+long NWebWebStorageImpl::GetOriginQuota(const std::string& origin) {
+  if (delegate_ != nullptr) {
+    return delegate_->GetOriginQuota(origin);
+  }
+  return -1;
+}
+
+void NWebWebStorageImpl::GetOriginUsage(const std::string& origin,
+    std::shared_ptr<NWebValueCallback<long>> callback) {
+  if (delegate_ != nullptr) {
+    delegate_->GetOriginUsage(origin, callback);
+  }
+}
+
+long NWebWebStorageImpl::GetOriginUsage(const std::string& origin) {
+  if (delegate_ != nullptr) {
+    return delegate_->GetOriginUsage(origin);
+  }
+  return -1;
+}
+
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/nweb_web_storage_impl.h b/ohos_nweb/src/nweb_web_storage_impl.h
new file mode 100644
index 0000000000000..28373ceea6fb7
--- /dev/null
+++ b/ohos_nweb/src/nweb_web_storage_impl.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_WEB_STORAGE_IMPL_H
+#define NWEB_WEB_STORAGE_IMPL_H
+
+#include "nweb_web_storage.h"
+#include "nweb_web_storage_delegate_interface.h"
+
+namespace OHOS::NWeb {
+class NWebWebStorageImpl : public NWebWebStorage {
+ public:
+  NWebWebStorageImpl();
+  ~NWebWebStorageImpl() = default;
+
+  void DeleteAllData() override;
+  void DeleteOrigin(const std::string& origin) override;
+  void GetOrigins(std::shared_ptr<NWebGetOriginsCallback> callback) override;
+  std::vector<NWebWebStorageOrigin> GetOrigins() override;
+  void GetOriginQuota(const std::string& origin,
+      std::shared_ptr<NWebValueCallback<long>> callback) override;
+  long GetOriginQuota(const std::string& origin) override;
+  void GetOriginUsage(const std::string& origin,
+      std::shared_ptr<NWebValueCallback<long>> callback) override;
+  long GetOriginUsage(const std::string& origin) override;
+ private:
+  std::shared_ptr<NWebWebStorageDelegateInterface> delegate_;
+};
+}  // namespace OHOS::NWeb
+
+#endif  // NWEB_WEB_STORAGE_IMPL_H
diff --git a/services/device/battery/BUILD.gn b/services/device/battery/BUILD.gn
index f2a1bc3544fc8..25553e1c36771 100644
--- a/services/device/battery/BUILD.gn
+++ b/services/device/battery/BUILD.gn
@@ -57,6 +57,12 @@ if (!is_android) {
         "battery_status_manager_win.cc",
         "battery_status_manager_win.h",
       ]
+    } else if (is_ohos) {
+      sources += [ "battery_status_manager_ohos.cc" ]
+      import("//build/config/ohos/config.gni")
+      libs = [ "nweb_ohos_adapter.z" ]
+      include_dirs = ohos_src_includes
+      lib_dirs = ohos_libs_dir
     } else {
       sources += [ "battery_status_manager_default.cc" ]
     }
diff --git a/services/device/battery/battery_status_manager_ohos.cc b/services/device/battery/battery_status_manager_ohos.cc
new file mode 100755
index 0000000000000..2889c2aa7c7a3
--- /dev/null
+++ b/services/device/battery/battery_status_manager_ohos.cc
@@ -0,0 +1,128 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/device/battery/battery_status_manager.h"
+
+#include <memory>
+
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "ohos_adapter_helper.h"
+
+using namespace OHOS::NWeb;
+namespace device {
+namespace {
+class BatteryManagerListener : public base::RefCountedThreadSafe<BatteryManagerListener> {
+ public:
+  explicit BatteryManagerListener(
+      const BatteryStatusService::BatteryUpdateCallback& callback) : callback_(callback), isListen(false) {
+        batteryClient = OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateBatteryClientAdapter();
+        if (batteryClient == nullptr) {
+            return;
+        }
+        batteryClient->RegBatteryEvent([this](WebBatteryInfo& info) {
+            this->BatteryChanged(info);
+        });
+      }
+
+  bool StartListen() {
+    LOG(INFO) << "start listen";
+    if (isListen) {
+        return true;
+    }
+    if (batteryClient == nullptr) {
+        return false;
+    }
+    if (!batteryClient->StartListen()) {
+        LOG(ERROR) << "start listen fail";
+        return false;
+    }
+    LOG(INFO) << "fisrt request battery info";
+    std::unique_ptr<WebBatteryInfo> batteryInfo = batteryClient->RequestBatteryInfo();
+    if (batteryInfo != nullptr) {
+        mojom::BatteryStatus status;
+        status.level = batteryInfo->GetLevel();
+        status.charging = batteryInfo->IsCharging();
+        status.charging_time = std::numeric_limits<double>::infinity();
+        if(status.charging) {
+            status.discharging_time = std::numeric_limits<double>::infinity();
+        } else {
+            status.discharging_time = 0.0;
+        }
+        callback_.Run(status);
+    } else {
+        callback_.Run(mojom::BatteryStatus());
+    }
+    isListen = true;
+    return true;
+  }
+
+  void StopListen() {
+    if (!isListen) {
+       return;
+    }
+    LOG(INFO) << "stop Listen";
+    if (batteryClient == nullptr) {
+        return;
+    }
+    batteryClient->StopListen();
+    isListen = false;
+  }
+
+ private:
+  void BatteryChanged(WebBatteryInfo& info) {
+    mojom::BatteryStatus status;
+    status.level = info.GetLevel();
+    status.charging = info.IsCharging();
+    status.charging_time = std::numeric_limits<double>::infinity();
+    if(status.charging) {
+        status.discharging_time = std::numeric_limits<double>::infinity();
+    } else {
+        status.discharging_time = 0.0;
+    }
+    LOG(INFO) << "recive battery changed" << status.level << status.charging;
+    callback_.Run(status);
+  }
+
+  BatteryStatusService::BatteryUpdateCallback callback_;
+  bool isListen;
+  std::unique_ptr<BatteryMgrClientAdapter> batteryClient = nullptr;
+
+  DISALLOW_COPY_AND_ASSIGN(BatteryManagerListener);
+};
+
+class BatteryStatusManagerOhos: public BatteryStatusManager {
+ public:
+  explicit BatteryStatusManagerOhos(
+      const BatteryStatusService::BatteryUpdateCallback& callback)
+      : observer_(base::MakeRefCounted<BatteryManagerListener>(callback)) {}
+
+  ~BatteryStatusManagerOhos() override {
+    LOG(INFO) << "battery release";
+    observer_->StopListen();
+  }
+
+ private:
+  bool StartListeningBatteryChange() override {
+    LOG(INFO) << "start listening battery change";
+    return observer_->StartListen();
+  }
+
+  void StopListeningBatteryChange() override {
+    LOG(INFO) << "stop listen battery change";
+    observer_->StopListen();
+  }
+
+  scoped_refptr<BatteryManagerListener> observer_;
+  DISALLOW_COPY_AND_ASSIGN(BatteryStatusManagerOhos);
+};
+
+}
+
+std::unique_ptr<BatteryStatusManager> BatteryStatusManager::Create(
+    const BatteryStatusService::BatteryUpdateCallback& callback) {
+  return std::make_unique<BatteryStatusManagerOhos>(callback);
+}
+
+}
diff --git a/services/device/wake_lock/power_save_blocker/BUILD.gn b/services/device/wake_lock/power_save_blocker/BUILD.gn
index 8ca1d4da121f8..1439d5cf6f87f 100644
--- a/services/device/wake_lock/power_save_blocker/BUILD.gn
+++ b/services/device/wake_lock/power_save_blocker/BUILD.gn
@@ -70,6 +70,12 @@ source_set("power_save_blocker") {
     ]
   } else if (is_win) {
     sources += [ "power_save_blocker_win.cc" ]
+  } else if (is_ohos) {
+    sources += [ "power_save_blocker_ohos.cc" ]
+    import("//build/config/ohos/config.gni")
+    libs = [ "nweb_ohos_adapter.z" ]
+    include_dirs = ohos_src_includes
+    lib_dirs = ohos_libs_dir
   } else {
     # Fuchsia and non-DBus Linux.
     sources += [ "power_save_blocker_stub.cc" ]
diff --git a/services/device/wake_lock/power_save_blocker/power_save_blocker_ohos.cc b/services/device/wake_lock/power_save_blocker/power_save_blocker_ohos.cc
new file mode 100644
index 0000000000000..95d320fab6bda
--- /dev/null
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_ohos.cc
@@ -0,0 +1,74 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/device/wake_lock/power_save_blocker/power_save_blocker.h"
+
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/logging.h"
+#include "ohos_adapter_helper.h"
+
+using namespace OHOS::NWeb;
+namespace device {
+
+class PowerSaveBlocker::Delegate
+    : public base::RefCountedThreadSafe<PowerSaveBlocker::Delegate> {
+ public:
+  Delegate();
+
+  void ApplyBlock();
+  void RemoveBlock();
+
+ private:
+  friend class base::RefCountedThreadSafe<Delegate>;
+  virtual ~Delegate() {}
+
+  std::unique_ptr<PowerMgrClientAdapter> power_mgr_client_ = nullptr;
+  std::shared_ptr<RunningLockAdapter> lock_ = nullptr;
+
+  DISALLOW_COPY_AND_ASSIGN(Delegate);
+};
+
+PowerSaveBlocker::Delegate::Delegate() {
+  power_mgr_client_ =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().CreatePowerMgrClientAdapter();
+  if (power_mgr_client_ != nullptr) {
+    lock_ = power_mgr_client_->CreateRunningLock(
+      "nweb_lock", RunningLockAdapterType::SCREEN);
+  }
+}
+
+void PowerSaveBlocker::Delegate::ApplyBlock() {
+  if (lock_ != nullptr) {
+    lock_->Lock(0);
+  }
+}
+
+void PowerSaveBlocker::Delegate::RemoveBlock() {
+  if (lock_ != nullptr) {
+    lock_->UnLock();
+  }
+}
+
+PowerSaveBlocker::PowerSaveBlocker(
+    mojom::WakeLockType type,
+    mojom::WakeLockReason reason,
+    const std::string& description,
+    scoped_refptr<base::SequencedTaskRunner> ui_task_runner,
+    scoped_refptr<base::SingleThreadTaskRunner> blocking_task_runner)
+    : delegate_(new Delegate()),
+      ui_task_runner_(ui_task_runner),
+      blocking_task_runner_(blocking_task_runner) {
+  if (delegate_.get()) {
+    delegate_->ApplyBlock();
+  }
+}
+
+PowerSaveBlocker::~PowerSaveBlocker() {
+  if (delegate_.get()) {
+    delegate_->RemoveBlock();
+  }
+}
+
+}  // namespace device
\ No newline at end of file
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index cab3a8937801e..f0c31f64312c6 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -655,6 +655,12 @@ component("skia") {
   }
 }
 
+  #ifdef OHOS_NWEB_EX
+  if (ohos_nweb_ex_config_name != "") {
+    configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
+    configs += [ "//build/config:ohos_nweb_ex_def_other" ]
+  }  #endif  // OHOS_NWEB_EX
+
 # Template for things that are logically part of :skia, but need to be split out
 # so custom compile flags can be applied.
 #
diff --git a/storage/browser/database/database_tracker.cc b/storage/browser/database/database_tracker.cc
index 6e72a8ffcef83..107d448ccd1cf 100644
--- a/storage/browser/database/database_tracker.cc
+++ b/storage/browser/database/database_tracker.cc
@@ -48,6 +48,12 @@ const base::FilePath::CharType kTemporaryDirectoryPrefix[] =
 const base::FilePath::CharType kTemporaryDirectoryPattern[] =
     FILE_PATH_LITERAL("DeleteMe*");
 
+#ifdef OS_OHOS
+const std::u16string baseDatabaseDir = base::UTF8ToUTF16("/data/storage/el2/base/");
+const std::u16string divisionStr = base::UTF8ToUTF16("/");
+const std::u16string suffixStr = base::UTF8ToUTF16(".db");
+#endif
+
 OriginInfo::OriginInfo()
     : total_size_(0) {}
 
@@ -276,6 +282,12 @@ base::FilePath DatabaseTracker::GetOriginDirectory(
 base::FilePath DatabaseTracker::GetFullDBFilePath(
     const std::string& origin_identifier,
     const std::u16string& database_name) {
+#ifdef OS_OHOS
+  DCHECK(!origin_identifier.empty());
+  std::u16string origin_directory = base::UTF8ToUTF16(origin_identifier);
+  std::u16string filename = baseDatabaseDir + origin_directory + divisionStr + database_name + suffixStr;
+  return base::FilePath::FromUTF16Unsafe(filename);
+#else
   DCHECK(task_runner_->RunsTasksInCurrentSequence());
   DCHECK(!origin_identifier.empty());
   if (!LazyInit())
@@ -288,6 +300,7 @@ base::FilePath DatabaseTracker::GetFullDBFilePath(
 
   return GetOriginDirectory(origin_identifier)
       .AppendASCII(base::NumberToString(id));
+#endif
 }
 
 bool DatabaseTracker::GetOriginInfo(const std::string& origin_identifier,
diff --git a/third_party/blink/common/web_preferences/web_preferences.cc b/third_party/blink/common/web_preferences/web_preferences.cc
index 9414c4e6c3769..9b24c1c518738 100644
--- a/third_party/blink/common/web_preferences/web_preferences.cc
+++ b/third_party/blink/common/web_preferences/web_preferences.cc
@@ -173,7 +173,7 @@ WebPreferences::WebPreferences()
       wide_viewport_quirk(false),
       use_wide_viewport(false),
       force_zero_layout_height(false),
-      viewport_meta_merge_content_quirk(true),
+      viewport_meta_merge_content_quirk(false),
       viewport_meta_non_user_scalable_quirk(true),
       viewport_meta_zero_values_quirk(true),
       clobber_user_agent_initial_scale_quirk(false),
diff --git a/third_party/blink/renderer/core/BUILD.gn b/third_party/blink/renderer/core/BUILD.gn
index 191064b5c5b81..b0d8a485e2e62 100644
--- a/third_party/blink/renderer/core/BUILD.gn
+++ b/third_party/blink/renderer/core/BUILD.gn
@@ -1680,6 +1680,12 @@ source_set("unit_tests") {
   if (use_aura) {
     sources += [ "scroll/scrollbar_theme_aura_test.cc" ]
   }
+
+  #ifdef OHOS_NWEB_EX
+  if (ohos_nweb_ex_config_name != "") {
+    configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
+    configs += [ "//build/config:ohos_nweb_ex_def_blink" ]
+  }  #endif  // OHOS_NWEB_EX
 }
 
 group("unit_tests_data") {
diff --git a/third_party/blink/renderer/core/css/resolver/style_adjuster.cc b/third_party/blink/renderer/core/css/resolver/style_adjuster.cc
index 8edb81b8cc8d3..13f40ade446fd 100644
--- a/third_party/blink/renderer/core/css/resolver/style_adjuster.cc
+++ b/third_party/blink/renderer/core/css/resolver/style_adjuster.cc
@@ -44,8 +44,10 @@
 #include "third_party/blink/renderer/core/frame/local_frame_view.h"
 #include "third_party/blink/renderer/core/frame/settings.h"
 #include "third_party/blink/renderer/core/frame/web_feature.h"
+#include "third_party/blink/renderer/core/fullscreen/fullscreen.h"
 #include "third_party/blink/renderer/core/html/forms/html_input_element.h"
 #include "third_party/blink/renderer/core/html/forms/html_text_area_element.h"
+#include "third_party/blink/renderer/core/html/html_dialog_element.h"
 #include "third_party/blink/renderer/core/html/html_iframe_element.h"
 #include "third_party/blink/renderer/core/html/html_image_element.h"
 #include "third_party/blink/renderer/core/html/html_plugin_element.h"
@@ -633,6 +635,31 @@ static void AdjustStateForContentVisibility(ComputedStyle& style,
   context->AdjustElementStyle(&style);
 }
 
+static void AdjustStyleForInert(ComputedStyle& style, Element* element) {
+  if (!element || style.IsForcedInert())
+    return;
+
+  if (RuntimeEnabledFeatures::InertAttributeEnabled() &&
+      element->FastHasAttribute(html_names::kInertAttr) &&
+      element->IsHTMLElement()) {
+    style.SetIsForcedInert();
+    return;
+  }
+
+  Document& document = element->GetDocument();
+  const Element* modal_element = document.ActiveModalDialog();
+  if (!modal_element)
+    modal_element = Fullscreen::FullscreenElementFrom(document);
+  if (modal_element == element) {
+    style.SetIsInert(false);
+    return;
+  }
+  if (modal_element && element == document.documentElement()) {
+    style.SetIsInert(true);
+    return;
+  }
+}
+
 void StyleAdjuster::AdjustForForcedColorsMode(ComputedStyle& style) {
   if (!style.InForcedColorsMode() ||
       style.ForcedColorAdjust() == EForcedColorAdjust::kNone)
@@ -757,6 +784,8 @@ void StyleAdjuster::AdjustComputedStyle(StyleResolverState& state,
   // Let the theme also have a crack at adjusting the style.
   LayoutTheme::GetTheme().AdjustStyle(element, style);
 
+  AdjustStyleForInert(style, element);
+
   AdjustStyleForEditing(style);
 
   bool is_svg_root = false;
diff --git a/third_party/blink/renderer/core/css/resolver/style_resolver_test.cc b/third_party/blink/renderer/core/css/resolver/style_resolver_test.cc
index 3078169563161..192d931f48149 100644
--- a/third_party/blink/renderer/core/css/resolver/style_resolver_test.cc
+++ b/third_party/blink/renderer/core/css/resolver/style_resolver_test.cc
@@ -21,6 +21,8 @@
 #include "third_party/blink/renderer/core/dom/pseudo_element.h"
 #include "third_party/blink/renderer/core/dom/shadow_root.h"
 #include "third_party/blink/renderer/core/dom/text.h"
+#include "third_party/blink/renderer/core/fullscreen/fullscreen.h"
+#include "third_party/blink/renderer/core/html/html_dialog_element.h"
 #include "third_party/blink/renderer/core/html/html_style_element.h"
 #include "third_party/blink/renderer/core/testing/page_test_base.h"
 #include "third_party/blink/renderer/platform/testing/runtime_enabled_features_test_helpers.h"
@@ -1211,4 +1213,372 @@ TEST_F(StyleResolverTestCQ, DependsOnContainerQueriesMPC) {
   EXPECT_FALSE(b->ComputedStyleRef().DependsOnContainerQueries());
 }
 
+TEST_F(StyleResolverTest, IsInertWithAttributeAndDialog) {
+  ScopedInertAttributeForTest enabled_scope(true);
+  Document& document = GetDocument();
+  NonThrowableExceptionState exception_state;
+
+  document.body()->setInnerHTML(R"HTML(
+    <div inert>
+      div_text
+      <dialog>dialog_text</dialog>
+    </div>
+  )HTML");
+  Element* html = document.documentElement();
+  Element* body = document.body();
+  Element* div = document.QuerySelector("div");
+  Node* div_text = div->firstChild();
+  auto* dialog = To<HTMLDialogElement>(document.QuerySelector("dialog"));
+  Node* dialog_text = dialog->firstChild();
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_EQ(dialog->GetComputedStyle(), nullptr);
+  EXPECT_EQ(dialog_text->GetComputedStyle(), nullptr);
+
+  div->SetBooleanAttribute(html_names::kInertAttr, false);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_EQ(dialog->GetComputedStyle(), nullptr);
+  EXPECT_EQ(dialog_text->GetComputedStyle(), nullptr);
+
+  dialog->showModal(exception_state);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(dialog->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(dialog_text->GetComputedStyle()->IsInert());
+
+  div->SetBooleanAttribute(html_names::kInertAttr, true);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(dialog->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(dialog_text->GetComputedStyle()->IsInert());
+
+  dialog->close();
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_EQ(dialog->GetComputedStyle(), nullptr);
+  EXPECT_EQ(dialog_text->GetComputedStyle(), nullptr);
+}
+
+TEST_F(StyleResolverTest, IsInertWithDialogs) {
+  Document& document = GetDocument();
+  NonThrowableExceptionState exception_state;
+
+  document.body()->setInnerHTML(R"HTML(
+    <dialog>
+      dialog1_text
+      <dialog>dialog2_text</dialog>
+    </dialog>
+    <div>
+      <dialog>dialog3_text</dialog>
+    </div>
+  )HTML");
+  StaticElementList* dialogs = document.QuerySelectorAll("dialog");
+  Element* html = document.documentElement();
+  Element* body = document.body();
+  auto* dialog1 = To<HTMLDialogElement>(dialogs->item(0));
+  Node* dialog1_text = dialog1->firstChild();
+  auto* dialog2 = To<HTMLDialogElement>(dialogs->item(1));
+  Node* dialog2_text = dialog2->firstChild();
+  Element* div = document.QuerySelector("div");
+  auto* dialog3 = To<HTMLDialogElement>(dialogs->item(2));
+  Node* dialog3_text = dialog3->firstChild();
+  UpdateAllLifecyclePhasesForTest();
+
+  auto ExpectState0 = [&]() {
+    EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+    EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+    EXPECT_EQ(dialog1->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog1_text->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog2->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog2_text->GetComputedStyle(), nullptr);
+    EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+    EXPECT_EQ(dialog3->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog3_text->GetComputedStyle(), nullptr);
+  };
+  ExpectState0();
+
+  dialog1->showModal(exception_state);
+  UpdateAllLifecyclePhasesForTest();
+
+  auto ExpectState1 = [&]() {
+    EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+    EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(dialog1->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(dialog1_text->GetComputedStyle()->IsInert());
+    EXPECT_EQ(dialog2->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog2_text->GetComputedStyle(), nullptr);
+    EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+    EXPECT_EQ(dialog3->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog3_text->GetComputedStyle(), nullptr);
+  };
+  ExpectState1();
+
+  dialog2->showModal(exception_state);
+  UpdateAllLifecyclePhasesForTest();
+
+  auto ExpectState2 = [&]() {
+    EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+    EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(dialog1->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(dialog1_text->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(dialog2->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(dialog2_text->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+    EXPECT_EQ(dialog3->GetComputedStyle(), nullptr);
+    EXPECT_EQ(dialog3_text->GetComputedStyle(), nullptr);
+  };
+  ExpectState2();
+
+  dialog3->showModal(exception_state);
+  UpdateAllLifecyclePhasesForTest();
+
+  auto ExpectState3 = [&]() {
+    EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+    EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(dialog1->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(dialog1_text->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(dialog2->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(dialog2_text->GetComputedStyle()->IsInert());
+    EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(dialog3->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(dialog3_text->GetComputedStyle()->IsInert());
+  };
+  ExpectState3();
+
+  dialog3->close();
+  UpdateAllLifecyclePhasesForTest();
+
+  ExpectState2();
+
+  dialog2->close();
+  UpdateAllLifecyclePhasesForTest();
+
+  ExpectState1();
+
+  dialog1->close();
+  UpdateAllLifecyclePhasesForTest();
+
+  ExpectState0();
+}
+
+static void EnterFullscreen(Document& document, Element& element) {
+  LocalFrame::NotifyUserActivation(
+      document.GetFrame(), mojom::UserActivationNotificationType::kTest);
+  Fullscreen::RequestFullscreen(element);
+  Fullscreen::DidResolveEnterFullscreenRequest(document, /*granted*/ true);
+  EXPECT_EQ(Fullscreen::FullscreenElementFrom(document), element);
+}
+
+static void ExitFullscreen(Document& document) {
+  Fullscreen::FullyExitFullscreen(document);
+  Fullscreen::DidExitFullscreen(document);
+  EXPECT_EQ(Fullscreen::FullscreenElementFrom(document), nullptr);
+}
+
+TEST_F(StyleResolverTest, IsInertWithFullscreen) {
+  Document& document = GetDocument();
+  document.body()->setInnerHTML(R"HTML(
+    <div>
+      div_text
+      <span>span_text</span>
+    </div>
+    <p>p_text</p>
+  )HTML");
+  Element* html = document.documentElement();
+  Element* body = document.body();
+  Element* div = document.QuerySelector("div");
+  Node* div_text = div->firstChild();
+  Element* span = document.QuerySelector("span");
+  Node* span_text = span->firstChild();
+  Element* p = document.QuerySelector("p");
+  Node* p_text = p->firstChild();
+  UpdateAllLifecyclePhasesForTest();
+
+  auto ExpectState0 = [&]() {
+    EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+    EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(span->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(span_text->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(p->GetComputedStyle()->IsInert());
+    EXPECT_FALSE(p_text->GetComputedStyle()->IsInert());
+  };
+  ExpectState0();
+
+  EnterFullscreen(document, *div);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(span->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(span_text->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(p->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(p_text->GetComputedStyle()->IsInert());
+
+  EnterFullscreen(document, *span);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(span->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(span_text->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(p->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(p_text->GetComputedStyle()->IsInert());
+
+  EnterFullscreen(document, *p);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(div_text->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(span->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(span_text->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(p->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(p_text->GetComputedStyle()->IsInert());
+
+  ExitFullscreen(document);
+  UpdateAllLifecyclePhasesForTest();
+
+  ExpectState0();
+}
+
+TEST_F(StyleResolverTest, IsInertWithFrameAndFullscreen) {
+  Document& document = GetDocument();
+  document.body()->setInnerHTML(R"HTML(
+    <div>div_text</div>
+  )HTML");
+  Element* html = document.documentElement();
+  Element* body = document.body();
+  Element* div = document.QuerySelector("div");
+  Node* div_text = div->firstChild();
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+
+  EnterFullscreen(document, *div);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_TRUE(body->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+
+  EnterFullscreen(document, *body);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_TRUE(html->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+
+  EnterFullscreen(document, *html);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(document.GetComputedStyle()->IsInert());
+  EXPECT_FALSE(html->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(body->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div->GetComputedStyle()->IsInert());
+  EXPECT_FALSE(div_text->GetComputedStyle()->IsInert());
+}
+
+TEST_F(StyleResolverTest, IsInertWithBackdrop) {
+  Document& document = GetDocument();
+  NonThrowableExceptionState exception_state;
+
+  document.documentElement()->setInnerHTML(R"HTML(
+    <style>:root:fullscreen::backdrop { --enable: true }</style>
+    <dialog></dialog>
+  )HTML");
+  Element* html = document.documentElement();
+  Element* body = document.body();
+  auto* dialog = To<HTMLDialogElement>(document.QuerySelector("dialog"));
+
+  auto IsBackdropInert = [](Element* element) {
+    PseudoElement* backdrop = element->GetPseudoElement(kPseudoIdBackdrop);
+    EXPECT_NE(backdrop, nullptr) << element;
+    return backdrop->GetComputedStyle()->IsInert();
+  };
+
+  EnterFullscreen(document, *body);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_EQ(html->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+  EXPECT_FALSE(IsBackdropInert(body));
+  EXPECT_EQ(dialog->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+
+  dialog->showModal(exception_state);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_EQ(html->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+  EXPECT_FALSE(IsBackdropInert(body));
+  EXPECT_FALSE(IsBackdropInert(dialog));
+
+  dialog->close();
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_EQ(html->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+  EXPECT_FALSE(IsBackdropInert(body));
+  EXPECT_EQ(dialog->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+
+  EnterFullscreen(document, *html);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(IsBackdropInert(html));
+  EXPECT_EQ(body->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+  EXPECT_EQ(dialog->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+
+  dialog->showModal(exception_state);
+  UpdateAllLifecyclePhasesForTest();
+
+  EXPECT_FALSE(IsBackdropInert(html));
+  EXPECT_EQ(body->GetPseudoElement(kPseudoIdBackdrop), nullptr);
+  EXPECT_FALSE(IsBackdropInert(dialog));
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/css/style_change_reason.cc b/third_party/blink/renderer/core/css/style_change_reason.cc
index ca40b55182cf3..add4c2f63e2a4 100644
--- a/third_party/blink/renderer/core/css/style_change_reason.cc
+++ b/third_party/blink/renderer/core/css/style_change_reason.cc
@@ -18,6 +18,7 @@ const char kControlValue[] = "ControlValue";
 const char kControl[] = "Control";
 const char kDeclarativeContent[] = "Extension declarativeContent.css";
 const char kDesignMode[] = "DesignMode";
+const char kDialog[] = "Dialog";
 const char kDisplayLock[] = "DisplayLock";
 const char kFlatTreeChange[] = "FlatTreeChange";
 const char kFonts[] = "Fonts";
diff --git a/third_party/blink/renderer/core/css/style_change_reason.h b/third_party/blink/renderer/core/css/style_change_reason.h
index cdd0ec20f0b3b..794bd7a53b94c 100644
--- a/third_party/blink/renderer/core/css/style_change_reason.h
+++ b/third_party/blink/renderer/core/css/style_change_reason.h
@@ -21,6 +21,7 @@ extern const char kControlValue[];
 extern const char kControl[];
 extern const char kDeclarativeContent[];
 extern const char kDesignMode[];
+extern const char kDialog[];
 extern const char kDisplayLock[];
 extern const char kFrame[];
 extern const char kFlatTreeChange[];
diff --git a/third_party/blink/renderer/core/dom/node.cc b/third_party/blink/renderer/core/dom/node.cc
index fc47a4b02f336..95c1d5695f8a7 100644
--- a/third_party/blink/renderer/core/dom/node.cc
+++ b/third_party/blink/renderer/core/dom/node.cc
@@ -1386,31 +1386,9 @@ bool Node::ShouldHaveFocusAppearance() const {
 }
 
 bool Node::IsInert() const {
-  if (!isConnected() || !CanParticipateInFlatTree())
-    return true;
-
-  if (this != GetDocument() && this != GetDocument().documentElement()) {
-    const Element* modal_element = GetDocument().ActiveModalDialog();
-    if (!modal_element)
-      modal_element = Fullscreen::FullscreenElementFrom(GetDocument());
-    if (modal_element && !FlatTreeTraversal::ContainsIncludingPseudoElement(
-                             *modal_element, *this)) {
-      return true;
-    }
-  }
-
-  if (RuntimeEnabledFeatures::InertAttributeEnabled()) {
-    const auto* element = DynamicTo<Element>(this);
-    if (!element)
-      element = FlatTreeTraversal::ParentElement(*this);
-
-    while (element) {
-      if (element->FastHasAttribute(html_names::kInertAttr))
-        return true;
-      element = FlatTreeTraversal::ParentElement(*element);
-    }
-  }
-  return GetDocument().GetFrame() && GetDocument().GetFrame()->IsInert();
+  if (const ComputedStyle* style = GetComputedStyle())
+    return style->IsInert();
+  return false;
 }
 
 unsigned Node::NodeIndex() const {
diff --git a/third_party/blink/renderer/core/editing/serializers/serialization.cc b/third_party/blink/renderer/core/editing/serializers/serialization.cc
index 9a60c5c954873..164cb2ff58047 100644
--- a/third_party/blink/renderer/core/editing/serializers/serialization.cc
+++ b/third_party/blink/renderer/core/editing/serializers/serialization.cc
@@ -836,6 +836,12 @@ static bool StripSVGUseDataURLs(Node& node) {
   return stripped;
 }
 
+namespace {
+
+constexpr unsigned kMaxSanitizationIterations = 16;
+
+}  // namespace
+
 DocumentFragment* CreateSanitizedFragmentFromMarkupWithContext(
     Document& document,
     const String& raw_markup,
@@ -845,42 +851,56 @@ DocumentFragment* CreateSanitizedFragmentFromMarkupWithContext(
   if (raw_markup.IsEmpty())
     return nullptr;
 
-  Document* staging_document = CreateStagingDocumentForMarkupSanitization(
-      *document.GetFrame()->GetFrameScheduler()->GetAgentGroupScheduler());
-  Element* body = staging_document->body();
-
-  DocumentFragment* fragment = CreateFragmentFromMarkupWithContext(
-      *staging_document, raw_markup, fragment_start, fragment_end, KURL(),
-      kDisallowScriptingAndPluginContent);
-  if (!fragment) {
-    staging_document->GetPage()->WillBeDestroyed();
-    return nullptr;
-  }
+  // Iterate on parsing, sanitization and serialization until the markup is
+  // stable, or if we have exceeded the maximum allowed number of iterations.
+  String last_markup;
+  String markup = raw_markup;
+  for (unsigned iteration = 0;
+       iteration < kMaxSanitizationIterations && last_markup != markup;
+       ++iteration) {
+    last_markup = markup;
+
+    Document* staging_document = CreateStagingDocumentForMarkupSanitization(
+        *document.GetFrame()->GetFrameScheduler()->GetAgentGroupScheduler());
+    Element* body = staging_document->body();
+
+    DocumentFragment* fragment = CreateFragmentFromMarkupWithContext(
+        *staging_document, last_markup, fragment_start, fragment_end, KURL(),
+        kDisallowScriptingAndPluginContent);
+    if (!fragment) {
+      staging_document->GetPage()->WillBeDestroyed();
+      return nullptr;
+    }
 
-  bool needs_sanitization = false;
-  if (ContainsStyleElements(*fragment))
-    needs_sanitization = true;
-  if (StripSVGUseDataURLs(*fragment))
-    needs_sanitization = true;
+    bool needs_sanitization = false;
+    if (ContainsStyleElements(*fragment))
+      needs_sanitization = true;
+    if (StripSVGUseDataURLs(*fragment))
+      needs_sanitization = true;
 
-  if (!needs_sanitization) {
+    if (!needs_sanitization) {
+      markup = CreateMarkup(fragment);
+    } else {
+      body->appendChild(fragment);
+      staging_document->UpdateStyleAndLayout(DocumentUpdateReason::kEditing);
+
+      // This sanitizes stylesheets in the markup into element inline styles
+      markup = CreateMarkup(Position::FirstPositionInNode(*body),
+                            Position::LastPositionInNode(*body),
+                            CreateMarkupOptions::Builder()
+                                .SetShouldAnnotateForInterchange(true)
+                                .SetIsForMarkupSanitization(true)
+                                .Build());
+    }
     staging_document->GetPage()->WillBeDestroyed();
-    return CreateFragmentFromMarkupWithContext(
-        document, raw_markup, fragment_start, fragment_end, base_url,
-        kDisallowScriptingAndPluginContent);
+
+    fragment_start = 0;
+    fragment_end = markup.length();
   }
 
-  body->appendChild(fragment);
-  staging_document->UpdateStyleAndLayout(DocumentUpdateReason::kEditing);
-
-  // This sanitizes stylesheets in the markup into element inline styles
-  String markup = CreateMarkup(Position::FirstPositionInNode(*body),
-                               Position::LastPositionInNode(*body),
-                               CreateMarkupOptions::Builder()
-                                   .SetShouldAnnotateForInterchange(true)
-                                   .SetIsForMarkupSanitization(true)
-                                   .Build());
-  staging_document->GetPage()->WillBeDestroyed();
+  // Sanitization failed because markup can't stabilize.
+  if (last_markup != markup)
+    return nullptr;
 
   return CreateFragmentFromMarkup(document, markup, base_url,
                                   kDisallowScriptingAndPluginContent);
diff --git a/third_party/blink/renderer/core/frame/frame.cc b/third_party/blink/renderer/core/frame/frame.cc
index f06a116b6a5b9..dccee4b312e76 100644
--- a/third_party/blink/renderer/core/frame/frame.cc
+++ b/third_party/blink/renderer/core/frame/frame.cc
@@ -327,8 +327,9 @@ bool Frame::IsAdRoot() const {
 void Frame::UpdateInertIfPossible() {
   if (auto* frame_owner_element =
           DynamicTo<HTMLFrameOwnerElement>(owner_.Get())) {
-    if (frame_owner_element->IsInert())
-      SetIsInert(true);
+    const ComputedStyle* style = frame_owner_element->GetComputedStyle();
+    const LocalFrame* parent = DynamicTo<LocalFrame>(Parent());
+    SetIsInert((style && style->IsInert()) || (parent && parent->IsInert()));
   }
 }
 
diff --git a/third_party/blink/renderer/core/frame/local_frame.cc b/third_party/blink/renderer/core/frame/local_frame.cc
index c7cbda4502c42..0fb26b5bc2f82 100644
--- a/third_party/blink/renderer/core/frame/local_frame.cc
+++ b/third_party/blink/renderer/core/frame/local_frame.cc
@@ -1001,19 +1001,22 @@ void LocalFrame::SetTextDirection(base::i18n::TextDirection direction) {
 }
 
 void LocalFrame::SetIsInert(bool inert) {
+  if (is_inert_ == inert)
+    return;
   is_inert_ = inert;
-  PropagateInertToChildFrames();
-}
-
-void LocalFrame::PropagateInertToChildFrames() {
+ 
+  // Propagate inert to child frames
   for (Frame* child = Tree().FirstChild(); child;
        child = child->Tree().NextSibling()) {
-    // is_inert_ means that this Frame is inert because of a modal dialog or
-    // inert element in an ancestor Frame. Otherwise, decide whether a child
-    // Frame element is inert because of an element in this Frame.
-    child->SetIsInert(is_inert_ ||
-                      To<HTMLFrameOwnerElement>(child->Owner())->IsInert());
-  }
+    child->UpdateInertIfPossible();
+  }
+ 
+  // Nodes all over the accessibility tree can change inertness which means they
+  // must be added or removed from the tree. The most foolproof way is to clear
+  // the entire tree and rebuild it, though a more clever way is probably
+  // possible.
+  if (Document* document = GetDocument())
+    document->ClearAXObjectCache();
 }
 
 void LocalFrame::SetInheritedEffectiveTouchAction(TouchAction touch_action) {
diff --git a/third_party/blink/renderer/core/frame/local_frame.h b/third_party/blink/renderer/core/frame/local_frame.h
index ad721b3494db8..dbdd4651ffcd9 100644
--- a/third_party/blink/renderer/core/frame/local_frame.h
+++ b/third_party/blink/renderer/core/frame/local_frame.h
@@ -802,8 +802,6 @@ class CORE_EXPORT LocalFrame final
   void EnableNavigation() { --navigation_disable_count_; }
   void DisableNavigation() { ++navigation_disable_count_; }
 
-  void PropagateInertToChildFrames();
-
   // Internal implementation for starting and ending paint preview capture.
   // `capturing` is true when capture starts and false when it ends.
   void SetInvalidationForCapture(bool capturing);
diff --git a/third_party/blink/renderer/core/frame/web_frame_test.cc b/third_party/blink/renderer/core/frame/web_frame_test.cc
index 650ff87c4f256..a8fec0707f207 100644
--- a/third_party/blink/renderer/core/frame/web_frame_test.cc
+++ b/third_party/blink/renderer/core/frame/web_frame_test.cc
@@ -112,6 +112,7 @@
 #include "third_party/blink/renderer/core/css/media_values.h"
 #include "third_party/blink/renderer/core/css/resolver/style_resolver.h"
 #include "third_party/blink/renderer/core/css/resolver/viewport_style_resolver.h"
+#include "third_party/blink/renderer/core/css/style_engine.h"
 #include "third_party/blink/renderer/core/css/style_sheet_contents.h"
 #include "third_party/blink/renderer/core/dom/document.h"
 #include "third_party/blink/renderer/core/dom/events/native_event_listener.h"
@@ -14154,4 +14155,27 @@ TEST_F(WebFrameTest, IsPrerendering) {
                   .IsPrerendering());
 }
 
+TEST_F(WebFrameTest, FrameOwnerColorScheme) {
+  frame_test_helpers::WebViewHelper web_view_helper;
+  web_view_helper.InitializeAndLoad(
+      "data:text/html,<frameset><frame id=frame></frame></frameset>");
+
+  WebViewImpl* web_view = web_view_helper.GetWebView();
+
+  Document* document = web_view->MainFrameImpl()->GetFrame()->GetDocument();
+  HTMLFrameOwnerElement* frame =
+      To<HTMLFrameOwnerElement>(document->getElementById("frame"));
+  EXPECT_EQ(frame->GetColorScheme(), mojom::blink::ColorScheme::kLight);
+  EXPECT_EQ(frame->contentDocument()->GetStyleEngine().GetOwnerColorScheme(),
+            mojom::blink::ColorScheme::kLight);
+
+  frame->SetInlineStyleProperty(CSSPropertyID::kColorScheme, "dark");
+  EXPECT_EQ(frame->GetColorScheme(), mojom::blink::ColorScheme::kLight);
+
+  UpdateAllLifecyclePhases(web_view);
+  EXPECT_EQ(frame->GetColorScheme(), mojom::blink::ColorScheme::kDark);
+  EXPECT_EQ(frame->contentDocument()->GetStyleEngine().GetOwnerColorScheme(),
+            mojom::blink::ColorScheme::kDark);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/fullscreen/fullscreen.cc b/third_party/blink/renderer/core/fullscreen/fullscreen.cc
index bd3ca9b6af4db..bb7a0c7bf6ddd 100644
--- a/third_party/blink/renderer/core/fullscreen/fullscreen.cc
+++ b/third_party/blink/renderer/core/fullscreen/fullscreen.cc
@@ -102,11 +102,15 @@ void FullscreenElementChanged(Document& document,
         true);
   }
 
-  if (document.GetFrame()) {
-    // SetIsInert recurses through subframes to propagate the inert bit as
-    // needed.
-    document.GetFrame()->SetIsInert(document.LocalOwner() &&
-                                    document.LocalOwner()->IsInert());
+  // Update IsInert() flags.
+  Element* maybe_root =
+      old_element && new_element ? nullptr : document.documentElement();
+  for (Element* element : {maybe_root, old_element, new_element}) {
+    if (!element)
+      continue;
+    element->SetNeedsStyleRecalc(
+        kLocalStyleChange,
+        StyleChangeReasonForTracing::Create(style_change_reason::kFullscreen));
   }
 
   // Any element not contained by the fullscreen element is inert (see
diff --git a/third_party/blink/renderer/core/html/html_dialog_element.cc b/third_party/blink/renderer/core/html/html_dialog_element.cc
index 3882308da823d..59c8a27032d4f 100644
--- a/third_party/blink/renderer/core/html/html_dialog_element.cc
+++ b/third_party/blink/renderer/core/html/html_dialog_element.cc
@@ -26,6 +26,7 @@
 #include "third_party/blink/renderer/core/html/html_dialog_element.h"
 
 #include "third_party/blink/renderer/core/accessibility/ax_object_cache.h"
+#include "third_party/blink/renderer/core/css/style_change_reason.h"
 #include "third_party/blink/renderer/core/dom/events/event.h"
 #include "third_party/blink/renderer/core/dom/flat_tree_traversal.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context.h"
@@ -92,11 +93,22 @@ static void SetFocusForDialog(HTMLDialogElement* dialog) {
   doc.TopDocument().FinalizeAutofocus();
 }
 
-static void InertSubtreesChanged(Document& document) {
-  // SetIsInert recurses through subframes to propagate the inert bit.
-  if (document.GetFrame()) {
-    document.GetFrame()->SetIsInert(document.LocalOwner() &&
-                                    document.LocalOwner()->IsInert());
+static void InertSubtreesChanged(Document& document,
+                                 Element* old_modal_dialog) {
+  Element* new_modal_dialog = document.ActiveModalDialog();
+  if (old_modal_dialog == new_modal_dialog)
+    return;
+
+  // Update IsInert() flags.
+  Element* maybe_root = old_modal_dialog && new_modal_dialog
+                            ? nullptr
+                            : document.documentElement();
+  for (Element* element : {maybe_root, old_modal_dialog, new_modal_dialog}) {
+    if (!element)
+      continue;
+    element->SetNeedsStyleRecalc(
+        kLocalStyleChange,
+        StyleChangeReasonForTracing::Create(style_change_reason::kDialog));
   }
 
   // When a modal dialog opens or closes, nodes all over the accessibility
@@ -121,10 +133,10 @@ void HTMLDialogElement::close(const String& return_value) {
   SetBooleanAttribute(html_names::kOpenAttr, false);
   SetIsModal(false);
 
-  HTMLDialogElement* active_modal_dialog = GetDocument().ActiveModalDialog();
-  GetDocument().RemoveFromTopLayer(this);
-  if (active_modal_dialog == this)
-    InertSubtreesChanged(GetDocument());
+  Document& document = GetDocument();
+  HTMLDialogElement* old_modal_dialog = document.ActiveModalDialog();
+  document.RemoveFromTopLayer(this);
+  InertSubtreesChanged(document, old_modal_dialog);
 
   if (!return_value.IsNull())
     return_value_ = return_value;
@@ -173,32 +185,37 @@ void HTMLDialogElement::showModal(ExceptionState& exception_state) {
     return;
   }
 
+  Document& document = GetDocument();
+  HTMLDialogElement* old_modal_dialog = document.ActiveModalDialog();
+
   // See comment in |Fullscreen::RequestFullscreen|.
   if (Fullscreen::IsInFullscreenElementStack(*this)) {
-    UseCounter::Count(GetDocument(),
+    UseCounter::Count(document,
                       WebFeature::kShowModalForElementInFullscreenStack);
   }
 
   // Showing a <dialog> should hide all open popups.
   GetDocument().HideAllPopupsUntil(nullptr);
 
-  GetDocument().AddToTopLayer(this);
+  document.AddToTopLayer(this);
   SetBooleanAttribute(html_names::kOpenAttr, true);
 
   SetIsModal(true);
-  GetDocument().UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);
+  document.UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);
 
   // Throw away the AX cache first, so the subsequent steps don't have a chance
   // of queuing up AX events on objects that would be invalidated when the cache
   // is thrown away.
-  InertSubtreesChanged(GetDocument());
+  InertSubtreesChanged(document, old_modal_dialog);
 
   SetFocusForDialog(this);
 }
 
 void HTMLDialogElement::RemovedFrom(ContainerNode& insertion_point) {
+  Document& document = GetDocument();
+  HTMLDialogElement* old_modal_dialog = document.ActiveModalDialog();
   HTMLElement::RemovedFrom(insertion_point);
-  InertSubtreesChanged(GetDocument());
+  InertSubtreesChanged(document, old_modal_dialog);
 }
 
 void HTMLDialogElement::DefaultEventHandler(Event& event) {
diff --git a/third_party/blink/renderer/core/html/html_dialog_element.h b/third_party/blink/renderer/core/html/html_dialog_element.h
index 605672be06ba7..c90457897ca15 100644
--- a/third_party/blink/renderer/core/html/html_dialog_element.h
+++ b/third_party/blink/renderer/core/html/html_dialog_element.h
@@ -34,7 +34,7 @@ namespace blink {
 class Document;
 class ExceptionState;
 
-class HTMLDialogElement final : public HTMLElement {
+class CORE_EXPORT HTMLDialogElement final : public HTMLElement {
   DEFINE_WRAPPERTYPEINFO();
 
  public:
diff --git a/third_party/blink/renderer/core/html/html_element.cc b/third_party/blink/renderer/core/html/html_element.cc
index 9ec792d2649c5..0ac849686d2cb 100644
--- a/third_party/blink/renderer/core/html/html_element.cc
+++ b/third_party/blink/renderer/core/html/html_element.cc
@@ -289,7 +289,8 @@ bool HTMLElement::IsPresentationAttribute(const QualifiedName& name) const {
       name == html_names::kContenteditableAttr ||
       name == html_names::kHiddenAttr || name == html_names::kLangAttr ||
       name.Matches(xml_names::kLangAttr) ||
-      name == html_names::kDraggableAttr || name == html_names::kDirAttr)
+      name == html_names::kDraggableAttr || name == html_names::kDirAttr ||
+      name == html_names::kInertAttr)
     return true;
   return Element::IsPresentationAttribute(name);
 }
@@ -393,8 +394,6 @@ AttributeTriggers* HTMLElement::TriggersForAttributeName(
        &HTMLElement::OnDirAttrChanged},
       {html_names::kFormAttr, kNoWebFeature, kNoEvent,
        &HTMLElement::OnFormAttrChanged},
-      {html_names::kInertAttr, WebFeature::kInertAttribute, kNoEvent,
-       &HTMLElement::OnInertAttrChanged},
       {html_names::kLangAttr, kNoWebFeature, kNoEvent,
        &HTMLElement::OnLangAttrChanged},
       {html_names::kNonceAttr, kNoWebFeature, kNoEvent,
@@ -1856,15 +1855,6 @@ void HTMLElement::OnFormAttrChanged(const AttributeModificationParams& params) {
     EnsureElementInternals().FormAttributeChanged();
 }
 
-void HTMLElement::OnInertAttrChanged(
-    const AttributeModificationParams& params) {
-  UpdateDistributionForUnknownReasons();
-  if (GetDocument().GetFrame()) {
-    GetDocument().GetFrame()->SetIsInert(GetDocument().LocalOwner() &&
-                                         GetDocument().LocalOwner()->IsInert());
-  }
-}
-
 void HTMLElement::OnLangAttrChanged(const AttributeModificationParams& params) {
   PseudoStateChanged(CSSSelector::kPseudoLang);
 }
diff --git a/third_party/blink/renderer/core/html/html_element.h b/third_party/blink/renderer/core/html/html_element.h
index 3b903ec7aa5d7..81118a79ae59f 100644
--- a/third_party/blink/renderer/core/html/html_element.h
+++ b/third_party/blink/renderer/core/html/html_element.h
@@ -229,7 +229,6 @@ class CORE_EXPORT HTMLElement : public Element {
 
   void OnDirAttrChanged(const AttributeModificationParams&);
   void OnFormAttrChanged(const AttributeModificationParams&);
-  void OnInertAttrChanged(const AttributeModificationParams&);
   void OnLangAttrChanged(const AttributeModificationParams&);
   void OnNonceAttrChanged(const AttributeModificationParams&);
   void OnTabIndexAttrChanged(const AttributeModificationParams&);
diff --git a/third_party/blink/renderer/core/html/html_frame_owner_element_test.cc b/third_party/blink/renderer/core/html/html_frame_owner_element_test.cc
new file mode 100644
index 0000000000000..e69de29bb2d1d
diff --git a/third_party/blink/renderer/core/inspector/inspect_tools.cc b/third_party/blink/renderer/core/inspector/inspect_tools.cc
index 937955cb02f84..474cd28fd6e6b 100644
--- a/third_party/blink/renderer/core/inspector/inspect_tools.cc
+++ b/third_party/blink/renderer/core/inspector/inspect_tools.cc
@@ -436,16 +436,11 @@ bool PersistentTool::IsEmpty() {
   return !grid_node_highlights_.size() && !flex_container_configs_.size();
 }
 
-void PersistentTool::SetGridConfigs(
-    Vector<std::pair<Member<Node>,
-                     std::unique_ptr<InspectorGridHighlightConfig>>> configs) {
+void PersistentTool::SetGridConfigs(GirdConfigs configs) {
   grid_node_highlights_ = std::move(configs);
 }
 
-void PersistentTool::SetFlexContainerConfigs(
-    Vector<std::pair<Member<Node>,
-                     std::unique_ptr<InspectorFlexContainerHighlightConfig>>>
-        configs) {
+void PersistentTool::SetFlexContainerConfigs(FlexContainerConfigs configs) {
   flex_container_configs_ = std::move(configs);
 }
 
@@ -464,14 +459,14 @@ bool PersistentTool::HideOnMouseMove() {
 void PersistentTool::Draw(float scale) {
   for (auto& entry : grid_node_highlights_) {
     std::unique_ptr<protocol::Value> highlight =
-        InspectorGridHighlight(entry.first.Get(), *(entry.second));
+        InspectorGridHighlight(entry.key, *(entry.value));
     if (!highlight)
       continue;
     overlay_->EvaluateInOverlay("drawGridHighlight", std::move(highlight));
   }
   for (auto& entry : flex_container_configs_) {
     std::unique_ptr<protocol::Value> highlight =
-        InspectorFlexContainerHighlight(entry.first.Get(), *(entry.second));
+        InspectorFlexContainerHighlight(entry.key, *(entry.value));
     if (!highlight)
       continue;
     overlay_->EvaluateInOverlay("drawFlexContainerHighlight",
@@ -485,7 +480,7 @@ PersistentTool::GetGridInspectorHighlightsAsJson() const {
       protocol::ListValue::create();
   for (auto& entry : grid_node_highlights_) {
     std::unique_ptr<protocol::Value> highlight =
-        InspectorGridHighlight(entry.first.Get(), *(entry.second));
+        InspectorGridHighlight(entry.key, *(entry.value));
     if (!highlight)
       continue;
     highlights->pushValue(std::move(highlight));
@@ -498,6 +493,12 @@ PersistentTool::GetGridInspectorHighlightsAsJson() const {
   return result;
 }
 
+void PersistentTool::Trace(Visitor* visitor) const {
+  InspectTool::Trace(visitor);
+  visitor->Trace(grid_node_highlights_);
+  visitor->Trace(flex_container_configs_);
+}
+
 // SourceOrderTool -----------------------------------------------------------
 
 SourceOrderTool::SourceOrderTool(
diff --git a/third_party/blink/renderer/core/inspector/inspect_tools.h b/third_party/blink/renderer/core/inspector/inspect_tools.h
index bd16149f25fbd..095843a9d91fb 100644
--- a/third_party/blink/renderer/core/inspector/inspect_tools.h
+++ b/third_party/blink/renderer/core/inspector/inspect_tools.h
@@ -142,11 +142,11 @@ class SourceOrderTool : public InspectTool {
 
 // -----------------------------------------------------------------------------
 
-using GirdConfigs = Vector<
-    std::pair<Member<Node>, std::unique_ptr<InspectorGridHighlightConfig>>>;
+using GirdConfigs = HeapHashMap<WeakMember<Node>,
+                                std::unique_ptr<InspectorGridHighlightConfig>>;
 using FlexContainerConfigs =
-    Vector<std::pair<Member<Node>,
-                     std::unique_ptr<InspectorFlexContainerHighlightConfig>>>;
+    HeapHashMap<WeakMember<Node>,
+                std::unique_ptr<InspectorFlexContainerHighlightConfig>>;
 class PersistentTool : public InspectTool {
   using InspectTool::InspectTool;
 
@@ -159,6 +159,8 @@ class PersistentTool : public InspectTool {
   std::unique_ptr<protocol::DictionaryValue> GetGridInspectorHighlightsAsJson()
       const;
 
+  void Trace(Visitor* visitor) const override;
+
  private:
   bool ForwardEventsToOverlay() override;
   bool HideOnMouseMove() override;
diff --git a/third_party/blink/renderer/core/inspector/inspector_overlay_agent.cc b/third_party/blink/renderer/core/inspector/inspector_overlay_agent.cc
index a0ea77ccffc3f..d911642214dd3 100644
--- a/third_party/blink/renderer/core/inspector/inspector_overlay_agent.cc
+++ b/third_party/blink/renderer/core/inspector/inspector_overlay_agent.cc
@@ -700,7 +700,7 @@ Response InspectorOverlayAgent::setShowGridOverlays(
         MakeGarbageCollected<PersistentTool>(this, GetFrontend());
   }
 
-  Vector<std::pair<Member<Node>, std::unique_ptr<InspectorGridHighlightConfig>>>
+  HeapHashMap<WeakMember<Node>, std::unique_ptr<InspectorGridHighlightConfig>>
       configs;
   for (std::unique_ptr<protocol::Overlay::GridNodeHighlightConfig>& config :
        *grid_node_highlight_configs) {
@@ -708,9 +708,8 @@ Response InspectorOverlayAgent::setShowGridOverlays(
     Response response = dom_agent_->AssertNode(config->getNodeId(), node);
     if (!response.IsSuccess())
       return response;
-    configs.push_back(
-        std::make_pair(node, InspectorOverlayAgent::ToGridHighlightConfig(
-                                 config->getGridHighlightConfig())));
+    configs.insert(node, InspectorOverlayAgent::ToGridHighlightConfig(
+                             config->getGridHighlightConfig()));
   }
 
   persistent_tool_->SetGridConfigs(std::move(configs));
@@ -728,8 +727,8 @@ Response InspectorOverlayAgent::setShowFlexOverlays(
         MakeGarbageCollected<PersistentTool>(this, GetFrontend());
   }
 
-  Vector<std::pair<Member<Node>,
-                   std::unique_ptr<InspectorFlexContainerHighlightConfig>>>
+  HeapHashMap<WeakMember<Node>,
+              std::unique_ptr<InspectorFlexContainerHighlightConfig>>
       configs;
 
   for (std::unique_ptr<protocol::Overlay::FlexNodeHighlightConfig>& config :
@@ -738,9 +737,8 @@ Response InspectorOverlayAgent::setShowFlexOverlays(
     Response response = dom_agent_->AssertNode(config->getNodeId(), node);
     if (!response.IsSuccess())
       return response;
-    configs.push_back(std::make_pair(
-        node, InspectorOverlayAgent::ToFlexContainerHighlightConfig(
-                  config->getFlexContainerHighlightConfig())));
+    configs.insert(node, InspectorOverlayAgent::ToFlexContainerHighlightConfig(
+                             config->getFlexContainerHighlightConfig()));
   }
 
   persistent_tool_->SetFlexContainerConfigs(std::move(configs));
@@ -844,16 +842,16 @@ Response InspectorOverlayAgent::getGridHighlightObjectsForTest(
     std::unique_ptr<protocol::Array<int>> node_ids,
     std::unique_ptr<protocol::DictionaryValue>* highlights) {
   PersistentTool persistent_tool(this, GetFrontend());
-  Vector<std::pair<Member<Node>, std::unique_ptr<InspectorGridHighlightConfig>>>
+
+  HeapHashMap<WeakMember<Node>, std::unique_ptr<InspectorGridHighlightConfig>>
       configs;
   for (const int node_id : *node_ids) {
     Node* node = nullptr;
     Response response = dom_agent_->AssertNode(node_id, node);
     if (!response.IsSuccess())
       return response;
-    configs.push_back(
-        std::make_pair(node, std::make_unique<InspectorGridHighlightConfig>(
-                                 InspectorHighlight::DefaultGridConfig())));
+    configs.insert(node, std::make_unique<InspectorGridHighlightConfig>(
+                             InspectorHighlight::DefaultGridConfig()));
   }
   persistent_tool.SetGridConfigs(std::move(configs));
   *highlights = persistent_tool.GetGridInspectorHighlightsAsJson();
diff --git a/third_party/blink/renderer/core/layout/layout_embedded_content.cc b/third_party/blink/renderer/core/layout/layout_embedded_content.cc
index f63674aa0c74c..b6b5f2ec48617 100644
--- a/third_party/blink/renderer/core/layout/layout_embedded_content.cc
+++ b/third_party/blink/renderer/core/layout/layout_embedded_content.cc
@@ -274,29 +274,33 @@ void LayoutEmbeddedContent::StyleDidChange(StyleDifference diff,
                                            const ComputedStyle* old_style) {
   NOT_DESTROYED();
   LayoutReplaced::StyleDidChange(diff, old_style);
+  const ComputedStyle& new_style = StyleRef();
+
+  if (Frame* frame = GetFrameOwnerElement()->ContentFrame())
+    frame->UpdateInertIfPossible();
 
   if (EmbeddedContentView* embedded_content_view = GetEmbeddedContentView()) {
-    if (StyleRef().Visibility() != EVisibility::kVisible) {
+    if (new_style.Visibility() != EVisibility::kVisible) {
       embedded_content_view->Hide();
     } else {
       embedded_content_view->Show();
     }
   }
 
-  if (old_style &&
-      StyleRef().VisibleToHitTesting() == old_style->VisibleToHitTesting()) {
-    return;
-  }
-
   auto* frame_owner = GetFrameOwnerElement();
   if (!frame_owner)
     return;
 
-  auto* frame = frame_owner->ContentFrame();
-  if (!frame)
+  if (old_style && new_style.UsedColorScheme() != old_style->UsedColorScheme())
+    frame_owner->SetColorScheme(new_style.UsedColorScheme());
+
+  if (old_style &&
+      new_style.VisibleToHitTesting() == old_style->VisibleToHitTesting()) {
     return;
+  }
 
-  frame->UpdateVisibleToHitTesting();
+  if (auto* frame = frame_owner->ContentFrame())
+    frame->UpdateVisibleToHitTesting();
 }
 
 void LayoutEmbeddedContent::UpdateLayout() {
diff --git a/third_party/blink/renderer/core/layout/layout_iframe.cc b/third_party/blink/renderer/core/layout/layout_iframe.cc
index 0e05ae67ecf8d..739fc97f5c4ef 100644
--- a/third_party/blink/renderer/core/layout/layout_iframe.cc
+++ b/third_party/blink/renderer/core/layout/layout_iframe.cc
@@ -65,15 +65,4 @@ void LayoutIFrame::UpdateLayout() {
   ClearNeedsLayout();
 }
 
-void LayoutIFrame::StyleWillChange(StyleDifference diff,
-                                   const ComputedStyle& new_style) {
-  NOT_DESTROYED();
-  if (Style() && StyleRef().UsedColorSchemeForInitialColors() !=
-                     new_style.UsedColorSchemeForInitialColors()) {
-    GetFrameOwnerElement()->SetColorScheme(
-        new_style.UsedColorSchemeForInitialColors());
-  }
-  LayoutEmbeddedContent::StyleWillChange(diff, new_style);
-}
-
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/layout_iframe.h b/third_party/blink/renderer/core/layout/layout_iframe.h
index 45f3f76b8a832..66ed05f0355e8 100644
--- a/third_party/blink/renderer/core/layout/layout_iframe.h
+++ b/third_party/blink/renderer/core/layout/layout_iframe.h
@@ -51,8 +51,6 @@ class LayoutIFrame final : public LayoutEmbeddedContent {
   }
 
   PaintLayerType LayerTypeRequired() const override;
-  void StyleWillChange(StyleDifference,
-                       const ComputedStyle& new_style) override;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/messaging/message_port.cc b/third_party/blink/renderer/core/messaging/message_port.cc
index 9e9de51e37ee4..51c75993117ef 100644
--- a/third_party/blink/renderer/core/messaging/message_port.cc
+++ b/third_party/blink/renderer/core/messaging/message_port.cc
@@ -52,7 +52,11 @@
 namespace blink {
 
 MessagePort::MessagePort(ExecutionContext& execution_context)
-    : ExecutionContextLifecycleObserver(&execution_context),
+    : ExecutionContextLifecycleObserver(execution_context.IsContextDestroyed()
+                                            ? nullptr
+                                            : &execution_context),
+      // Ports in a destroyed context start out in a closed state.
+      closed_(execution_context.IsContextDestroyed()),
       task_runner_(execution_context.GetTaskRunner(TaskType::kPostedMessage)) {}
 
 MessagePort::~MessagePort() {
@@ -164,11 +168,22 @@ void MessagePort::Entangle(MessagePortDescriptor port) {
   DCHECK(port.IsValid());
   DCHECK(!connector_);
 
+  // If the context was already destroyed, there is no reason to actually
+  // entangle the port and create a Connector. No messages will ever be able to
+  // be sent or received anyway, as StartReceiving will never be called.
+  if (!GetExecutionContext())
+    return;
+
   port_ = std::move(port);
   connector_ = std::make_unique<mojo::Connector>(
       port_.TakeHandleToEntangle(GetExecutionContext()),
       mojo::Connector::SINGLE_THREADED_SEND, task_runner_);
   connector_->PauseIncomingMethodCallProcessing();
+  // The raw `this` is safe despite `this` being a garbage collected object
+  // because we make sure that:
+  // 1. This object will not be garbage collected while it is connected and
+  //    the execution context is not destroyed, and
+  // 2. when the execution context is destroyed, the connector_ is reset.
   connector_->set_incoming_receiver(this);
   connector_->set_connection_error_handler(
       WTF::Bind(&MessagePort::close, WrapWeakPersistent(this)));
diff --git a/third_party/blink/renderer/core/messaging/message_port.h b/third_party/blink/renderer/core/messaging/message_port.h
index 7a83dce5113dc..78436117476d2 100644
--- a/third_party/blink/renderer/core/messaging/message_port.h
+++ b/third_party/blink/renderer/core/messaging/message_port.h
@@ -141,7 +141,7 @@ class CORE_EXPORT MessagePort : public EventTargetWithInlineData,
   std::unique_ptr<mojo::Connector> connector_;
 
   bool started_ = false;
-  bool closed_ = false;
+  bool closed_;
 
   scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
 
diff --git a/third_party/blink/renderer/core/page/pointer_lock_controller.cc b/third_party/blink/renderer/core/page/pointer_lock_controller.cc
index 83cf68c10f290..51dfbe4108dc1 100644
--- a/third_party/blink/renderer/core/page/pointer_lock_controller.cc
+++ b/third_party/blink/renderer/core/page/pointer_lock_controller.cc
@@ -50,6 +50,7 @@ PointerLockController::PointerLockController(Page* page)
 
 bool PointerLockController::RequestPointerLock(Element* target,
                                                ResultCallback callback) {
+  LOG(INFO) << "PointerLockController RequestPointerLock called";
   if (!target || !target->isConnected() ||
       document_of_removed_element_while_waiting_for_unlock_ || element_) {
     return false;
@@ -71,6 +72,7 @@ ScriptPromise PointerLockController::RequestPointerLock(
     Element* target,
     ExceptionState& exception_state,
     const PointerLockOptions* options) {
+  LOG(INFO) << "PointerLockController RequestPointerLock promise called";
   ScriptPromise promise = resolver->Promise();
 
   if (!target || !target->isConnected() ||
@@ -263,6 +265,7 @@ void PointerLockController::RejectIfPromiseEnabled(
 }
 
 void PointerLockController::ExitPointerLock() {
+  LOG(INFO) << "PointerLockController ExitPointerLock";
   Document* pointer_lock_document =
       element_ ? &element_->GetDocument()
                : document_of_removed_element_while_waiting_for_unlock_.Get();
diff --git a/third_party/blink/renderer/core/style/computed_style.h b/third_party/blink/renderer/core/style/computed_style.h
index ec3398c5b218c..81350d4cf83f3 100644
--- a/third_party/blink/renderer/core/style/computed_style.h
+++ b/third_party/blink/renderer/core/style/computed_style.h
@@ -2125,6 +2125,20 @@ class ComputedStyle : public ComputedStyleBase,
     }
   }
 
+  // Inertness utility functions.
+  bool IsInert() const { return InertnessInternal() != Inertness::kNone; }
+  void SetIsInert(bool is_inert) {
+    if (InertnessInternal() == Inertness::kForced) {
+      DCHECK(is_inert);
+      return;
+    }
+    SetInertnessInternal(is_inert ? Inertness::kOverridable : Inertness::kNone);
+  }
+  bool IsForcedInert() const {
+    return InertnessInternal() == Inertness::kForced;
+  }
+  void SetIsForcedInert() { SetInertnessInternal(Inertness::kForced); }
+
   // Text decoration utility functions.
   bool TextDecorationVisualOverflowEqual(const ComputedStyle& o) const;
   void ApplyTextDecorations(const Color& parent_text_decoration_color,
diff --git a/third_party/blink/renderer/core/style/computed_style_extra_fields.json5 b/third_party/blink/renderer/core/style/computed_style_extra_fields.json5
index ffab1426f9991..2c2ec3b1c3943 100644
--- a/third_party/blink/renderer/core/style/computed_style_extra_fields.json5
+++ b/third_party/blink/renderer/core/style/computed_style_extra_fields.json5
@@ -1067,5 +1067,24 @@
       field_group: "*",
       default_value: "false",
     },
+    {
+      // https://html.spec.whatwg.org/multipage/interaction.html#inert
+      // The inertness is represented with one of these values:
+      // - 'none' means that the node is not inert (the default).
+      // - 'overridable' means that the node is inert, and descendants will
+      //    inherit by default, but may change their inertness to e.g. 'none'.
+      // - 'forced' means that that the node is inert, and its decendants
+      //   won't be able to change their inertness to something else.
+      // ComputedStyle doesn't directly expose the inertness. Instead, use
+      // IsInert(), SetIsInert(bool), IsForcedInert() or SetIsForcedInert().
+      name: "Inertness",
+      inherited: true,
+      field_template: "keyword",
+      type_name: "Inertness",
+      keywords: ["none", "overridable", "forced"],
+      default_value: "none",
+      field_group: "*",
+      computed_style_custom_functions: ["getter", "setter"],
+    },
   ],
 }
diff --git a/third_party/blink/renderer/modules/BUILD.gn b/third_party/blink/renderer/modules/BUILD.gn
index d31ccd7c8ad27..1bbecaf2d0ff3 100644
--- a/third_party/blink/renderer/modules/BUILD.gn
+++ b/third_party/blink/renderer/modules/BUILD.gn
@@ -215,6 +215,12 @@ component("modules") {
 
   configs -= [ "//build/config/compiler:default_symbols" ]
   configs += blink_symbols_config
+
+  #ifdef ohos_nweb_ex
+  if (ohos_nweb_ex_config_name != "") {
+    configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
+    configs += [ "//build/config:ohos_nweb_ex_def_blink" ]
+  }  #endif  // ohos_nweb_ex
 }
 
 source_set("modules_testing") {
diff --git a/third_party/blink/renderer/modules/accessibility/ax_object.cc b/third_party/blink/renderer/modules/accessibility/ax_object.cc
index a9a32b11a113f..0c4f2e4e7d634 100644
--- a/third_party/blink/renderer/modules/accessibility/ax_object.cc
+++ b/third_party/blink/renderer/modules/accessibility/ax_object.cc
@@ -2208,6 +2208,14 @@ bool AXObject::ComputeIsInertOrAriaHidden(
       return true;
     } else if (IsBlockedByAriaModalDialog(ignored_reasons)) {
       return true;
+    } else if (const LocalFrame* frame = GetNode()->GetDocument().GetFrame()) {
+      // Inert frames don't expose the inertness to the style of their contents,
+      // but accessibility should consider them inert anyways.
+      if (frame->IsInert()) {
+        if (ignored_reasons)
+          ignored_reasons->push_back(IgnoredReason(kAXInertSubtree));
+        return true;
+      }
     }
   } else {
     AXObject* parent = ParentObject();
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 09667cadf7ef3..ea7f410b3e267 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1816,6 +1816,12 @@ component("platform") {
 
   configs -= [ "//build/config/compiler:default_symbols" ]
   configs += blink_symbols_config
+
+  #ifdef OHOS_NWEB_EX
+  if (ohos_nweb_ex_config_name != "") {
+    configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
+    configs += [ "//build/config:ohos_nweb_ex_def_blink" ]
+  }  #endif  // OHOS_NWEB_EX
 }
 
 static_library("test_support") {
diff --git a/third_party/blink/renderer/platform/runtime_enabled_features.json5 b/third_party/blink/renderer/platform/runtime_enabled_features.json5
index 71b5be9b34f09..a73eca8265e92 100644
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -1369,8 +1369,9 @@
     },
     {
       name: "NetInfoDownlinkMax",
-      // Only Android, ChromeOS support NetInfo downlinkMax, type and ontypechange now
-      status: {"Android": "stable", "ChromeOS": "stable", "default": "experimental"},
+      // Only Android, ChromeOS support NetInfo downlinkMax, type and ontypechange now, add ohos.
+      // status: {"Android": "stable", "ChromeOS": "stable", "default": "experimental"},
+      status: "stable",
     },
     {
       name: "NeverSlowMode",
diff --git a/third_party/blink/web_tests/editing/pasteboard/paste-svg-use.html b/third_party/blink/web_tests/editing/pasteboard/paste-svg-use.html
index c03ca90d492a5..1af77f8faa450 100644
--- a/third_party/blink/web_tests/editing/pasteboard/paste-svg-use.html
+++ b/third_party/blink/web_tests/editing/pasteboard/paste-svg-use.html
@@ -32,6 +32,6 @@ selection_test(
       <use href=data:application/xml;base64,PHN2ZyBpZD0neCcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJz4KPGEgaHJlZj0namF2YXNjcmlwdDphbGVydCgxMjMpJz4KICAgIDxyZWN0IHdpZHRoPScxMDAlJyBoZWlnaHQ9JzEwMCUnIGZpbGw9J2xpZ2h0Ymx1ZScgLz4KICAgICA8dGV4dCB4PScwJyB5PScwJyBmaWxsPSdibGFjayc+CiAgICAgICA8dHNwYW4geD0nMCcgZHk9JzEuMmVtJz5Pb3BzLCB0aGVyZSdzIHNvbWV0aGluZyB3cm9uZyB3aXRoIHRoZSBwYWdlITwvdHNwYW4+CiAgICAgPHRzcGFuIHg9JzAnIGR5PScxLjJlbSc+UGxlYXNlIGNsaWNrIGhlcmUgdG8gcmVsb2FkLjwvdHNwYW4+Cjwvc3ZnPg==#x>"></noscript>asdasd`);
     selection.document.execCommand('paste');
   },
-  '<div contenteditable>|<noscript>&lt;u title="</noscript><div contenteditable="false"><svg></svg></div></div>',
+  '<div contenteditable><div><br></div><div>      <u title="</div><div>      </div><div>      ">asdasd|</div></div>',
   'Paste blocks data URI in SVG use element injection via <noscript>');
 </script>
diff --git a/third_party/blink/web_tests/external/wpt/clipboard-apis/async-navigator-clipboard-read-sanitize.https.html b/third_party/blink/web_tests/external/wpt/clipboard-apis/async-navigator-clipboard-read-sanitize.https.html
new file mode 100644
index 0000000000000..9e0ab2ee740f8
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/clipboard-apis/async-navigator-clipboard-read-sanitize.https.html
@@ -0,0 +1,44 @@
+<!doctype html>
+<meta charset="utf-8">
+<title>Async Clipboard.read() should sanitize text/html</title>
+<link rel="help" href="https://w3c.github.io/clipboard-apis/#dom-clipboard-read">
+<link rel="help" href="https://bugs.chromium.org/p/chromium/issues/detail?id=1315563">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="/resources/testdriver.js"></script>
+<script src="/resources/testdriver-vendor.js"></script>
+
+<p><button id="button">Put payload in the clipboard</button></p>
+<div id="output"></div>
+
+<script>
+let testFailed = false;
+function fail() {
+  testFailed = true;
+}
+
+button.onclick = () => document.execCommand('copy');
+document.oncopy = ev => {
+  ev.preventDefault();
+  ev.clipboardData.setData(
+      'text/html',
+      `<form><math><mtext></form><form><mglyph><xmp></math><img src=invalid onerror=fail()></xmp>`);
+};
+
+promise_test(async test => {
+  await test_driver.set_permission({name: 'clipboard-read'}, 'granted');
+  await test_driver.click(button);
+
+  const items = await navigator.clipboard.read();
+  const htmlBlob = await items[0].getType("text/html");
+  const html = await htmlBlob.text();
+
+  // This inserts an image with `onerror` handler if `html` is not properly sanitized
+  output.innerHTML = html;
+
+  // Allow the 'error' event to be dispatched asynchronously
+  await new Promise(resolve => test.step_timeout(resolve, 100));
+
+  assert_false(testFailed);
+});
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/webmessaging/message-channels/detached-iframe.window.js b/third_party/blink/web_tests/external/wpt/webmessaging/message-channels/detached-iframe.window.js
new file mode 100644
index 0000000000000..c1effaf141b72
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/webmessaging/message-channels/detached-iframe.window.js
@@ -0,0 +1,47 @@
+// META: title=MessageChannel in a detached iframe test
+// META: script=/service-workers/service-worker/resources/test-helpers.sub.js
+// Pull in the with_iframe helper function from the service worker tests
+
+
+const IframeAction = {
+  REMOVE_BEFORE_CREATION: 'remove-before-creation',
+  REMOVE_AFTER_CREATION: 'remove-after-creation',
+};
+
+async function detached_frame_test(t, action) {
+  const iframe = await with_iframe('about:blank');
+  const iframe_MessageChannel = iframe.contentWindow.MessageChannel;
+
+  if (action === IframeAction.REMOVE_BEFORE_CREATION) {
+    iframe.remove();
+  }
+
+  (() => {
+    const mc = new iframe_MessageChannel();
+    mc.port1.postMessage("boo");
+    mc.port2.onmessage = t.unreached_func("message event received");
+    mc.port2.onmessageerror = t.unreached_func("message event received");
+  })();
+
+  if (action === IframeAction.REMOVE_AFTER_CREATION) {
+    iframe.remove();
+  }
+
+  // TODO(https://github.com/web-platform-tests/wpt/issues/7899): Change to
+  // some sort of cross-browser GC trigger.
+  if (self.gc) self.gc();
+
+  // We are testing that neither of the above two events fire. We assume that a 2 second timeout
+  // is good enough. We can't use any other API for an end condition because each MessagePort has
+  // its own independent port message queue, which has no ordering guarantees relative to other
+  // APIs.
+  await new Promise(resolve => t.step_timeout(resolve, 2000));
+}
+
+promise_test(async (t) => {
+  return detached_frame_test(t, IframeAction.REMOVE_AFTER_CREATION);
+}, 'MessageChannel created from a detached iframe should not send messages (remove after create)');
+
+promise_test(async (t) => {
+  return detached_frame_test(t, IframeAction.REMOVE_BEFORE_CREATION);
+}, 'MessageChannel created from a detached iframe should not send messages (remove before create)');
diff --git a/third_party/blink/web_tests/fast/dom/inert/inert-focus-in-frames.html b/third_party/blink/web_tests/fast/dom/inert/inert-focus-in-frames.html
index e2b8aa49e23eb..ddeb1a123ae14 100644
--- a/third_party/blink/web_tests/fast/dom/inert/inert-focus-in-frames.html
+++ b/third_party/blink/web_tests/fast/dom/inert/inert-focus-in-frames.html
@@ -28,20 +28,20 @@ function frameLoaded() {
         test(function() {
             var frame1 = mainIframe.contentWindow.frames[0].document;
             var target1 = frame1.querySelector('.target');
-            testCantFocus(target1);
+            testCanFocus(target1);
             var iframe = frame1.querySelector('iframe').contentDocument;
-            testCantFocus(iframe.querySelector('.target'));
-        }, "Focus can't go into frames or iframes in inert subtree");
+            testCanFocus(iframe.querySelector('.target'));
+        }, "Focus can go into frames or iframes in inert subtree");
         done();
     }
 }
 
-function testCantFocus(element) {
+function testCanFocus(element) {
     focusedElement = null;
     element.addEventListener('focus', function() { focusedElement = element; }, false);
     element.focus();
     theElement = element;
-    assert_false(focusedElement === theElement);
+    assert_equals(focusedElement, theElement);
 }
 
 mainIframe.contentDocument.write(mainIframe.textContent);
diff --git a/third_party/blink/web_tests/fast/peerconnection/simulcast-munge.html b/third_party/blink/web_tests/fast/peerconnection/simulcast-munge.html
new file mode 100644
index 0000000000000..2e6dcf92694e4
--- /dev/null
+++ b/third_party/blink/web_tests/fast/peerconnection/simulcast-munge.html
@@ -0,0 +1,50 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <title>Simulcast manipulation</title>
+    <script src="../../resources/testharness.js"></script>
+<script src="../../resources/testharnessreport.js"></script>
+
+<script>
+
+var canvas = document.createElement('canvas');
+
+function createConnection() {
+  var pc = new RTCPeerConnection({
+    iceServers: [],
+    iceTransportPolicy: 'relay'
+  });
+  var encodings = [];
+  for (var i = 0; i < 2; i++) {
+    encodings.push({ rid: String.fromCharCode(97 + i) });
+    // rid must be alphabetic and unique
+  }
+  pc.addTransceiver(canvas.captureStream(0).getTracks()[0],
+                    { sendEncodings: encodings });
+  return pc;
+}
+
+function sdp_munge(offer) {
+  let sdp = offer.sdp;
+  sdp = sdp.replace(/\r?\na=rid:(.+)\s+send\r?\na=simulcast:send\s+.+;\1/, '');
+  // Check that munging worked
+  assert_false(sdp === offer.sdp);
+  offer.sdp = sdp;
+  return offer;
+}
+
+promise_test(async t => {
+  const pc = createConnection();
+  const offer = await pc.createOffer();
+  const sender = pc.getSenders()[0];
+  const parametersBefore = sender.getParameters();
+  const munged_offer = sdp_munge(offer);
+  await pc.setLocalDescription(munged_offer);
+  const parametersAfter = sender.getParameters();
+  assert_equals(parametersBefore.encodings.length,
+                parametersAfter.encodings.length);
+}, "Munging SDP simulcast should not cause changes to simulcast envelope")
+
+</script>
+</head>
+</html>
\ No newline at end of file
diff --git a/tools/metrics/histograms/enums.xml b/tools/metrics/histograms/enums.xml
index 808a241114bbf..4af899b058a6a 100644
--- a/tools/metrics/histograms/enums.xml
+++ b/tools/metrics/histograms/enums.xml
@@ -68571,6 +68571,7 @@ https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_2.7.1.pdf
   <int value="394" label="FILELOC"/>
   <int value="395" label="WEBLOC"/>
   <int value="396" label="XSD"/>
+  <int value="397" label="INETLOC"/>
 </enum>
 
 <enum name="SBClientDownloadIsSignedBinary">
diff --git a/ui/aura/gestures/gesture_recognizer_unittest.cc b/ui/aura/gestures/gesture_recognizer_unittest.cc
index 40ad046607507..fafd5cb6096de 100644
--- a/ui/aura/gestures/gesture_recognizer_unittest.cc
+++ b/ui/aura/gestures/gesture_recognizer_unittest.cc
@@ -29,6 +29,7 @@
 #include "ui/events/event_utils.h"
 #include "ui/events/gesture_detection/gesture_configuration.h"
 #include "ui/events/gesture_detection/gesture_provider.h"
+#include "ui/events/gestures/gesture_recognizer_impl.h"
 #include "ui/events/gestures/gesture_types.h"
 #include "ui/events/test/event_generator.h"
 #include "ui/events/test/events_test_utils.h"
@@ -1737,6 +1738,75 @@ TEST_F(GestureRecognizerTest, GestureTapFollowedByScroll) {
   EXPECT_TRUE(delegate->fling());
 }
 
+// Verifies that destroying a gesture provider aura instance before a touch
+// event is ACKed works as expected (see https://crbug.com/1292264).
+TEST_F(GestureRecognizerTest, DestroyGestureProviderAuraBeforeAck) {
+  TimedEvents tes;
+  const int kTouchId = 4;
+  std::unique_ptr<GestureEventConsumeDelegate> delegate(
+      new GestureEventConsumeDelegate());
+  std::unique_ptr<aura::Window> window1(CreateTestWindowWithDelegate(
+      delegate.get(), /*id=*/-2345, /*bounds=*/gfx::Rect(0, 0, 50, 50),
+      /*parent=*/root_window()));
+
+  // Touch press then release on `window1`.
+  constexpr gfx::Point touch_location(/*x=*/10, /*y=*/20);
+  ui::TouchEvent press(
+      ui::ET_TOUCH_PRESSED, touch_location, /*time_stamp=*/tes.Now(),
+      ui::PointerDetails(ui::EventPointerType::kTouch, kTouchId));
+  delegate->Reset();
+  DispatchEventUsingWindowDispatcher(&press);
+  EXPECT_TRUE(delegate->tap_down());
+  delegate->Reset();
+  ui::TouchEvent release(
+      ui::ET_TOUCH_RELEASED, touch_location,
+      /*time_stamp=*/press.time_stamp() + base::Milliseconds(50),
+      ui::PointerDetails(ui::EventPointerType::kTouch, kTouchId));
+  DispatchEventUsingWindowDispatcher(&release);
+  EXPECT_FALSE(delegate->tap_down());
+
+  // Verify that the gesture provider for `window1` is created.
+  auto* gesture_recognizer = static_cast<ui::GestureRecognizerImpl*>(
+      aura::Env::GetInstance()->gesture_recognizer());
+  const auto& consumer_provider_mappings =
+      gesture_recognizer->consumer_gesture_provider_;
+  EXPECT_NE(consumer_provider_mappings.cend(),
+            consumer_provider_mappings.find(window1.get()));
+
+  // Create a second window for handling touch events.
+  std::unique_ptr<QueueTouchEventDelegate> delegate2(
+      new QueueTouchEventDelegate(host()->dispatcher()));
+  const int kTouchId2 = 4;
+  std::unique_ptr<aura::Window> window2(CreateTestWindowWithDelegate(
+      delegate2.get(), /*id=*/-1234, /*bounds=*/gfx::Rect(100, 100, 500, 500),
+      root_window()));
+  delegate2->set_window(window2.get());
+
+  // Send a press event on `window2`. Verify that the gesture provider for
+  // `window2` is created.
+  ui::TouchEvent press2(
+      ui::ET_TOUCH_PRESSED, /*location=*/gfx::Point(200, 200),
+      /*time_stamp=*/tes.Now(),
+      ui::PointerDetails(ui::EventPointerType::kTouch, kTouchId2));
+  DispatchEventUsingWindowDispatcher(&press2);
+  EXPECT_NE(consumer_provider_mappings.cend(),
+            consumer_provider_mappings.find(window2.get()));
+
+  // Verify that `press2` is associated with a gesture provider raw pointer.
+  const auto& event_provider_mappings =
+      gesture_recognizer->event_to_gesture_provider_;
+  EXPECT_NE(event_provider_mappings.cend(),
+            event_provider_mappings.find(press2.unique_event_id()));
+
+  // Before ACKing `press2`, replacing the gesture provider of `window2` with a
+  // new value through event transferal.
+  aura::Env::GetInstance()->gesture_recognizer()->TransferEventsTo(
+      window1.get(), window2.get(), ui::TransferTouchesBehavior::kCancel);
+
+  // ACK the press event.
+  delegate2->ReceivedAck();
+}
+
 TEST_F(GestureRecognizerTest, AsynchronousGestureRecognition) {
   std::unique_ptr<QueueTouchEventDelegate> queued_delegate(
       new QueueTouchEventDelegate(host()->dispatcher()));
diff --git a/ui/events/gestures/gesture_provider_aura.cc b/ui/events/gestures/gesture_provider_aura.cc
index eb43a56ceda5c..3d100093bb466 100644
--- a/ui/events/gestures/gesture_provider_aura.cc
+++ b/ui/events/gestures/gesture_provider_aura.cc
@@ -39,7 +39,9 @@ GestureProviderAura::GestureProviderAura(GestureConsumer* consumer,
       kDoubleTapPlatformSupport);
 }
 
-GestureProviderAura::~GestureProviderAura() {}
+GestureProviderAura::~GestureProviderAura() {
+  client_->OnGestureProviderAuraWillBeDestroyed(this);
+}
 
 bool GestureProviderAura::OnTouchEvent(TouchEvent* event) {
   if (!pointer_state_.OnTouch(*event))
@@ -110,4 +112,4 @@ void GestureProviderAura::OnTouchEnter(int pointer_id, float x, float y) {
                   false /* is_source_touch_event_set_blocking */);
 }
 
-}  // namespace content
+}  // namespace ui
diff --git a/ui/events/gestures/gesture_provider_aura.h b/ui/events/gestures/gesture_provider_aura.h
index 1cf2b3a47dc30..1a7ff93aa0a33 100644
--- a/ui/events/gestures/gesture_provider_aura.h
+++ b/ui/events/gestures/gesture_provider_aura.h
@@ -27,6 +27,10 @@ class EVENTS_EXPORT GestureProviderAuraClient {
   virtual ~GestureProviderAuraClient() {}
   virtual void OnGestureEvent(GestureConsumer* consumer,
                               GestureEvent* event) = 0;
+
+  // Called when `gesture_provider` will be destroyed.
+  virtual void OnGestureProviderAuraWillBeDestroyed(
+      GestureProviderAura* gesture_provider) {}
 };
 
 // Provides gesture detection and dispatch given a sequence of touch events
diff --git a/ui/events/gestures/gesture_recognizer_impl.cc b/ui/events/gestures/gesture_recognizer_impl.cc
index 85912f5ad4eb5..344412f1c2993 100644
--- a/ui/events/gestures/gesture_recognizer_impl.cc
+++ b/ui/events/gestures/gesture_recognizer_impl.cc
@@ -393,6 +393,18 @@ void GestureRecognizerImpl::OnGestureEvent(GestureConsumer* raw_input_consumer,
   DispatchGestureEvent(raw_input_consumer, event);
 }
 
+void GestureRecognizerImpl::OnGestureProviderAuraWillBeDestroyed(
+    GestureProviderAura* gesture_provider) {
+  // Clean `event_to_gesture_provider_` by removing invalid raw pointers.
+  for (auto iter = event_to_gesture_provider_.begin();
+       iter != event_to_gesture_provider_.end();) {
+    if (iter->second == gesture_provider)
+      iter = event_to_gesture_provider_.erase(iter);
+    else
+      ++iter;
+  }
+}
+
 GestureEventHelper* GestureRecognizerImpl::FindDispatchHelperForConsumer(
     GestureConsumer* consumer) {
   std::vector<GestureEventHelper*>::iterator it;
diff --git a/ui/events/gestures/gesture_recognizer_impl.h b/ui/events/gestures/gesture_recognizer_impl.h
index 54d9c1079a30a..b2a24c0fbdfba 100644
--- a/ui/events/gestures/gesture_recognizer_impl.h
+++ b/ui/events/gestures/gesture_recognizer_impl.h
@@ -19,6 +19,11 @@
 #include "ui/events/types/event_type.h"
 #include "ui/gfx/geometry/point.h"
 
+namespace aura::test {
+FORWARD_DECLARE_TEST(GestureRecognizerTest,
+                     DestroyGestureProviderAuraBeforeAck);
+}  // namespace aura::test
+
 namespace ui {
 class GestureConsumer;
 class GestureEvent;
@@ -73,6 +78,9 @@ class EVENTS_EXPORT GestureRecognizerImpl : public GestureRecognizer,
                                     GestureConsumer* consumer) override;
 
  private:
+  FRIEND_TEST_ALL_PREFIXES(aura::test::GestureRecognizerTest,
+                           DestroyGestureProviderAuraBeforeAck);
+
   // Sets up the target consumer for gestures based on the touch-event.
   void SetupTargets(const TouchEvent& event, GestureConsumer* consumer);
 
@@ -94,6 +102,8 @@ class EVENTS_EXPORT GestureRecognizerImpl : public GestureRecognizer,
   // Overridden from GestureProviderAuraClient
   void OnGestureEvent(GestureConsumer* raw_input_consumer,
                       GestureEvent* event) override;
+  void OnGestureProviderAuraWillBeDestroyed(
+      GestureProviderAura* gesture_provider) override;
 
   // Convenience method to find the GestureEventHelper that can dispatch events
   // to a specific |consumer|.
diff --git a/ui/gl/gl_surface_egl_ohos.cc b/ui/gl/gl_surface_egl_ohos.cc
index 3da5f22041582..a8c5763683753 100644
--- a/ui/gl/gl_surface_egl_ohos.cc
+++ b/ui/gl/gl_surface_egl_ohos.cc
@@ -64,14 +64,7 @@ void NativeViewGLSurfaceEGLOhos::FrameCounter::Start() {
           frame_counter->last_time_ = curr_time;
           continue;
         }
-        if (frame_counter->local_render_count_ != 0) {
-          auto fps_cur = 1000.0 * 1000 * frame_counter->local_render_count_ /
-                         (curr_time - frame_counter->last_time_);
-          LOG(INFO) << "NWeb fps_cur=" << std::fixed << std::setprecision(1)
-                    << fps_cur << " frame_output_count="
-                    << frame_counter->frame_render_count_
-                    << " frame_miss_count=" << frame_counter->frame_miss_count_;
-        }
+
         frame_counter->local_render_count_ = 0;
         frame_counter->last_time_ = curr_time;
       }
diff --git a/ui/ozone/common/egl_util.cc b/ui/ozone/common/egl_util.cc
index 5c5a416cfcc6f..c9bc79ef1fe25 100644
--- a/ui/ozone/common/egl_util.cc
+++ b/ui/ozone/common/egl_util.cc
@@ -39,7 +39,7 @@ const base::FilePath::CharType kDefaultEglSoname[] =
     FILE_PATH_LITERAL("libEGL.so");
 #if defined(GL_RK3568)
 const base::FilePath::CharType kDefaultGlesSoname[] =
-    FILE_PATH_LITERAL("libGLESv2.so");
+    FILE_PATH_LITERAL("libGLESv3.so");
 #else
 const base::FilePath::CharType kDefaultGlesSoname[] =
     FILE_PATH_LITERAL("libGLES_mali.so");
diff --git a/ui/views/controls/table/table_view.cc b/ui/views/controls/table/table_view.cc
index d1df0759384be..89e795165d3ec 100644
--- a/ui/views/controls/table/table_view.cc
+++ b/ui/views/controls/table/table_view.cc
@@ -793,7 +793,7 @@ void TableView::OnItemsRemoved(int start, int length) {
 
   // Remove the virtual views that are no longer needed.
   auto& virtual_children = GetViewAccessibility().virtual_children();
-  for (int i = start; i < start + length; i++)
+  for (int i = start; !virtual_children.empty() && i < start + length; i++)
     virtual_children[virtual_children.size() - 1]->RemoveFromParentView();
 
   UpdateVirtualAccessibilityChildrenBounds();
@@ -1573,7 +1573,11 @@ void TableView::UpdateVirtualAccessibilityChildrenBounds() {
 
   // Update the bounds for the table's content rows.
   for (int row_index = 0; row_index < GetRowCount(); row_index++) {
-    auto& ax_row = virtual_children[header_ ? row_index + 1 : row_index];
+    const size_t ax_row_index = header_ ? row_index + 1 : row_index;
+    if (ax_row_index >= virtual_children.size())
+      break;
+
+    auto& ax_row = virtual_children[ax_row_index];
     ui::AXNodeData& row_data = ax_row->GetCustomData();
     DCHECK_EQ(row_data.role, ax::mojom::Role::kRow);
     row_data.relative_bounds.bounds =
diff --git a/ui/views/controls/table/table_view_unittest.cc b/ui/views/controls/table/table_view_unittest.cc
index 7c5954e71fdd4..d2a5c5701bdaa 100644
--- a/ui/views/controls/table/table_view_unittest.cc
+++ b/ui/views/controls/table/table_view_unittest.cc
@@ -770,6 +770,19 @@ TEST_P(TableViewTest, ColumnVisibility) {
   EXPECT_EQ("rows=0 4 cols=0 2", helper_->GetPaintRegion(table_->bounds()));
 }
 
+// Regression tests for https://crbug.com/1283805, and
+// https://crbug.com/1283807.
+TEST_P(TableViewTest, NoCrashesWithAllColumnsHidden) {
+  // Set both initially visible columns hidden.
+  table_->SetColumnVisibility(0, false);
+  table_->SetColumnVisibility(1, false);
+  EXPECT_EQ(0u, helper_->visible_col_count());
+
+  // Remove and add rows in this state, there should be no crashes.
+  model_->RemoveRow(0);
+  model_->AddRows(1, 2, /*value_multiplier=*/10);
+}
+
 // Verifies resizing a column using the mouse works.
 TEST_P(TableViewTest, Resize) {
   const int x = table_->GetVisibleColumn(0).width;
