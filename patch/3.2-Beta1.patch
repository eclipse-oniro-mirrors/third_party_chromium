diff --git a/.gitattributes b/.gitattributes
index 621f7d35b0..7708cf565b 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -1,49 +1,16 @@
-src/native_client/toolchain/.tars/package_archives/toolchain.tar.bz2/04a77d2e2d6e814a6a5efd66de14142bb4c37c61.tar.bz2 filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ filter=lfs diff=lfs merge=lfs -text
 src/third_party/jdk/current/lib/src.zip filter=lfs diff=lfs merge=lfs -text
-src/third_party/instrumented_libraries/binaries/msan-chained-origins-trusty.tgz filter=lfs diff=lfs merge=lfs -text
-src/third_party/node/linux/node-linux-x64/bin/node filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/215/iC6RDM5EH3GEAzR-1shW_Mg0FeeNE5shq1okkFfuuNQC/lib/android-all-10-robolectric-5803371.jar filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang filter=lfs diff=lfs merge=lfs -text
 src/third_party/jdk/extras/java_8/jre/lib/rt.jar filter=lfs diff=lfs merge=lfs -text
-src/third_party/swiftshader/tests/regres/testlists/vk-master-NOT_SUPPORTED.txt filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/134/87169fbc701d244c311e6aa8843591a7f1710bc0/lib/libart-compiler.so filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang-cl filter=lfs diff=lfs merge=lfs -text
 src/third_party/llvm-build/Release+Asserts/bin/clang filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/199/no8ss5nRg6uYDM08HboypuIQuix7bS1kVqRGyWmwP-YC/android_system.jar filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/prebuilt/linux-x86_64/bin/gdb-orig filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib64/libclang.so.11git filter=lfs diff=lfs merge=lfs -text
-src/third_party/angle/third_party/VK-GL-CTS/src/android/cts/master/vk-master.txt filter=lfs diff=lfs merge=lfs -text
-src/third_party/angle/third_party/VK-GL-CTS/src/external/vulkancts/mustpass/master/vk-default.txt filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/215/iC6RDM5EH3GEAzR-1shW_Mg0FeeNE5shq1okkFfuuNQC/lib/android-all-5.0.2_r3-robolectric-r0.jar filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/134/87169fbc701d244c311e6aa8843591a7f1710bc0/lib/libart.so filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib64/liblldb.so filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib64/liblldb.so.11git filter=lfs diff=lfs merge=lfs -text
-src/third_party/android_build_tools/aapt2/aapt2 filter=lfs diff=lfs merge=lfs -text
-src/third_party/swiftshader/tests/regres/testlists/vk-master.txt filter=lfs diff=lfs merge=lfs -text
-src/third_party/depot_tools/.cipd_bin/compiler_proxy filter=lfs diff=lfs merge=lfs -text
-src/chrome/test/data/xr/webvr_info/samples/media/textures/vr_bench_man.mp4 filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/215/iC6RDM5EH3GEAzR-1shW_Mg0FeeNE5shq1okkFfuuNQC/lib/android-all-8.1.0-robolectric-4611349.jar filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib64/libclang_cxx.so.11git filter=lfs diff=lfs merge=lfs -text
 src/third_party/jdk/current/lib/modules filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/215/iC6RDM5EH3GEAzR-1shW_Mg0FeeNE5shq1okkFfuuNQC/lib/android-all-9-robolectric-4913185-2.jar filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/215/iC6RDM5EH3GEAzR-1shW_Mg0FeeNE5shq1okkFfuuNQC/lib/android-all-8.0.0_r4-robolectric-r1.jar filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/134/87169fbc701d244c311e6aa8843591a7f1710bc0/lib/libartd-compiler.so filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib/python3.8/site-packages/lldb/_lldb.so filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib64/libLLVM-11git.so filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/lib64/liblldb.so.11.0.5git filter=lfs diff=lfs merge=lfs -text
 src/third_party/android_sdk/public/emulator/lib64/qt/lib/libQt5WebEngineCoreAndroidEmu.so.5 filter=lfs diff=lfs merge=lfs -text
-src/third_party/instrumented_libraries/binaries/msan-no-origins-trusty.tgz filter=lfs diff=lfs merge=lfs -text
-src/third_party/catapult/tracing/test_data/theverge_trace.json filter=lfs diff=lfs merge=lfs -text
-.cipd/pkgs/215/iC6RDM5EH3GEAzR-1shW_Mg0FeeNE5shq1okkFfuuNQC/lib/android-all-7.1.0_r7-robolectric-r1.jar filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/bin/lld filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/bin/clang-check filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/lib/libLLVM-10.so filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/lib/libLTO.so.10 filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/lib/libclang.so.10 filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/lib/liblldb.so.10.0.1 filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/lib/libclang-cpp.so.10 filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk/toolchains/llvm/bin/clang-10 filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk_aosp/toolchains/clang-r353983c/bin/clang-9 filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk_aosp/toolchains/clang-r353983c/lib64/libclang_cxx.so.9svn filter=lfs diff=lfs merge=lfs -text
-src/ohos_ndk_aosp/toolchains/clang-r353983c/lib64/libclang.so.9svn filter=lfs diff=lfs merge=lfs -text
diff --git a/build.sh b/build.sh
index 688aef5277..759a2f3492 100755
--- a/build.sh
+++ b/build.sh
@@ -10,7 +10,6 @@ basedir=`dirname "$0"`
 #Add build args begin
 buildargs="
   target_os=\"ohos\"
-  target_cpu=\"arm\"
   is_debug=false
   enable_remoting=true
   use_allocator=\"none\"
@@ -35,24 +34,42 @@ buildargs="
   enable_one_click_signin=true
   enable_message_center=true
   enable_offline_pages=false
-  use_musl=false
   safe_browsing_mode=0
   use_custom_libcxx=false
   use_sysroot=false
-  product_name=\"wgr\"
 "
 #Add build args end
 
-buildgn=0
+buildgn=1
 buildcount=0
 buildccache=0
 buildsymbol=0
 buildproduct=""
+buildarg_cpu="target_cpu=\"arm\""
+buildarg_musl="use_musl=false"
+build_dir="out/wgr/"
 
 while [ "$1" != "" ]; do
   case $1 in
-    "-gn")
-      buildgn=1
+    "wgr")
+      buildarg_cpu="target_cpu=\"arm\""
+      buildarg_musl="use_musl=false"
+      build_dir="out/wgr/"
+    ;;
+    "wgr_64")
+      buildarg_cpu="target_cpu=\"arm64\""
+      buildarg_musl="use_musl=false"
+      build_dir="out/wgr_64/"
+    ;;
+    "rk3568")
+      buildarg_cpu="target_cpu=\"arm\""
+      buildarg_musl="use_musl=true"
+      build_dir="out/rk3568/"
+    ;;
+    "rk3568_64")
+      buildarg_cpu="target_cpu=\"arm64\""
+      buildarg_musl="use_musl=true"
+      build_dir="out/rk3568_64/"
     ;;
     "-j")
       shift
@@ -69,12 +86,13 @@ while [ "$1" != "" ]; do
     ;;
     *)
       echo " -> $1 <- is not a valid option, please follow the usage below: "
-      echo "usage: ./build.sh [option]"
-      echo "[option:]"
-      echo "         -gn: build with generating gn files"
-      echo "         -j N: force number of build jobs"
-      echo "         -nosym: build without symbols"
-      echo "         -product_name: product_name [wgr|rk3568]"
+      echo "usage: ./build.sh [product]"
+      echo "Default product : wgr"
+      echo "Support product : wgr wgr_64 rk3568 rk3568_64"
+      #echo "         -gn: build with generating gn files"
+      #echo "         -j N: force number of build jobs"
+      #echo "         -nosym: build without symbols"
+      #echo "         -product_name: product_name [wgr|rk3568]"
       exit
     ;;
   esac
@@ -87,7 +105,8 @@ if [ $buildsymbol = 1 ]; then
 fi
 
 if [ $buildcount = 0 ]; then
-  buildcount=`grep processor /proc/cpuinfo | wc -l`
+  #buildcount=`grep processor /proc/cpuinfo | wc -l`
+  buildcount=40
 fi
 
 if [ $buildccache = 1 ]; then
@@ -105,11 +124,11 @@ time_start_for_gn=$time_start_for_build
 
 if [ $buildgn = 1 ]; then
   echo "generating args list: $buildargs $GN_ARGS"
-  gn gen out/Default --args="$buildargs $GN_ARGS symbol_level=$SYMBOL_LEVEL"
+  gn gen $build_dir --args="$buildargs $buildarg_cpu $buildarg_musl $GN_ARGS symbol_level=$SYMBOL_LEVEL"
 fi
 time_end_for_gn=`date +%s`
 
-autoninja -C out/Default/ -j$buildcount libnweb_adapter libweb_engine web_render libnweb_render
+autoninja -C $build_dir -j$buildcount libnweb_adapter libweb_engine web_render libnweb_render
 time_end_for_build=`date +%s`
 
 time_format() {
diff --git a/build_all.sh b/build_all.sh
index 17ad944046..ac141cb056 100755
--- a/build_all.sh
+++ b/build_all.sh
@@ -5,7 +5,7 @@ basedir=`pwd`
 echo "basedir = $basedir"
 nweb_base=$basedir/openharmony/third_party/webview_chromium
 harmony_base=$basedir/openharmony
-ohos_nweb_path=$harmony_base/foundation/web/webview
+ohos_nweb_path=$harmony_base/base/web/webview
 
 archieve_nweb_base=$basedir/binary/webview
 archieve_harmony_base=$basedir/binary/harmony
diff --git a/gen_ohos_ndk.sh b/gen_ohos_ndk.sh
index f9d215b7f8..a12c94d9ef 100755
--- a/gen_ohos_ndk.sh
+++ b/gen_ohos_ndk.sh
@@ -66,6 +66,9 @@ declare -A src_ohos_includes=(
   ["location_request_config"]="base/location/location_common/common/include/"
   ["system_ability"]="foundation/distributedschedule/samgr/interfaces/innerkits/samgr_proxy/include/"
   ["accesstoken"]="base/security/access_token/interfaces/innerkits/accesstoken/include/"
+  ["aafwk"]="foundation/aafwk/standard/interfaces/innerkits/"
+  ["json"]="third_party/json/include/"
+  ["appexecfwk"]="foundation/appexecfwk/standard/interfaces/innerkits/appexecfwk_base/include"
 )
 
 src_ohos_libs=(
@@ -80,6 +83,12 @@ src_ohos_libs=(
   liblocator_sdk.z.so
   liblbsservice_common.z.so
   libaccesstoken_sdk.z.so
+  libapp_manager.z.so
+  libbase.z.so
+  libwant.z.so
+  libappexecfwk_common.z.so
+  libappexecfwk_base.z.so
+  libsamgr_proxy.z.so
 )
 
 target_includes_dir="includes"
diff --git a/src/DEPS b/src/DEPS
index 5be6aa5b06..9bc5bbe9fe 100644
--- a/src/DEPS
+++ b/src/DEPS
@@ -261,7 +261,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling freetype
   # and whatever else without interference from each other.
-  'freetype_revision': 'e9c50fa77de58b749b4b95706f7b55bfff0dd27f',
+  'freetype_revision': '6a2b3e4007e794bfc6c91030d0ed987f925164a8',
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling freetype
   # and whatever else without interference from each other.
diff --git a/src/base/message_loop/message_pump_ohos.cc b/src/base/message_loop/message_pump_ohos.cc
index b49e2a76cb..25a245d923 100644
--- a/src/base/message_loop/message_pump_ohos.cc
+++ b/src/base/message_loop/message_pump_ohos.cc
@@ -76,7 +76,11 @@ int timerfd_settime(int ufc,
                     const struct itimerspec* utmr,
                     struct itimerspec* otmr) {
 #if defined(__MUSL__)
+#if defined(__aarch64__)
+  return syscall(__NR_timerfd_settime, ufc, flags, utmr, otmr);
+#else
   return syscall(__NR_timerfd_settime32, ufc, flags, utmr, otmr);
+#endif
 #else
   return syscall(__NR_timerfd_settime, ufc, flags, utmr, otmr);
 #endif
diff --git a/src/build/config/ohos/BUILD.gn b/src/build/config/ohos/BUILD.gn
index 534f0020d7..7461d2b0f7 100644
--- a/src/build/config/ohos/BUILD.gn
+++ b/src/build/config/ohos/BUILD.gn
@@ -53,14 +53,14 @@ config("compiler") {
   if (use_musl) {
     if (current_cpu == "arm") {
     } else {
-      ldflags += [ "--rtlib=libgcc" ]
+     # ldflags += [ "--rtlib=libgcc" ]
     }
   }
 
   if (current_cpu == "arm64") {
     # For outline atomics on AArch64 (can't pass this unconditionally
     # due to unused flag warning on other targets).
-    cflags += [ "--rtlib=libgcc" ]
+    # cflags += [ "--rtlib=libgcc" ]
   }
 
   # $compile_api_level corresponds to the API level used for the sysroot path
@@ -76,6 +76,7 @@ config("compiler") {
     abi_target = ""
     compile_api_level = ""
   } else if (current_cpu == "arm64") {
+    abi_target = "aarch64-linux-ohos"
     if (!use_musl) {
       abi_target = "aarch64-linux-android"
       compile_api_level = arm64_ndk_api_level
@@ -130,13 +131,23 @@ config("runtime_library") {
     ]
   }
   if (use_musl) {
-    ldflags += [
-      "-L" + rebase_path("$ohos_sysroot/usr/lib/arm-linux-ohosmusl", root_build_dir),
-      "-L" + rebase_path("$ohos_toolchain_root/lib/arm-linux-ohosmusl/c++", root_build_dir),
-      "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohosmusl", root_build_dir),
-    ]
-    ldflags += [ "-Wl,--dynamic-linker,/system/bin/ld-musl-arm.so.1" ]
-    libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohosmusl/libclang_rt.builtins.a"
+    ldflags += [ "-Wl,--dynamic-linker,/lib/ld-musl-arm.so.1" ]
+
+    if (current_cpu == "arm") {
+      ldflags += [ "-L" + rebase_path("$ohos_sysroot/usr/lib/arm-linux-ohos", root_build_dir) ]
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/arm-linux-ohos/c++", root_build_dir) ]
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohos", root_build_dir) ]
+      libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohos/libclang_rt.builtins.a"
+    }
+
+    if (current_cpu == "arm64") {
+      ldflags += [ "-Wl,-z,max-page-size=4096" ]
+      ldflags += [ "-Wl,--hash-style=gnu" ]
+      ldflags += [ "-L" + rebase_path("$ohos_sysroot/usr/lib/aarch64-linux-ohos", root_build_dir) ]
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/aarch64-linux-ohos/c++", root_build_dir) ]
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/aarch64-linux-ohos", root_build_dir) ]
+      libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/aarch64-linux-ohos/libclang_rt.builtins.a"
+    }
 
     libs += [
       rebase_path(libclang_rt_file),
@@ -171,6 +182,21 @@ config("runtime_library") {
       ldflags += [ "-L" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm/usr/lib", root_build_dir) ]
     }
 
+    if (current_cpu == "arm64") {
+      ldflags += [ "-Wl,-z,max-page-size=4096" ]
+      ldflags += [ "-Wl,--hash-style=gnu" ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/gcc/linux-x86/arm/gcc-linaro-7.5.0-arm-linux-gnueabi/arm-linux-gnueabi/lib", root_build_dir) ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/gcc/linux-x86/arm/gcc-linaro-7.5.0-arm-linux-gnueabi/lib/gcc/arm-linux-gnueabi/7.5.0", root_build_dir) ]
+      ldflags += [ "-l:libgcc.a" ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/libcxx/arm64", root_build_dir) ]
+      ldflags += [ "-l:libc++_static.a" ]
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib64/clang/9.0.3/lib/linux", root_build_dir) ]
+      ldflags += [ "-l:libclang_rt.builtins-aarch64-android.a" ]
+      ldflags += [ "-L" + rebase_path("//ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64", root_build_dir) ]
+      ldflags += [ "-l:liblog.so" ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm64/usr/lib", root_build_dir) ]
+    }
+
     libs += [ "unwind_llvm" ]
   }
 
diff --git a/src/build/config/ohos/config.gni b/src/build/config/ohos/config.gni
index ac4d39c78b..1ad2a5244f 100644
--- a/src/build/config/ohos/config.gni
+++ b/src/build/config/ohos/config.gni
@@ -13,7 +13,7 @@ if (is_ohos) {
   }
 
   declare_args() {
-    build_chromium_with_ohos_src = false
+    build_chromium_with_ohos_src = true
   }
 
   declare_args() {
@@ -46,30 +46,43 @@ if (is_ohos) {
     ohos_build_root = "//../../.."
     if (use_musl) {
       ohos_toolchain_root = "$ohos_ndk_root/clang/ohos/linux-x86_64/llvm"
-      ohos_sysroot = "$ohos_build_root/out/ohos-arm-release/obj/third_party/musl"
+      ohos_sysroot = "$ohos_build_root/out/rk3568/obj/third_party/musl"
     } else {
       ohos_toolchain_root = "$ohos_ndk_root/clang/host/linux-x86/clang-r353983c"
-      ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
+      if (current_cpu == "arm") {
+        ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
+      } else if (current_cpu == "arm64") {
+        ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm64"
+      } else {
+        assert(false, "Unsupport target cpu")
+      }
     }
 
     # ohos include and libs dependencies
     ohos_src_includes = [
+      "$ohos_build_root/base/location/services/location_locator/callback/include",
+      "$ohos_build_root/base/location/services/location_common/common/include",
+      "$ohos_build_root/base/location/interfaces/inner_api/include",
+      "$ohos_build_root/base/location/services/utils/include",
+      "$ohos_build_root/foundation/bundlemanager/bundle_framework/interfaces/innerkits/libeventhandler/include",
+
       "$ohos_build_root/foundation/appexecfwk/standard/interfaces/innerkits/libeventhandler/include",
       "$ohos_build_root/utils/native/base/include",
       "$ohos_build_root/base/hiviewdfx/hilog/interfaces/native/innerkits/include",
-      "$ohos_build_root/foundation/graphic/standard/interfaces/innerkits/common",
+      "$ohos_build_root/foundation/graphic/graphic/interfaces/inner_api/common",
       "$ohos_build_root/drivers/peripheral/display/interfaces/include",
-      "$ohos_build_root/foundation/graphic/standard/utils/buffer_handle/export",
+      "$ohos_build_root/foundation/graphic/graphic/utils/buffer_handle/export",
       "$ohos_build_root/foundation/multimedia/media_standard/interfaces/innerkits/native/media/include",
+      "$ohos_build_root/foundation/multimedia/media_standard/interfaces/inner_api/native",
       "$ohos_build_root/drivers/peripheral/base",
-      "$ohos_build_root/foundation/graphic/standard/interfaces/innerkits/surface",
+      "$ohos_build_root/foundation/graphic/graphic/interfaces/inner_api/surface",
+      "$ohos_build_root/foundation/graphic/surface/interfaces/kits",
       "$ohos_build_root/foundation/communication/ipc/interfaces/innerkits/ipc_core/include",
       "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_controller/include",
       "$ohos_build_root/base/miscservices/inputmethod/services/include",
       "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_ability/include",
       "$ohos_build_root/utils/native/base/include",
       "$ohos_build_root/foundation/multimodalinput/input/interfaces/native/innerkits/event/include",
-      "$ohos_build_root/base/location/location_locator/callback/include",
       "$ohos_build_root/base/location/utils/include",
       "$ohos_build_root/base/location/interfaces/innerkits/locator_standard/include",
       "$ohos_build_root/base/location/location_common/common/include",
@@ -85,10 +98,27 @@ if (is_ohos) {
       "$ohos_build_root/third_party/jsoncpp/include",
       "$ohos_build_root/third_party/json/include",
       "$ohos_build_root/base/security/access_token/interfaces/innerkits/accesstoken/include/",
+      "$ohos_build_root/foundation/aafwk/standard/interfaces/innerkits/uri/include",
+      "$ohos_build_root/base/web/webview/ohos_adapter/interfaces",
+      "$ohos_build_root/base/location/services/location_common/common/include",
+      "$ohos_build_root/base/location/interfaces/inner_api/include",
+      "$ohos_build_root/base/location/services/utils/include",
+      "$ohos_build_root/base/location/services/location_locator/callback/include"
     ]
-    ohos_libs_dir = [
-      "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib",
-    ]
+
+    if (use_musl) {
+      if (current_cpu == "arm") {
+        ohos_libs_dir = [ "$ohos_build_root/out/rk3568/packages/phone/system/lib" ]
+      } else if (current_cpu == "arm64") {
+        ohos_libs_dir = [ "$ohos_build_root/out/rk3568/packages/phone/system/lib64" ]
+      }
+    } else {
+      if (current_cpu == "arm") {
+        ohos_libs_dir = [ "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib" ]
+      } else if (current_cpu == "arm64") {
+        ohos_libs_dir = [ "$ohos_build_root/out/ohos-arm64-release/packages/phone/system/lib64" ]
+      }
+    }
   } else {
     if (use_musl) {
       ohos_build_root = "//ohos_ndk"
@@ -124,6 +154,12 @@ if (is_ohos) {
       "$ohos_build_root/includes/location_request_config",
       "$ohos_build_root/includes/system_ability",
       "$ohos_build_root/includes/accesstoken",
+      "$ohos_build_root/includes/aafwk/want/include/ohos/aafwk/content",
+      "$ohos_build_root/includes/aafwk/uri/include",
+      "$ohos_build_root/includes/aafwk/app_manager/include",
+      "$ohos_build_root/includes/aafwk/base/include",
+      "$ohos_build_root/includes/json",
+      "$ohos_build_root/includes/appexecfwk",
     ]
     ohos_libs_dir = [
       "$ohos_build_root/libs",
diff --git a/src/cef/include/capi/cef_browser_capi.h b/src/cef/include/capi/cef_browser_capi.h
index 4da347b328..08a853a713 100644
--- a/src/cef/include/capi/cef_browser_capi.h
+++ b/src/cef/include/capi/cef_browser_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=c67f05b1e5dfb20ca1895cd289fa391fc2f8d21b$
+// $hash=e434c8f59b8c8cbfa6c41550f4b53940c57d68f7$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_BROWSER_CAPI_H_
@@ -104,6 +104,11 @@ typedef struct _cef_browser_t {
   int(CEF_CALLBACK* can_go_back_or_forward)(struct _cef_browser_t* self,
                                             int num_steps);
 
+  ///
+  // DeleteHistory
+  ///
+  void(CEF_CALLBACK* delete_history)(struct _cef_browser_t* self);
+
   ///
   // Returns true (1) if the browser is currently loading.
   ///
@@ -1049,6 +1054,17 @@ typedef struct _cef_browser_host_t {
   ///
   void(CEF_CALLBACK* set_native_window)(struct _cef_browser_host_t* self,
                                         cef_native_window_t window);
+
+  ///
+  // Set web debugging access
+  ///
+  void(CEF_CALLBACK* set_web_debugging_access)(struct _cef_browser_host_t* self,
+                                               int isEnableDebug);
+
+  ///
+  // Get web debugging access
+  ///
+  int(CEF_CALLBACK* get_web_debugging_access)(struct _cef_browser_host_t* self);
 } cef_browser_host_t;
 
 ///
diff --git a/src/cef/include/capi/cef_dialog_handler_capi.h b/src/cef/include/capi/cef_dialog_handler_capi.h
index 51563dbdc0..0071832626 100644
--- a/src/cef/include/capi/cef_dialog_handler_capi.h
+++ b/src/cef/include/capi/cef_dialog_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=0f56154217707d141912dc8a298279df8df04311$
+// $hash=abdbb4a150fc310df31ec08d1618e1e557dfe3e2$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_DIALOG_HANDLER_CAPI_H_
@@ -106,6 +106,7 @@ typedef struct _cef_dialog_handler_t {
       const cef_string_t* default_file_path,
       cef_string_list_t accept_filters,
       int selected_accept_filter,
+      int capture,
       struct _cef_file_dialog_callback_t* callback);
 } cef_dialog_handler_t;
 
diff --git a/src/cef/include/capi/cef_load_handler_capi.h b/src/cef/include/capi/cef_load_handler_capi.h
index 13871a2b69..5441c2a61c 100644
--- a/src/cef/include/capi/cef_load_handler_capi.h
+++ b/src/cef/include/capi/cef_load_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=4e59a8c7cda2f13ee54599773755637ec846fe84$
+// $hash=01d2eb08fb2b56fd87c80e441d4b6c7f7d082bb6$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_LOAD_HANDLER_CAPI_H_
@@ -138,6 +138,16 @@ typedef struct _cef_load_handler_t {
                                     int is_main_frame,
                                     int has_user_gesture,
                                     struct _cef_response_t* response);
+
+  ///
+  // OnRefreshAccessedHistory
+  ///
+  void(CEF_CALLBACK* on_refresh_accessed_history)(
+      struct _cef_load_handler_t* self,
+      struct _cef_browser_t* browser,
+      struct _cef_frame_t* frame,
+      const cef_string_t* url,
+      int isReload);
 } cef_load_handler_t;
 
 #ifdef __cplusplus
diff --git a/src/cef/include/cef_api_hash.h b/src/cef/include/cef_api_hash.h
index f3f3a84157..26cd4c0945 100755
--- a/src/cef/include/cef_api_hash.h
+++ b/src/cef/include/cef_api_hash.h
@@ -42,15 +42,15 @@
 // way that may cause binary incompatibility with other builds. The universal
 // hash value will change if any platform is affected whereas the platform hash
 // values will change only if that particular platform is affected.
-#define CEF_API_HASH_UNIVERSAL "1f76ea4de1ba7ea76c979c9e1b8979dd9635627c"
+#define CEF_API_HASH_UNIVERSAL "e71457f3fd884ff5c35e8be2ad91e649d7b00e45"
 #if defined(OS_WIN)
-#define CEF_API_HASH_PLATFORM "8495446ce9aab5825a73927de2d283a4c476cb78"
+#define CEF_API_HASH_PLATFORM "b950292957927fcf6a52690fb196331a3a44ce67"
 #elif defined(OS_MAC)
-#define CEF_API_HASH_PLATFORM "f29274b57821fd5052c5e2b438189ad9f9343aeb"
+#define CEF_API_HASH_PLATFORM "3b5736924b75007ae90ee5bc9979b829c564581d"
 #elif defined(OS_LINUX)
-#define CEF_API_HASH_PLATFORM "441fb55700b31842dfc6e31f9757ef63c0359623"
+#define CEF_API_HASH_PLATFORM "3ed0e1dedda07cfe679f709fb96d40ca92900395"
 #elif defined(OS_OHOS)
-#define CEF_API_HASH_PLATFORM "441fb55700b31842dfc6e31f9757ef63c0359623"
+#define CEF_API_HASH_PLATFORM "3ed0e1dedda07cfe679f709fb96d40ca92900395"
 #endif
 
 #ifdef __cplusplus
diff --git a/src/cef/include/cef_browser.h b/src/cef/include/cef_browser.h
index 7e977e4297..43a571f43d 100755
--- a/src/cef/include/cef_browser.h
+++ b/src/cef/include/cef_browser.h
@@ -100,6 +100,12 @@ class CefBrowser : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual bool CanGoBackOrForward(int num_steps) = 0;
 
+  ///
+  // DeleteHistory
+  ///
+  /*--cef()--*/
+  virtual void DeleteHistory() = 0;
+
   ///
   // Returns true if the browser is currently loading.
   ///
@@ -1078,6 +1084,18 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   ///
   /*--cef()--*/
   virtual void SetNativeWindow(cef_native_window_t window) = 0;
+
+  ///
+  // Set web debugging access
+  ///
+  /*--cef()--*/
+  virtual void SetWebDebuggingAccess(bool isEnableDebug) = 0;
+
+  ///
+  // Get web debugging access
+  ///
+  /*--cef()--*/
+  virtual bool GetWebDebuggingAccess() = 0;
 };
 
 ///
diff --git a/src/cef/include/cef_dialog_handler.h b/src/cef/include/cef_dialog_handler.h
index 3ce02e6c13..5b77305af9 100644
--- a/src/cef/include/cef_dialog_handler.h
+++ b/src/cef/include/cef_dialog_handler.h
@@ -98,6 +98,7 @@ class CefDialogHandler : public virtual CefBaseRefCounted {
                             const CefString& default_file_path,
                             const std::vector<CefString>& accept_filters,
                             int selected_accept_filter,
+                            bool capture,
                             CefRefPtr<CefFileDialogCallback> callback) {
     return false;
   }
diff --git a/src/cef/include/cef_load_handler.h b/src/cef/include/cef_load_handler.h
old mode 100644
new mode 100755
index 3389aa306b..412e3b981f
--- a/src/cef/include/cef_load_handler.h
+++ b/src/cef/include/cef_load_handler.h
@@ -131,6 +131,15 @@ class CefLoadHandler : public virtual CefBaseRefCounted {
                                    bool is_main_frame,
                                    bool has_user_gesture,
                                    CefRefPtr<CefResponse> response) {}
+
+  ///
+  // OnRefreshAccessedHistory
+  ///
+  /*--cef()--*/
+  virtual void OnRefreshAccessedHistory(CefRefPtr<CefBrowser> browser,
+                                        CefRefPtr<CefFrame> frame,
+                                        const CefString& url,
+                                        bool isReload) {}
 };
 
 #endif  // CEF_INCLUDE_CEF_LOAD_HANDLER_H_
diff --git a/src/cef/include/internal/cef_types.h b/src/cef/include/internal/cef_types.h
old mode 100644
new mode 100755
index c5c6171674..1c5fb3b85c
--- a/src/cef/include/internal/cef_types.h
+++ b/src/cef/include/internal/cef_types.h
@@ -703,13 +703,13 @@ typedef struct _cef_browser_settings_t {
   cef_state_t loads_images_automatically;
   bool javascript_can_open_windows_automatically;
   int text_size_percent;
-  int mixed_content_mode;
   cef_state_t allow_running_insecure_content;
   cef_state_t strict_mixed_content_checking;
   cef_state_t allow_mixed_content_upgrades;
   bool geolocation_enabled;
   bool supports_double_tap_zoom;
   bool supports_multi_touch_zoom;
+  cef_state_t initialize_at_minimum_page_scale;
   /* ohos webview end */
 } cef_browser_settings_t;
 
diff --git a/src/cef/include/internal/cef_types_wrappers.h b/src/cef/include/internal/cef_types_wrappers.h
old mode 100644
new mode 100755
index 49429490a9..e4c0d643bc
--- a/src/cef/include/internal/cef_types_wrappers.h
+++ b/src/cef/include/internal/cef_types_wrappers.h
@@ -732,13 +732,13 @@ struct CefBrowserSettingsTraits {
         src->javascript_can_open_windows_automatically;
     target->loads_images_automatically = src->loads_images_automatically;
     target->text_size_percent = src->text_size_percent;
-    target->mixed_content_mode = src->mixed_content_mode;
     target->allow_running_insecure_content = src->allow_running_insecure_content;
     target->strict_mixed_content_checking = src->strict_mixed_content_checking;
     target->allow_mixed_content_upgrades = src->allow_mixed_content_upgrades;
     target->geolocation_enabled = src->geolocation_enabled;
     target->supports_double_tap_zoom = src->supports_double_tap_zoom;
     target->supports_multi_touch_zoom = src->supports_multi_touch_zoom;
+    target->initialize_at_minimum_page_scale = src->initialize_at_minimum_page_scale;
     /* ohos webview end */
   }
 };
diff --git a/src/cef/libcef/browser/alloy/alloy_browser_main.cc b/src/cef/libcef/browser/alloy/alloy_browser_main.cc
index 433272c61c..60c2b83aea 100644
--- a/src/cef/libcef/browser/alloy/alloy_browser_main.cc
+++ b/src/cef/libcef/browser/alloy/alloy_browser_main.cc
@@ -194,10 +194,6 @@ int AlloyBrowserMainParts::PreMainMessageLoopRun() {
   // Create the global RequestContext.
   global_request_context_ =
       CefRequestContextImpl::CreateGlobalRequestContext(settings);
-  auto browser_context =
-      global_request_context_->GetBrowserContext()->AsBrowserContext();
-
-  CefDevToolsManagerDelegate::StartHttpHandler(browser_context);
 
 #if defined(OS_WIN)
   // Windows parental controls calls can be slow, so we do an early init here
diff --git a/src/cef/libcef/browser/alloy/alloy_content_browser_client.cc b/src/cef/libcef/browser/alloy/alloy_content_browser_client.cc
index a936b5659e..4530987a86 100755
--- a/src/cef/libcef/browser/alloy/alloy_content_browser_client.cc
+++ b/src/cef/libcef/browser/alloy/alloy_content_browser_client.cc
@@ -1229,6 +1229,8 @@ void AlloyContentBrowserClient::ConfigureNetworkContextParams(
     }
     network_context_params->persist_session_cookies = cef_context->ShouldPersistSessionCookies();
     network_context_params->restore_old_session_cookies = cef_context->ShouldRestoreOldSessionCookies();
+    network_context_params->http_cache_enabled = true;
+    network_context_params->http_cache_path = cache_path;
   }
   if (!SystemNetworkContextManager::GetInstance()) {
     // This must match the value expected in
diff --git a/src/cef/libcef/browser/browser_contents_delegate.cc b/src/cef/libcef/browser/browser_contents_delegate.cc
old mode 100644
new mode 100755
index fca6d1e95f..6273fb3a88
--- a/src/cef/libcef/browser/browser_contents_delegate.cc
+++ b/src/cef/libcef/browser/browser_contents_delegate.cc
@@ -406,6 +406,11 @@ void CefBrowserContentsDelegate::DidFinishNavigation(
     if (is_main_frame) {
       OnAddressChange(url);
     }
+
+    bool isReload = PageTransitionCoreTypeIs(navigation_handle->GetPageTransition(),
+                                             ui::PageTransition::PAGE_TRANSITION_RELOAD);
+    LOG(INFO) << "load type = " << PageTransitionStripQualifier(navigation_handle->GetPageTransition());
+    OnRefreshAccessedHistory(frame.get(), url, isReload);
   } else {
     // The navigation failed with an error. This may happen before commit
     // (e.g. network error) or after commit (e.g. response filter error).
@@ -663,3 +668,19 @@ void CefBrowserContentsDelegate::InitIconHelper() {
     }
   }
 }
+
+void CefBrowserContentsDelegate::OnRefreshAccessedHistory(CefRefPtr<CefFrame> frame, const GURL& url, bool isReload) {
+  CefRefPtr<CefClient> cefClient = client();
+  if (!cefClient.get()) {
+    LOG(ERROR) << "cef client is null";
+    return;
+  }
+
+  auto handler = cefClient->GetLoadHandler();
+  if (!handler.get()) {
+    LOG(ERROR) << "cef client handler is null";
+    return;
+  }
+
+  handler->OnRefreshAccessedHistory(browser(), frame, url.spec(), isReload);
+}
diff --git a/src/cef/libcef/browser/browser_contents_delegate.h b/src/cef/libcef/browser/browser_contents_delegate.h
old mode 100644
new mode 100755
index 991010f4f7..ab6a9ae07a
--- a/src/cef/libcef/browser/browser_contents_delegate.h
+++ b/src/cef/libcef/browser/browser_contents_delegate.h
@@ -176,6 +176,8 @@ class CefBrowserContentsDelegate : public content::WebContentsDelegate,
 
   void OnStateChanged(State state_changed);
 
+  void OnRefreshAccessedHistory(CefRefPtr<CefFrame> frame, const GURL& url, bool isReload);
+
   scoped_refptr<CefBrowserInfo> browser_info_;
 
   bool is_loading_ = false;
diff --git a/src/cef/libcef/browser/browser_host_base.cc b/src/cef/libcef/browser/browser_host_base.cc
index 152bbb89d5..249d40e4f1 100755
--- a/src/cef/libcef/browser/browser_host_base.cc
+++ b/src/cef/libcef/browser/browser_host_base.cc
@@ -10,6 +10,7 @@
 #include "libcef/browser/browser_info_manager.h"
 #include "libcef/browser/browser_platform_delegate.h"
 #include "libcef/browser/context.h"
+#include "libcef/browser/devtools/devtools_manager_delegate.h"
 #include "libcef/browser/image_impl.h"
 #include "libcef/browser/navigation_entry_impl.h"
 #include "libcef/browser/permission/alloy_access_request.h"
@@ -465,7 +466,6 @@ void CefBrowserHostBase::UpdateBrowserSettings(
   settings_.loads_images_automatically =
       browser_settings.loads_images_automatically;
   settings_.text_size_percent = browser_settings.text_size_percent;
-  settings_.mixed_content_mode = browser_settings.mixed_content_mode;
   settings_.allow_running_insecure_content =
       browser_settings.allow_running_insecure_content;
   settings_.strict_mixed_content_checking =
@@ -477,6 +477,8 @@ void CefBrowserHostBase::UpdateBrowserSettings(
       browser_settings.supports_double_tap_zoom;
   settings_.supports_multi_touch_zoom =
       browser_settings.supports_multi_touch_zoom;
+  settings_.initialize_at_minimum_page_scale =
+      browser_settings.initialize_at_minimum_page_scale;
 }
 
 void CefBrowserHostBase::SetWebPreferences(
@@ -682,15 +684,27 @@ void CefBrowserHostBase::GoForward() {
 
 bool CefBrowserHostBase::CanGoBackOrForward(int num_steps) {
   auto wc = GetWebContents();
-  LOG(INFO) << "CanGoBackOrForward";
   if (wc != nullptr) {
-    LOG(INFO) << "CanGoBackOrForward:"
-              << wc->GetController().CanGoToOffset(num_steps);
     return wc->GetController().CanGoToOffset(num_steps);
   }
   return false;
 }
 
+void CefBrowserHostBase::DeleteHistory() {
+  auto callback = base::BindOnce(&CefBrowserHostBase::DeleteHistory, this);
+  if (!CEF_CURRENTLY_ON_UIT()) {
+    CEF_POST_TASK(CEF_UIT, std::move(callback));
+    return;
+  }
+  auto wc = GetWebContents();
+  if (wc && wc->GetController().CanPruneAllButLastCommitted()) {
+    wc->GetController().PruneAllButLastCommitted();
+    base::AutoLock lock_scope(state_lock_);
+    can_go_forward_ = false;
+    can_go_back_ = false;
+  }
+}
+
 bool CefBrowserHostBase::IsLoading() {
   base::AutoLock lock_scope(state_lock_);
   return is_loading_;
@@ -1300,4 +1314,24 @@ void CefBrowserHostBase::SetNativeWindow(cef_native_window_t window)
 cef_accelerated_widget_t CefBrowserHostBase::GetAcceleratedWidget()
 {
   return widget_;
-}
\ No newline at end of file
+}
+
+void CefBrowserHostBase::SetWebDebuggingAccess(bool isEnableDebug) {
+  base::AutoLock lock_scope(state_lock_);
+  if (is_web_debugging_access_ == isEnableDebug) {
+    LOG(ERROR) << "set web debugging access failed, already is " << isEnableDebug;
+    return;
+  }
+
+  if (isEnableDebug) {
+    CefDevToolsManagerDelegate::StartHttpHandler(GetBrowserContext());
+  } else {
+    CefDevToolsManagerDelegate::StopHttpHandler();
+  }
+  is_web_debugging_access_ = isEnableDebug;
+}
+
+bool CefBrowserHostBase::GetWebDebuggingAccess() {
+  base::AutoLock lock_scope(state_lock_);
+  return is_web_debugging_access_;
+}
diff --git a/src/cef/libcef/browser/browser_host_base.h b/src/cef/libcef/browser/browser_host_base.h
index 6931c1f2f6..e85729d5a8 100755
--- a/src/cef/libcef/browser/browser_host_base.h
+++ b/src/cef/libcef/browser/browser_host_base.h
@@ -219,6 +219,7 @@ class CefBrowserHostBase : public CefBrowserHost,
   bool CanGoForward() override;
   void GoForward() override;
   bool CanGoBackOrForward(int num_steps) override;
+  void DeleteHistory() override;
   bool IsLoading() override;
   void Reload() override;
   void ReloadIgnoreCache() override;
@@ -354,6 +355,9 @@ class CefBrowserHostBase : public CefBrowserHost,
   void SetNativeWindow(cef_native_window_t window) override;
   cef_accelerated_widget_t GetAcceleratedWidget();
 
+  void SetWebDebuggingAccess(bool isEnableDebug) override;
+  bool GetWebDebuggingAccess() override;
+
  protected:
   bool EnsureDevToolsManager();
   void InitializeDevToolsRegistrationOnUIThread(
@@ -407,6 +411,7 @@ class CefBrowserHostBase : public CefBrowserHost,
   DISALLOW_COPY_AND_ASSIGN(CefBrowserHostBase);
 
   cef_accelerated_widget_t widget_;
+  bool is_web_debugging_access_ = false;
 };
 
 #endif  // CEF_LIBCEF_BROWSER_BROWSER_HOST_BASE_H_
diff --git a/src/cef/libcef/browser/devtools/devtools_manager_delegate.cc b/src/cef/libcef/browser/devtools/devtools_manager_delegate.cc
index f53323d81d..3d52d457f2 100644
--- a/src/cef/libcef/browser/devtools/devtools_manager_delegate.cc
+++ b/src/cef/libcef/browser/devtools/devtools_manager_delegate.cc
@@ -102,8 +102,15 @@ void CefDevToolsManagerDelegate::StartHttpHandler(
       CreateSocketFactory();
   if (!socket_factory)
     return;
-  content::DevToolsAgentHost::StartRemoteDebuggingServer(
+
+  LOG(INFO) << "start remote debugging server";
+  if (browser_context == nullptr) {
+    content::DevToolsAgentHost::StartRemoteDebuggingServer(
+      std::move(socket_factory), base::FilePath(), base::FilePath());
+  } else {
+    content::DevToolsAgentHost::StartRemoteDebuggingServer(
       std::move(socket_factory), browser_context->GetPath(), base::FilePath());
+  }
 
   const base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();
@@ -116,6 +123,7 @@ void CefDevToolsManagerDelegate::StartHttpHandler(
 // static
 void CefDevToolsManagerDelegate::StopHttpHandler() {
   // This is a no-op if the server was never started.
+  LOG(INFO) << "stop remote debugging server";
   content::DevToolsAgentHost::StopRemoteDebuggingServer();
 }
 
diff --git a/src/cef/libcef/browser/file_dialog_manager.cc b/src/cef/libcef/browser/file_dialog_manager.cc
old mode 100644
new mode 100755
index 4d139eb51a..bb81426a02
--- a/src/cef/libcef/browser/file_dialog_manager.cc
+++ b/src/cef/libcef/browser/file_dialog_manager.cc
@@ -204,7 +204,6 @@ void CefFileDialogManager::RunFileChooser(
     scoped_refptr<content::FileSelectListener> listener,
     const blink::mojom::FileChooserParams& params) {
   CEF_REQUIRE_UIT();
-
   CefFileDialogRunner::FileChooserParams cef_params;
   static_cast<blink::mojom::FileChooserParams&>(cef_params) = params;
 
@@ -286,7 +285,8 @@ void CefFileDialogManager::RunFileChooserInternal(
       handled = handler->OnFileDialog(
           browser_, static_cast<cef_file_dialog_mode_t>(mode), params.title,
           params.default_file_name.value(), accept_filters,
-          params.selected_accept_filter, callbackImpl.get());
+          params.selected_accept_filter, params.use_media_capture,
+          callbackImpl.get());
       if (!handled) {
         // May return nullptr if the client has already executed the callback.
         callback = callbackImpl->Disconnect();
diff --git a/src/cef/libcef/browser/net_service/cookie_helper.cc b/src/cef/libcef/browser/net_service/cookie_helper.cc
index 0f0af971f7..6b2adf40cc 100644
--- a/src/cef/libcef/browser/net_service/cookie_helper.cc
+++ b/src/cef/libcef/browser/net_service/cookie_helper.cc
@@ -192,7 +192,7 @@ void LoadCookies(content::BrowserContext* browser_context,
 
   if ((request.load_flags & net::LOAD_DO_NOT_SEND_COOKIES) ||
       request.credentials_mode == network::mojom::CredentialsMode::kOmit ||
-      request.url.IsAboutBlank() || !request.SendsCookies()) {
+      request.url.IsAboutBlank()) {
     // Continue immediately without loading cookies.
     std::move(done_callback).Run(0, {});
     return;
@@ -213,8 +213,7 @@ void SaveCookies(content::BrowserContext* browser_context,
 
   if (request.credentials_mode == network::mojom::CredentialsMode::kOmit ||
       request.url.IsAboutBlank() || !headers ||
-      !headers->HasHeader(net_service::kHTTPSetCookieHeaderName) ||
-      !request.SavesCookies()) {
+      !headers->HasHeader(net_service::kHTTPSetCookieHeaderName)) {
     // Continue immediately without saving cookies.
     std::move(done_callback).Run(0, {});
     return;
diff --git a/src/cef/libcef/browser/net_service/cookie_manager_impl.cc b/src/cef/libcef/browser/net_service/cookie_manager_impl.cc
old mode 100644
new mode 100755
index 67c7419dd7..38c4c9833a
--- a/src/cef/libcef/browser/net_service/cookie_manager_impl.cc
+++ b/src/cef/libcef/browser/net_service/cookie_manager_impl.cc
@@ -20,7 +20,7 @@ namespace {
 
 // Do not keep a reference to the object returned by this method.
 CefBrowserContext* GetBrowserContext(const CefBrowserContext::Getter& getter) {
-  CEF_REQUIRE_UIT();
+  // CEF_REQUIRE_UIT();
   DCHECK(!getter.is_null());
 
   // Will return nullptr if the BrowserContext has been destroyed.
@@ -29,10 +29,10 @@ CefBrowserContext* GetBrowserContext(const CefBrowserContext::Getter& getter) {
 
 // Do not keep a reference to the object returned by this method.
 CookieManager* GetCookieManager(CefBrowserContext* browser_context) {
-  CEF_REQUIRE_UIT();
+  // CEF_REQUIRE_UIT();
   return content::BrowserContext::GetDefaultStoragePartition(
              browser_context->AsBrowserContext())
-      ->GetCookieManagerForBrowserProcess();
+      ->GetCookieManagerForOhos();
 }
 
 // Always execute the callback asynchronously.
@@ -43,34 +43,10 @@ void RunAsyncCompletionOnUIThread(CefRefPtr<CefCompletionCallback> callback) {
                 base::Bind(&CefCompletionCallback::OnComplete, callback.get()));
 }
 
-// Always execute the callback asynchronously.
-void SetCookieCallbackImpl(CefRefPtr<CefSetCookieCallback> callback,
-                           net::CookieAccessResult access_result) {
-  if (!callback.get()) {
-    return;
-  }
-  const bool is_include = access_result.status.IsInclude();
-  if (!is_include) {
-    LOG(WARNING) << "SetCookie failed with reason: "
-                 << access_result.status.GetDebugString();
-  }
-  CEF_POST_TASK(CEF_UIT, base::Bind(&CefSetCookieCallback::OnComplete,
-                                    callback.get(), is_include));
-}
-
-// Always execute the callback asynchronously.
-void DeleteCookiesCallbackImpl(CefRefPtr<CefDeleteCookiesCallback> callback,
-                               uint32_t num_deleted) {
-  if (!callback.get())
-    return;
-  CEF_POST_TASK(CEF_UIT, base::Bind(&CefDeleteCookiesCallback::OnComplete,
-                                    callback.get(), num_deleted));
-}
-
 void ExecuteVisitor(CefRefPtr<CefCookieVisitor> visitor,
                     const CefBrowserContext::Getter& browser_context_getter,
                     const std::vector<net::CanonicalCookie>& cookies) {
-  CEF_REQUIRE_UIT();
+  // CEF_REQUIRE_UIT();
 
   auto browser_context = GetBrowserContext(browser_context_getter);
   if (!browser_context)
@@ -103,30 +79,13 @@ void ExecuteVisitor(CefRefPtr<CefCookieVisitor> visitor,
   std::string cookie_line = net::CanonicalCookie::BuildCookieLine(cookies);
   visitor->SetCookieLine(CefString(cookie_line));
 }
-
-// Always execute the callback asynchronously.
-void GetAllCookiesCallbackImpl(
-    CefRefPtr<CefCookieVisitor> visitor,
-    const CefBrowserContext::Getter& browser_context_getter,
-    const net::CookieList& cookies) {
-  CEF_POST_TASK(CEF_UIT, base::Bind(&ExecuteVisitor, visitor,
-                                    browser_context_getter, cookies));
-}
-
-void GetCookiesCallbackImpl(
-    CefRefPtr<CefCookieVisitor> visitor,
-    const CefBrowserContext::Getter& browser_context_getter,
-    const net::CookieAccessResultList& include_cookies,
-    const net::CookieAccessResultList&) {
-  net::CookieList cookies;
-  for (const auto& status : include_cookies) {
-    cookies.push_back(status.cookie);
-  }
-  GetAllCookiesCallbackImpl(visitor, browser_context_getter, cookies);
-}
 }  // namespace
 
-CefCookieManagerImpl::CefCookieManagerImpl() {}
+CefCookieManagerImpl::CefCookieManagerImpl() :
+  cookie_thread{"CookieThread"} {
+  cookie_thread.Start();
+  cookie_store_task_runner_ = cookie_thread.task_runner();
+}
 
 void CefCookieManagerImpl::Initialize(
     CefBrowserContext::Getter browser_context_getter,
@@ -215,7 +174,6 @@ bool CefCookieManagerImpl::SetCookie(const CefString& url,
   if (!gurl.is_valid()) {
     return false;
   }
-
   if (!ValidContext()) {
     StoreOrTriggerInitCallback(base::BindOnce(
         base::IgnoreResult(&CefCookieManagerImpl::SetCookieInternal), this,
@@ -292,7 +250,9 @@ bool CefCookieManagerImpl::VisitAllCookiesInternal(
     return false;
 
   GetCookieManager(browser_context)
-      ->GetAllCookies(base::Bind(&GetAllCookiesCallbackImpl, visitor,
+      ->GetAllCookies(base::Bind(&CefCookieManagerImpl::GetAllCookiesCallbackImpl,
+                                 base::Unretained(this),
+                                 visitor,
                                  browser_context_getter_));
   return true;
 }
@@ -317,7 +277,9 @@ bool CefCookieManagerImpl::VisitUrlCookiesInternal(
 
   GetCookieManager(browser_context)
       ->GetCookieList(url, options,
-                      base::Bind(&GetCookiesCallbackImpl, visitor,
+                      base::Bind(&CefCookieManagerImpl::GetCookiesCallbackImpl,
+                                 base::Unretained(this),
+                                 visitor,
                                  browser_context_getter_));
   return true;
 }
@@ -367,9 +329,12 @@ bool CefCookieManagerImpl::SetCookieInternal(
   auto browser_context = GetBrowserContext(browser_context_getter_);
   if (!browser_context)
     return false;
+
   GetCookieManager(browser_context)
       ->SetCanonicalCookie(*canonical_cookie, url, options,
-                           base::Bind(SetCookieCallbackImpl, callback));
+                           base::Bind(&CefCookieManagerImpl::SetCookieCallbackImpl,
+                                      base::Unretained(this),
+                                      callback));
   return true;
 }
 
@@ -406,7 +371,9 @@ bool CefCookieManagerImpl::DeleteCookiesInternal(
 
   GetCookieManager(browser_context)
       ->DeleteCookies(std::move(deletion_filter),
-                      base::Bind(DeleteCookiesCallbackImpl, callback));
+                      base::Bind(&CefCookieManagerImpl::DeleteCookiesCallbackImpl,
+                      base::Unretained(this),
+                      callback));
   return true;
 }
 
@@ -419,15 +386,18 @@ bool CefCookieManagerImpl::FlushStoreInternal(
     return false;
 
   GetCookieManager(browser_context)
-      ->FlushCookieStore(base::Bind(RunAsyncCompletionOnUIThread, callback));
+      ->FlushCookieStore(base::Bind(
+        &CefCookieManagerImpl::RunAsyncCompletionOnTaskRunner,
+        base::Unretained(this),
+        callback));
   return true;
 }
 
 void CefCookieManagerImpl::StoreOrTriggerInitCallback(
     base::OnceClosure callback) {
-  if (!CEF_CURRENTLY_ON_UIT()) {
-    CEF_POST_TASK(
-        CEF_UIT,
+  if (!cookie_store_task_runner_->RunsTasksInCurrentSequence()) {
+    cookie_store_task_runner_->PostTask(
+        FROM_HERE,
         base::BindOnce(&CefCookieManagerImpl::StoreOrTriggerInitCallback, this,
                        std::move(callback)));
     return;
@@ -441,7 +411,7 @@ void CefCookieManagerImpl::StoreOrTriggerInitCallback(
 }
 
 bool CefCookieManagerImpl::ValidContext() const {
-  return CEF_CURRENTLY_ON_UIT() && initialized_;
+  return cookie_store_task_runner_->RunsTasksInCurrentSequence() && initialized_;
 }
 
 // CefCookieManager methods ----------------------------------------------------
@@ -459,3 +429,65 @@ bool CefCookieManager::CreateCefCookie(const CefString& url,
   return net_service::MakeCefCookie(GURL(url.ToString()), value.ToString(),
                                     cef_cookie);
 }
+
+// Always execute the set callback on cookie_store_task_runner_.
+void CefCookieManagerImpl::SetCookieCallbackImpl(
+  CefRefPtr<CefSetCookieCallback> callback,
+  net::CookieAccessResult access_result) {
+  if (!callback.get()) {
+    return;
+  }
+  const bool is_include = access_result.status.IsInclude();
+  if (!is_include) {
+    LOG(WARNING) << "SetCookie failed with reason: "
+                 << access_result.status.GetDebugString();
+  }
+
+  cookie_store_task_runner_->PostTask(
+    FROM_HERE,
+    base::Bind(&CefSetCookieCallback::OnComplete,
+                callback.get(), is_include));
+}
+
+void CefCookieManagerImpl::RunAsyncCompletionOnTaskRunner(
+  CefRefPtr<CefCompletionCallback> callback) {
+  if (!callback.get())
+    return;
+  cookie_store_task_runner_->PostTask(
+    FROM_HERE,
+    base::Bind(&CefCompletionCallback::OnComplete,
+                callback.get()));
+}
+
+void CefCookieManagerImpl::GetAllCookiesCallbackImpl(
+    CefRefPtr<CefCookieVisitor> visitor,
+    const CefBrowserContext::Getter& browser_context_getter,
+    const net::CookieList& cookies) {
+  cookie_store_task_runner_->PostTask(
+    FROM_HERE,
+    base::Bind(&ExecuteVisitor, visitor,
+               browser_context_getter, cookies));
+}
+
+void CefCookieManagerImpl::GetCookiesCallbackImpl(
+    CefRefPtr<CefCookieVisitor> visitor,
+    const CefBrowserContext::Getter& browser_context_getter,
+    const net::CookieAccessResultList& include_cookies,
+    const net::CookieAccessResultList&) {
+  net::CookieList cookies;
+  for (const auto& status : include_cookies) {
+    cookies.push_back(status.cookie);
+  }
+  GetAllCookiesCallbackImpl(visitor, browser_context_getter, cookies);
+}
+
+void CefCookieManagerImpl::DeleteCookiesCallbackImpl(
+  CefRefPtr<CefDeleteCookiesCallback> callback,
+  uint32_t num_deleted) {
+  if (!callback.get())
+    return;
+  cookie_store_task_runner_->PostTask(
+    FROM_HERE,
+    base::Bind(&CefDeleteCookiesCallback::OnComplete,
+               callback.get(), num_deleted));
+}
\ No newline at end of file
diff --git a/src/cef/libcef/browser/net_service/cookie_manager_impl.h b/src/cef/libcef/browser/net_service/cookie_manager_impl.h
old mode 100644
new mode 100755
index 860ec7b90c..55c544dbdc
--- a/src/cef/libcef/browser/net_service/cookie_manager_impl.h
+++ b/src/cef/libcef/browser/net_service/cookie_manager_impl.h
@@ -12,6 +12,7 @@
 #include "libcef/browser/thread_util.h"
 
 #include "base/files/file_path.h"
+#include "base/threading/thread.h"
 
 // Implementation of the CefCookieManager interface. May be created on any
 // thread.
@@ -58,6 +59,18 @@ class CefCookieManagerImpl : public CefCookieManager {
                              CefRefPtr<CefDeleteCookiesCallback> callback);
   bool FlushStoreInternal(CefRefPtr<CefCompletionCallback> callback);
 
+  void SetCookieCallbackImpl(CefRefPtr<CefSetCookieCallback> callback,
+                                 net::CookieAccessResult access_result);
+  void GetCookiesCallbackImpl(CefRefPtr<CefCookieVisitor> visitor,
+                              const CefBrowserContext::Getter& browser_context_getter,
+                              const net::CookieAccessResultList& include_cookies,
+                              const net::CookieAccessResultList&);
+  void GetAllCookiesCallbackImpl(CefRefPtr<CefCookieVisitor> visitor,
+                                 const CefBrowserContext::Getter& browser_context_getter,
+                                 const net::CookieList& cookies);
+  void DeleteCookiesCallbackImpl(CefRefPtr<CefDeleteCookiesCallback> callback,
+                                 uint32_t num_deleted);
+  void RunAsyncCompletionOnTaskRunner(CefRefPtr<CefCompletionCallback> callback);
   // If the context is fully initialized execute |callback|, otherwise
   // store it until the context is fully initialized.
   void StoreOrTriggerInitCallback(base::OnceClosure callback);
@@ -71,6 +84,8 @@ class CefCookieManagerImpl : public CefCookieManager {
   std::atomic<bool> accept_cookies_ = true;
   std::atomic<bool> allow_file_scheme_cookies_ = false;
   std::vector<base::OnceClosure> init_callbacks_;
+  base::Thread cookie_thread;
+  scoped_refptr<base::SingleThreadTaskRunner> cookie_store_task_runner_;
 
   IMPLEMENT_REFCOUNTING(CefCookieManagerImpl);
   DISALLOW_COPY_AND_ASSIGN(CefCookieManagerImpl);
diff --git a/src/cef/libcef/browser/net_service/net_helpers.cc b/src/cef/libcef/browser/net_service/net_helpers.cc
index 8cb3a1afe3..056525bb27 100644
--- a/src/cef/libcef/browser/net_service/net_helpers.cc
+++ b/src/cef/libcef/browser/net_service/net_helpers.cc
@@ -30,6 +30,7 @@ int UpdateCacheLoadFlags(int load_flags, int cache_control_flags) {
 bool NetHelpers::allow_content_access = false;
 bool NetHelpers::allow_file_access = false;
 bool NetHelpers::is_network_blocked = false;
+int NetHelpers::cache_mode = 0;
 
 bool NetHelpers::ShouldBlockContentUrls() {
   return !allow_content_access;
@@ -87,7 +88,11 @@ int UpdateLoadFlags(int load_flags) {
         net::LOAD_ONLY_FROM_CACHE | net::LOAD_SKIP_CACHE_VALIDATION);
   }
 
-  return load_flags;
+  if (!NetHelpers::cache_mode) {
+    return load_flags;
+  }
+
+  return UpdateCacheLoadFlags(load_flags, NetHelpers::cache_mode);
 }
 
 }  // namespace net_service
diff --git a/src/cef/libcef/browser/net_service/net_helpers.h b/src/cef/libcef/browser/net_service/net_helpers.h
index 67ff956861..c9ca95e737 100644
--- a/src/cef/libcef/browser/net_service/net_helpers.h
+++ b/src/cef/libcef/browser/net_service/net_helpers.h
@@ -19,6 +19,7 @@ class NETHELPERS_EXPORT NetHelpers {
   static bool allow_content_access;
   static bool allow_file_access;
   static bool is_network_blocked;
+  static int cache_mode;
 };
 
 bool IsSpecialFileUrl(const GURL& url);
diff --git a/src/cef/libcef/browser/osr/browser_platform_delegate_osr.cc b/src/cef/libcef/browser/osr/browser_platform_delegate_osr.cc
index c298893749..93abbbee00 100755
--- a/src/cef/libcef/browser/osr/browser_platform_delegate_osr.cc
+++ b/src/cef/libcef/browser/osr/browser_platform_delegate_osr.cc
@@ -160,7 +160,10 @@ void CefBrowserPlatformDelegateOsr::SendTouchEvent(const CefTouchEvent& event) {
   if (!view)
     return;
   view->SendTouchEvent(event);
-  SendTouchEventToRender(event);
+
+  if (event.type == CEF_TET_PRESSED) {
+    SendTouchEventToRender(event);
+  }
 }
 
 void CefBrowserPlatformDelegateOsr::SendFocusEvent(bool setFocus) {
diff --git a/src/cef/libcef/browser/prefs/renderer_prefs.cc b/src/cef/libcef/browser/prefs/renderer_prefs.cc
old mode 100644
new mode 100755
index 7ed5929a4e..5eb7b4c927
--- a/src/cef/libcef/browser/prefs/renderer_prefs.cc
+++ b/src/cef/libcef/browser/prefs/renderer_prefs.cc
@@ -371,6 +371,7 @@ void SetCefPrefs(const CefBrowserSettings& cef,
   SET_STATE(cef.strict_mixed_content_checking,
             web.strict_mixed_content_checking);
   SET_STATE(cef.allow_mixed_content_upgrades, web.allow_mixed_content_upgrades);
+  SET_STATE(cef.initialize_at_minimum_page_scale, web.initialize_at_minimum_page_scale);
   /* ohos webview end */
 }
 
diff --git a/src/cef/libcef/renderer/browser_impl.cc b/src/cef/libcef/renderer/browser_impl.cc
index 80a4444232..b32efcfab2 100644
--- a/src/cef/libcef/renderer/browser_impl.cc
+++ b/src/cef/libcef/renderer/browser_impl.cc
@@ -83,6 +83,10 @@ bool CefBrowserImpl::CanGoBackOrForward(int num_steps) {
   return blink_glue::CanGoBackOrForward(GetWebView(), num_steps);
 }
 
+void CefBrowserImpl::DeleteHistory() {
+  CEF_REQUIRE_RT_RETURN_VOID();
+}
+
 bool CefBrowserImpl::IsLoading() {
   CEF_REQUIRE_RT_RETURN(false);
 
diff --git a/src/cef/libcef/renderer/browser_impl.h b/src/cef/libcef/renderer/browser_impl.h
index 0f6711a91d..b3d5b51b99 100644
--- a/src/cef/libcef/renderer/browser_impl.h
+++ b/src/cef/libcef/renderer/browser_impl.h
@@ -50,6 +50,7 @@ class CefBrowserImpl : public CefBrowser, public blink::WebViewObserver {
   bool CanGoForward() override;
   void GoForward() override;
   bool CanGoBackOrForward(int num_steps) override;
+  void DeleteHistory() override;
   bool IsLoading() override;
   void Reload() override;
   void ReloadIgnoreCache() override;
diff --git a/src/cef/libcef_dll/cpptoc/browser_cpptoc.cc b/src/cef/libcef_dll/cpptoc/browser_cpptoc.cc
index 3105dcd17b..915e95b93c 100644
--- a/src/cef/libcef_dll/cpptoc/browser_cpptoc.cc
+++ b/src/cef/libcef_dll/cpptoc/browser_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=37305a392b6fceed48564b7a7d5f0d2811c537f4$
+// $hash=a0db7b8177fbabe225af5a0e2db3fc5bc23ddec4$
 //
 
 #include "libcef_dll/cpptoc/browser_cpptoc.h"
@@ -117,6 +117,19 @@ int CEF_CALLBACK browser_can_go_back_or_forward(struct _cef_browser_t* self,
   return _retval;
 }
 
+void CEF_CALLBACK browser_delete_history(struct _cef_browser_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserCppToC::Get(self)->DeleteHistory();
+}
+
 int CEF_CALLBACK browser_is_loading(struct _cef_browser_t* self) {
   shutdown_checker::AssertNotShutdown();
 
@@ -439,6 +452,7 @@ CefBrowserCppToC::CefBrowserCppToC() {
   GetStruct()->can_go_forward = browser_can_go_forward;
   GetStruct()->go_forward = browser_go_forward;
   GetStruct()->can_go_back_or_forward = browser_can_go_back_or_forward;
+  GetStruct()->delete_history = browser_delete_history;
   GetStruct()->is_loading = browser_is_loading;
   GetStruct()->reload = browser_reload;
   GetStruct()->reload_ignore_cache = browser_reload_ignore_cache;
diff --git a/src/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc b/src/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
index 8a7a69f3cd..7959765ed4 100644
--- a/src/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
+++ b/src/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=895ebf37281c0926ef4cc9262fe90e940d8b7ab4$
+// $hash=ff0c3692d8878d45dd92ab0da41ccfb481762e26$
 //
 
 #include "libcef_dll/cpptoc/browser_host_cpptoc.h"
@@ -1635,6 +1635,39 @@ browser_host_set_native_window(struct _cef_browser_host_t* self,
   CefBrowserHostCppToC::Get(self)->SetNativeWindow(window);
 }
 
+void CEF_CALLBACK
+browser_host_set_web_debugging_access(struct _cef_browser_host_t* self,
+                                      int isEnableDebug) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->SetWebDebuggingAccess(isEnableDebug ? true
+                                                                       : false);
+}
+
+int CEF_CALLBACK
+browser_host_get_web_debugging_access(struct _cef_browser_host_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+
+  // Execute
+  bool _retval = CefBrowserHostCppToC::Get(self)->GetWebDebuggingAccess();
+
+  // Return type: bool
+  return _retval;
+}
+
 }  // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -1728,6 +1761,8 @@ CefBrowserHostCppToC::CefBrowserHostCppToC() {
   GetStruct()->is_audio_muted = browser_host_is_audio_muted;
   GetStruct()->execute_java_script = browser_host_execute_java_script;
   GetStruct()->set_native_window = browser_host_set_native_window;
+  GetStruct()->set_web_debugging_access = browser_host_set_web_debugging_access;
+  GetStruct()->get_web_debugging_access = browser_host_get_web_debugging_access;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/src/cef/libcef_dll/cpptoc/dialog_handler_cpptoc.cc b/src/cef/libcef_dll/cpptoc/dialog_handler_cpptoc.cc
index 6dcffbb174..e66a9617d4 100644
--- a/src/cef/libcef_dll/cpptoc/dialog_handler_cpptoc.cc
+++ b/src/cef/libcef_dll/cpptoc/dialog_handler_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=639576c610ca3898809cdee6d19c45253e9ea4d2$
+// $hash=2f925fbe5bb419b6adf14c4b508c7330ec8dd84a$
 //
 
 #include "libcef_dll/cpptoc/dialog_handler_cpptoc.h"
@@ -30,6 +30,7 @@ dialog_handler_on_file_dialog(struct _cef_dialog_handler_t* self,
                               const cef_string_t* default_file_path,
                               cef_string_list_t accept_filters,
                               int selected_accept_filter,
+                              int capture,
                               cef_file_dialog_callback_t* callback) {
   shutdown_checker::AssertNotShutdown();
 
@@ -60,7 +61,7 @@ dialog_handler_on_file_dialog(struct _cef_dialog_handler_t* self,
   bool _retval = CefDialogHandlerCppToC::Get(self)->OnFileDialog(
       CefBrowserCToCpp::Wrap(browser), mode, CefString(title),
       CefString(default_file_path), accept_filtersList, selected_accept_filter,
-      CefFileDialogCallbackCToCpp::Wrap(callback));
+      capture ? true : false, CefFileDialogCallbackCToCpp::Wrap(callback));
 
   // Return type: bool
   return _retval;
diff --git a/src/cef/libcef_dll/cpptoc/load_handler_cpptoc.cc b/src/cef/libcef_dll/cpptoc/load_handler_cpptoc.cc
index ced6a1faaf..0de3515a46 100644
--- a/src/cef/libcef_dll/cpptoc/load_handler_cpptoc.cc
+++ b/src/cef/libcef_dll/cpptoc/load_handler_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=b9eb6961bd51d881bd4b0aff6e1c2ad16de8bc93$
+// $hash=e34f727a8cb722c5ee52932d82790d4252a43dbc$
 //
 
 #include "libcef_dll/cpptoc/load_handler_cpptoc.h"
@@ -189,6 +189,38 @@ void CEF_CALLBACK load_handler_on_http_error(struct _cef_load_handler_t* self,
       has_user_gesture ? true : false, CefResponseCToCpp::Wrap(response));
 }
 
+void CEF_CALLBACK
+load_handler_on_refresh_accessed_history(struct _cef_load_handler_t* self,
+                                         cef_browser_t* browser,
+                                         cef_frame_t* frame,
+                                         const cef_string_t* url,
+                                         int isReload) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser);
+  if (!browser)
+    return;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame);
+  if (!frame)
+    return;
+  // Verify param: url; type: string_byref_const
+  DCHECK(url);
+  if (!url)
+    return;
+
+  // Execute
+  CefLoadHandlerCppToC::Get(self)->OnRefreshAccessedHistory(
+      CefBrowserCToCpp::Wrap(browser), CefFrameCToCpp::Wrap(frame),
+      CefString(url), isReload ? true : false);
+}
+
 }  // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -201,6 +233,8 @@ CefLoadHandlerCppToC::CefLoadHandlerCppToC() {
   GetStruct()->on_load_error_with_request =
       load_handler_on_load_error_with_request;
   GetStruct()->on_http_error = load_handler_on_http_error;
+  GetStruct()->on_refresh_accessed_history =
+      load_handler_on_refresh_accessed_history;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/src/cef/libcef_dll/ctocpp/browser_ctocpp.cc b/src/cef/libcef_dll/ctocpp/browser_ctocpp.cc
index ab518cb458..51faa16e1d 100644
--- a/src/cef/libcef_dll/ctocpp/browser_ctocpp.cc
+++ b/src/cef/libcef_dll/ctocpp/browser_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=669b83a0500ef99c8537d8f00fe746c28e09b31a$
+// $hash=1d64c15697f6087a6931b74f296a37907fbc8dec$
 //
 
 #include "libcef_dll/ctocpp/browser_ctocpp.h"
@@ -114,6 +114,19 @@ bool CefBrowserCToCpp::CanGoBackOrForward(int num_steps) {
   return _retval ? true : false;
 }
 
+NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::DeleteHistory() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, delete_history))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->delete_history(_struct);
+}
+
 NO_SANITIZE("cfi-icall") bool CefBrowserCToCpp::IsLoading() {
   shutdown_checker::AssertNotShutdown();
 
diff --git a/src/cef/libcef_dll/ctocpp/browser_ctocpp.h b/src/cef/libcef_dll/ctocpp/browser_ctocpp.h
index c8ac3665f4..088258f6f0 100644
--- a/src/cef/libcef_dll/ctocpp/browser_ctocpp.h
+++ b/src/cef/libcef_dll/ctocpp/browser_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=5a8d946ed143178608c22b2952d6f82e46b52976$
+// $hash=02e030f24314da7dc9c9c85b0247b9389730bfaf$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_BROWSER_CTOCPP_H_
@@ -42,6 +42,7 @@ class CefBrowserCToCpp
   bool CanGoForward() OVERRIDE;
   void GoForward() OVERRIDE;
   bool CanGoBackOrForward(int num_steps) OVERRIDE;
+  void DeleteHistory() OVERRIDE;
   bool IsLoading() OVERRIDE;
   void Reload() OVERRIDE;
   void ReloadIgnoreCache() OVERRIDE;
diff --git a/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc b/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
index 5b6ff83734..5f6f8b5d02 100644
--- a/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
+++ b/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=dcd2dbff40a3be4939f946075675080ac88e9441$
+// $hash=87bb5126d6b4b3bd34ed78af087e3afd803d2dcd$
 //
 
 #include "libcef_dll/ctocpp/browser_host_ctocpp.h"
@@ -1450,6 +1450,36 @@ void CefBrowserHostCToCpp::SetNativeWindow(cef_native_window_t window) {
   _struct->set_native_window(_struct, window);
 }
 
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::SetWebDebuggingAccess(bool isEnableDebug) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, set_web_debugging_access))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->set_web_debugging_access(_struct, isEnableDebug);
+}
+
+NO_SANITIZE("cfi-icall") bool CefBrowserHostCToCpp::GetWebDebuggingAccess() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_web_debugging_access))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  int _retval = _struct->get_web_debugging_access(_struct);
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefBrowserHostCToCpp::CefBrowserHostCToCpp() {}
diff --git a/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.h b/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
index fd85705cfb..bb2fe2c254 100644
--- a/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
+++ b/src/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=aca73f8ef9bcd54b300b1772d1115a32bf270084$
+// $hash=55f32c914962cf44aa47185731a5049c27887223$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_BROWSER_HOST_CTOCPP_H_
@@ -162,6 +162,8 @@ class CefBrowserHostCToCpp : public CefCToCppRefCounted<CefBrowserHostCToCpp,
       const CefString& code,
       CefRefPtr<CefJavaScriptResultCallback> callback) OVERRIDE;
   void SetNativeWindow(cef_native_window_t window) OVERRIDE;
+  void SetWebDebuggingAccess(bool isEnableDebug) OVERRIDE;
+  bool GetWebDebuggingAccess() OVERRIDE;
 };
 
 #endif  // CEF_LIBCEF_DLL_CTOCPP_BROWSER_HOST_CTOCPP_H_
diff --git a/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.cc b/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.cc
index 3377b564ca..2cb31ef563 100644
--- a/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.cc
+++ b/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=cac933371fc47c864230d4537ef1da76cd7e4d8e$
+// $hash=df2505130721df8255b0d5bd511fb8ef394a7d8e$
 //
 
 #include "libcef_dll/ctocpp/dialog_handler_ctocpp.h"
@@ -28,6 +28,7 @@ bool CefDialogHandlerCToCpp::OnFileDialog(
     const CefString& default_file_path,
     const std::vector<CefString>& accept_filters,
     int selected_accept_filter,
+    bool capture,
     CefRefPtr<CefFileDialogCallback> callback) {
   shutdown_checker::AssertNotShutdown();
 
@@ -61,7 +62,7 @@ bool CefDialogHandlerCToCpp::OnFileDialog(
   int _retval = _struct->on_file_dialog(
       _struct, CefBrowserCppToC::Wrap(browser), mode, title.GetStruct(),
       default_file_path.GetStruct(), accept_filtersList, selected_accept_filter,
-      CefFileDialogCallbackCppToC::Wrap(callback));
+      capture, CefFileDialogCallbackCppToC::Wrap(callback));
 
   // Restore param:accept_filters; type: string_vec_byref_const
   if (accept_filtersList)
diff --git a/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.h b/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.h
index f2e0798a16..6ebdca5539 100644
--- a/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.h
+++ b/src/cef/libcef_dll/ctocpp/dialog_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=4c07a40d3bd171adf3ae3cc4aa935bc7eca4aa5e$
+// $hash=fb268437c35b6a412dc6305ae83798d4d1db56d6$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_DIALOG_HANDLER_CTOCPP_H_
@@ -42,6 +42,7 @@ class CefDialogHandlerCToCpp
                     const CefString& default_file_path,
                     const std::vector<CefString>& accept_filters,
                     int selected_accept_filter,
+                    bool capture,
                     CefRefPtr<CefFileDialogCallback> callback) override;
 };
 
diff --git a/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.cc b/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.cc
index ea239aadf4..08557dfba6 100644
--- a/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.cc
+++ b/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=a815207886f2b474bff70f4f988a4407bcb3d42a$
+// $hash=ad518c31633727cce6a14d2b17c06370c05b4426$
 //
 
 #include "libcef_dll/ctocpp/load_handler_ctocpp.h"
@@ -187,6 +187,39 @@ void CefLoadHandlerCToCpp::OnHttpError(CefRefPtr<CefRequest> request,
                          CefResponseCppToC::Wrap(response));
 }
 
+NO_SANITIZE("cfi-icall")
+void CefLoadHandlerCToCpp::OnRefreshAccessedHistory(
+    CefRefPtr<CefBrowser> browser,
+    CefRefPtr<CefFrame> frame,
+    const CefString& url,
+    bool isReload) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_load_handler_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_refresh_accessed_history))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: browser; type: refptr_diff
+  DCHECK(browser.get());
+  if (!browser.get())
+    return;
+  // Verify param: frame; type: refptr_diff
+  DCHECK(frame.get());
+  if (!frame.get())
+    return;
+  // Verify param: url; type: string_byref_const
+  DCHECK(!url.empty());
+  if (url.empty())
+    return;
+
+  // Execute
+  _struct->on_refresh_accessed_history(_struct, CefBrowserCppToC::Wrap(browser),
+                                       CefFrameCppToC::Wrap(frame),
+                                       url.GetStruct(), isReload);
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefLoadHandlerCToCpp::CefLoadHandlerCToCpp() {}
diff --git a/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.h b/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.h
index 0ef91fc464..021bf5e2eb 100644
--- a/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.h
+++ b/src/cef/libcef_dll/ctocpp/load_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=dcaaaa3afd30e1e4be34e0d22cedacddc71e41d0$
+// $hash=f2e44ce99b154e3bbfaafd462eb29cbcce01812e$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_LOAD_HANDLER_CTOCPP_H_
@@ -58,6 +58,10 @@ class CefLoadHandlerCToCpp : public CefCToCppRefCounted<CefLoadHandlerCToCpp,
                    bool is_main_frame,
                    bool has_user_gesture,
                    CefRefPtr<CefResponse> response) override;
+  void OnRefreshAccessedHistory(CefRefPtr<CefBrowser> browser,
+                                CefRefPtr<CefFrame> frame,
+                                const CefString& url,
+                                bool isReload) override;
 };
 
 #endif  // CEF_LIBCEF_DLL_CTOCPP_LOAD_HANDLER_CTOCPP_H_
diff --git a/src/chrome/browser/safe_browsing/threat_details_unittest.cc b/src/chrome/browser/safe_browsing/threat_details_unittest.cc
index 377771239c..1895af7a73 100755
--- a/src/chrome/browser/safe_browsing/threat_details_unittest.cc
+++ b/src/chrome/browser/safe_browsing/threat_details_unittest.cc
@@ -601,7 +601,8 @@ TEST_F(ThreatDetailsTest, ThreatDOMDetails) {
   parent_node->children.push_back(GURL(kDOMChildURL));
   params.push_back(std::move(parent_node));
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     main_rfh(), std::move(params));
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(params));
 
   std::string serialized = WaitForThreatDetailsDone(
       report.get(), false /* did_proceed*/, 0 /* num_visit */);
@@ -820,10 +821,11 @@ TEST_F(ThreatDetailsTest, ThreatDOMDetails_MultipleFrames) {
 
     // Send both sets of nodes from different render frames.
     report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                       main_rfh(),
+                                       main_rfh()->GetGlobalId(),
                                        std::move(outer_params_copy));
     report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                       child_rfh, std::move(inner_params_copy));
+                                       child_rfh->GetGlobalId(),
+                                       std::move(inner_params_copy));
 
     std::string serialized = WaitForThreatDetailsDone(
         report.get(), false /* did_proceed*/, 0 /* num_visit */);
@@ -869,9 +871,11 @@ TEST_F(ThreatDetailsTest, ThreatDOMDetails_MultipleFrames) {
 
     // Send both sets of nodes from different render frames.
     report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                       child_rfh, std::move(inner_params));
+                                       child_rfh->GetGlobalId(),
+                                       std::move(inner_params));
     report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                       main_rfh(), std::move(outer_params));
+                                       main_rfh()->GetGlobalId(),
+                                       std::move(outer_params));
 
     std::string serialized = WaitForThreatDetailsDone(
         report.get(), false /* did_proceed*/, 0 /* num_visit */);
@@ -995,9 +999,11 @@ TEST_F(ThreatDetailsTest, ThreatDOMDetails_AmbiguousDOM) {
 
   // Send both sets of nodes from different render frames.
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     main_rfh(), std::move(outer_params));
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(outer_params));
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     child_rfh, std::move(inner_params));
+                                     child_rfh->GetGlobalId(),
+                                     std::move(inner_params));
   std::string serialized = WaitForThreatDetailsDone(
       report.get(), false /* did_proceed*/, 0 /* num_visit */);
   ClientSafeBrowsingReportRequest actual;
@@ -1262,10 +1268,10 @@ TEST_F(ThreatDetailsTest, ThreatDOMDetails_TrimToAdTags) {
 
   // Send both sets of nodes from different render frames.
   trimmed_report->OnReceivedThreatDOMDetails(
-      mojo::Remote<mojom::ThreatReporter>(), child_rfh,
+      mojo::Remote<mojom::ThreatReporter>(), child_rfh->GetGlobalId(),
       std::move(inner_params));
   trimmed_report->OnReceivedThreatDOMDetails(
-      mojo::Remote<mojom::ThreatReporter>(), main_rfh(),
+      mojo::Remote<mojom::ThreatReporter>(), main_rfh()->GetGlobalId(),
       std::move(outer_params));
 
   std::string serialized = WaitForThreatDetailsDone(
@@ -1338,10 +1344,10 @@ TEST_F(ThreatDetailsTest, ThreatDOMDetails_EmptyReportNotSent) {
 
   // Send both sets of nodes from different render frames.
   trimmed_report->OnReceivedThreatDOMDetails(
-      mojo::Remote<mojom::ThreatReporter>(), child_rfh,
+      mojo::Remote<mojom::ThreatReporter>(), child_rfh->GetGlobalId(),
       std::move(inner_params));
   trimmed_report->OnReceivedThreatDOMDetails(
-      mojo::Remote<mojom::ThreatReporter>(), main_rfh(),
+      mojo::Remote<mojom::ThreatReporter>(), main_rfh()->GetGlobalId(),
       std::move(outer_params));
 
   std::string serialized = WaitForThreatDetailsDone(
@@ -1599,7 +1605,8 @@ TEST_F(ThreatDetailsTest, HTTPCache) {
   // The cache collection starts after the IPC from the DOM is fired.
   std::vector<mojom::ThreatDOMDetailsNodePtr> params;
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     main_rfh(), std::move(params));
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(params));
 
   // Let the cache callbacks complete.
   base::RunLoop().RunUntilIdle();
@@ -1679,7 +1686,8 @@ TEST_F(ThreatDetailsTest, HttpsResourceSanitization) {
   // The cache collection starts after the IPC from the DOM is fired.
   std::vector<mojom::ThreatDOMDetailsNodePtr> params;
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     main_rfh(), std::move(params));
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(params));
 
   // Let the cache callbacks complete.
   base::RunLoop().RunUntilIdle();
@@ -1762,7 +1770,8 @@ TEST_F(ThreatDetailsTest, HTTPCacheNoEntries) {
   // The cache collection starts after the IPC from the DOM is fired.
   std::vector<mojom::ThreatDOMDetailsNodePtr> params;
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     main_rfh(), std::move(params));
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(params));
 
   // Let the cache callbacks complete.
   base::RunLoop().RunUntilIdle();
@@ -1821,7 +1830,8 @@ TEST_F(ThreatDetailsTest, HistoryServiceUrls) {
   // The redirects collection starts after the IPC from the DOM is fired.
   std::vector<mojom::ThreatDOMDetailsNodePtr> params;
   report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
-                                     main_rfh(), std::move(params));
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(params));
 
   // Let the redirects callbacks complete.
   base::RunLoop().RunUntilIdle();
diff --git a/src/chrome/browser/site_isolation/chrome_site_per_process_browsertest.cc b/src/chrome/browser/site_isolation/chrome_site_per_process_browsertest.cc
index d2a347bd99..2272b7cc9c 100644
--- a/src/chrome/browser/site_isolation/chrome_site_per_process_browsertest.cc
+++ b/src/chrome/browser/site_isolation/chrome_site_per_process_browsertest.cc
@@ -1541,4 +1541,50 @@ IN_PROC_BROWSER_TEST_F(ChromeSitePerProcessTest, TestInitialDSFForOOPIF) {
   // screen, then it will satisfy the following expectation.
   EXPECT_EQ(1.f, observer.get_proxy_host_dsf(0));
 }
+
+// Test that opening a window with `noopener` consumes user activation.
+// crbug.com/1264543, crbug.com/1291210
+IN_PROC_BROWSER_TEST_F(ChromeSitePerProcessTest,
+                       UserActivationConsumptionNoopener) {
+  // Start on a page a.com.
+  GURL main_url(embedded_test_server()->GetURL(
+      "a.com", "/cross_site_iframe_factory.html?a"));
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), main_url));
+  content::WebContents* web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+
+  // Activate the frame by executing a dummy script.
+  const std::string no_op_script = "// No-op script";
+  EXPECT_TRUE(ExecuteScript(web_contents, no_op_script));
+
+  // Add a popup observer.
+  content::TestNavigationObserver popup_observer(nullptr);
+  popup_observer.StartWatchingNewWebContents();
+
+  // Open a popup from the frame, with `noopener`. This should consume
+  // transient user activation.
+  GURL popup_url(embedded_test_server()->GetURL("popup.com", "/"));
+  EXPECT_TRUE(ExecuteScriptWithoutUserGesture(
+      web_contents,
+      base::StringPrintf(
+          "window.w = window.open('%s'+'title1.html', '_blank', 'noopener');",
+          popup_url.spec().c_str())));
+
+  // Try to open another popup.
+  EXPECT_TRUE(ExecuteScriptWithoutUserGesture(
+      web_contents,
+      base::StringPrintf(
+          "window.w = window.open('%s'+'title2.html', '_blank', 'noopener');",
+          popup_url.spec().c_str())));
+
+  // Wait and check that only one popup was opened.
+  popup_observer.Wait();
+  EXPECT_EQ(2, browser()->tab_strip_model()->count());
+
+  content::WebContents* popup =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  EXPECT_EQ(embedded_test_server()->GetURL("popup.com", "/title1.html"),
+            popup->GetLastCommittedURL());
+  EXPECT_NE(popup, web_contents);
+}
 #endif
diff --git a/src/chrome/browser/ui/views/omnibox/omnibox_view_views.cc b/src/chrome/browser/ui/views/omnibox/omnibox_view_views.cc
index 756cb0a9cc..406ea5c8f0 100644
--- a/src/chrome/browser/ui/views/omnibox/omnibox_view_views.cc
+++ b/src/chrome/browser/ui/views/omnibox/omnibox_view_views.cc
@@ -470,6 +470,13 @@ void OmniboxViewViews::SaveStateToTab(content::WebContents* tab) {
 }
 
 void OmniboxViewViews::OnTabChanged(content::WebContents* web_contents) {
+  // The context menu holds references to share_submenu_model_ and
+  // send_tab_to_self_sub_menu_model_; invalidate it here so we can destroy
+  // those below.
+  InvalidateContextMenu();
+
+  // These have a reference to the WebContents, which might be being destroyed
+  // here:
   const OmniboxState* state = static_cast<OmniboxState*>(
       web_contents->GetUserData(&OmniboxState::kKey));
   model()->RestoreState(state ? &state->model_state : nullptr);
diff --git a/src/components/safe_browsing/content/browser/threat_details.cc b/src/components/safe_browsing/content/browser/threat_details.cc
index 3018ac13e4..4332ec72e0 100644
--- a/src/components/safe_browsing/content/browser/threat_details.cc
+++ b/src/components/safe_browsing/content/browser/threat_details.cc
@@ -654,16 +654,20 @@ void ThreatDetails::RequestThreatDOMDetails(content::RenderFrameHost* frame) {
   pending_render_frame_hosts_.push_back(frame);
   raw_threat_report->GetThreatDOMDetails(
       base::BindOnce(&ThreatDetails::OnReceivedThreatDOMDetails, GetWeakPtr(),
-                     std::move(threat_reporter), frame));
+                     std::move(threat_reporter), frame->GetGlobalFrameRoutingId()));
 }
 
 // When the renderer is done, this is called.
 void ThreatDetails::OnReceivedThreatDOMDetails(
     mojo::Remote<mojom::ThreatReporter> threat_reporter,
-    content::RenderFrameHost* sender,
+    content::GlobalFrameRoutingId sender_id,
     std::vector<mojom::ThreatDOMDetailsNodePtr> params) {
   // If the RenderFrameHost was closed between sending the IPC and this callback
   // running, |sender| will be invalid.
+  auto* sender = content::RenderFrameHost::FromID(sender_id);
+  if (!sender) {
+    return;
+  }
   const auto sender_it = std::find(pending_render_frame_hosts_.begin(),
                                    pending_render_frame_hosts_.end(), sender);
   if (sender_it == pending_render_frame_hosts_.end()) {
diff --git a/src/components/safe_browsing/content/browser/threat_details.h b/src/components/safe_browsing/content/browser/threat_details.h
index 18fcfdfe21..58ebb1bba5 100755
--- a/src/components/safe_browsing/content/browser/threat_details.h
+++ b/src/components/safe_browsing/content/browser/threat_details.h
@@ -24,6 +24,7 @@
 #include "components/safe_browsing/core/proto/csd.pb.h"
 #include "components/security_interstitials/core/unsafe_resource.h"
 #include "content/public/browser/browser_thread.h"
+#include "content/public/browser/global_routing_id.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/remote.h"
 
@@ -170,7 +171,7 @@ class ThreatDetails : public content::WebContentsObserver {
 
   void OnReceivedThreatDOMDetails(
       mojo::Remote<mojom::ThreatReporter> threat_reporter,
-      content::RenderFrameHost* sender,
+      content::GlobalFrameRoutingId sender_id,
       std::vector<mojom::ThreatDOMDetailsNodePtr> params);
 
   void AddRedirectUrlList(const std::vector<GURL>& urls);
diff --git a/src/content/browser/BUILD.gn b/src/content/browser/BUILD.gn
old mode 100644
new mode 100755
index 157b489c3a..b6aaaae0a1
--- a/src/content/browser/BUILD.gn
+++ b/src/content/browser/BUILD.gn
@@ -2206,6 +2206,7 @@ source_set("browser") {
       "memory/swap_metrics_driver_impl_linux.h",
       "speech/tts_ohos.cc",
     ]
+
     public_deps += [ "//components/services/font/public/mojom" ]
   }
 
diff --git a/src/content/browser/child_process_launcher_helper.h b/src/content/browser/child_process_launcher_helper.h
old mode 100644
new mode 100755
index 7b78341112..6e92b30ed6
--- a/src/content/browser/child_process_launcher_helper.h
+++ b/src/content/browser/child_process_launcher_helper.h
@@ -48,7 +48,7 @@
 #endif
 
 #if defined(OS_OHOS)
-#include "appmgr/app_mgr_client.h"
+#include "ohos_adapter_helper.h"
 #endif
 
 namespace base {
@@ -211,6 +211,10 @@ class ChildProcessLauncherHelper :
   static void ForceNormalProcessTerminationSync(
       ChildProcessLauncherHelper::Process process);
 
+#if defined(OS_OHOS)
+  base::TerminationStatus GetProcessStatusByExitCode(int status);
+#endif
+
 #if defined(OS_ANDROID)
   void set_java_peer_available_on_client_thread() {
     java_peer_avaiable_on_client_thread_ = true;
@@ -258,7 +262,7 @@ class ChildProcessLauncherHelper :
 #endif
 
 #if defined(OS_OHOS)
-  std::unique_ptr<OHOS::AppExecFwk::AppMgrClient> app_mgr_client_{nullptr};
+  std::unique_ptr<OHOS::NWeb::AafwkAppMgrClientAdapter> app_mgr_client_adapter_{nullptr};
 #endif
 };
 
diff --git a/src/content/browser/child_process_launcher_helper_linux.cc b/src/content/browser/child_process_launcher_helper_linux.cc
old mode 100644
new mode 100755
index 422d3a0183..0bdff0732d
--- a/src/content/browser/child_process_launcher_helper_linux.cc
+++ b/src/content/browser/child_process_launcher_helper_linux.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
 #include "base/path_service.h"
 #include "base/posix/global_descriptors.h"
 #include "build/build_config.h"
@@ -116,10 +120,10 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
     int32_t shared_fd = options.fds_to_remap[SHARED_FD_INDEX].first;
     int32_t ipc_fd = options.fds_to_remap[IPC_FD_INDEX].first;
     pid_t render_pid = 0;
-    if (app_mgr_client_ == nullptr) {
-      app_mgr_client_ = std::make_unique<OHOS::AppExecFwk::AppMgrClient>();
+    if (app_mgr_client_adapter_ == nullptr) {
+      app_mgr_client_adapter_ = OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateAafwkAdapter();
     }
-    int ret = app_mgr_client_->StartRenderProcess(argv_ss.str(), ipc_fd, shared_fd, render_pid);
+    int ret = app_mgr_client_adapter_->StartRenderProcess(argv_ss.str(), ipc_fd, shared_fd, render_pid);
     if (ret != 0) {
       LOG(ERROR) << "start render process error, ret=" << ret << ", render pid=" << render_pid;
       process.process = base::Process();
@@ -140,6 +144,40 @@ void ChildProcessLauncherHelper::AfterLaunchOnLauncherThread(
     const base::LaunchOptions& options) {
 }
 
+#if defined(OS_OHOS)
+base::TerminationStatus ChildProcessLauncherHelper::GetProcessStatusByExitCode(int status) {
+  if (WIFSIGNALED(status)) {
+    switch (WTERMSIG(status)) {
+      case SIGABRT:
+      case SIGBUS:
+      case SIGFPE:
+      case SIGILL:
+      case SIGSEGV:
+      case SIGTRAP:
+      case SIGSYS:
+        return base::TERMINATION_STATUS_PROCESS_CRASHED;
+      case SIGKILL:
+#if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
+        // On ChromeOS, only way a process gets kill by SIGKILL
+        // is by oom-killer.
+        return TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM;
+#endif
+      case SIGINT:
+      case SIGTERM:
+        return base::TERMINATION_STATUS_PROCESS_WAS_KILLED;
+      default:
+        break;
+    }
+  }
+
+  if (WIFEXITED(status) && WEXITSTATUS(status) != 0) {
+    return base::TERMINATION_STATUS_ABNORMAL_TERMINATION;
+  }
+
+  return base::TERMINATION_STATUS_NORMAL_TERMINATION;
+}
+#endif
+
 ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(
     const ChildProcessLauncherHelper::Process& process,
     bool known_dead) {
@@ -147,12 +185,23 @@ ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(
   if (process.zygote) {
     info.status = process.zygote->GetTerminationStatus(
         process.process.Handle(), known_dead, &info.exit_code);
+#if defined(OS_OHOS)
+  } else if (app_mgr_client_adapter_) {
+    int exitStatus;
+    int ret = app_mgr_client_adapter_->GetRenderProcessTerminationStatus(process.process.Handle(), exitStatus);
+    if (ret != 0) {
+      LOG(ERROR) << "get render process termination status failed, ret = " << ret;
+    } else if (exitStatus < 0) {
+      LOG(ERROR) << "get render process termination status success, invalid status = " << exitStatus;
+    } else {
+      info.status = GetProcessStatusByExitCode(exitStatus);
+    }
+#endif
   } else if (known_dead) {
     info.status = base::GetKnownDeadTerminationStatus(process.process.Handle(),
                                                       &info.exit_code);
   } else {
-    info.status =
-        base::GetTerminationStatus(process.process.Handle(), &info.exit_code);
+    info.status = base::GetTerminationStatus(process.process.Handle(), &info.exit_code);
   }
   return info;
 }
diff --git a/src/content/browser/devtools/devtools_http_handler.cc b/src/content/browser/devtools/devtools_http_handler.cc
index ab3f19563d..774fa4f6a2 100644
--- a/src/content/browser/devtools/devtools_http_handler.cc
+++ b/src/content/browser/devtools/devtools_http_handler.cc
@@ -278,6 +278,7 @@ void StartServerOnHandlerThread(
         browser_guid.c_str());
     fprintf(stderr, "%s", message.c_str());
     fflush(stderr);
+    LOG(INFO) << "start devtools listening ok, " << message;
 
     // Write this port to a well-known file in the profile directory
     // so Telemetry, ChromeDriver, etc. can pick it up.
diff --git a/src/content/browser/devtools/protocol/input_handler.cc b/src/content/browser/devtools/protocol/input_handler.cc
index d36f64f77f..e4efb22686 100644
--- a/src/content/browser/devtools/protocol/input_handler.cc
+++ b/src/content/browser/devtools/protocol/input_handler.cc
@@ -116,16 +116,19 @@ base::TimeTicks GetEventTimeTicks(const Maybe<double>& timestamp) {
              : base::TimeTicks::Now();
 }
 
-bool SetKeyboardEventText(char16_t* to, Maybe<std::string> from) {
+bool SetKeyboardEventText(
+    char16_t (&to)[blink::WebKeyboardEvent::kTextLengthCap],
+    Maybe<std::string> from) {
   if (!from.isJust())
     return true;
 
   std::u16string text16 = base::UTF8ToUTF16(from.fromJust());
-  if (text16.size() > blink::WebKeyboardEvent::kTextLengthCap)
+  if (text16.size() >= blink::WebKeyboardEvent::kTextLengthCap)
     return false;
 
   for (size_t i = 0; i < text16.size(); ++i)
     to[i] = text16[i];
+  to[text16.size()] = 0;
   return true;
 }
 
diff --git a/src/content/browser/loader/prefetch_url_loader_service.cc b/src/content/browser/loader/prefetch_url_loader_service.cc
index 5211d5552d..345bf02154 100644
--- a/src/content/browser/loader/prefetch_url_loader_service.cc
+++ b/src/content/browser/loader/prefetch_url_loader_service.cc
@@ -202,29 +202,25 @@ void PrefetchURLLoaderService::CreateLoaderAndStart(
             ->prefetched_signed_exchange_cache;
   }
 
-  // For now we make self owned receiver for the loader to the request, while we
-  // can also possibly make the new loader owned by the factory so that they can
-  // live longer than the client (i.e. run in detached mode).
-  // TODO(kinuko): Revisit this.
-  mojo::MakeSelfOwnedReceiver(
-      std::make_unique<PrefetchURLLoader>(
-          request_id, options, current_context.frame_tree_node_id,
-          resource_request,
-          resource_request.trusted_params
-              ? resource_request.trusted_params->isolation_info
-                    .network_isolation_key()
-              : current_context.render_frame_host->GetNetworkIsolationKey(),
-          std::move(client), traffic_annotation,
-          std::move(network_loader_factory_to_use),
-          base::BindRepeating(
-              &PrefetchURLLoaderService::CreateURLLoaderThrottles, this,
-              resource_request, current_context.frame_tree_node_id),
-          browser_context_, signed_exchange_prefetch_metric_recorder_,
-          std::move(prefetched_signed_exchange_cache), accept_langs_,
-          base::BindOnce(
-              &PrefetchURLLoaderService::GenerateRecursivePrefetchToken, this,
-              current_context.weak_ptr_factory.GetWeakPtr())),
-      std::move(receiver));
+  // base::Unretained is safe here since |this| owns the loader.
+  auto loader = std::make_unique<PrefetchURLLoader>(
+      request_id, options, current_context.frame_tree_node_id, resource_request,
+      resource_request.trusted_params
+          ? resource_request.trusted_params->isolation_info
+                .network_isolation_key()
+          : current_context.render_frame_host->GetNetworkIsolationKey(),
+      std::move(client), traffic_annotation,
+      std::move(network_loader_factory_to_use),
+      base::BindRepeating(&PrefetchURLLoaderService::CreateURLLoaderThrottles,
+                          base::Unretained(this), resource_request,
+                          current_context.frame_tree_node_id),
+      browser_context_, signed_exchange_prefetch_metric_recorder_,
+      std::move(prefetched_signed_exchange_cache), accept_langs_,
+      base::BindOnce(&PrefetchURLLoaderService::GenerateRecursivePrefetchToken,
+                     base::Unretained(this),
+                     current_context.weak_ptr_factory.GetWeakPtr()));
+  auto* raw_loader = loader.get();
+  prefetch_receivers_.Add(raw_loader, std::move(receiver), std::move(loader));
 }
 
 PrefetchURLLoaderService::~PrefetchURLLoaderService() = default;
diff --git a/src/content/browser/loader/prefetch_url_loader_service.h b/src/content/browser/loader/prefetch_url_loader_service.h
index 210794966c..c5fff844f7 100644
--- a/src/content/browser/loader/prefetch_url_loader_service.h
+++ b/src/content/browser/loader/prefetch_url_loader_service.h
@@ -35,13 +35,11 @@ class URLLoaderFactoryGetter;
 // prefetches. The renderer uses it for prefetch requests including <link
 // rel="prefetch">.
 class CONTENT_EXPORT PrefetchURLLoaderService final
-    : public base::RefCountedThreadSafe<
-          PrefetchURLLoaderService,
-          content::BrowserThread::DeleteOnUIThread>,
-      public blink::mojom::RendererPreferenceWatcher,
+    : public blink::mojom::RendererPreferenceWatcher,
       public network::mojom::URLLoaderFactory {
  public:
   explicit PrefetchURLLoaderService(BrowserContext* browser_context);
+  ~PrefetchURLLoaderService() override;
 
   void GetFactory(
       mojo::PendingReceiver<network::mojom::URLLoaderFactory> receiver,
@@ -67,12 +65,8 @@ class CONTENT_EXPORT PrefetchURLLoaderService final
   }
 
  private:
-  friend class base::DeleteHelper<content::PrefetchURLLoaderService>;
-  friend struct BrowserThread::DeleteOnThread<BrowserThread::UI>;
   struct BindContext;
 
-  ~PrefetchURLLoaderService() override;
-
   // network::mojom::URLLoaderFactory:
   void CreateLoaderAndStart(
       mojo::PendingReceiver<network::mojom::URLLoader> receiver,
@@ -114,6 +108,9 @@ class CONTENT_EXPORT PrefetchURLLoaderService final
   mojo::ReceiverSet<network::mojom::URLLoaderFactory,
                     std::unique_ptr<BindContext>>
       loader_factory_receivers_;
+  mojo::ReceiverSet<network::mojom::URLLoader,
+                    std::unique_ptr<network::mojom::URLLoader>>
+      prefetch_receivers_;
   // Used in the IO thread.
   mojo::Receiver<blink::mojom::RendererPreferenceWatcher>
       preference_watcher_receiver_{this};
diff --git a/src/content/browser/portal/portal.cc b/src/content/browser/portal/portal.cc
old mode 100644
new mode 100755
index 2565b98545..aef23d7854
--- a/src/content/browser/portal/portal.cc
+++ b/src/content/browser/portal/portal.cc
@@ -606,6 +606,11 @@ void Portal::ActivateImpl(blink::TransferableMessage data,
   devtools_instrumentation::PortalActivated(outer_contents->GetMainFrame());
   successor_contents_raw->set_portal(nullptr);
 
+  // It's important we call this before destroying the outer contents'
+  // RenderWidgetHostView, otherwise the dialog may not be cleaned up correctly.
+  // See crbug.com/1292261 for more details.
+  outer_contents->CancelActiveAndPendingDialogs();
+
   std::unique_ptr<WebContents> predecessor_web_contents =
       delegate->ActivatePortalWebContents(outer_contents,
                                           std::move(successor_contents));
diff --git a/src/content/browser/renderer_host/render_frame_host_impl.cc b/src/content/browser/renderer_host/render_frame_host_impl.cc
index 7bca1e9446..9da018174d 100644
--- a/src/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/src/content/browser/renderer_host/render_frame_host_impl.cc
@@ -5355,17 +5355,22 @@ void RenderFrameHostImpl::CreateNewWindow(
     can_create_window = false;
   }
 
-  bool was_consumed = false;
-  if (can_create_window) {
-    // Consume activation even w/o User Activation v2, to sync other renderers
-    // with calling renderer.
-    was_consumed = frame_tree_node_->UpdateUserActivationState(
-        blink::mojom::UserActivationUpdateType::kConsumeTransientActivation,
-        blink::mojom::UserActivationNotificationType::kNone);
-  } else {
-    std::move(callback).Run(mojom::CreateNewWindowStatus::kIgnore, nullptr);
-    return;
-  }
+  // If this frame isn't allowed to create a window, return early (before we
+  // consume transient user activation).
+  if (!can_create_window) {
+    std::move(callback).Run(mojom::CreateNewWindowStatus::kBlocked, nullptr);
+    return;
+  }
+
+  // Otherwise, consume user activation before we proceed. In particular, it is
+  // important to do this before we return from the |opener_suppressed| case
+  // below.
+  // NB: This call will consume activations in the browser and the remote frame
+  // proxies for this frame. The initiating renderer will consume its view of
+  // the activations after we return.
+  bool was_consumed = frame_tree_node_->UpdateUserActivationState(
+      blink::mojom::UserActivationUpdateType::kConsumeTransientActivation,
+      blink::mojom::UserActivationNotificationType::kNone);
 
   // For Android WebView, we support a pop-up like behavior for window.open()
   // even if the embedding app doesn't support multiple windows. In this case,
diff --git a/src/content/browser/service_worker/service_worker_container_host.cc b/src/content/browser/service_worker/service_worker_container_host.cc
index 0b1981efd9..ceaec3e6d3 100644
--- a/src/content/browser/service_worker/service_worker_container_host.cc
+++ b/src/content/browser/service_worker/service_worker_container_host.cc
@@ -349,10 +349,12 @@ void ServiceWorkerContainerHost::EnsureFileAccess(
     ChildProcessSecurityPolicyImpl* policy =
         ChildProcessSecurityPolicyImpl::GetInstance();
     for (const auto& file : file_paths) {
-      if (!policy->CanReadFile(process_id_, file))
+      if (!policy->CanReadFile(process_id_, file)) {
         mojo::ReportBadMessage(
             "The renderer doesn't have access to the file "
             "but it tried to grant access to the controller.");
+	   return;
+      }
 
       if (!policy->CanReadFile(controller_process_id, file))
         policy->GrantReadFile(controller_process_id, file);
diff --git a/src/content/browser/storage_partition_impl.cc b/src/content/browser/storage_partition_impl.cc
index 7a517fe224..1aaa64d502 100755
--- a/src/content/browser/storage_partition_impl.cc
+++ b/src/content/browser/storage_partition_impl.cc
@@ -12,6 +12,9 @@
 #include <utility>
 #include <vector>
 
+#include <unistd.h>
+#include <thread>
+
 #include "base/barrier_closure.h"
 #include "base/bind.h"
 #include "base/callback_helpers.h"
@@ -1267,7 +1270,7 @@ void StoragePartitionImpl::Initialize(
       blob_context, filesystem_context_, fallback_blob_registry);
 
   prefetch_url_loader_service_ =
-      base::MakeRefCounted<PrefetchURLLoaderService>(browser_context_);
+      std::make_unique<PrefetchURLLoaderService>(browser_context_);
 
   cookie_store_context_ = base::MakeRefCounted<CookieStoreContext>();
   // Unit tests use the Initialize() callback to crash early if restoring the
@@ -1382,6 +1385,32 @@ StoragePartitionImpl::GetCookieManagerForBrowserProcess() {
   return cookie_manager_for_browser_process_.get();
 }
 
+#if defined(OS_OHOS)
+network::mojom::CookieManager*
+StoragePartitionImpl::GetCookieManagerForOhos() {
+  DCHECK(initialized_);
+  // Create the CookieManager remote for ohos as needed.
+  if (!cookie_manager_for_ohos_ ||
+      !cookie_manager_for_ohos_.is_connected()) {
+    // Reset |cookie_manager_for_ohos_| before binding it again.
+
+    cookie_manager_for_ohos_.reset();
+    GetIOThreadTaskRunner({})->PostTask(
+        FROM_HERE,
+        base::BindOnce(&StoragePartitionImpl::GetCookieManagerForOhosInternal,
+                       base::Unretained(this)));
+    completion_.Wait();
+  }
+  return cookie_manager_for_ohos_.get();
+}
+
+void StoragePartitionImpl::GetCookieManagerForOhosInternal() {
+  GetNetworkContext()->GetCookieManager(
+        cookie_manager_for_ohos_.BindNewPipeAndPassReceiver());
+  completion_.Signal();
+}
+#endif
+
 void StoragePartitionImpl::CreateRestrictedCookieManager(
     network::mojom::RestrictedCookieManagerRole role,
     const url::Origin& origin,
diff --git a/src/content/browser/storage_partition_impl.h b/src/content/browser/storage_partition_impl.h
index 39ad00ebb1..96305d9811 100644
--- a/src/content/browser/storage_partition_impl.h
+++ b/src/content/browser/storage_partition_impl.h
@@ -11,6 +11,11 @@
 #include <memory>
 #include <string>
 
+#if defined(OS_OHOS)
+#include "base/synchronization/lock.h"
+#include "base/synchronization/waitable_event.h"
+#endif
+
 #include "base/compiler_specific.h"
 #include "base/containers/flat_map.h"
 #include "base/containers/flat_set.h"
@@ -140,6 +145,7 @@ class CONTENT_EXPORT StoragePartitionImpl
   std::unique_ptr<network::PendingSharedURLLoaderFactory>
   GetURLLoaderFactoryForBrowserProcessIOThread() override;
   network::mojom::CookieManager* GetCookieManagerForBrowserProcess() override;
+  network::mojom::CookieManager* GetCookieManagerForOhos() override;
   void CreateHasTrustTokensAnswerer(
       mojo::PendingReceiver<network::mojom::HasTrustTokensAnswerer> receiver,
       const url::Origin& top_frame_origin) override;
@@ -502,6 +508,10 @@ class CONTENT_EXPORT StoragePartitionImpl
   // OnLocalTrustTokenFulfillerConnectionError.
   void ProvisionallyBindUnboundLocalTrustTokenFulfillerIfSupportedBySystem();
 
+#if defined(OS_OHOS)
+  void GetCookieManagerForOhosInternal();
+#endif
+
   // Raw pointer that should always be valid. The BrowserContext owns the
   // StoragePartitionImplMap which then owns StoragePartitionImpl. When the
   // BrowserContext is destroyed, |this| will be destroyed too.
@@ -547,7 +557,7 @@ class CONTENT_EXPORT StoragePartitionImpl
   std::unique_ptr<BroadcastChannelProvider> broadcast_channel_provider_;
   std::unique_ptr<BluetoothAllowedDevicesMap> bluetooth_allowed_devices_map_;
   scoped_refptr<BlobRegistryWrapper> blob_registry_;
-  scoped_refptr<PrefetchURLLoaderService> prefetch_url_loader_service_;
+  std::unique_ptr<PrefetchURLLoaderService> prefetch_url_loader_service_;
   scoped_refptr<CookieStoreContext> cookie_store_context_;
   scoped_refptr<BucketContext> bucket_context_;
   scoped_refptr<GeneratedCodeCacheContext> generated_code_cache_context_;
@@ -603,6 +613,12 @@ class CONTENT_EXPORT StoragePartitionImpl
   bool is_test_url_loader_factory_for_browser_process_with_corb_ = false;
   mojo::Remote<network::mojom::CookieManager>
       cookie_manager_for_browser_process_;
+#if defined(OS_OHOS)
+  mojo::Remote<network::mojom::CookieManager>
+      cookie_manager_for_ohos_;
+  base::WaitableEvent completion_{base::WaitableEvent::ResetPolicy::AUTOMATIC,
+                                  base::WaitableEvent::InitialState::NOT_SIGNALED};
+#endif
   mojo::Remote<network::mojom::OriginPolicyManager>
       origin_policy_manager_for_browser_process_;
 
diff --git a/src/content/common/cursors/webcursor.cc b/src/content/common/cursors/webcursor.cc
index a9d5a6f64f..e5a4e709ea 100644
--- a/src/content/common/cursors/webcursor.cc
+++ b/src/content/common/cursors/webcursor.cc
@@ -32,16 +32,19 @@ WebCursor& WebCursor::operator=(const WebCursor& other) {
 }
 
 bool WebCursor::SetCursor(const ui::Cursor& cursor) {
-  static constexpr int kMaxSize = 1024;
+  // This value is just large enough to accommodate:
+  // - kMaximumCursorSize in Blink's EventHandler
+  // - kCursorSize in Chrome's DevToolsEyeDropper
+  static constexpr int kMaximumCursorSize = 150;
   if (cursor.image_scale_factor() < 0.01f ||
       cursor.image_scale_factor() > 100.f ||
       (cursor.type() == ui::mojom::CursorType::kCustom &&
-       (cursor.custom_bitmap().width() > kMaxSize ||
-        cursor.custom_bitmap().height() > kMaxSize ||
+       (cursor.custom_bitmap().width() > kMaximumCursorSize ||
+        cursor.custom_bitmap().height() > kMaximumCursorSize ||
         cursor.custom_bitmap().width() / cursor.image_scale_factor() >
-            kMaxSize ||
+            kMaximumCursorSize ||
         cursor.custom_bitmap().height() / cursor.image_scale_factor() >
-            kMaxSize))) {
+            kMaximumCursorSize))) {
     return false;
   }
 
diff --git a/src/content/common/cursors/webcursor_mac.mm b/src/content/common/cursors/webcursor_mac.mm
index 2d269dff5f..3359c8033e 100644
--- a/src/content/common/cursors/webcursor_mac.mm
+++ b/src/content/common/cursors/webcursor_mac.mm
@@ -261,6 +261,7 @@ gfx::NativeCursor WebCursor::GetNativeCursor() {
     case ui::mojom::CursorType::kCustom:
       return CreateCustomCursor(cursor_);
     case ui::mojom::CursorType::kNull:
+      return [NSCursor arrowCursor];
     case ui::mojom::CursorType::kDndNone:
     case ui::mojom::CursorType::kDndMove:
     case ui::mojom::CursorType::kDndCopy:
diff --git a/src/content/common/cursors/webcursor_unittest.cc b/src/content/common/cursors/webcursor_unittest.cc
index b3e0eb250e..42bfc2445e 100644
--- a/src/content/common/cursors/webcursor_unittest.cc
+++ b/src/content/common/cursors/webcursor_unittest.cc
@@ -137,11 +137,11 @@ TEST(WebCursorTest, SetCursor) {
 
   // SetCursor should return false when the image width is too large.
   cursor.set_image_scale_factor(1.f);
-  cursor.set_custom_bitmap(CreateTestBitmap(1025, 3));
+  cursor.set_custom_bitmap(CreateTestBitmap(151, 3));
   EXPECT_FALSE(webcursor.SetCursor(cursor));
 
   // SetCursor should return false when the image height is too large.
-  cursor.set_custom_bitmap(CreateTestBitmap(3, 1025));
+  cursor.set_custom_bitmap(CreateTestBitmap(3, 151));
   EXPECT_FALSE(webcursor.SetCursor(cursor));
 
   // SetCursor should return false when the scaled image width is too large.
@@ -151,7 +151,7 @@ TEST(WebCursorTest, SetCursor) {
 
   // SetCursor should return false when the scaled image height is too large.
   cursor.set_image_scale_factor(0.1f);
-  cursor.set_custom_bitmap(CreateTestBitmap(5, 200));
+  cursor.set_custom_bitmap(CreateTestBitmap(5, 20));
   EXPECT_FALSE(webcursor.SetCursor(cursor));
 }
 
diff --git a/src/content/common/frame.mojom b/src/content/common/frame.mojom
index fb71337543..06e3d53cbf 100644
--- a/src/content/common/frame.mojom
+++ b/src/content/common/frame.mojom
@@ -532,8 +532,10 @@ struct CreateNewWindowParams {
 
 // Operation result when the renderer asks the browser to create a new window.
 enum CreateNewWindowStatus {
-  // Ignore creation of the new window. This can happen because creation is
-  // blocked or because the new window should have no opener relationship.
+  // Creation of the new window was blocked, e.g. because the source frame
+  // doesn't have user activation.
+  kBlocked,
+  // Ignore creation of the new window, e.g. because noopener is in effect.
   kIgnore,
   // Reuse the current window rather than creating a new window.
   kReuse,
diff --git a/src/content/public/browser/storage_partition.h b/src/content/public/browser/storage_partition.h
index 2c21c9721c..e3eb244941 100644
--- a/src/content/public/browser/storage_partition.h
+++ b/src/content/public/browser/storage_partition.h
@@ -113,7 +113,10 @@ class CONTENT_EXPORT StoragePartition {
   GetURLLoaderFactoryForBrowserProcessIOThread() = 0;
   virtual network::mojom::CookieManager*
   GetCookieManagerForBrowserProcess() = 0;
-
+#if defined(OS_OHOS)
+  virtual network::mojom::CookieManager*
+  GetCookieManagerForOhos() = 0;
+#endif
   virtual void CreateHasTrustTokensAnswerer(
       mojo::PendingReceiver<network::mojom::HasTrustTokensAnswerer> receiver,
       const url::Origin& top_frame_origin) = 0;
diff --git a/src/content/renderer/BUILD.gn b/src/content/renderer/BUILD.gn
old mode 100644
new mode 100755
index 9325b96383..810393cab2
--- a/src/content/renderer/BUILD.gn
+++ b/src/content/renderer/BUILD.gn
@@ -23,16 +23,7 @@ if (is_ohos) {
   import("//build/config/ohos/config.gni")
   config("ohos_system_libs") {
     libs = [
-      "hilog",
-      "utils.z",
-      "eventhandler.z",
-      "app_manager.z",
-      "base.z",
-      "want.z",
-      "appexecfwk_common.z",
-      "appexecfwk_base.z",
-      "samgr_proxy.z",
-      "ipc_core.z",
+      "nweb_ohos_adapter.z"
     ]
     include_dirs = ohos_src_includes
     lib_dirs = ohos_libs_dir
diff --git a/src/content/renderer/media/ohos/ohos_media_player_renderer_client.cc b/src/content/renderer/media/ohos/ohos_media_player_renderer_client.cc
index ae4c206382..60b5889189 100644
--- a/src/content/renderer/media/ohos/ohos_media_player_renderer_client.cc
+++ b/src/content/renderer/media/ohos/ohos_media_player_renderer_client.cc
@@ -136,8 +136,9 @@ void OHOSMediaPlayerRendererClient::OnFrameUpdate(
                << " coded_width:" << coded_width
                << " coded_height:" << coded_height
                << " visible_width:" << visible_width
-               << " visible_height:" << visible_height
-               << " format:" << src_format << " size:" << buffer_size;
+               << " visible_height:" << visible_height << " fd:" << fd
+               << " mapped:" << (void*)mapped << " format:" << src_format
+               << " size:" << buffer_size;
   }
   gfx::Size coded_size = gfx::Size(coded_width, coded_height);
   gfx::Rect visible_rect = gfx::Rect(0, 0, visible_width, visible_height);
diff --git a/src/content/renderer/render_remote_proxy.cc b/src/content/renderer/render_remote_proxy.cc
old mode 100644
new mode 100755
index 2fada4e83b..1d0a8b3697
--- a/src/content/renderer/render_remote_proxy.cc
+++ b/src/content/renderer/render_remote_proxy.cc
@@ -5,16 +5,15 @@
 #include "render_remote_proxy.h"
 
 #include <thread>
-#include "appmgr/app_mgr_client.h"
 #include "base/command_line.h"
 #include "base/posix/global_descriptors.h"
 #include "content/public/common/content_descriptors.h"
 #include "content/public/common/content_switches.h"
-#include "refbase.h"
+#include "ohos_adapter_helper.h"
 
 namespace content {
-std::unique_ptr<OHOS::AppExecFwk::AppMgrClient> g_app_mgr_client{nullptr};
-OHOS::sptr<RenderRemoteProxy> g_render_remote_proxy{nullptr};
+std::unique_ptr<OHOS::NWeb::AafwkAppMgrClientAdapter> g_app_mgr_client_adapter{nullptr};
+std::shared_ptr<RenderRemoteProxy> g_render_remote_proxy{nullptr};
 
 std::mutex RenderRemoteProxy::browser_fd_mtx_;
 std::condition_variable RenderRemoteProxy::browser_fd_cv_;
@@ -53,9 +52,9 @@ void RenderRemoteProxy::NotifyBrowserFd(int32_t ipcFd, int32_t sharedFd) {
 void RenderRemoteProxy::CreateAndRegist(const base::CommandLine& command_line) {
   is_for_test_ = command_line.HasSwitch(switches::kForTest);
   if (!is_for_test_) {
-    g_app_mgr_client = std::make_unique<OHOS::AppExecFwk::AppMgrClient>();
-    g_render_remote_proxy = new RenderRemoteProxy();
-    g_app_mgr_client->AttachRenderProcess(g_render_remote_proxy);
+    g_app_mgr_client_adapter = OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateAafwkAdapter();
+    g_render_remote_proxy = std::make_shared<RenderRemoteProxy>();
+    g_app_mgr_client_adapter->AttachRenderProcess(g_render_remote_proxy);
   }
 }
 
@@ -65,14 +64,22 @@ bool RenderRemoteProxy::WaitForBrowserFd() {
   }
   LOG(INFO) << "wait for browser fd start";
   std::unique_lock<std::mutex> lk(browser_fd_mtx_);
-  constexpr int kTimeOutDur = 5;  // seconds
-  if (!browser_fd_cv_.wait_for(lk, std::chrono::seconds(kTimeOutDur),
-                               []() { return is_browser_fd_received_; })) {
-    LOG(ERROR) << "wait for browser fd timeout(" << kTimeOutDur << "s)";
-    return false;
+  constexpr uint32_t kTimeOutDur = 10;  // milliseconds
+  constexpr uint32_t kMaxWaitCount = 10;
+  uint32_t wait_count = 0;
+  while (++wait_count <= kMaxWaitCount) {
+    if (!browser_fd_cv_.wait_for(lk, std::chrono::milliseconds(kTimeOutDur),
+                                 []() { return is_browser_fd_received_; })) {
+      LOG(INFO) << "retry AttachRenderProcess for " << wait_count << "time";
+      g_app_mgr_client_adapter->AttachRenderProcess(g_render_remote_proxy);
+    } else {
+      LOG(INFO) << "success, wait for browser fd end";
+      return true;
+    }
   }
-  LOG(INFO) << "wait for browser fd end";
-  return true;
+  LOG(ERROR) << "wait for browser fd timeout(" << (kTimeOutDur * kMaxWaitCount)
+             << "ms)";
+  return false;
 }
 
 } // namespace content
\ No newline at end of file
diff --git a/src/content/renderer/render_remote_proxy.h b/src/content/renderer/render_remote_proxy.h
old mode 100644
new mode 100755
index 1127280fbf..c6e3b98b25
--- a/src/content/renderer/render_remote_proxy.h
+++ b/src/content/renderer/render_remote_proxy.h
@@ -7,14 +7,14 @@
 
 #include <condition_variable>
 #include <mutex>
-#include "appmgr/render_scheduler_host.h"
+#include "aafwk_render_scheduler_host_adapter.h"
 
 namespace base {
 class CommandLine;
 }
 
 namespace content {
-class RenderRemoteProxy : public OHOS::AppExecFwk::RenderSchedulerHost {
+class RenderRemoteProxy : public OHOS::NWeb::AafwkRenderSchedulerHostAdapter {
  public:
   RenderRemoteProxy() = default;
   ~RenderRemoteProxy() = default;
diff --git a/src/content/renderer/render_view_impl.cc b/src/content/renderer/render_view_impl.cc
index 8c8b5f4efe..7939d7a142 100644
--- a/src/content/renderer/render_view_impl.cc
+++ b/src/content/renderer/render_view_impl.cc
@@ -337,8 +337,27 @@ WebView* RenderViewImpl::CreateView(
   mojom::CreateNewWindowStatus status;
   mojom::CreateNewWindowReplyPtr reply;
   auto* frame_host = creator_frame->GetFrameHost();
-  bool err = !frame_host->CreateNewWindow(std::move(params), &status, &reply);
-  if (err || status == mojom::CreateNewWindowStatus::kIgnore)
+  if (!frame_host->CreateNewWindow(std::move(params), &status, &reply)) {
+    // The sync IPC failed, e.g. maybe the render process is in the middle of
+    // shutting down. Can't create a new window without the browser process,
+    // so just bail out.
+    return nullptr;
+  }
+
+  // If creation of the window was blocked (e.g. because this frame doesn't
+  // have user activation), return before consuming user activation. A frame
+  // that isn't allowed to open a window  shouldn't be able to consume the
+  // activation for the rest of the frame tree.
+  if (status == mojom::CreateNewWindowStatus::kBlocked)
+    return nullptr;
+
+  // Consume the transient user activation in the current renderer.
+  consumed_user_gesture = creator->ConsumeTransientUserActivation(
+      blink::UserActivationUpdateSource::kBrowser);
+
+  // If we should ignore the new window (e.g. because of `noopener`), return
+  // now that user activation was consumed.
+  if (status == mojom::CreateNewWindowStatus::kIgnore)
     return nullptr;
 
   // For Android WebView, we support a pop-up like behavior for window.open()
@@ -358,11 +377,6 @@ WebView* RenderViewImpl::CreateView(
   DCHECK_NE(MSG_ROUTING_NONE, reply->main_frame_route_id);
   DCHECK_NE(MSG_ROUTING_NONE, reply->widget_params->routing_id);
 
-  // The browser allowed creation of a new window and consumed the user
-  // activation.
-  consumed_user_gesture = creator->ConsumeTransientUserActivation(
-      blink::UserActivationUpdateSource::kBrowser);
-
   // While this view may be a background extension page, it can spawn a visible
   // render view. So we just assume that the new one is not another background
   // page instead of passing on our own value.
diff --git a/src/media/base/ohos/BUILD.gn b/src/media/base/ohos/BUILD.gn
index 96b060fe0a..0d19eac123 100644
--- a/src/media/base/ohos/BUILD.gn
+++ b/src/media/base/ohos/BUILD.gn
@@ -19,6 +19,11 @@ if (is_ohos) {
       "ohos_media_player_listener.h",
     ]
     configs += [ "//media:subcomponent_config" ]
+
+    if (product_name == "rk3568") {
+      defines = [ "RK3568" ]
+    }
+
     deps = [
       "//media/base",
       "//url",
diff --git a/src/media/base/ohos/ohos_media_player_bridge.cc b/src/media/base/ohos/ohos_media_player_bridge.cc
index 5c1a893b31..fc4c0a086a 100644
--- a/src/media/base/ohos/ohos_media_player_bridge.cc
+++ b/src/media/base/ohos/ohos_media_player_bridge.cc
@@ -44,7 +44,11 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
   if (url_.SchemeIsFile()) {
     ret = SetFdSource(url_.GetContent());
   } else {
-    ret = player_->SetSource(url_.spec());
+    if (url_.spec().rfind("https", 0) == std::string::npos) {
+      ret = player_->SetSource(url_.spec());
+    } else {
+      ret = -1;
+    }
   }
   if (ret != 0) {
     LOG(ERROR) << "SetSource error::ret=" << ret;
@@ -139,10 +143,17 @@ void OHOSMediaPlayerBridge::FinishPaint(int fd) {
     return;
   }
 
+#if defined(RK3568)
+  if (cached_buffers_.front()->GetBufferHandle()->fd != fd) {
+    LOG(ERROR) << "match fd error render fd=" << fd << "  browser fd="
+               << cached_buffers_.front()->GetBufferHandle()->fd;
+  }
+#else
   if (cached_buffers_.front()->GetBufferHandle()->reserve[0] != fd) {
     LOG(ERROR) << "match fd error render fd=" << fd << "  browser fd="
                << cached_buffers_.front()->GetBufferHandle()->reserve[0];
   }
+#endif
   OHOS::SurfaceError ret =
       consumer_surface_->ReleaseBuffer(cached_buffers_.front(), -1);
   if (ret != OHOS::SURFACE_ERROR_OK) {
@@ -188,6 +199,25 @@ void OHOSMediaPlayerBridge::OnBufferAvailable(
     return;
   }
 
+#if defined(RK3568)
+  int fd = buffer->GetBufferHandle()->fd;
+#else
+  int fd = buffer->GetBufferHandle()->reserve[0];
+#endif
+  if (fd <= 0) {
+    LOG(ERROR) << "surface buffer fd error fd:" << fd;
+    OHOS::SurfaceError ret = consumer_surface_->ReleaseBuffer(buffer, -1);
+    if (ret != OHOS::SURFACE_ERROR_OK) {
+      LOG(ERROR) << "release buffer fail, ret=" << ret;
+    }
+    return;
+  }
+
+#if defined(RK3568)
+  client_->OnFrameAvailable(fd, buffer->GetSize(), buffer->GetWidth(),
+                            buffer->GetHeight(), buffer->GetWidth(),
+                            buffer->GetHeight(), buffer->GetFormat());
+#else
   int32_t coded_height;
   int32_t coded_width;
 
@@ -205,10 +235,10 @@ void OHOSMediaPlayerBridge::OnBufferAvailable(
   } else {
     coded_width = buffer->GetStride();
   }
-  client_->OnFrameAvailable(buffer->GetBufferHandle()->reserve[0],
-                            buffer->GetSize(), coded_width, coded_height,
+  client_->OnFrameAvailable(fd, buffer->GetSize(), coded_width, coded_height,
                             buffer->GetWidth(), buffer->GetHeight(),
                             buffer->GetFormat());
+#endif
   cached_buffers_.push_back(buffer);
 }
 
diff --git a/src/media/media_options.gni b/src/media/media_options.gni
index 40c6e09c5a..8081db082b 100644
--- a/src/media/media_options.gni
+++ b/src/media/media_options.gni
@@ -52,7 +52,7 @@ declare_args() {
   # Enable usage of FFmpeg within the media library. Used for most software
   # based decoding, demuxing, and sometimes optimized FFTs. If disabled,
   # implementors must provide their own demuxers and decoders.
-  media_use_ffmpeg = true
+  media_use_ffmpeg = false
 
   # Enable usage of libvpx within the media library. Used for software based
   # decoding of VP9 and VP8A type content.
diff --git a/src/ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64/libcutils.so b/src/ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64/libcutils.so
new file mode 100644
index 0000000000..45ec7af8fa
Binary files /dev/null and b/src/ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64/libcutils.so differ
diff --git a/src/ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64/liblog.so b/src/ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64/liblog.so
new file mode 100644
index 0000000000..bda087127b
Binary files /dev/null and b/src/ohos_ndk_aosp/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm64/liblog.so differ
diff --git a/src/ohos_ndk_aosp/toolchains/clang-r353983c/bin/clang-9 b/src/ohos_ndk_aosp/toolchains/clang-r353983c/bin/clang-9
index 220a0cc764..f33e058e95 100755
Binary files a/src/ohos_ndk_aosp/toolchains/clang-r353983c/bin/clang-9 and b/src/ohos_ndk_aosp/toolchains/clang-r353983c/bin/clang-9 differ
diff --git a/src/ohos_nweb/BUILD.gn b/src/ohos_nweb/BUILD.gn
index e53fb88534..1fd2aea892 100644
--- a/src/ohos_nweb/BUILD.gn
+++ b/src/ohos_nweb/BUILD.gn
@@ -1,6 +1,15 @@
-# Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
+# Copyright (c) 2022 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 
 import("//build/buildflag_header.gni")
 import("//build/config/features.gni")
@@ -55,6 +64,7 @@ component("cef_nweb") {
   sources = [
     "src/cef_delegate/nweb_application.h",
     "src/cef_delegate/nweb_application.cc",
+    "src/cef_delegate/nweb_input_delegate.cc",
     "src/cef_delegate/nweb_handler_delegate.h",
     "src/cef_delegate/nweb_handler_delegate.cc",
     "src/cef_delegate/nweb_delegate.cc",
@@ -63,6 +73,8 @@ component("cef_nweb") {
     "src/cef_delegate/nweb_render_handler.cc",
     "src/cef_delegate/nweb_event_handler.h",
     "src/cef_delegate/nweb_event_handler.cc",
+    "src/cef_delegate/nweb_file_selector_params_impl.h",
+    "src/cef_delegate/nweb_file_selector_params_impl.cc",
     "src/cef_delegate/nweb_js_dialog_result_impl.cc",
     "src/cef_delegate/nweb_js_dialog_result_impl.h",
     "src/cef_delegate/nweb_geolocation_callback.h",
@@ -94,6 +106,10 @@ config("nweb_config") {
     "USE_CEF",
   ]
 
+  if (product_name == "rk3568") {
+    defines += [ "GPU_RK3568" ]
+  }
+
   include_dirs = [
     "include",
     "src",
@@ -210,4 +226,4 @@ shared_library("libnweb_render") {
     "//cef:libweb_engine",
     "//cef:libcef_dll_wrapper",
   ]
-}
\ No newline at end of file
+}
diff --git a/src/ohos_nweb/include/nweb.h b/src/ohos_nweb/include/nweb.h
index fbf54eaac3..8c93edb7ba 100755
--- a/src/ohos_nweb/include/nweb.h
+++ b/src/ohos_nweb/include/nweb.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_H
 #define NWEB_H
@@ -37,11 +48,11 @@ struct OHOS_NWEB_EXPORT NWebCreateInfo {
     std::function<bool(const char*, uint32_t, uint32_t)> output_render_frame =
     nullptr;
 
-    /* rs producer surface, for acquiring elgsurface from ohos */
-    void *producer_surface = nullptr;
-
     /* init args */
     NWebInitArgs init_args;
+
+    /* rs producer surface, for acquiring elgsurface from ohos */
+    void *producer_surface = nullptr;
 };
 
 class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
@@ -62,6 +73,7 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
     virtual void OnTouchMove(int32_t id, double x, double y) = 0;
     virtual void OnTouchCancel() = 0;
     virtual void OnNavigateBack() = 0;
+    virtual bool SendKeyEvent(int32_t keyCode, int32_t keyAction) = 0;
 
     /**
      * Loads the given URL.
@@ -103,6 +115,10 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      *
      */
     virtual void NavigateForward() const = 0;
+    /**
+     * Delete back and forward history list.
+     */
+    virtual void DeleteNavigateHistory() = 0;
     /**
      * Reloads the current URL.
      *
diff --git a/src/ohos_nweb/include/nweb_access_request.h b/src/ohos_nweb/include/nweb_access_request.h
index 6592ba26ee..6a08dd8c44 100644
--- a/src/ohos_nweb/include/nweb_access_request.h
+++ b/src/ohos_nweb/include/nweb_access_request.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_ACCESS_REQUEST_H
 #define NWEB_ACCESS_REQUEST_H
diff --git a/src/ohos_nweb/include/nweb_console_log.h b/src/ohos_nweb/include/nweb_console_log.h
index b0a8d6bbd9..207d6dddaf 100644
--- a/src/ohos_nweb/include/nweb_console_log.h
+++ b/src/ohos_nweb/include/nweb_console_log.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_CONSOLE_LOG_H
 #define NWEB_CONSOLE_LOG_H
diff --git a/src/ohos_nweb/include/nweb_cookie_manager.h b/src/ohos_nweb/include/nweb_cookie_manager.h
index 4e2c33aaf9..fc5c58ddc9 100644
--- a/src/ohos_nweb/include/nweb_cookie_manager.h
+++ b/src/ohos_nweb/include/nweb_cookie_manager.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_COOKIE_MANAGER_H
 #define NWEB_COOKIE_MANAGER_H
@@ -18,13 +29,6 @@ public:
 
     virtual ~NWebCookieManager() = default;
 
-    /**
-     * @brief Gets the singleton NWebCookieManager instance.
-     *
-     * @return the singleton NWebCookieManager instance.
-     */
-    static NWebCookieManager* GetInstance();
-
     /**
      * @brief Get whether the instance can send and accept cookies.
      *
@@ -59,7 +63,14 @@ public:
     virtual void ReturnCookie(const std::string &url,
                               std::shared_ptr<NWebValueCallback<std::string>> callback) = 0;
     /**
-     * @brief GSets a single cookie (key-value pair) for the given URL.
+     * @brief Gets all the cookies for the given URL. This is sync method
+     *
+     * @param url the URL for which the cookies are requested.
+     * @return the cookie value for given URL.
+     */
+    virtual std::string ReturnCookie(const std::string &url) = 0;
+    /**
+     * @brief Sets a single cookie (key-value pair) for the given URL.
      *
      * @param url the URL for which the cookie is to be set.
      * @param value the cookie as a string, using the format of the 'Set-Cookie' HTTP response header.
@@ -68,6 +79,15 @@ public:
     virtual void SetCookie(const std::string &url,
                            const std::string &value,
                            std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
+    /**
+     * @brief Sets a single cookie (key-value pair) for the given URL sync.
+     *
+     * @param url the URL for which the cookie is to be set.
+     * @param value the cookie as a string, using the format of the 'Set-Cookie' HTTP response header.
+     * @return true if set cookie success else return false.
+     */
+    virtual bool SetCookie(const std::string &url,
+                           const std::string &value) = 0;
     /**
      * @brief Gets whether there are stored cookies.
      *
@@ -81,6 +101,13 @@ public:
      * @param callback a callback to be executed when cookies has Stored.
      */
     virtual void Store(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
+    /**
+     * @brief Ensures all cookies currently accessible through the ReturnCookie API are written to
+     * persistent storage.
+     *
+     * @param true if store cookie success else return false.
+     */
+    virtual bool Store() = 0;
     /**
      * @brief Removes all session cookies, which are cookies without an expiration date.
      *
diff --git a/src/ohos_nweb/include/nweb_download_callback.h b/src/ohos_nweb/include/nweb_download_callback.h
index 5ce16d93b4..b7e06a4fa6 100644
--- a/src/ohos_nweb/include/nweb_download_callback.h
+++ b/src/ohos_nweb/include/nweb_download_callback.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_DOWNLOAD_CALLBACK_H
 #define NWEB_DOWNLOAD_CALLBACK_H
diff --git a/src/ohos_nweb/include/nweb_export.h b/src/ohos_nweb/include/nweb_export.h
index e4ebd385d7..fbc05e714b 100644
--- a/src/ohos_nweb/include/nweb_export.h
+++ b/src/ohos_nweb/include/nweb_export.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OHOS_NWEB_EXPORT_H
 #define OHOS_NWEB_EXPORT_H
diff --git a/src/ohos_nweb/include/nweb_file_selector_params.h b/src/ohos_nweb/include/nweb_file_selector_params.h
new file mode 100644
index 0000000000..1b5d42397b
--- /dev/null
+++ b/src/ohos_nweb/include/nweb_file_selector_params.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_FILE_SELECTOR_PARAMS_H
+#define NWEB_FILE_SELECTOR_PARAMS_H
+
+#include <string>
+#include <vector>
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+using AcceptTypeList = std::vector<std::string>;
+class OHOS_NWEB_EXPORT NWebFileSelectorParams {
+public:
+    enum FileSelectorMode{
+        FILE_OPEN_MODE = 0,
+        FILE_OPEN_MULTIPLE_MODE,
+        FILE_OPEN_FOLDER_MODE,
+        FILE_SAVE_MODE
+    };
+
+    NWebFileSelectorParams() = default;
+
+    virtual ~NWebFileSelectorParams() = default;
+
+    virtual const std::string Title() const = 0;
+
+    virtual FileSelectorMode Mode() const = 0;
+
+    virtual const std::string DefaultFilename() const = 0;
+
+    virtual const AcceptTypeList AcceptType() const = 0;
+
+    virtual bool IsCapture() const = 0;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/src/ohos_nweb/include/nweb_geolocation_callback_interface.h b/src/ohos_nweb/include/nweb_geolocation_callback_interface.h
index 5fe586d606..c7645d7497 100644
--- a/src/ohos_nweb/include/nweb_geolocation_callback_interface.h
+++ b/src/ohos_nweb/include/nweb_geolocation_callback_interface.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_GEOLOCATION_CALLBACK_INTERFACE_H
 #define NWEB_GEOLOCATION_CALLBACK_INTERFACE_H
diff --git a/src/ohos_nweb/include/nweb_handler.h b/src/ohos_nweb/include/nweb_handler.h
old mode 100644
new mode 100755
index c6dab95ccb..89e8bc49d7
--- a/src/ohos_nweb/include/nweb_handler.h
+++ b/src/ohos_nweb/include/nweb_handler.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_HANDLER_H
 #define NWEB_HANDLER_H
@@ -13,6 +24,7 @@
 #include "nweb_access_request.h"
 #include "nweb.h"
 #include "nweb_console_log.h"
+#include "nweb_file_selector_params.h"
 #include "nweb_geolocation_callback_interface.h"
 #include "nweb_js_dialog_result.h"
 #include "nweb_url_resource_error.h"
@@ -51,6 +63,25 @@ enum class ImageAlphaType {
     ALPHA_TYPE_POSTMULTIPLIED = 2,
 };
 
+enum class RenderExitReason {
+    // Render process non-zero exit status
+    PROCESS_ABNORMAL_TERMINATION,
+
+    // SIGKILL or task manager kill
+    PROCESS_WAS_KILLED,
+
+    // Segmentation fault
+    PROCESS_CRASHED,
+
+    // Out of memory
+    PROCESS_OOM,
+
+    // Unknown reason
+    PROCESS_EXIT_UNKNOWN,
+};
+
+using FileSelectorCallback = NWebValueCallback<std::vector<std::string>&>;
+
 class OHOS_NWEB_EXPORT NWebHandler {
 public:
     NWebHandler() = default;
@@ -302,6 +333,32 @@ public:
      * permission.
      */
     virtual void OnPermissionRequestCanceled(std::shared_ptr<NWebAccessRequest> request) {}
+
+    /**
+     * @brief called when the render process exit.
+     *
+     * @param reason  the detail reason why render process exit, the implementation of this callback
+     * should attempt to clean up the specific nweb that was set by SetNWeb interface.
+     */
+    virtual void OnRenderExited(RenderExitReason reason) {}
+
+    /**
+     * @brief inform application to update its visited links database.
+     *
+     * @param url the url being visited.
+     * @param isReload true if the url is being reload.
+     */
+    virtual void OnRefreshAccessedHistory(const std::string& url, bool isReload) {}
+
+    /**
+     * @brief inform application to show a file selector.
+     * @param callback the file list to select.
+     * @param params the params of file selector.
+     */
+    virtual bool OnFileSelectorShow(std::shared_ptr<FileSelectorCallback> callback,
+                                    std::shared_ptr<NWebFileSelectorParams> params) {
+        return false;
+    }
 };
 }  // namespace OHOS::NWeb
 
diff --git a/src/ohos_nweb/include/nweb_hit_testresult.h b/src/ohos_nweb/include/nweb_hit_testresult.h
index 510e471280..9115f488cd 100755
--- a/src/ohos_nweb/include/nweb_hit_testresult.h
+++ b/src/ohos_nweb/include/nweb_hit_testresult.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef WEB_HIT_TESTRESULT_H
 #define WEB_HIT_TESTRESULT_H
diff --git a/src/ohos_nweb/include/nweb_javascript_result_callback.h b/src/ohos_nweb/include/nweb_javascript_result_callback.h
index 2faeb6495d..96ec05f2b1 100644
--- a/src/ohos_nweb/include/nweb_javascript_result_callback.h
+++ b/src/ohos_nweb/include/nweb_javascript_result_callback.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_JAVASCRIPT_RESULT_CALLBACK_H
 #define NWEB_JAVASCRIPT_RESULT_CALLBACK_H
diff --git a/src/ohos_nweb/include/nweb_preference.h b/src/ohos_nweb/include/nweb_preference.h
old mode 100644
new mode 100755
index f2b805bbda..a9032eb490
--- a/src/ohos_nweb/include/nweb_preference.h
+++ b/src/ohos_nweb/include/nweb_preference.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_PREFERENCE_H
 #define NWEB_PREFERENCE_H
@@ -13,26 +24,26 @@ class OHOS_NWEB_EXPORT NWebPreference {
 public:
     NWebPreference() = default;
     virtual ~NWebPreference() = default;
-    enum AccessMode { ALWAYS_ALLOW = 0, NEVER_ALLOW = 1, COMPATIBILITY_MODE = 2 };
+    enum class AccessMode { ALWAYS_ALLOW = 0, NEVER_ALLOW = 1, COMPATIBILITY_MODE = 2 };
     /* synchronous set NWebPreference and web preferences */
     /**
      * Enables or disables content URL(content from a content provider installed
      * in the system) access within WebView. The default is true.
      */
     virtual void PutEnableContentAccess(bool flag) = 0;
-  
+
     /**
      * Enables or disables file system access within WebView. But files in the
      * path of AppData are still accessible. The default is false.
      */
     virtual void PutEnableRawFileAccess(bool flag) = 0;
-  
+
     /**
      * Put whether to allow JavaScript running in a file scheme URL to access
      * content from other file scheme URLs. The default is false.
      */
     virtual void PutEnableRawFileAccessFromFileURLs(bool flag) = 0;
-  
+
     /**
      * Put whether to allow JavaScript running in a file scheme URL to access
      * content from any origin. This includes access to content from other file
@@ -40,21 +51,21 @@ public:
      * false.
      */
     virtual void PutEnableUniversalAccessFromFileURLs(bool flag) = 0;
-  
+
     /**
      * Put whether to block the WebView from loading image resources from the
      * network (http and https URI schemes). This settings is invalid, if {@link
      * #IsImageLoadingAllowed} returns false. The default is false.
      */
     virtual void PutLoadImageFromNetworkDisabled(bool flag) = 0;
-  
+
     /**
      * Put the cursive font family name. The default is "cursive".
      *
      * @param font a font family name
      */
     virtual void PutCursiveFontFamilyName(std::string font) = 0;
-  
+
     /**
      * Enables or disables the database storage API. The default is false.
      * This setting is global and effectd all WebView instances in a
@@ -62,7 +73,7 @@ public:
      * changes won't be ignored.
      */
     virtual void PutDatabaseAllowed(bool flag) = 0;
-  
+
     /**
      * Put the size of default fixed font. The default is 13.
      *
@@ -70,7 +81,7 @@ public:
      *             the specified range will be pinned.
      */
     virtual void PutDefaultFixedFontSize(int size) = 0;
-  
+
     /**
      * Put the size of default font. The default is 16.
      *
@@ -78,7 +89,7 @@ public:
      *             the specified range will be pinned.
      */
     virtual void PutDefaultFontSize(int size) = 0;
-  
+
     /**
      * Put the default text encoding format that uses to decode html pages.
      * The default is "UTF-8".
@@ -86,49 +97,49 @@ public:
      * @param the text encoding format
      */
     virtual void PutDefaultTextEncodingFormat(std::string encoding) = 0;
-  
+
     /**
      * Enables or disables the DOM storage API. The default value is false.
      */
     virtual void PutDomStorageEnabled(bool flag) = 0;
-  
+
     /**
      * Put the fantasy font family name. The default is "fantasy".
      *
      * @param font a font family name
      */
     virtual void PutFantasyFontFamilyName(std::string font) = 0;
-  
+
     /**
      * Put the fixed font family name. The default is "monospace".
      *
      * @param font a font family name
      */
     virtual void PutFixedFontFamilyName(std::string font) = 0;
-  
+
     /**
      * Enables or disables the force dark mode for this WebView.
      *
      * @param forceDark true if set the force dark mode for this WebView.
      */
     virtual void PutDarkModeEnabled(int forceDark) = 0;
-  
+
     /**
      * Put whether JavaScript can open windows by JavaScript. This applies to the
      * JavaScript function {@code window.open()}. The default is false.
      */
     virtual void PutIsCreateWindowsByJavaScriptAllowed(bool flag) = 0;
-  
+
     /**
      * Put whether the WebView can execute JavaScript. The default is false.
      */
     virtual void PutJavaScriptEnabled(bool flag) = 0;
-  
+
     /**
      * Put whether the WebView can load image. The default is true.
      */
     virtual void PutImageLoadingAllowed(bool flag) = 0;
-  
+
     /**
      * Put the lower limit of the minimum font size. The default is 8.
      *
@@ -136,7 +147,7 @@ public:
      *             the specified range will be pinned.
      */
     virtual void PutFontSizeLowerLimit(int size) = 0;
-  
+
     /**
      * Put the lower limit of the minimum logical font size. The default is 8.
      *
@@ -144,28 +155,35 @@ public:
      *             the specified range will be pinned.
      */
     virtual void PutLogicalFontSizeLowerLimit(int size) = 0;
-  
+
+    /**
+     * Sets whether the WebView loads pages in overview mode, that is, zooms out the
+     * content to fit on screen by width.
+     *
+     */
+    virtual void PutLoadWithOverviewMode(bool flag) = 0;
+
     /**
      * Put the sans-serif font family name. The default is "sans-serif".
      *
      * @param font a font family name
      */
     virtual void PutSansSerifFontFamilyName(std::string font) = 0;
-  
+
     /**
      * Put the serif font family name. The default is "serif".
      *
      * @param font a font family name
      */
     virtual void PutSerifFontFamilyName(std::string font) = 0;
-  
+
     /**
      * Put the standard font family name. The default is "sans-serif".
      *
      * @param font a font family name
      */
     virtual void PutStandardFontFamilyName(std::string font) = 0;
-  
+
     /**
      * Put the user-agent string to the nweb. If it is null or empty,
      * webview will use the system default value. Changing the user-agent
@@ -174,14 +192,14 @@ public:
      * @param ua user-agent string. The value may be null.
      */
     virtual void PutUserAgent(std::string ua) = 0;
-  
+
     /**
      * Put the zoom percentage of the page text. The default is 100.
      *
      * @param textZoom the zoom percentage of the page text
      */
     virtual void PutZoomingForTextFactor(int textZoom) = 0;
-  
+
     /**
      * Put whether the WebView can get geolocation. The default is true.
      * To get geolocation, an application must have permission to access
@@ -191,7 +209,7 @@ public:
      * the location request via the JavaScript Geolocation API.
      */
     virtual void PutGeolocationAllowed(bool flag) = 0;
-  
+
     /**
      * Put the WebView's behavior when a secure origin attempts to load a
      * resource from an insecure origin. The default is NEVER_ALLOW.
@@ -200,12 +218,12 @@ public:
      */
     virtual void PutAccessModeForSecureOriginLoadFromInsecure(
         AccessMode mode) = 0;
-  
+
     /**
      * Put whether the WebView supports zooming. The default is true.
      */
     virtual void PutZoomingFunctionEnabled(bool flag) = 0;
-  
+
     /**
      * Put whether the WebView block loading resources from the network. The
      * default value is false if the hap has the
@@ -215,6 +233,22 @@ public:
      */
     virtual void PutBlockNetwork(bool flag) = 0;
 
+    enum CacheModeFlag {
+        USE_DEFAULT = 0,
+        USE_CACHE_ELSE_NETWORK,
+        USE_NO_CACHE,
+        USE_CACHE_ONLY
+    };
+    /**
+     * PutCacheMode
+     */
+    virtual void PutCacheMode(CacheModeFlag flag) = 0;
+
+    /**
+     * Put whether the NWeb can be debugging, default value is false.
+     */
+    virtual void PutWebDebuggingAccess(bool flag) = 0;
+
     /* get methods */
     /**
      * Get if content URL(content from a content provider installed
@@ -223,7 +257,7 @@ public:
      * @see PutEnableContentAccess
      */
     virtual bool EnableContentAccess() = 0;
-  
+
     /**
      * Get if file system access within WebView is supported. Notified files in the
      * path of AppData are always accessible.
@@ -231,7 +265,7 @@ public:
      * @see PutEnableRawFileAccess
      */
     virtual bool EnableRawFileAccess() = 0;
-  
+
     /**
      * Get if JavaScript running in a file scheme URL to access
      * content from other file scheme URLs is supported.
@@ -239,7 +273,7 @@ public:
      * @see PutEnableRawFileAccessFromFileURLs
      */
     virtual bool EnableRawFileAccessFromFileURLs() = 0;
-  
+
     /**
      * Get if JavaScript running in a file scheme URL to access
      * content from any origin is supported. This includes access to content from other file
@@ -248,7 +282,7 @@ public:
      * @see PutEnableUniversalAccessFromFileURLs
      */
     virtual bool EnableUniversalAccessFromFileURLs() = 0;
-  
+
     /**
      * Get if the WebView from loading image resources from the
      * network (http and https URI schemes) is supported.
@@ -256,177 +290,198 @@ public:
      * @see PutLoadImageFromNetworkDisabled
      */
     virtual bool IsLoadImageFromNetworkDisabled() = 0;
-  
+
     /**
      * Get the cursive font family name.
      *
      * @see PutCursiveFontFamilyName
      */
     virtual std::string CursiveFontFamilyName() = 0;
-  
+
     /**
      * Get if the database storage API is supported.
      *
      * @see PutDatabaseAllowed
      */
     virtual bool IsDataBaseEnabled() = 0;
-  
+
     /**
      * Get the size of default fixed font.
      *
      * @see PutDefaultFixedFontSize
      */
     virtual int DefaultFixedFontSize() = 0;
-  
+
     /**
      * Get the size of default font.
      *
      * @see PutDefaultFontSize
      */
     virtual int DefaultFontSize() = 0;
-  
+
     /**
      * Get the default text encoding format that uses to decode html pages.
      *
      * @see PutDefaultTextEncodingFormat
      */
     virtual std::string DefaultTextEncodingFormat() = 0;
-  
+
     /**
-     * Get the default user-agent string to the nweb. 
+     * Get the default user-agent string to the nweb.
      * An instance of WebView could use a different User-Agent that
      * NWebPreference#PutUserAgent(String) set to.
      *
      * @see PutUserAgent
      */
     virtual std::string DefaultUserAgent() = 0;
-  
+
     /**
-     * Get if the DOM storage API is supported. 
+     * Get if the DOM storage API is supported.
      *
      * @see PutDomStorageEnabled
      */
     virtual bool IsDomStorageEnabled() = 0;
-  
+
     /**
-     * Get the fantasy font family name. 
+     * Get the fantasy font family name.
      *
      * @see PutFantasyFontFamilyName
      */
     virtual std::string FantasyFontFamilyName() = 0;
-  
+
     /**
-     * Get the fixed font family name. 
+     * Get the fixed font family name.
      *
      * @see PutFixedFontFamilyName
      */
     virtual std::string FixedFontFamilyName() = 0;
-  
+
     /**
-     * Get if the dark mode for this WebView is supported. 
+     * Get if the dark mode for this WebView is supported.
      *
      * @see PutDarkModeEnabled
      */
     virtual int DarkModeEnabled() = 0;
-  
+
     /**
-     * Get if JavaScript can open windows. 
+     * Get if JavaScript can open windows.
      *
      * @see PutIsCreateWindowsByJavaScriptAllowed
      */
     virtual bool IsCreateWindowsByJavaScriptAllowed() = 0;
-  
+
     /**
-     * Get if the WebView can execute JavaScript. 
+     * Get if the WebView can execute JavaScript.
      *
      * @see PutJavaScriptEnabled
      */
     virtual bool IsJavaScriptAllowed() = 0;
-  
+
     /**
-     * Get if the WebView can load image. 
+     * Get if the WebView can load image.
      *
      * @see PutImageLoadingAllowed
      */
     virtual bool IsImageLoadingAllowed() = 0;
-  
+
     /**
-     * Get the lower limit of the minimum font size. 
+     * Get the lower limit of the minimum font size.
      *
      * @see PutFontSizeLowerLimit
      */
     virtual int FontSizeLowerLimit() = 0;
-  
+
     /**
-     * Get the lower limit of the minimum logical font size. 
+     * Get the lower limit of the minimum logical font size.
      *
      * @see PutLogicalFontSizeLowerLimit
      */
     virtual int LogicalFontSizeLowerLimit() = 0;
-  
+
+    /**
+     * Get the swith for the overview mode.
+     *
+     * @see PutLoadWithOverviewMode
+     */
+    virtual bool IsLoadWithOverviewMode() = 0;
+
     /**
-     * Get the sans-serif font family name. 
+     * Get the sans-serif font family name.
      *
      * @see PutSansSerifFontFamilyName
      */
     virtual std::string SansSerifFontFamilyName() = 0;
-  
+
     /**
-     * Get the serif font family name. 
+     * Get the serif font family name.
      *
      * @see PutSerifFontFamilyName
      */
     virtual std::string SerifFontFamilyName() = 0;
-  
+
     /**
-     * Get the standard font family name. 
+     * Get the standard font family name.
      *
      * @see PutStandardFontFamilyName
      */
     virtual std::string StandardFontFamilyName() = 0;
-  
+
     /**
-     * Get the user-agent string to the nweb. 
+     * Get the user-agent string to the nweb.
      *
      * @see PutUserAgent
      */
     virtual std::string UserAgent() = 0;
-  
+
     /**
-     * Get the zoom percentage of the page text. 
+     * Get the zoom percentage of the page text.
      *
      * @see PutZoomingForTextFactor
      */
     virtual int ZoomingForTextFactor() = 0;
-  
+
     /**
-     * Get if the WebView can get geolocation. 
+     * Get if the WebView can get geolocation.
      *
      * @see PutGeolocationAllowed
      */
     virtual bool GeolocationAllowed() = 0;
-  
+
     /**
      * Get the WebView's behavior when a secure origin attempts to load a
      * resource from an insecure origin.
      *
      * @see PutAccessModeForSecureOriginLoadFromInsecure
      */
-    virtual int AccessModeForSecureOriginLoadFromInsecure() = 0;
-  
+    virtual AccessMode AccessModeForSecureOriginLoadFromInsecure() = 0;
+
     /**
      * Get if the WebView supports zooming.
      *
      * @see PutZoomingFunctionEnabled
      */
     virtual bool ZoomingfunctionEnabled() = 0;
-  
+
     /**
      * Get if the WebView block loading resources from the network.
      *
      * @see PutBlockNetwork
      */
     virtual bool IsNetworkBlocked() = 0;
+
+    /**
+     * Get cache mode
+     *
+     * @see PutCacheMode
+     */
+    virtual CacheModeFlag CacheMode() = 0;
+
+    /**
+     * Get if the NWeb can be debugging.
+     *
+     * @see PutWebDebuggingAccess
+     */
+    virtual bool IsWebDebuggingAccess() = 0;
 };
 }  // namespace OHOS::NWeb
 #endif  // NWEB_PREFERENCE_H
diff --git a/src/ohos_nweb/include/nweb_url_resource_error.h b/src/ohos_nweb/include/nweb_url_resource_error.h
index dafc312994..3a4f1871d6 100644
--- a/src/ohos_nweb/include/nweb_url_resource_error.h
+++ b/src/ohos_nweb/include/nweb_url_resource_error.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_URL_RESOURCE_ERROR_H
 #define NWEB_URL_RESOURCE_ERROR_H
diff --git a/src/ohos_nweb/include/nweb_url_resource_request.h b/src/ohos_nweb/include/nweb_url_resource_request.h
index b7166e8ccc..cf2e339cc1 100644
--- a/src/ohos_nweb/include/nweb_url_resource_request.h
+++ b/src/ohos_nweb/include/nweb_url_resource_request.h
@@ -1,6 +1,18 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef NWEB_URL_RESOURCE_REQUEST_H
 #define NWEB_URL_RESOURCE_REQUEST_H
 #include <map>
diff --git a/src/ohos_nweb/include/nweb_url_resource_response.h b/src/ohos_nweb/include/nweb_url_resource_response.h
index b8d827df2e..f5755c54e8 100644
--- a/src/ohos_nweb/include/nweb_url_resource_response.h
+++ b/src/ohos_nweb/include/nweb_url_resource_response.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_URL_RESOURCE_RESPONSE_H
 #define NWEB_URL_RESOURCE_RESPONSE_H
diff --git a/src/ohos_nweb/include/nweb_value.h b/src/ohos_nweb/include/nweb_value.h
index e08d162fe9..9120456d91 100644
--- a/src/ohos_nweb/include/nweb_value.h
+++ b/src/ohos_nweb/include/nweb_value.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_VALUE_H_
 #define NWEB_VALUE_H_
@@ -29,7 +40,7 @@ public:
         LIST
     };
 
-    NWebValue(Type type) : type_(type) {}
+    explicit NWebValue(Type type) : type_(type) {}
 
     ~NWebValue() = default;
 
diff --git a/src/ohos_nweb/include/nweb_value_callback.h b/src/ohos_nweb/include/nweb_value_callback.h
index 4f521b4232..1a1a0e5537 100644
--- a/src/ohos_nweb/include/nweb_value_callback.h
+++ b/src/ohos_nweb/include/nweb_value_callback.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef VALUE_CALLBACK_H
 #define VALUE_CALLBACK_H
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc b/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc
index 304addd1ad..d9e40643e3 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "ohos_nweb/src/cef_delegate/nweb_access_request_delegate.h"
 #include "base/logging.h"
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.h b/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.h
index 24cc0ff87c..e182672d7d 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_ACCESS_REQUEST_DELEGATE_H
 #define NWEB_ACCESS_REQUEST_DELEGATE_H
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_application.cc b/src/ohos_nweb/src/cef_delegate/nweb_application.cc
index 2c41dfd128..9840456777 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_application.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_application.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_application.h"
 
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_application.h b/src/ohos_nweb/src/cef_delegate/nweb_application.h
index 84a5c50f4c..7437770d20 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_application.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_application.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_APPLICATION_H
 #define NWEB_APPLICATION_H
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc b/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
old mode 100644
new mode 100755
index 0b0bb59284..3870cdb3a7
--- a/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_cookie_manager_delegate.h"
 #include <memory>
@@ -101,8 +112,10 @@ class ReturnCookieVisitor : public CefCookieVisitor {
  public:
   ReturnCookieVisitor() = delete;
   explicit ReturnCookieVisitor(
+      std::shared_ptr<WaitableEvent> event,
       std::shared_ptr<NWebValueCallback<std::string>> callback)
-      : cookie_line_(std::string()),
+      : event_(event),
+        cookie_line_(std::string()),
         cookies_(std::vector<CefCookie>()),
         callback_(callback) {}
   ~ReturnCookieVisitor() = default;
@@ -115,6 +128,9 @@ class ReturnCookieVisitor : public CefCookieVisitor {
       if (callback_ != nullptr) {
         callback_->OnReceiveValue(cookie_line_);
       }
+      if (event_ != nullptr) {
+        event_->Signal();
+      }
       return true;
     }
     deleteCookie = !cookie.has_expires ? delete_session_ : false;
@@ -128,6 +144,9 @@ class ReturnCookieVisitor : public CefCookieVisitor {
     if (callback_ != nullptr) {
       callback_->OnReceiveValue(cookie_line_);
     }
+    if (event_ != nullptr) {
+      event_->Signal();
+    }
   }
 
   std::vector<CefCookie>& GetVisitorCookies() { return cookies_; }
@@ -136,6 +155,7 @@ class ReturnCookieVisitor : public CefCookieVisitor {
 
  private:
   bool delete_session_;
+  std::shared_ptr<WaitableEvent> event_;
   std::string cookie_line_;
   std::vector<CefCookie> cookies_;
   std::shared_ptr<NWebValueCallback<std::string>> callback_;
@@ -181,8 +201,6 @@ class CookieDeleteCallback : public CefDeleteCookiesCallback {
 }  // namespace
 
 namespace OHOS::NWeb {
-NWebCookieManagerDelegate::NWebCookieManagerDelegate() {}
-
 CefRefPtr<CefCookieManager>
 NWebCookieManagerDelegate::GetGlobalCookieManager() {
   if (!cookie_manager_) {
@@ -232,13 +250,33 @@ void NWebCookieManagerDelegate::ReturnCookie(
     LOG(ERROR) << "GetGlobalCookieManager failed";
     return;
   }
-  CefRefPtr<ReturnCookieVisitor> visitor = new ReturnCookieVisitor(callback);
+  CefRefPtr<ReturnCookieVisitor> visitor = new ReturnCookieVisitor(nullptr, callback);
   if (!cookie_manager->VisitUrlCookies(CefString(url), false, visitor)) {
     LOG(ERROR) << "VisitUrlCookies failed";
     return;
   }
 }
 
+std::string NWebCookieManagerDelegate::ReturnCookie(
+  const std::string& url) {
+  CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
+  if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
+    return "";
+  }
+  std::shared_ptr<base::WaitableEvent> event =
+    std::make_shared<base::WaitableEvent>(
+      base::WaitableEvent::ResetPolicy::AUTOMATIC,
+      base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<ReturnCookieVisitor> visitor = new ReturnCookieVisitor(event, nullptr);
+  if (!cookie_manager->VisitUrlCookies(CefString(url), false, visitor)) {
+    LOG(ERROR) << "VisitUrlCookies failed";
+    return "";
+  }
+  event->Wait();
+  return visitor->ReturnCookieLine();
+}
+
 void NWebCookieManagerDelegate::SetCookie(
     const std::string& url,
     const std::string& value,
@@ -254,6 +292,7 @@ void NWebCookieManagerDelegate::SetCookie(
     LOG(ERROR) << "CreateCefCookie failed";
     return;
   }
+
   if (!cookie_manager->SetCookie(CefString(url), cef_cookie,
                                  new CookieSetCallback(nullptr, callback))) {
     LOG(ERROR) << "SetCookie error";
@@ -261,6 +300,33 @@ void NWebCookieManagerDelegate::SetCookie(
   }
 }
 
+bool NWebCookieManagerDelegate::SetCookie(
+    const std::string& url,
+    const std::string& value) {
+  CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
+  if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
+    return false;
+  }
+  CefCookie cef_cookie;
+  if (!CefCookieManager::CreateCefCookie(CefString(url), CefString(value),
+                                         cef_cookie)) {
+    LOG(ERROR) << "CreateCefCookie failed";
+    return false;
+  }
+  std::shared_ptr<base::WaitableEvent> completion =
+    std::make_shared<base::WaitableEvent>(
+      base::WaitableEvent::ResetPolicy::AUTOMATIC,
+      base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<CookieSetCallback> callback(new CookieSetCallback(completion, nullptr));
+  if (!cookie_manager->SetCookie(CefString(url), cef_cookie, callback)) {
+    LOG(ERROR) << "SetCookie error";
+    return false;
+  }
+  completion->Wait();
+  return callback->IsSetSuccess();
+}
+
 void NWebCookieManagerDelegate::ExistCookies(
     std::shared_ptr<NWebValueCallback<bool>> callback) {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
@@ -288,6 +354,25 @@ void NWebCookieManagerDelegate::Store(
   }
 }
 
+bool NWebCookieManagerDelegate::Store() {
+  CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
+  if (cookie_manager == nullptr) {
+    return false;
+  }
+  std::shared_ptr<base::WaitableEvent> event =
+    std::make_shared<base::WaitableEvent>(
+      base::WaitableEvent::ResetPolicy::AUTOMATIC,
+      base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<CookieCompletionCallback> complete =
+      new CookieCompletionCallback(event, nullptr);
+  if (!cookie_manager->FlushStore(complete)) {
+    LOG(ERROR) << "Store Failed";
+    return false;
+  }
+  event->Wait();
+  return true;
+}
+
 void NWebCookieManagerDelegate::DeleteSessionCookies(
     std::shared_ptr<NWebValueCallback<bool>> callback) {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
@@ -309,12 +394,19 @@ void NWebCookieManagerDelegate::DeleteCookieEntirely(
   if (cookie_manager == nullptr) {
     return;
   }
+  std::shared_ptr<base::WaitableEvent> event = (callback != nullptr) ?
+    nullptr : std::make_shared<base::WaitableEvent>(
+      base::WaitableEvent::ResetPolicy::AUTOMATIC,
+      base::WaitableEvent::InitialState::NOT_SIGNALED);
   CefRefPtr<CefDeleteCookiesCallback> delete_callback =
-      new CookieDeleteCallback(callback);
+      new CookieDeleteCallback(event, callback);
   if (!cookie_manager->DeleteCookies(CefString(std::string()),
                                      CefString(std::string()), false,
                                      delete_callback)) {
     LOG(ERROR) << "DeleteCookieEntirely Failed";
   }
+  if (event != nullptr) {
+    event->Wait();
+  }
 }
 }  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h b/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h
index cb4c60b625..c77cb4c9a6 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_COOKIE_MANAGER_DELEGATE_H
 #define NWEB_COOKIE_MANAGER_DELEGATE_H
@@ -13,7 +24,7 @@
 namespace OHOS::NWeb {
 class NWebCookieManagerDelegate : public NWebCookieManagerDelegateInterface {
  public:
-  NWebCookieManagerDelegate();
+  NWebCookieManagerDelegate() = default;
   ~NWebCookieManagerDelegate() = default;
 
   bool IsAcceptCookieAllowed() override;
@@ -23,11 +34,15 @@ class NWebCookieManagerDelegate : public NWebCookieManagerDelegateInterface {
   void ReturnCookie(
       const std::string& url,
       std::shared_ptr<NWebValueCallback<std::string>> callback) override;
+  std::string ReturnCookie(const std::string& url) override;
   void SetCookie(const std::string& url,
                  const std::string& value,
                  std::shared_ptr<NWebValueCallback<bool>> callback) override;
+  bool SetCookie(const std::string &url,
+                 const std::string &value) override;
   void ExistCookies(std::shared_ptr<NWebValueCallback<bool>> callback) override;
   void Store(std::shared_ptr<NWebValueCallback<bool>> callback) override;
+  bool Store() override;
   void DeleteSessionCookies(
       std::shared_ptr<NWebValueCallback<bool>> callback) override;
   void DeleteCookieEntirely(
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_delegate.cc b/src/ohos_nweb/src/cef_delegate/nweb_delegate.cc
index a32a1d2410..4a47e77222 100755
--- a/src/ohos_nweb/src/cef_delegate/nweb_delegate.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_delegate.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_delegate.h"
 
@@ -136,6 +147,14 @@ void NWebDelegate::OnTouchCancel() {
   }
 }
 
+bool NWebDelegate::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
+  bool retVal = false;
+  if (event_handler_ != nullptr) {
+    retVal = event_handler_->SendKeyEvent(keyCode, keyAction);
+  }
+  return retVal;
+}
+
 std::shared_ptr<NWebPreference> NWebDelegate::GetPreference() const {
   return preference_delegate_;
 }
@@ -187,6 +206,13 @@ void NWebDelegate::NavigateForward() const {
   }
 }
 
+void NWebDelegate::DeleteNavigateHistory() {
+  LOG(INFO) << "NWebDelegate::DeleteNavigateHistory";
+  if (GetBrowser().get()) {
+    GetBrowser()->DeleteHistory();
+  }
+}
+
 void NWebDelegate::Reload() const {
   LOG(INFO) << "NWebDelegate::Reload";
   if (GetBrowser().get()) {
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_delegate.h b/src/ohos_nweb/src/cef_delegate/nweb_delegate.h
index 5c4b10fc04..63ad48c690 100755
--- a/src/ohos_nweb/src/cef_delegate/nweb_delegate.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_delegate.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_DELEGATE_H
 #define NWEB_DELEGATE_H
@@ -40,6 +51,7 @@ class NWebDelegate : public NWebDelegateInterface,
   void OnTouchRelease(int32_t id, double x, double y) override;
   void OnTouchMove(int32_t id, double x, double y) override;
   void OnTouchCancel() override;
+  bool SendKeyEvent(int32_t keyCode, int32_t keyAction) override;
 
   void Load(const std::string& url) override;
   bool IsNavigatebackwardAllowed() const override;
@@ -47,6 +59,7 @@ class NWebDelegate : public NWebDelegateInterface,
   bool CanNavigateBackOrForward(int num_steps) const override;
   void NavigateBack() const override;
   void NavigateForward() const override;
+  void DeleteNavigateHistory() override;
   void Reload() const override;
   void Zoom(float zoomFactor) const override;
   void Stop() const override;
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_event_handler.cc b/src/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
index e737f46e20..99d1b5f0e7 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_event_handler.h"
 
@@ -71,4 +82,16 @@ void NWebEventHandler::OnTouchCancel() {
     browser_->GetHost()->SendTouchEvent(touch_cancelled);
   }
 }
+
+bool NWebEventHandler::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
+  CefKeyEvent keyEvent;
+  input_delegate_.SetModifiers(keyCode, keyAction);
+  keyEvent.windows_key_code = NWebInputDelegate::CefConverter("keycode", keyCode);
+  keyEvent.type = static_cast<cef_key_event_type_t>(NWebInputDelegate::CefConverter("keyaction", keyAction));
+  keyEvent.modifiers = input_delegate_.GetModifiers();
+  if (browser_ && browser_->GetHost()) {
+    browser_->GetHost()->SendKeyEvent(keyEvent);
+  }
+  return false;
+}
 }  // namespace OHOS::NWeb
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_event_handler.h b/src/ohos_nweb/src/cef_delegate/nweb_event_handler.h
index 4cc8b0c0d9..0ef2e92f3e 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_event_handler.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_event_handler.h
@@ -1,11 +1,23 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_EVENT_HANDLER_H
 #define NWEB_EVENT_HANDLER_H
 
 #include "cef/include/cef_client.h"
+#include "nweb_input_delegate.h"
 
 namespace OHOS::NWeb {
 class NWebEventHandler {
@@ -23,9 +35,11 @@ class NWebEventHandler {
   void OnTouchRelease(int32_t id, double x, double y);
   void OnTouchCancel();
   void OnKeyBack();
+  bool SendKeyEvent(int32_t keyCode, int32_t keyAction);
 
  private:
   CefRefPtr<CefBrowser> browser_ = nullptr;
+  NWebInputDelegate input_delegate_;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_file_selector_params_impl.cc b/src/ohos_nweb/src/cef_delegate/nweb_file_selector_params_impl.cc
new file mode 100644
index 0000000000..0ab1c50d60
--- /dev/null
+++ b/src/ohos_nweb/src/cef_delegate/nweb_file_selector_params_impl.cc
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_file_selector_params_impl.h"
+
+#include "base/logging.h"
+
+namespace OHOS::NWeb {
+FileSelectorParamsImpl::FileSelectorParamsImpl(
+    FileSelectorMode mode,
+    const std::string& title,
+    const std::vector<CefString>& accept_type,
+    const std::string& default_filename,
+    bool is_capture)
+    : mode_(mode),
+      title_(title),
+      default_filename_(default_filename),
+      is_capture_(is_capture) {
+  for (auto& c : accept_type) {
+    accept_type_.push_back(c.ToString());
+  }
+}
+
+const std::string FileSelectorParamsImpl::Title() const {
+  return title_;
+}
+
+NWebFileSelectorParams::FileSelectorMode FileSelectorParamsImpl::Mode() const {
+  return mode_;
+}
+
+const std::string FileSelectorParamsImpl::DefaultFilename() const {
+  return default_filename_;
+}
+
+const AcceptTypeList FileSelectorParamsImpl::AcceptType() const {
+  return accept_type_;
+}
+
+bool FileSelectorParamsImpl::IsCapture() const {
+  return is_capture_;
+}
+
+void FileSelectorCallbackImpl::OnReceiveValue(std::vector<std::string>& value) {
+  if (callback_ == nullptr || is_used_) {
+    LOG(ERROR) << "FileSelectorCallbackImpl is null or already used";
+    return;
+  }
+  is_used_ = true;
+  if (value.size() == 0) {
+    callback_->Cancel();
+  } else {
+    for (auto& c : value) {
+      file_path_.push_back(CefString(c));
+    }
+    callback_->Continue(0, file_path_);
+  }
+}
+}  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_file_selector_params_impl.h b/src/ohos_nweb/src/cef_delegate/nweb_file_selector_params_impl.h
new file mode 100644
index 0000000000..0311d4409d
--- /dev/null
+++ b/src/ohos_nweb/src/cef_delegate/nweb_file_selector_params_impl.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_FILE_SELECTOR_PARAMS_IMPL_H
+#define NWEB_FILE_SELECTOR_PARAMS_IMPL_H
+
+#include <string>
+#include <vector>
+#include "cef_dialog_handler.h"
+#include "nweb_handler.h"
+#include "nweb_file_selector_params.h"
+
+namespace OHOS::NWeb {
+class FileSelectorParamsImpl : public NWebFileSelectorParams{
+public:
+    FileSelectorParamsImpl(FileSelectorMode mode,
+                           const std::string &title,
+                           const std::vector<CefString> &accept_type,
+                           const std::string &default_filename,
+                           bool is_capture);
+
+    const std::string Title() const override;
+    NWebFileSelectorParams::FileSelectorMode Mode() const override;
+    const std::string DefaultFilename() const override;
+    const AcceptTypeList AcceptType() const override;
+    bool IsCapture() const override;
+
+private:
+    NWebFileSelectorParams::FileSelectorMode mode_;
+    std::string title_;
+    std::string default_filename_;
+    AcceptTypeList accept_type_;
+    bool is_capture_;
+};
+
+class FileSelectorCallbackImpl : public FileSelectorCallback {
+ public:
+  explicit FileSelectorCallbackImpl(CefRefPtr<CefFileDialogCallback> callback)
+      : callback_(callback),
+        file_path_(std::vector<CefString>()),
+        is_used_(false) {}
+  ~FileSelectorCallbackImpl() = default;
+
+  void OnReceiveValue(std::vector<std::string>& value) override;
+
+ private:
+  CefRefPtr<CefFileDialogCallback> callback_;
+  std::vector<CefString> file_path_;
+  bool is_used_;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc b/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc
index 893b92a9bb..3a97044650 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "ohos_nweb/src/cef_delegate/nweb_geolocation_callback.h"
 #include "base/logging.h"
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.h b/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.h
index 7240ebdf2e..b39feec5c5 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_GEOLOCATION_CALLBACK_H
 #define NWEB_GEOLOCATION_CALLBACK_H
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc b/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
index 6fc789fd1e..04dc120990 100755
--- a/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_handler_delegate.h"
 
@@ -13,12 +24,14 @@
 #include "cef/include/wrapper/cef_closure_task.h"
 #include "cef/include/wrapper/cef_helpers.h"
 #include "nweb_access_request_delegate.h"
+#include "nweb_file_selector_params_impl.h"
 #include "nweb_geolocation_callback.h"
 #include "nweb_js_dialog_result_impl.h"
 #include "nweb_resource_handler.h"
 #include "nweb_url_resource_error_impl.h"
 #include "nweb_url_resource_request_impl.h"
 #include "nweb_url_resource_response.h"
+#include "nweb_value_callback.h"
 
 namespace OHOS::NWeb {
 namespace {
@@ -68,6 +81,25 @@ NWebConsoleLog::NWebConsoleLogLevel ConvertConsoleMessageLevel(
       return NWebConsoleLog::NWebConsoleLogLevel::UNKNOWN;
   }
 }
+
+NWebFileSelectorParams::FileSelectorMode ConvertFileSelectorMode(
+    CefDialogHandler::FileDialogMode mode) {
+  NWebFileSelectorParams::FileSelectorMode result_mode =
+      NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_MODE;
+  switch (mode & FILE_DIALOG_TYPE_MASK) {
+    case FILE_DIALOG_OPEN:
+      return NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_MODE;
+    case FILE_DIALOG_OPEN_MULTIPLE:
+      return NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_MULTIPLE_MODE;
+    case FILE_DIALOG_OPEN_FOLDER:
+      return NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_FOLDER_MODE;
+    case FILE_DIALOG_SAVE:
+      return NWebFileSelectorParams::FileSelectorMode::FILE_SAVE_MODE;
+    default:
+      break;
+  }
+  return result_mode;
+}
 }  // namespace
 
 // static
@@ -182,6 +214,10 @@ CefRefPtr<CefJSDialogHandler> NWebHandlerDelegate::GetJSDialogHandler() {
   return this;
 }
 
+CefRefPtr<CefDialogHandler> NWebHandlerDelegate::GetDialogHandler() {
+  return this;
+}
+
 bool NWebHandlerDelegate::OnProcessMessageReceived(
     CefRefPtr<CefBrowser> browser,
     CefRefPtr<CefFrame> frame,
@@ -307,7 +343,7 @@ void NWebHandlerDelegate::OnLoadEnd(CefRefPtr<CefBrowser> browser,
                                     int http_status_code) {
   LOG(INFO) << "NWebHandlerDelegate::OnLoadEnd";
   if (frame == nullptr || !frame->IsMain()) {
-      return;
+    return;
   }
   LOG(INFO) << "NWebHandlerDelegate:: Mainframe OnLoadEnd";
   if (nweb_handler_ != nullptr) {
@@ -392,6 +428,19 @@ void NWebHandlerDelegate::OnHttpError(CefRefPtr<CefRequest> request,
   }
 }
 
+void NWebHandlerDelegate::OnRefreshAccessedHistory(CefRefPtr<CefBrowser> browser,
+                                                   CefRefPtr<CefFrame> frame,
+                                                   const CefString& url,
+                                                   bool isReload) {
+  LOG(INFO) << "NWebHandlerDelegate::OnRefreshAccessedHistory, url = " << url.ToString() << ", isReload = " << isReload;
+  if (nweb_handler_ == nullptr) {
+    LOG(ERROR) << "nweb handler is null";
+    return;
+  }
+
+  nweb_handler_->OnRefreshAccessedHistory(url.ToString(), isReload);
+}
+
 /* CefLoadHandler methods end */
 
 /* CefRequestHandler methods begin */
@@ -423,8 +472,7 @@ bool NWebHandlerDelegate::OnCertificateError(
   return false;
 }
 
-CefRefPtr<CefResourceRequestHandler>
-NWebHandlerDelegate::GetResourceRequestHandler(
+CefRefPtr<CefResourceRequestHandler> NWebHandlerDelegate::GetResourceRequestHandler(
     CefRefPtr<CefBrowser> browser,
     CefRefPtr<CefFrame> frame,
     CefRefPtr<CefRequest> request,
@@ -435,6 +483,34 @@ NWebHandlerDelegate::GetResourceRequestHandler(
   return this;
 }
 
+void NWebHandlerDelegate::OnRenderProcessTerminated(CefRefPtr<CefBrowser> browser, TerminationStatus status) {
+  if (nweb_handler_ == nullptr) {
+    LOG(ERROR) << "invalid nweb handler (nullptr)";
+    return;
+  }
+
+  RenderExitReason reason;
+  switch (status) {
+    case TS_ABNORMAL_TERMINATION:
+      reason = RenderExitReason::PROCESS_ABNORMAL_TERMINATION;
+      break;
+    case TS_PROCESS_WAS_KILLED:
+      reason = RenderExitReason::PROCESS_WAS_KILLED;
+      break;
+    case TS_PROCESS_CRASHED:
+      reason = RenderExitReason::PROCESS_CRASHED;
+      break;
+    case TS_PROCESS_OOM:
+      reason = RenderExitReason::PROCESS_OOM;
+      break;
+    default:
+      reason = RenderExitReason::PROCESS_EXIT_UNKNOWN;
+      break;
+  }
+
+  LOG(INFO) << "render process exit, reason = " << static_cast<int>(reason);
+  nweb_handler_->OnRenderExited(reason);
+}
 /* CefRequestHandler methods end */
 
 /* CefDownloadHandler methods begin */
@@ -465,7 +541,8 @@ void NWebHandlerDelegate::OnBeforeDownload(
         download_item->GetTotalBytes());
   }
 }
-/* CefDownloadHandler methods end */
+
+/* CefKeyboardHandler methods end */
 
 /* CefResourceRequestHandler method begin */
 CefResourceRequestHandler::ReturnValue
@@ -564,7 +641,7 @@ bool NWebHandlerDelegate::OnConsoleMessage(CefRefPtr<CefBrowser> browser,
     NWebConsoleLog::NWebConsoleLogLevel message_level =
         ConvertConsoleMessageLevel(level);
     NWebConsoleLog console_message(line, message.ToString(), message_level,
-                                       source.ToString());
+                                   source.ToString());
     return nweb_handler_->OnConsoleLog(console_message);
   }
   return false;
@@ -584,10 +661,11 @@ bool NWebHandlerDelegate::OnSetFocus(CefRefPtr<CefBrowser> browser,
 /* CefPermissionRequest method begin */
 void NWebHandlerDelegate::OnGeolocationShow(const CefString& origin) {
   if (nweb_handler_ != nullptr) {
-    NWebGeolocationCallback* callback =
-        new NWebGeolocationCallback(main_browser_);
-    nweb_handler_->OnGeolocationShow(origin, callback);
-    delete callback;
+    // lifecycle wrapped by ace WebGeolocationOhos
+    if (callback_ == nullptr) {
+      callback_ = new NWebGeolocationCallback(main_browser_);
+    }
+    nweb_handler_->OnGeolocationShow(origin, callback_);
   }
   return;
 }
@@ -666,6 +744,49 @@ bool NWebHandlerDelegate::OnBeforeUnloadDialog(
 
 /* CefJSDialogHandler method end */
 
+/* CefDialogHandler method begin */
+bool NWebHandlerDelegate::OnFileDialog(
+    CefRefPtr<CefBrowser> browser,
+    FileDialogMode mode,
+    const CefString& title,
+    const CefString& default_file_path,
+    const std::vector<CefString>& accept_filters,
+    int selected_accept_filter,
+    bool capture,
+    CefRefPtr<CefFileDialogCallback> callback) {
+  if (nweb_handler_ == nullptr) {
+    return false;
+  }
+  std::string file_selector_title = title.ToString();
+  NWebFileSelectorParams::FileSelectorMode file_mode = ConvertFileSelectorMode(mode);
+  if (title.ToString().size() == 0) {
+    switch (file_mode) {
+      case NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_MODE:
+        file_selector_title = "open file";
+        break;
+      case NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_MULTIPLE_MODE:
+        file_selector_title = "open files";
+        break;
+      case NWebFileSelectorParams::FileSelectorMode::FILE_OPEN_FOLDER_MODE:
+        file_selector_title = "open file folder";
+        break;
+      case NWebFileSelectorParams::FileSelectorMode::FILE_SAVE_MODE:
+        file_selector_title = "save as";
+        break;
+      default:
+        break;
+    }
+  }
+  std::shared_ptr<NWebFileSelectorParams> param =
+      std::make_shared<FileSelectorParamsImpl>(
+          file_mode, file_selector_title, accept_filters,
+          default_file_path.ToString(), capture);
+  std::shared_ptr<FileSelectorCallback> file_path_callback =
+      std::make_shared<FileSelectorCallbackImpl>(callback);
+  return nweb_handler_->OnFileSelectorShow(file_path_callback, param);
+}
+/* CefDialogHandler method end */
+
 const std::vector<std::string> NWebHandlerDelegate::GetVisitedHistory() {
   if (nweb_handler_ != nullptr) {
     return nweb_handler_->VisitedUrlHistory();
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h b/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
index 2d92d17575..b977a6be06 100755
--- a/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_HANDLER_DELEGATE_H
 #define NWEB_HANDLER_DELEGATE_H
@@ -9,6 +20,7 @@
 #include "cef/include/cef_client.h"
 #include "cef/include/cef_jsdialog_handler.h"
 #include "cef/include/cef_permission_request.h"
+#include "cef/include/cef_dialog_handler.h"
 #include "nweb_event_handler.h"
 #include "nweb_handler.h"
 #include "nweb_preference_delegate.h"
@@ -25,6 +37,7 @@
 
 namespace OHOS::NWeb {
 class NWebHandler;
+class NWebGeolocationCallback;
 
 class NWebHandlerDelegate : public CefClient,
                             public CefLifeSpanHandler,
@@ -35,7 +48,8 @@ class NWebHandlerDelegate : public CefClient,
                             public CefDownloadHandler,
                             public CefFocusHandler,
                             public CefPermissionRequest,
-                            public CefJSDialogHandler {
+                            public CefJSDialogHandler,
+                            public CefDialogHandler {
  public:
   static CefRefPtr<NWebHandlerDelegate> Create(
       std::shared_ptr<NWebPreferenceDelegate> preference_delegate,
@@ -71,6 +85,7 @@ class NWebHandlerDelegate : public CefClient,
   CefRefPtr<CefFocusHandler> GetFocusHandler() override;
   CefRefPtr<CefPermissionRequest> GetPermissionRequest() override;
   CefRefPtr<CefJSDialogHandler> GetJSDialogHandler() override;
+  CefRefPtr<CefDialogHandler> GetDialogHandler() override;
   virtual bool OnProcessMessageReceived(
       CefRefPtr<CefBrowser> browser,
       CefRefPtr<CefFrame> frame,
@@ -131,6 +146,11 @@ class NWebHandlerDelegate : public CefClient,
                    bool is_main_frame,
                    bool has_user_gesture,
                    CefRefPtr<CefResponse> response) override;
+
+  void OnRefreshAccessedHistory(CefRefPtr<CefBrowser> browser,
+                                CefRefPtr<CefFrame> frame,
+                                const CefString& url,
+                                bool isReload) override;
   /* CefLoadHandler methods end */
 
   /* CefRequestHandler methods begin */
@@ -152,6 +172,9 @@ class NWebHandlerDelegate : public CefClient,
       bool is_download,
       const CefString& request_initiator,
       bool& disable_default_handling) override;
+
+  void OnRenderProcessTerminated(CefRefPtr<CefBrowser> browser,
+                                 TerminationStatus status) override;
   /* CefRequestHandler methods end */
 
   /* CefDownloadHandler methods begin */
@@ -223,6 +246,17 @@ class NWebHandlerDelegate : public CefClient,
                             CefRefPtr<CefJSDialogCallback> callback) override;
   /* CefJSDialogHandler method end */
 
+  /* CefDialogHandler method begin */
+  bool OnFileDialog(CefRefPtr<CefBrowser> browser,
+                    FileDialogMode mode,
+                    const CefString& title,
+                    const CefString& default_file_path,
+                    const std::vector<CefString>& accept_filters,
+                    int selected_accept_filter,
+                    bool capture,
+                    CefRefPtr<CefFileDialogCallback> callback) override;
+  /* CefDialogHandler method end */
+
   const std::vector<std::string> GetVisitedHistory();
 
  private:
@@ -245,6 +279,8 @@ class NWebHandlerDelegate : public CefClient,
   std::shared_ptr<NWebHandler> nweb_handler_ = nullptr;
   std::shared_ptr<NWebJavaScriptResultCallBack> nweb_javascript_callback_ =
       nullptr;
+  // lifecycle wrapped by ace WebGeolocationOhos
+  NWebGeolocationCallback* callback_ = nullptr;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc b/src/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
new file mode 100644
index 0000000000..50b80661fd
--- /dev/null
+++ b/src/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_input_delegate.h"
+#include "cef/include/internal/cef_types_wrappers.h"
+
+using namespace OHOS::NWeb;
+const int32_t KEY_DOWN = 0;
+const int32_t KEY_UP = 1;
+
+const std::unordered_map<int, int>keycodeConverter = {
+  {OHOS::MMI::KeyEvent::KEYCODE_0, ui::VKEY_0},
+  {OHOS::MMI::KeyEvent::KEYCODE_1, ui::VKEY_1},
+  {OHOS::MMI::KeyEvent::KEYCODE_2, ui::VKEY_2},
+  {OHOS::MMI::KeyEvent::KEYCODE_3, ui::VKEY_3},
+  {OHOS::MMI::KeyEvent::KEYCODE_4, ui::VKEY_4},
+  {OHOS::MMI::KeyEvent::KEYCODE_5, ui::VKEY_5},
+  {OHOS::MMI::KeyEvent::KEYCODE_6, ui::VKEY_6},
+  {OHOS::MMI::KeyEvent::KEYCODE_7, ui::VKEY_7},
+  {OHOS::MMI::KeyEvent::KEYCODE_8, ui::VKEY_8},
+  {OHOS::MMI::KeyEvent::KEYCODE_9, ui::VKEY_9},
+  {OHOS::MMI::KeyEvent::KEYCODE_A, ui::VKEY_A},
+  {OHOS::MMI::KeyEvent::KEYCODE_B, ui::VKEY_B},
+  {OHOS::MMI::KeyEvent::KEYCODE_C, ui::VKEY_C},
+  {OHOS::MMI::KeyEvent::KEYCODE_D, ui::VKEY_D},
+  {OHOS::MMI::KeyEvent::KEYCODE_E, ui::VKEY_E},
+  {OHOS::MMI::KeyEvent::KEYCODE_F, ui::VKEY_F},
+  {OHOS::MMI::KeyEvent::KEYCODE_G, ui::VKEY_G},
+  {OHOS::MMI::KeyEvent::KEYCODE_H, ui::VKEY_H},
+  {OHOS::MMI::KeyEvent::KEYCODE_I, ui::VKEY_I},
+  {OHOS::MMI::KeyEvent::KEYCODE_J, ui::VKEY_J},
+  {OHOS::MMI::KeyEvent::KEYCODE_K, ui::VKEY_K},
+  {OHOS::MMI::KeyEvent::KEYCODE_L, ui::VKEY_L},
+  {OHOS::MMI::KeyEvent::KEYCODE_M, ui::VKEY_M},
+  {OHOS::MMI::KeyEvent::KEYCODE_N, ui::VKEY_N},
+  {OHOS::MMI::KeyEvent::KEYCODE_O, ui::VKEY_O},
+  {OHOS::MMI::KeyEvent::KEYCODE_P, ui::VKEY_P},
+  {OHOS::MMI::KeyEvent::KEYCODE_Q, ui::VKEY_Q},
+  {OHOS::MMI::KeyEvent::KEYCODE_R, ui::VKEY_R},
+  {OHOS::MMI::KeyEvent::KEYCODE_S, ui::VKEY_S},
+  {OHOS::MMI::KeyEvent::KEYCODE_T, ui::VKEY_T},
+  {OHOS::MMI::KeyEvent::KEYCODE_U, ui::VKEY_U},
+  {OHOS::MMI::KeyEvent::KEYCODE_V, ui::VKEY_V},
+  {OHOS::MMI::KeyEvent::KEYCODE_W, ui::VKEY_W},
+  {OHOS::MMI::KeyEvent::KEYCODE_X, ui::VKEY_X},
+  {OHOS::MMI::KeyEvent::KEYCODE_Y, ui::VKEY_Y},
+  {OHOS::MMI::KeyEvent::KEYCODE_Z, ui::VKEY_Z},
+  {OHOS::MMI::KeyEvent::KEYCODE_SHIFT_LEFT, ui::VKEY_SHIFT},
+  {OHOS::MMI::KeyEvent::KEYCODE_SHIFT_RIGHT, ui::VKEY_SHIFT},
+  {OHOS::MMI::KeyEvent::KEYCODE_TAB, ui::VKEY_TAB},
+  {OHOS::MMI::KeyEvent::KEYCODE_SPACE, ui::VKEY_SPACE},
+  {OHOS::MMI::KeyEvent::KEYCODE_ENTER, ui::VKEY_RETURN},
+  {OHOS::MMI::KeyEvent::KEYCODE_DEL, ui::VKEY_DELETE},
+  {OHOS::MMI::KeyEvent::KEYCODE_CTRL_LEFT, ui::VKEY_CONTROL},
+  {OHOS::MMI::KeyEvent::KEYCODE_CTRL_RIGHT, ui::VKEY_CONTROL},
+  {OHOS::MMI::KeyEvent::KEYCODE_F1, ui::VKEY_F1},
+  {OHOS::MMI::KeyEvent::KEYCODE_F2, ui::VKEY_F2},
+  {OHOS::MMI::KeyEvent::KEYCODE_F3, ui::VKEY_F3},
+  {OHOS::MMI::KeyEvent::KEYCODE_F4, ui::VKEY_F4},
+  {OHOS::MMI::KeyEvent::KEYCODE_F5, ui::VKEY_F5},
+  {OHOS::MMI::KeyEvent::KEYCODE_F6, ui::VKEY_F6},
+  {OHOS::MMI::KeyEvent::KEYCODE_F7, ui::VKEY_F7},
+  {OHOS::MMI::KeyEvent::KEYCODE_F8, ui::VKEY_F8},
+  {OHOS::MMI::KeyEvent::KEYCODE_F9, ui::VKEY_F9},
+  {OHOS::MMI::KeyEvent::KEYCODE_F10, ui::VKEY_F10},
+  {OHOS::MMI::KeyEvent::KEYCODE_F11, ui::VKEY_F11},
+  {OHOS::MMI::KeyEvent::KEYCODE_F12, ui::VKEY_F12},
+};
+
+const std::unordered_map<int, int> keyactionConverter = {
+  {KEY_UP, KEYEVENT_KEYUP},
+  {KEY_DOWN, KEYEVENT_KEYDOWN},
+};
+
+const std::unordered_map<std::string, std::unordered_map<int, int>> keyValueConverter = {
+  {"keycode", keycodeConverter},
+  {"keyaction", keyactionConverter},
+};
+
+bool NWebInputDelegate::KeyValueConvert(const std::string keyValue, std::unordered_map<int, int>& map) {
+  auto itKeyValue = keyValueConverter.find(keyValue);
+  if (itKeyValue == keyValueConverter.end()) {
+    return false;
+  }
+  map = itKeyValue->second;
+  return true;
+}
+
+int NWebInputDelegate::CefConverter(const std::string keyValue, int input) {
+  std::unordered_map<int, int> itConverter;
+  if (KeyValueConvert(keyValue, itConverter) == false) {
+    return -1;
+  }
+  auto item = itConverter.find(input);
+  if (item == itConverter.end()) {
+    return -1;
+  }
+  return item->second;
+}
+
+int NWebInputDelegate::OhosConverter(const std::string keyValue, int input) {
+  std::unordered_map<int, int> itConverter;
+  if (KeyValueConvert(keyValue, itConverter) == false) {
+    return -1;
+  }
+  auto item = itConverter.find(input);
+  if (item == itConverter.end()) {
+    return -1;
+  }
+  return item->first;
+}
+
+void NWebInputDelegate::SetModifiers(int keyCode, int keyAction)
+{
+  if ((keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_LEFT ||
+       keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_RIGHT) &&
+       keyCTL_ == true && keyAction == KEY_UP) {
+    keyCTL_ = false;
+  }
+
+  if ((keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_LEFT ||
+       keyCode == OHOS::MMI::KeyEvent::KEYCODE_CTRL_RIGHT) &&
+       keyCTL_ == false && keyAction == KEY_DOWN) {
+    keyCTL_ = true;
+  }
+}
+
+unsigned int NWebInputDelegate::GetModifiers()
+{
+  if (keyCTL_ == true) {
+    return (0 | EVENTFLAG_CONTROL_DOWN);
+  }
+  return 0;
+}
\ No newline at end of file
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_input_delegate.h b/src/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
new file mode 100644
index 0000000000..da5b1e1c26
--- /dev/null
+++ b/src/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_KEYCODE_INTERFACE_H
+#define NWEB_KEYCODE_INTERFACE_H
+
+#include <unordered_map>
+#include "key_event.h"
+#include "ui/events/keycodes/keyboard_codes_posix.h"
+
+namespace OHOS::NWeb {
+class NWebInputDelegate {
+ public:
+  virtual ~NWebInputDelegate() = default;
+  static int CefConverter(const std::string keyValue, int input);
+  static int OhosConverter(const std::string keyValue, int input);
+  void SetModifiers(int keyCode, int keyAction);
+  unsigned int GetModifiers();
+
+ private:
+  static bool KeyValueConvert(const std::string keyValue, std::unordered_map<int, int>& map);
+  bool keyCTL_ = false;
+};
+}  // namespace OHOS::NWeb
+
+#endif
\ No newline at end of file
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h b/src/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h
index 73cebd5e2b..2d4bcad12a 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OHOS_NWEB_SRC_CEF_DELEGATE_NWEB_INPUTMETHOD_CLIENT_H_
 #define OHOS_NWEB_SRC_CEF_DELEGATE_NWEB_INPUTMETHOD_CLIENT_H_
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.cc b/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.cc
index 23287ae9ac..7218fea53a 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_js_dialog_result_impl.h"
 
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.h b/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.h
index 0ad0d03214..a97587fe90 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_js_dialog_result_impl.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_JS_DIALOG_RESULT_IMPL_H
 #define NWEB_JS_DIALOG_RESULT_IMPL_H
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc b/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
old mode 100644
new mode 100755
index 37ea605711..e2250a7ef0
--- a/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "ohos_nweb/src/cef_delegate/nweb_preference_delegate.h"
 
@@ -15,8 +26,22 @@
 #include "cef/libcef/browser/net_service/net_helpers.h"
 
 #include "base/feature_list.h"
+#include "net/base/load_flags.h"
 
 namespace OHOS::NWeb {
+int ConvertCacheMode(NWebPreference::CacheModeFlag flag) {
+  switch (flag) {
+    case NWebPreference::CacheModeFlag::USE_CACHE_ELSE_NETWORK:
+      return net::LOAD_SKIP_CACHE_VALIDATION;
+    case NWebPreference::CacheModeFlag::USE_NO_CACHE:
+      return net::LOAD_BYPASS_CACHE;
+    case NWebPreference::CacheModeFlag::USE_CACHE_ONLY:
+      return net::LOAD_ONLY_FROM_CACHE | net::LOAD_SKIP_CACHE_VALIDATION;
+    default:
+      return 0;
+  }
+}
+
 const std::string ACCESS_LOCATION = "ohos.permission.INTERNET";
 NWebPreferenceDelegate::NWebPreferenceDelegate() {
   uint32_t tokenId = OHOS::IPCSkeleton::GetCallingTokenID();
@@ -80,6 +105,8 @@ void NWebPreferenceDelegate::ComputeBrowserSettings(
   browser_settings.default_fixed_font_size = DefaultFixedFontSize();
   browser_settings.minimum_font_size = FontSizeLowerLimit();
   browser_settings.minimum_logical_font_size = LogicalFontSizeLowerLimit();
+  browser_settings.initialize_at_minimum_page_scale =
+      !IsLoadWithOverviewMode() ? STATE_ENABLED : STATE_DISABLED;
 
   str = CefString(DefaultTextEncodingFormat());
   cef_string_set(str.c_str(), str.length(),
@@ -105,8 +132,6 @@ void NWebPreferenceDelegate::ComputeBrowserSettings(
   browser_settings.javascript_can_open_windows_automatically =
       IsCreateWindowsByJavaScriptAllowed();
   browser_settings.text_size_percent = ZoomingForTextFactor();
-  browser_settings.mixed_content_mode =
-      AccessModeForSecureOriginLoadFromInsecure();
   browser_settings.allow_running_insecure_content =
       RunningInsecureContentAllowed() ? STATE_ENABLED : STATE_DISABLED;
   browser_settings.strict_mixed_content_checking =
@@ -122,6 +147,7 @@ void NWebPreferenceDelegate::SetBrowserSettingsToNetHelpers() {
   net_service::NetHelpers::allow_file_access = EnableRawFileAccess();
   net_service::NetHelpers::allow_content_access = EnableContentAccess();
   net_service::NetHelpers::is_network_blocked = IsNetworkBlocked();
+  net_service::NetHelpers::cache_mode = ConvertCacheMode(CacheMode());
   return;
 }
 
@@ -219,6 +245,11 @@ void NWebPreferenceDelegate::PutLogicalFontSizeLowerLimit(int size) {
   WebPreferencesChanged();
 }
 
+void NWebPreferenceDelegate::PutLoadWithOverviewMode(bool flag) {
+  overload_mode_enabled_ = flag;
+  WebPreferencesChanged();
+}
+
 void NWebPreferenceDelegate::PutSansSerifFontFamilyName(std::string font) {
   sans_serif_font_family_name_ = font;
   WebPreferencesChanged();
@@ -282,6 +313,20 @@ void NWebPreferenceDelegate::PutBlockNetwork(bool flag) {
   SetBrowserSettingsToNetHelpers();
 }
 
+void NWebPreferenceDelegate::PutCacheMode(CacheModeFlag flag) {
+  cache_mode_flag_ = flag;
+  SetBrowserSettingsToNetHelpers();
+}
+
+void NWebPreferenceDelegate::PutWebDebuggingAccess(bool flag) {
+  if (!browser_.get()) {
+    LOG(ERROR) << "put web debugging access failed, browser is null";
+    return;
+  }
+
+  browser_->GetHost()->SetWebDebuggingAccess(flag);
+}
+
 bool NWebPreferenceDelegate::EnableContentAccess() {
   return content_access_;
 }
@@ -362,6 +407,10 @@ int NWebPreferenceDelegate::LogicalFontSizeLowerLimit() {
   return logical_font_size_lower_limit_;
 }
 
+bool NWebPreferenceDelegate::IsLoadWithOverviewMode() {
+  return overload_mode_enabled_;
+}
+
 std::string NWebPreferenceDelegate::SansSerifFontFamilyName() {
   return sans_serif_font_family_name_;
 }
@@ -389,16 +438,16 @@ bool NWebPreferenceDelegate::GeolocationAllowed() {
   return geolocation_allowed_;
 }
 
-int NWebPreferenceDelegate::AccessModeForSecureOriginLoadFromInsecure() {
+NWebPreference::AccessMode NWebPreferenceDelegate::AccessModeForSecureOriginLoadFromInsecure() {
   return access_mode_;
 }
 
 bool NWebPreferenceDelegate::RunningInsecureContentAllowed() {
-  return access_mode_ == ALWAYS_ALLOW;
+  return access_mode_ == AccessMode::ALWAYS_ALLOW;
 }
 
 bool NWebPreferenceDelegate::UseStricMixedContentCheckingAllowed() {
-  return access_mode_ == NEVER_ALLOW;
+  return access_mode_ == AccessMode::NEVER_ALLOW;
 }
 
 const base::Feature webview_mixed_content_autoupgrades{
@@ -406,7 +455,7 @@ const base::Feature webview_mixed_content_autoupgrades{
 
 bool NWebPreferenceDelegate::MixedContentAutoupgradesAllowed() {
   if (base::FeatureList::IsEnabled(webview_mixed_content_autoupgrades)) {
-    return access_mode_ == COMPATIBILITY_MODE;
+    return access_mode_ == AccessMode::COMPATIBILITY_MODE;
   }
   return false;
 }
@@ -419,7 +468,20 @@ bool NWebPreferenceDelegate::IsNetworkBlocked() {
   return is_network_blocked_;
 }
 
+NWebPreference::CacheModeFlag NWebPreferenceDelegate::CacheMode() {
+  return cache_mode_flag_;
+}
+
 void NWebPreferenceDelegate::PutHasInternetPermission(bool flag) {
   has_internet_permission_ = flag;
 }
+
+bool NWebPreferenceDelegate::IsWebDebuggingAccess() {
+  if (!browser_.get()) {
+    LOG(ERROR) << "get web debugggin access failed, browser is null";
+    return false;
+  }
+
+  return browser_->GetHost()->GetWebDebuggingAccess();
+}
 }  // namespace OHOS::NWeb
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h b/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h
old mode 100644
new mode 100755
index 50078329b1..f3f21f72eb
--- a/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_PREFERENCE_DELEGATE_H
 #define NWEB_PREFERENCE_DELEGATE_H
@@ -39,6 +50,7 @@ class NWebPreferenceDelegate : public NWebPreference {
   void PutJavaScriptEnabled(bool flag) override;
   void PutImageLoadingAllowed(bool flag) override;
   void PutFontSizeLowerLimit(int size) override;
+  void PutLoadWithOverviewMode(bool flag) override;
   void PutLogicalFontSizeLowerLimit(int size) override;
   void PutSansSerifFontFamilyName(std::string font) override;
   void PutSerifFontFamilyName(std::string font) override;
@@ -49,6 +61,8 @@ class NWebPreferenceDelegate : public NWebPreference {
   void PutAccessModeForSecureOriginLoadFromInsecure(AccessMode mode) override;
   void PutZoomingFunctionEnabled(bool flag) override;
   void PutBlockNetwork(bool flag) override;
+  void PutCacheMode(NWebPreference::CacheModeFlag flag) override;
+  void PutWebDebuggingAccess(bool flag) override;
 
   /* get methods*/
   bool EnableContentAccess() override;
@@ -71,15 +85,18 @@ class NWebPreferenceDelegate : public NWebPreference {
   bool IsImageLoadingAllowed() override;
   int FontSizeLowerLimit() override;
   int LogicalFontSizeLowerLimit() override;
+  bool IsLoadWithOverviewMode() override;
   std::string SansSerifFontFamilyName() override;
   std::string SerifFontFamilyName() override;
   std::string StandardFontFamilyName() override;
   std::string UserAgent() override;
   int ZoomingForTextFactor() override;
   bool GeolocationAllowed() override;
-  int AccessModeForSecureOriginLoadFromInsecure() override;
+  NWebPreference::AccessMode AccessModeForSecureOriginLoadFromInsecure() override;
   bool ZoomingfunctionEnabled() override;
   bool IsNetworkBlocked() override;
+  NWebPreference::CacheModeFlag CacheMode() override;
+  bool IsWebDebuggingAccess() override;
 
   bool RunningInsecureContentAllowed();
   bool UseStricMixedContentCheckingAllowed();
@@ -117,10 +134,12 @@ class NWebPreferenceDelegate : public NWebPreference {
   std::string user_agent_{""};
   int zooming_for_text_factor_{100};
   bool geolocation_allowed_{true};
-  int access_mode_{NEVER_ALLOW};
+  AccessMode access_mode_{AccessMode::NEVER_ALLOW};
   bool zooming_function_enabled_{true};
   bool is_network_blocked_;
   bool has_internet_permission_;
+  bool overload_mode_enabled_{true};
+  CacheModeFlag cache_mode_flag_{CacheModeFlag::USE_DEFAULT};
 };
 }  // namespace OHOS::NWeb
 
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_render_handler.cc b/src/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
index ae7be00613..b61d89831b 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_render_handler.h"
 
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_render_handler.h b/src/ohos_nweb/src/cef_delegate/nweb_render_handler.h
index 5f4165d47f..20d735e83a 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_render_handler.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_render_handler.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_RENDER_HANDLER_H
 #define NWEB_RENDER_HANDLER_H
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc b/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc
index 3b465b8f85..adbd62a1fc 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc
+++ b/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_resource_handler.h"
 #include "base/logging.h"
diff --git a/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.h b/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.h
index fc23967df1..e423190bd4 100644
--- a/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.h
+++ b/src/ohos_nweb/src/cef_delegate/nweb_resource_handler.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_REOURCE_HANDLER_H
 #define NWEB_REOURCE_HANDLER_H
diff --git a/src/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h b/src/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h
index 564c57934e..5364766d88 100644
--- a/src/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h
+++ b/src/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_COOKIE_MANAGER_DELEGATE_INTERFACE_H
 #define NWEB_COOKIE_MANAGER_DELEGATE_INTERFACE_H
@@ -20,12 +31,16 @@ class NWebCookieManagerDelegateInterface {
   virtual void ReturnCookie(
       const std::string& url,
       std::shared_ptr<NWebValueCallback<std::string>> callback) = 0;
+  virtual std::string ReturnCookie(const std::string &url) = 0;
   virtual void SetCookie(const std::string& url,
                          const std::string& value,
                          std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
+  virtual bool SetCookie(const std::string &url,
+                         const std::string &value) = 0;
   virtual void ExistCookies(
       std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
   virtual void Store(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
+  virtual bool Store() = 0;
   virtual void DeleteSessionCookies(
       std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
   virtual void DeleteCookieEntirely(
diff --git a/src/ohos_nweb/src/nweb_cookie_manager_impl.cc b/src/ohos_nweb/src/nweb_cookie_manager_impl.cc
index 5d0659ed85..64c0a04158 100644
--- a/src/ohos_nweb/src/nweb_cookie_manager_impl.cc
+++ b/src/ohos_nweb/src/nweb_cookie_manager_impl.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_cookie_manager_impl.h"
 #include "nweb_cookie_manager_delegate.h"
@@ -8,6 +19,12 @@
 
 using namespace OHOS::NWeb;
 
+extern "C" OHOS_NWEB_EXPORT NWebCookieManager* GetCookieManager() {
+  WVLOG_I("GetCookieManager");
+  static NWebCookieManagerImpl cookie_manager;
+  return &cookie_manager;
+}
+
 namespace OHOS::NWeb {
 NWebCookieManagerImpl::NWebCookieManagerImpl() {
 #if defined(USE_CEF)
@@ -50,6 +67,15 @@ void NWebCookieManagerImpl::SetCookie(
   }
 }
 
+bool NWebCookieManagerImpl::SetCookie(
+    const std::string& url,
+    const std::string& value) {
+  if (delegate_ != nullptr) {
+    return delegate_->SetCookie(url, value);
+  }
+  return false;
+}
+
 void NWebCookieManagerImpl::ReturnCookie(
     const std::string& url,
     std::shared_ptr<NWebValueCallback<std::string>> callback) {
@@ -58,6 +84,14 @@ void NWebCookieManagerImpl::ReturnCookie(
   }
 }
 
+std::string NWebCookieManagerImpl::ReturnCookie(
+    const std::string& url) {
+  if (delegate_ != nullptr) {
+    return delegate_->ReturnCookie(url);
+  }
+  return "";
+}
+
 void NWebCookieManagerImpl::ExistCookies(
     std::shared_ptr<NWebValueCallback<bool>> callback) {
   if (delegate_ != nullptr) {
@@ -72,6 +106,13 @@ void NWebCookieManagerImpl::Store(
   }
 }
 
+bool NWebCookieManagerImpl::Store() {
+  if (delegate_ != nullptr) {
+    return delegate_->Store();
+  }
+  return false;
+}
+
 void NWebCookieManagerImpl::DeleteSessionCookies(
     std::shared_ptr<NWebValueCallback<bool>> callback) {
   if (delegate_ != nullptr) {
@@ -85,9 +126,4 @@ void NWebCookieManagerImpl::DeleteCookieEntirely(
     delegate_->DeleteCookieEntirely(callback);
   }
 }
-
-NWebCookieManager* NWebCookieManager::GetInstance() {
-  static NWebCookieManagerImpl instance;
-  return &instance;
-}
 }  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/src/ohos_nweb/src/nweb_cookie_manager_impl.h b/src/ohos_nweb/src/nweb_cookie_manager_impl.h
index 128ab637b7..baa468006d 100644
--- a/src/ohos_nweb/src/nweb_cookie_manager_impl.h
+++ b/src/ohos_nweb/src/nweb_cookie_manager_impl.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_COOKIE_MANAGER_IMPL_H
 #define NWEB_COOKIE_MANAGER_IMPL_H
@@ -21,18 +32,22 @@ class NWebCookieManagerImpl : public NWebCookieManager {
   void ReturnCookie(
       const std::string& url,
       std::shared_ptr<NWebValueCallback<std::string>> callback) override;
+  std::string ReturnCookie(const std::string &url) override;
   void SetCookie(const std::string& url,
                  const std::string& value,
                  std::shared_ptr<NWebValueCallback<bool>> callback) override;
+  bool SetCookie(const std::string &url,
+                 const std::string &value) override;
   void ExistCookies(std::shared_ptr<NWebValueCallback<bool>> callback) override;
   void Store(std::shared_ptr<NWebValueCallback<bool>> callback) override;
+  bool Store() override;
   void DeleteSessionCookies(
       std::shared_ptr<NWebValueCallback<bool>> callback) override;
   void DeleteCookieEntirely(
       std::shared_ptr<NWebValueCallback<bool>> callback) override;
 
  private:
-  std::shared_ptr<NWebCookieManagerDelegateInterface> delegate_ = nullptr;
+  std::shared_ptr<NWebCookieManagerDelegateInterface> delegate_;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/src/ohos_nweb/src/nweb_delegate_adapter.cc b/src/ohos_nweb/src/nweb_delegate_adapter.cc
index e604c27e77..badff60157 100644
--- a/src/ohos_nweb/src/nweb_delegate_adapter.cc
+++ b/src/ohos_nweb/src/nweb_delegate_adapter.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_delegate_adapter.h"
 
diff --git a/src/ohos_nweb/src/nweb_delegate_adapter.h b/src/ohos_nweb/src/nweb_delegate_adapter.h
index 0a47d2b4ed..36eb920b24 100644
--- a/src/ohos_nweb/src/nweb_delegate_adapter.h
+++ b/src/ohos_nweb/src/nweb_delegate_adapter.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_DELEGATE_HELPER_H
 #define NWEB_DELEGATE_HELPER_H
diff --git a/src/ohos_nweb/src/nweb_delegate_interface.h b/src/ohos_nweb/src/nweb_delegate_interface.h
index 179578beec..f3f659e2a7 100755
--- a/src/ohos_nweb/src/nweb_delegate_interface.h
+++ b/src/ohos_nweb/src/nweb_delegate_interface.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_DELEGATE_INTERFACE_H
 #define NWEB_DELEGATE_INTERFACE_H
@@ -32,6 +43,7 @@ class NWebDelegateInterface {
   virtual void OnTouchRelease(int32_t id, double x, double y) = 0;
   virtual void OnTouchMove(int32_t id, double x, double y) = 0;
   virtual void OnTouchCancel() = 0;
+  virtual bool SendKeyEvent(int32_t keyCode, int32_t keyAction) = 0;
 
   virtual void Load(const std::string& url) = 0;
   virtual bool IsNavigatebackwardAllowed() const = 0;
@@ -39,6 +51,7 @@ class NWebDelegateInterface {
   virtual bool CanNavigateBackOrForward(int numSteps) const = 0;
   virtual void NavigateBack() const = 0;
   virtual void NavigateForward() const = 0;
+  virtual void DeleteNavigateHistory() = 0;
   virtual void Reload() const = 0;
   virtual void Zoom(float zoomFactor) const = 0;
   virtual void Stop() const = 0;
diff --git a/src/ohos_nweb/src/nweb_hilog.h b/src/ohos_nweb/src/nweb_hilog.h
index 0e9518b413..467fc56643 100644
--- a/src/ohos_nweb/src/nweb_hilog.h
+++ b/src/ohos_nweb/src/nweb_hilog.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_HILOG_H
 #define NWEB_HILOG_H
diff --git a/src/ohos_nweb/src/nweb_impl.cc b/src/ohos_nweb/src/nweb_impl.cc
index 27f257873e..60804d8523 100755
--- a/src/ohos_nweb/src/nweb_impl.cc
+++ b/src/ohos_nweb/src/nweb_impl.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_impl.h"
 
@@ -148,6 +159,9 @@ void NWebImpl::InitWebEngineArgs(const NWebInitArgs& init_args) {
   web_engine_args_.emplace_back("/system/bin/web_render");
   web_engine_args_.emplace_back("--in-process-gpu");
   web_engine_args_.emplace_back("--disable-dev-shm-usage");
+#ifdef GPU_RK3568
+  web_engine_args_.emplace_back("--disable-gpu");
+#endif
   web_engine_args_.emplace_back("--no-unsandboxed-zygote");
   web_engine_args_.emplace_back("--no-zygote");
   web_engine_args_.emplace_back("--off-screen-frame-rate=60");
@@ -157,9 +171,11 @@ void NWebImpl::InitWebEngineArgs(const NWebInitArgs& init_args) {
   web_engine_args_.emplace_back("--ignore-certificate-errors");
   web_engine_args_.emplace_back("--use-mobile-user-agent");
   web_engine_args_.emplace_back("--enable-gpu-rasterization");
+  web_engine_args_.emplace_back("--enable-viewport");
   web_engine_args_.emplace_back(
       "--browser-subprocess-path=/system/bin/web_render");
   web_engine_args_.emplace_back("--zygote-cmd-prefix=/system/bin/web_render");
+  web_engine_args_.emplace_back("--remote-debugging-port=9222");
 
   for (auto arg : init_args.web_engine_args_to_delete) {
     auto it = std::find(web_engine_args_.begin(), web_engine_args_.end(), arg);
@@ -236,6 +252,13 @@ void NWebImpl::OnNavigateBack() {
   input_handler_->OnNavigateBack();
 }
 
+bool NWebImpl::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
+  if (input_handler_ == nullptr) {
+    return false;
+  }
+  return input_handler_->SendKeyEvent(keyCode, keyAction);
+}
+
 void NWebImpl::Load(const std::string& url) const {
   if (nweb_delegate_ == nullptr || output_handler_ == nullptr) {
     return;
@@ -285,6 +308,13 @@ void NWebImpl::NavigateForward() const {
   nweb_delegate_->NavigateForward();
 }
 
+void NWebImpl::DeleteNavigateHistory() {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->DeleteNavigateHistory();
+}
+
 void NWebImpl::Reload() const {
   if (nweb_delegate_ == nullptr) {
     return;
diff --git a/src/ohos_nweb/src/nweb_impl.h b/src/ohos_nweb/src/nweb_impl.h
index e47f0a8e01..65daaffe87 100755
--- a/src/ohos_nweb/src/nweb_impl.h
+++ b/src/ohos_nweb/src/nweb_impl.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_IMPL_H
 #define NWEB_IMPL_H
@@ -32,6 +43,7 @@ class NWebImpl : public NWeb {
   void OnTouchMove(int32_t id, double x, double y) override;
   void OnTouchCancel() override;
   void OnNavigateBack() override;
+  bool SendKeyEvent(int32_t keyCode, int32_t keyAction) override;
 
   // public api
   void Load(const std::string& url) const override;
@@ -40,6 +52,7 @@ class NWebImpl : public NWeb {
   bool CanNavigateBackOrForward(int numSteps) const override;
   void NavigateBack() const override;
   void NavigateForward() const override;
+  void DeleteNavigateHistory() override;
   void Reload() const override;
   void Zoom(float zoomFactor) const override;
   void Stop() const override;
diff --git a/src/ohos_nweb/src/nweb_input_handler.cc b/src/ohos_nweb/src/nweb_input_handler.cc
index 78ea32c2b0..0708fb360e 100644
--- a/src/ohos_nweb/src/nweb_input_handler.cc
+++ b/src/ohos_nweb/src/nweb_input_handler.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_input_handler.h"
 #include "nweb_hilog.h"
@@ -83,6 +94,13 @@ void NWebInputHandler::OnNavigateBack() {
   }
 }
 
+bool NWebInputHandler::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
+  if (nweb_delegate_ == nullptr) {
+    return false;
+  }
+  return nweb_delegate_->SendKeyEvent(keyCode, keyAction);
+}
+
 void NWebInputHandler::CheckSlideNavigation(int16_t start_x, int16_t end_x) {
   if (nweb_delegate_ == nullptr) {
     return;
diff --git a/src/ohos_nweb/src/nweb_input_handler.h b/src/ohos_nweb/src/nweb_input_handler.h
index ee88ec0055..3351edbf94 100644
--- a/src/ohos_nweb/src/nweb_input_handler.h
+++ b/src/ohos_nweb/src/nweb_input_handler.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_INPUT_HANDLER_H
 #define NWEB_INPUT_HANDLER_H
@@ -28,6 +39,7 @@ class NWebInputHandler {
   void OnTouchMove(int32_t id, double x, double y);
   void OnTouchCancel();
   void OnNavigateBack();
+  bool SendKeyEvent(int32_t keyCode, int32_t keyAction);
 
  private:
   void CheckSlideNavigation(int16_t start_x, int16_t end_x);
diff --git a/src/ohos_nweb/src/nweb_inputmethod_handler.cc b/src/ohos_nweb/src/nweb_inputmethod_handler.cc
index 4163efc359..08e9f6ecac 100644
--- a/src/ohos_nweb/src/nweb_inputmethod_handler.cc
+++ b/src/ohos_nweb/src/nweb_inputmethod_handler.cc
@@ -1,11 +1,21 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_inputmethod_handler.h"
 
-#include <input_method_controller.h>
-#include <input_method_utils.h>
+#include "input_method_utils.h"
 
 #include "base/bind.h"
 #include "base/callback.h"
@@ -37,7 +47,7 @@ class OnTextChangedListenerImpl
 
   void SendKeyEventFromInputMethod(
       const OHOS::MiscServices::KeyEvent& event) override {
-    LOG(INFO) << "NWebInputMethodHandler::DeleteBackward";
+    LOG(INFO) << "NWebInputMethodHandler::SendKeyEventFromInputMethod";
   }
 
   void SendKeyboardInfo(const OHOS::MiscServices::KeyboardInfo& info) override {
@@ -54,16 +64,13 @@ class OnTextChangedListenerImpl
   }
 
   void MoveCursor(const OHOS::MiscServices::Direction direction) override {
-    LOG(INFO) << "NWebInputMethodHandler::MoveCursor ";
+    LOG(INFO) << "NWebInputMethodHandler::MoveCursor";
   }
 
  private:
   NWebInputMethodHandler* handler_;
 };
 
-// The object should be freed while keyboard hidden.
-OHOS::sptr<OHOS::MiscServices::OnTextChangedListener> g_listener = nullptr;
-
 class InputMethodTask : public CefTask {
  public:
   explicit InputMethodTask(const base::Closure& closure) : closure_(closure) {}
@@ -81,20 +88,17 @@ class InputMethodTask : public CefTask {
 };
 
 NWebInputMethodHandler::NWebInputMethodHandler()
-    : selected_from_(0), selected_to_(0) {
-  g_listener = nullptr;
-}
+    : selected_from_(0), selected_to_(0) {}
 
 NWebInputMethodHandler::~NWebInputMethodHandler() {}
 
 void NWebInputMethodHandler::Attach(CefRefPtr<CefBrowser> browser) {
   composing_text_.clear();
   browser_ = browser;
-
-  if (g_listener == nullptr) {
-    g_listener = new OnTextChangedListenerImpl(this);
+  if (inputmethod_listener_ == nullptr) {
+    inputmethod_listener_ = new OnTextChangedListenerImpl(this);
   }
-  OHOS::MiscServices::InputMethodController::GetInstance()->Attach(g_listener);
+  OHOS::MiscServices::InputMethodController::GetInstance()->Attach(inputmethod_listener_);
 }
 
 void NWebInputMethodHandler::ShowTextInput() {
@@ -183,6 +187,12 @@ void NWebInputMethodHandler::InsertTextHandlerOnUI(const std::u16string& text) {
   CefRange selection_range(0, static_cast<int>(composing_text_.length()));
   browser_->GetHost()->ImeSetComposition(CefString(composing_text_), underlines,
                                          replacement_range, selection_range);
+  // no selection
+  browser_->GetHost()->ImeFinishComposingText(false);
+  ime_text_composing_ = false;
+  selected_from_ += static_cast<int>(composing_text_.length());
+  selected_to_ += static_cast<int>(composing_text_.length());
+  composing_text_.clear();
 }
 
 void NWebInputMethodHandler::DeleteBackwardHandlerOnUI(int32_t length) {
diff --git a/src/ohos_nweb/src/nweb_inputmethod_handler.h b/src/ohos_nweb/src/nweb_inputmethod_handler.h
index 7fc624e2b3..9cb6c7c62f 100644
--- a/src/ohos_nweb/src/nweb_inputmethod_handler.h
+++ b/src/ohos_nweb/src/nweb_inputmethod_handler.h
@@ -1,10 +1,23 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OHOS_NWEB_SRC_NWEB_INPUTMETHOD_HANDLER_H_
 #define OHOS_NWEB_SRC_NWEB_INPUTMETHOD_HANDLER_H_
 
+#include "input_method_controller.h"
+
 #include "cef_delegate/nweb_inputmethod_client.h"
 
 namespace OHOS::NWeb {
@@ -37,6 +50,7 @@ class NWebInputMethodHandler : public NWebInputMethodClient {
   std::u16string composing_text_;
   int selected_from_;
   int selected_to_;
+  OHOS::sptr<OHOS::MiscServices::OnTextChangedListener> inputmethod_listener_ = nullptr;
 
   IMPLEMENT_REFCOUNTING(NWebInputMethodHandler);
   DISALLOW_COPY_AND_ASSIGN(NWebInputMethodHandler);
diff --git a/src/ohos_nweb/src/nweb_output_handler.cc b/src/ohos_nweb/src/nweb_output_handler.cc
index 1f2a5dec38..570f908ffb 100644
--- a/src/ohos_nweb/src/nweb_output_handler.cc
+++ b/src/ohos_nweb/src/nweb_output_handler.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_output_handler.h"
 
@@ -142,12 +153,6 @@ void NWebOutputHandler::StartFrameStat() {
                          (output_handler->local_render_count_ - 1) /
                          (output_handler->local_time_curr_ -
                           output_handler->local_time_base_);
-          WVLOG_W(
-              "NWeb %{public}u fps_cur=%{public}0.1f "
-              "frame_total_count=%{public}lld"
-              " frame_miss_count=%{public}lld",
-              output_handler->nweb_id_, fps_cur,
-              output_handler->render_count_, output_handler->frame_miss_count_);
           std::cout << "NWeb " << output_handler->nweb_id_
                     << " fps_cur=" << std::fixed << std::setprecision(1)
                     << fps_cur
diff --git a/src/ohos_nweb/src/nweb_output_handler.h b/src/ohos_nweb/src/nweb_output_handler.h
index 059f3d5722..165f136f66 100644
--- a/src/ohos_nweb/src/nweb_output_handler.h
+++ b/src/ohos_nweb/src/nweb_output_handler.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_OUTPUT_HANDLER_H
 #define NWEB_OUTPUT_HANDLER_H
diff --git a/src/ohos_nweb/src/nweb_render_main.cc b/src/ohos_nweb/src/nweb_render_main.cc
index b0b3122e56..a01d0e3007 100644
--- a/src/ohos_nweb/src/nweb_render_main.cc
+++ b/src/ohos_nweb/src/nweb_render_main.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
  
 #include <unistd.h>
 #include <sstream>
diff --git a/src/ohos_nweb/src/nweb_url_resource_error_impl.h b/src/ohos_nweb/src/nweb_url_resource_error_impl.h
index d935afea26..b5557badc3 100644
--- a/src/ohos_nweb/src/nweb_url_resource_error_impl.h
+++ b/src/ohos_nweb/src/nweb_url_resource_error_impl.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_URL_RESOURCE_ERROR_IMPL
 #define NWEB_URL_RESOURCE_ERROR_IMPL
diff --git a/src/ohos_nweb/src/nweb_url_resource_request_impl.cc b/src/ohos_nweb/src/nweb_url_resource_request_impl.cc
index 45b819debd..7c58f035b6 100644
--- a/src/ohos_nweb/src/nweb_url_resource_request_impl.cc
+++ b/src/ohos_nweb/src/nweb_url_resource_request_impl.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nweb_url_resource_request_impl.h"
 
diff --git a/src/ohos_nweb/src/nweb_url_resource_request_impl.h b/src/ohos_nweb/src/nweb_url_resource_request_impl.h
index 9387b49884..8e7b23c1ae 100644
--- a/src/ohos_nweb/src/nweb_url_resource_request_impl.h
+++ b/src/ohos_nweb/src/nweb_url_resource_request_impl.h
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NWEB_URL_RESOURCE_REQUEAST_IMPL_H
 #define NWEB_URL_RESOURCE_REQUEAST_IMPL_H
diff --git a/src/ohos_nweb/src/ohos_nweb_main.cc b/src/ohos_nweb/src/ohos_nweb_main.cc
index 746f9c4012..ca177b2b7b 100644
--- a/src/ohos_nweb/src/ohos_nweb_main.cc
+++ b/src/ohos_nweb/src/ohos_nweb_main.cc
@@ -1,6 +1,17 @@
-// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include <unistd.h>
 #include <dlfcn.h>
diff --git a/src/pdf/pdfium/pdfium_engine.cc b/src/pdf/pdfium/pdfium_engine.cc
index 753fc5ecf8..a82747409a 100644
--- a/src/pdf/pdfium/pdfium_engine.cc
+++ b/src/pdf/pdfium/pdfium_engine.cc
@@ -4236,7 +4236,7 @@ void PDFiumEngine::SetLinkUnderCursorForAnnotation(FPDF_ANNOTATION annot,
 void PDFiumEngine::RequestThumbnail(int page_index,
                                     float device_pixel_ratio,
                                     SendThumbnailCallback send_callback) {
-  DCHECK(PageIndexInBounds(page_index));
+  CHECK(PageIndexInBounds(page_index));
   pages_[page_index]->RequestThumbnail(device_pixel_ratio,
                                        std::move(send_callback));
 }
diff --git a/src/services/device/geolocation/ohos/location_provider_ohos.cc b/src/services/device/geolocation/ohos/location_provider_ohos.cc
index 8f3eba7d1a..a4b69fed8f 100644
--- a/src/services/device/geolocation/ohos/location_provider_ohos.cc
+++ b/src/services/device/geolocation/ohos/location_provider_ohos.cc
@@ -17,18 +17,31 @@ namespace device {
 
 // LocationProviderOhos
 LocationProviderOhos::LocationProviderOhos() {
-  locator_callback_ = this;
+  locator_callback_ = new LocationProviderCallback();
 }
 
 LocationProviderOhos::~LocationProviderOhos() {
   StopProvider();
-  if (locator_ != nullptr)
+  if (locator_ != nullptr) {
     locator_.reset();
+  }
+  if (locator_callback_ != nullptr) {
+    locator_callback_ = nullptr;
+  }
 }
 
 void LocationProviderOhos::SetUpdateCallback(
     const LocationProviderUpdateCallback& callback) {
   callback_ = callback;
+
+  locator_callback_->SetUpdateCallback(base::BindRepeating(
+      &LocationProviderOhos::ProviderUpdateCallback, base::Unretained(this)));
+}
+
+void LocationProviderOhos::ProviderUpdateCallback(
+    const mojom::Geoposition& position) {
+  if (!callback_.is_null() && is_running_)
+    callback_.Run(this, position);
 }
 
 void LocationProviderOhos::StartProvider(bool high_accuracy) {
@@ -40,18 +53,20 @@ void LocationProviderOhos::StopProvider() {
   if (!is_running_)
     return;
   is_running_ = false;
-  locator_->StopLocating(locator_callback_);
+  OHOS::sptr<OHOS::Location::ILocatorCallback> locator_call_back =
+      locator_callback_;
+  locator_->StopLocating(locator_call_back);
 }
 
 const mojom::Geoposition& LocationProviderOhos::GetPosition() {
-  return last_position_;
+  return locator_callback_->GetPosition();
 }
 
 void LocationProviderOhos::OnPermissionGranted() {
   // Nothing to do here.
 }
 
-void LocationProviderOhos::OnNewLocationAvailable(
+void LocationProviderCallback::OnNewLocationAvailable(
     const std::unique_ptr<OHOS::Location::Location>& location) {
   mojom::Geoposition position;
   position.latitude = location->GetLatitude();
@@ -67,7 +82,7 @@ void LocationProviderOhos::OnNewLocationAvailable(
   NewGeopositionReport(position);
 }
 
-void LocationProviderOhos::OnNewErrorAvailable(std::string message) {
+void LocationProviderCallback::OnNewErrorAvailable(std::string message) {
   mojom::Geoposition position_error;
   position_error.error_code =
       mojom::Geoposition::ErrorCode::POSITION_UNAVAILABLE;
@@ -82,7 +97,8 @@ void LocationProviderOhos::RequestLocationUpdate(bool high_accuracy) {
   CreateLocationManagerIfNeeded();
   if (locator_ == nullptr) {
     LOG(ERROR) << "Locator is null. Can not get location";
-    OnErrorReport(LOCATION_GET_FAILED);
+    locator_callback_->OnErrorReport(
+        LocationProviderCallback::LOCATION_GET_FAILED);
     return;
   }
 
@@ -90,14 +106,21 @@ void LocationProviderOhos::RequestLocationUpdate(bool high_accuracy) {
   std::unique_ptr<OHOS::Location::RequestConfig> requestConfig =
       std::make_unique<OHOS::Location::RequestConfig>();
   SetRequestConfig(requestConfig, high_accuracy);
-
-  locator_->StartLocating(requestConfig, locator_callback_, "location.ILocator",
-                          0, 0);
+  OHOS::sptr<OHOS::Location::ILocatorCallback> locator_call_back =
+      locator_callback_;
+  int ret = locator_->StartLocating(requestConfig, locator_call_back, "location.ILocator",
+                                    0, 0);
+  if (ret != 0) {
+    LOG(ERROR) << "StartLocating failed. Can not get location";
+    locator_callback_->OnErrorReport(
+        LocationProviderCallback::LOCATION_GET_FAILED);
+  }
 }
 
 void LocationProviderOhos::CreateLocationManagerIfNeeded() {
-  if (locator_ != nullptr)
+  if (locator_ != nullptr) {
     return;
+  }
   locator_ = std::make_unique<OHOS::Location::LocatorProxy>(
       OHOS::Location::CommonUtils::GetRemoteObject(
           OHOS::LOCATION_LOCATOR_SA_ID,
@@ -111,21 +134,25 @@ void LocationProviderOhos::SetRequestConfig(
   requestConfig->SetScenario(OHOS::Location::SCENE_UNSET);
   requestConfig->SetTimeInterval(1);
   requestConfig->SetDistanceInterval(0);
-  requestConfig->SetMaxAccuracy(0);
-  requestConfig->SetFixNumber(1);
+  requestConfig->SetMaxAccuracy(50);
+  requestConfig->SetFixNumber(0);
 }
 
-void LocationProviderOhos::NewGeopositionReport(
+void LocationProviderCallback::NewGeopositionReport(
     const mojom::Geoposition& position) {
   last_position_ = position;
   if (!callback_.is_null())
-    callback_.Run(this, position);
+    callback_.Run(position);
 }
 
-int LocationProviderOhos::OnRemoteRequest(uint32_t code,
-                                          OHOS::MessageParcel& data,
-                                          OHOS::MessageParcel& reply,
-                                          OHOS::MessageOption& option) {
+int LocationProviderCallback::OnRemoteRequest(uint32_t code,
+                                              OHOS::MessageParcel& data,
+                                              OHOS::MessageParcel& reply,
+                                              OHOS::MessageOption& option) {
+  if (data.ReadInterfaceToken() != GetDescriptor()) {
+    LOG(INFO) << "invalid token.";
+    return -1;
+  }
   switch (code) {
     case RECEIVE_LOCATION_INFO_EVENT: {
       std::unique_ptr<OHOS::Location::Location> location =
@@ -147,18 +174,14 @@ int LocationProviderOhos::OnRemoteRequest(uint32_t code,
   return 0;
 }
 
-void LocationProviderOhos::OnLocationReport(
+void LocationProviderCallback::OnLocationReport(
     const std::unique_ptr<OHOS::Location::Location>& location) {
-  if (is_running_) {
-    OnNewLocationAvailable(location);
-    StopProvider();
-  }
+  OnNewLocationAvailable(location);
 }
 
-void LocationProviderOhos::OnLocatingStatusChange(const int status) {}
+void LocationProviderCallback::OnLocatingStatusChange(const int status) {}
 
-void LocationProviderOhos::OnErrorReport(const int errorCode) {
-  StopProvider();
+void LocationProviderCallback::OnErrorReport(const int errorCode) {
   if (errorCode == LOCATION_GET_FAILED) {
     OnNewErrorAvailable("Failed to get location!");
   } else {
diff --git a/src/services/device/geolocation/ohos/location_provider_ohos.h b/src/services/device/geolocation/ohos/location_provider_ohos.h
index c005f7d123..008bba32b8 100644
--- a/src/services/device/geolocation/ohos/location_provider_ohos.h
+++ b/src/services/device/geolocation/ohos/location_provider_ohos.h
@@ -14,21 +14,17 @@
 #include <message_parcel.h>
 #include <request_config.h>
 
-#include "base/memory/scoped_refptr.h"
 #include "base/single_thread_task_runner.h"
 #include "base/threading/thread_checker.h"
 #include "services/device/public/cpp/geolocation/location_provider.h"
 #include "services/device/public/mojom/geoposition.mojom.h"
 
 namespace device {
-
-// Location provider for OpenHarmony using the platform provider over JNI.
-class LocationProviderOhos
-    : public LocationProvider,
-      public OHOS::IRemoteStub<OHOS::Location::ILocatorCallback> {
+class LocationProviderCallback
+    : public OHOS::IRemoteStub<OHOS::Location::ILocatorCallback> {
  public:
-  LocationProviderOhos();
-  ~LocationProviderOhos() override;
+  LocationProviderCallback() {}
+  ~LocationProviderCallback() = default;
 
   enum LocationErrorCode {
     LOCATION_GET_SUCCESS = 0,
@@ -36,13 +32,8 @@ class LocationProviderOhos
     LOCATION_UNKNOWN_ERROR,
   };
 
-  // LocationProvider implementation.
-  void SetUpdateCallback(
-      const LocationProviderUpdateCallback& callback) override;
-  void StartProvider(bool high_accuracy) override;
-  void StopProvider() override;
-  const mojom::Geoposition& GetPosition() override;
-  void OnPermissionGranted() override;
+  typedef base::RepeatingCallback<void(const mojom::Geoposition&)>
+      UpdateCallback;
 
   // ILocatorCallback implementation.
   virtual int OnRemoteRequest(uint32_t code,
@@ -57,6 +48,34 @@ class LocationProviderOhos
   void OnNewLocationAvailable(
       const std::unique_ptr<OHOS::Location::Location>& location);
   void OnNewErrorAvailable(std::string message);
+  void SetUpdateCallback(const UpdateCallback& callback) {
+    callback_ = callback;
+  }
+  const mojom::Geoposition& GetPosition() { return last_position_; }
+
+ private:
+  // Calls |callback_| with the new location.
+  void NewGeopositionReport(const mojom::Geoposition& position);
+
+  mojom::Geoposition last_position_;
+  UpdateCallback callback_;
+};
+
+// Location provider for OpenHarmony using the platform provider over JNI.
+class LocationProviderOhos : public LocationProvider {
+ public:
+  LocationProviderOhos();
+  ~LocationProviderOhos() override;
+
+  // LocationProvider implementation.
+  void SetUpdateCallback(
+      const LocationProviderUpdateCallback& callback) override;
+  void StartProvider(bool high_accuracy) override;
+  void StopProvider() override;
+  const mojom::Geoposition& GetPosition() override;
+  void OnPermissionGranted() override;
+
+  void ProviderUpdateCallback(const mojom::Geoposition& position);
 
  private:
   void RequestLocationUpdate(bool high_accuracy);
@@ -65,17 +84,12 @@ class LocationProviderOhos
       std::unique_ptr<OHOS::Location::RequestConfig>& requestConfig,
       bool high_accuracy);
 
-  // Calls |callback_| with the new location.
-  void NewGeopositionReport(const mojom::Geoposition& position);
-
   std::unique_ptr<OHOS::Location::LocatorProxy> locator_;
 
-  mojom::Geoposition last_position_;
-
   LocationProviderUpdateCallback callback_;
 
   bool is_running_ = false;
-  OHOS::sptr<OHOS::Location::ILocatorCallback> locator_callback_;
+  OHOS::sptr<LocationProviderCallback> locator_callback_ = nullptr;
 };
 
 }  // namespace device
diff --git a/src/services/network/public/cpp/server/http_server.cc b/src/services/network/public/cpp/server/http_server.cc
index 8f7ee43a38..c94a32b07d 100644
--- a/src/services/network/public/cpp/server/http_server.cc
+++ b/src/services/network/public/cpp/server/http_server.cc
@@ -105,8 +105,8 @@ void HttpServer::SendRaw(int connection_id,
     connection->write_watcher().Watch(
         connection->send_handle(),
         MOJO_HANDLE_SIGNAL_WRITABLE | MOJO_HANDLE_SIGNAL_PEER_CLOSED,
-        base::BindRepeating(&HttpServer::OnWritable, base::Unretained(this),
-                            connection->id()));
+        base::BindRepeating(&HttpServer::OnWritable,
+                            weak_ptr_factory_.GetWeakPtr(), connection->id()));
   }
 }
 
@@ -180,9 +180,9 @@ bool HttpServer::SetSendBufferSize(int connection_id, int32_t size) {
 }
 
 void HttpServer::DoAcceptLoop() {
-  server_socket_->Accept(
-      mojo::NullRemote(), /* observer */
-      base::BindOnce(&HttpServer::OnAcceptCompleted, base::Unretained(this)));
+  server_socket_->Accept(mojo::NullRemote(), /* observer */
+                         base::BindOnce(&HttpServer::OnAcceptCompleted,
+                                        weak_ptr_factory_.GetWeakPtr()));
 }
 
 void HttpServer::OnAcceptCompleted(
@@ -210,8 +210,8 @@ void HttpServer::OnAcceptCompleted(
         connection->receive_handle(),
         MOJO_HANDLE_SIGNAL_READABLE | MOJO_HANDLE_SIGNAL_PEER_CLOSED,
         MOJO_TRIGGER_CONDITION_SIGNALS_SATISFIED,
-        base::BindRepeating(&HttpServer::OnReadable, base::Unretained(this),
-                            connection->id()));
+        base::BindRepeating(&HttpServer::OnReadable,
+                            weak_ptr_factory_.GetWeakPtr(), connection->id()));
   }
 
   DoAcceptLoop();
diff --git a/src/storage/browser/blob/blob_registry_impl.cc b/src/storage/browser/blob/blob_registry_impl.cc
index 2479803044..e52fa941d2 100644
--- a/src/storage/browser/blob/blob_registry_impl.cc
+++ b/src/storage/browser/blob/blob_registry_impl.cc
@@ -634,6 +634,7 @@ void BlobRegistryImpl::URLStoreForOrigin(
   if (!origin.opaque() && !delegate->CanCommitURL(origin.GetURL())) {
     mojo::ReportBadMessage(
         "Non committable origin passed to BlobRegistryImpl::URLStoreForOrigin");
+    return;
   }
   auto self_owned_associated_receiver = mojo::MakeSelfOwnedAssociatedReceiver(
       std::make_unique<BlobURLStoreImpl>(origin, url_registry_),
diff --git a/src/third_party/blink/common/input/web_coalesced_input_event_mojom_traits.cc b/src/third_party/blink/common/input/web_coalesced_input_event_mojom_traits.cc
index 50fd458a6b..e6d78f448d 100644
--- a/src/third_party/blink/common/input/web_coalesced_input_event_mojom_traits.cc
+++ b/src/third_party/blink/common/input/web_coalesced_input_event_mojom_traits.cc
@@ -370,6 +370,13 @@ StructTraits<blink::mojom::EventDataView,
     return nullptr;
   const blink::WebKeyboardEvent* key_event =
       static_cast<const blink::WebKeyboardEvent*>(event->EventPointer());
+  // Assure char16_t[N] filds are null-terminated before converting
+  // them to std::u16string.
+  CHECK(std::find(std::begin(key_event->text), std::end(key_event->text), 0) <
+        std::end(key_event->text));
+  CHECK(std::find(std::begin(key_event->unmodified_text),
+                  std::end(key_event->unmodified_text),
+                  0) < std::end(key_event->unmodified_text));
   return blink::mojom::KeyData::New(
       key_event->dom_key, key_event->dom_code, key_event->windows_key_code,
       key_event->native_key_code, key_event->is_system_key,
diff --git a/src/third_party/blink/common/web_preferences/web_preferences.cc b/src/third_party/blink/common/web_preferences/web_preferences.cc
old mode 100644
new mode 100755
index b35748d818..9414c4e6c3
--- a/src/third_party/blink/common/web_preferences/web_preferences.cc
+++ b/src/third_party/blink/common/web_preferences/web_preferences.cc
@@ -122,7 +122,7 @@ WebPreferences::WebPreferences()
 #endif
       supports_multiple_windows(true),
       viewport_enabled(false),
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       viewport_meta_enabled(true),
       shrinks_viewport_contents_to_fit(true),
       viewport_style(mojom::ViewportStyle::kMobile),
@@ -155,13 +155,13 @@ WebPreferences::WebPreferences()
       text_tracks_enabled(false),
       text_track_margin_percentage(0.0f),
       immersive_mode_enabled(false),
-#if defined(OS_ANDROID) || defined(OS_MAC)
+#if defined(OS_ANDROID) || defined(OS_MAC) || defined(OS_OHOS)
       double_tap_to_zoom_enabled(true),
 #else
       double_tap_to_zoom_enabled(false),
 #endif
       fullscreen_supported(true),
-#if !defined(OS_ANDROID)
+#if !defined(OS_ANDROID) && !defined(OS_OHOS)
       text_autosizing_enabled(false),
 #else
       text_autosizing_enabled(true),
@@ -169,16 +169,16 @@ WebPreferences::WebPreferences()
       device_scale_adjustment(1.0f),
       force_enable_zoom(false),
       support_deprecated_target_density_dpi(false),
-      use_legacy_background_size_shorthand_behavior(false),
+      use_legacy_background_size_shorthand_behavior(true),
       wide_viewport_quirk(false),
-      use_wide_viewport(true),
+      use_wide_viewport(false),
       force_zero_layout_height(false),
-      viewport_meta_merge_content_quirk(false),
-      viewport_meta_non_user_scalable_quirk(false),
-      viewport_meta_zero_values_quirk(false),
+      viewport_meta_merge_content_quirk(true),
+      viewport_meta_non_user_scalable_quirk(true),
+      viewport_meta_zero_values_quirk(true),
       clobber_user_agent_initial_scale_quirk(false),
       ignore_main_frame_overflow_hidden_quirk(false),
-      report_screen_size_in_physical_pixels_quirk(false),
+      report_screen_size_in_physical_pixels_quirk(true),
       reuse_global_for_unowned_main_frame(false),
       spellcheck_enabled_by_default(true),
       video_fullscreen_orientation_lock_enabled(false),
@@ -196,7 +196,7 @@ WebPreferences::WebPreferences()
       default_minimum_page_scale_factor(1.f),
       default_maximum_page_scale_factor(3.f),
 #else
-      default_minimum_page_scale_factor(1.f),
+      default_minimum_page_scale_factor(2.f),
       default_maximum_page_scale_factor(4.f),
 #endif
       hide_download_ui(false),
diff --git a/src/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc b/src/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc
index 10829ad522..96ed045f29 100644
--- a/src/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc
+++ b/src/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc
@@ -164,7 +164,7 @@ bool StructTraits<blink::mojom::WebPreferencesDataView,
   out->double_tap_to_zoom_enabled = data.double_tap_to_zoom_enabled();
   out->fullscreen_supported = data.fullscreen_supported();
   out->text_autosizing_enabled = data.text_autosizing_enabled();
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID)  || defined(OS_OHOS)
   out->font_scale_factor = data.font_scale_factor();
   out->device_scale_adjustment = data.device_scale_adjustment();
   out->force_enable_zoom = data.force_enable_zoom();
diff --git a/src/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h b/src/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h
index ff772f7af6..5a3bcbbc36 100644
--- a/src/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h
+++ b/src/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h
@@ -546,7 +546,7 @@ struct BLINK_COMMON_EXPORT StructTraits<blink::mojom::WebPreferencesDataView,
     return r.web_app_scope;
   }
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   static float font_scale_factor(const blink::web_pref::WebPreferences& r) {
     return r.font_scale_factor;
   }
diff --git a/src/third_party/blink/public/mojom/webpreferences/web_preferences.mojom b/src/third_party/blink/public/mojom/webpreferences/web_preferences.mojom
index ba5ebe0cb8..0b4d0c90ba 100644
--- a/src/third_party/blink/public/mojom/webpreferences/web_preferences.mojom
+++ b/src/third_party/blink/public/mojom/webpreferences/web_preferences.mojom
@@ -270,91 +270,91 @@ struct WebPreferences {
   // Representation of the Web App Manifest scope if any.
   url.mojom.Url web_app_scope;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   float font_scale_factor;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   float device_scale_adjustment;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool force_enable_zoom;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   url.mojom.Url default_video_poster_url;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool support_deprecated_target_density_dpi;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool use_legacy_background_size_shorthand_behavior;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool wide_viewport_quirk;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool use_wide_viewport;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool force_zero_layout_height;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool viewport_meta_merge_content_quirk;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool viewport_meta_non_user_scalable_quirk;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool viewport_meta_zero_values_quirk;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool clobber_user_agent_initial_scale_quirk;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool ignore_main_frame_overflow_hidden_quirk;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool report_screen_size_in_physical_pixels_quirk;
 
   // Used by Android_WebView only to support legacy apps that inject script int32o
   // a top-level initial empty document and expect it to persist on navigation.
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool reuse_global_for_unowned_main_frame;
 
   // Specifies default setting for spellcheck when the spellcheck attribute is
   // not explicitly specified.
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool spellcheck_enabled_by_default;
 
   // If enabled, when a video goes fullscreen, the orientation should be locked.
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool video_fullscreen_orientation_lock_enabled;
 
   // If enabled, fullscreen should be entered/exited when the device is rotated
   // to/from the orientation of the video.
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool video_rotate_to_fullscreen_enabled;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool embedded_media_experience_enabled;
 
   // Enable 8 (#RRGGBBAA) and 4 (#RGBA) value hex colors in CSS Android
   // WebView quirk (http://crbug.com/618472).
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool css_hex_alpha_color_enabled;
 
   // Enable support for document.scrollingElement
   // WebView sets this to false to retain old documentElement behaviour
   // (http://crbug.com/761016).
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool scroll_top_left_interop_enabled;
 
   // Disable features such as offscreen canvas that depend on the viz
   // architecture of surface embedding. Android WebView does not support this
   // architecture yet.
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   bool disable_features_depending_on_viz;
 
-  [EnableIf=is_android]
+  // [EnableIf=is_android]
   // Don't accelerate small canvases to avoid crashes TODO(crbug.com/1004304)
   bool disable_accelerated_small_canvases;
 
diff --git a/src/third_party/blink/renderer/core/exported/web_view_impl.cc b/src/third_party/blink/renderer/core/exported/web_view_impl.cc
index 47e3ebb6fa..4552b8ec8c 100644
--- a/src/third_party/blink/renderer/core/exported/web_view_impl.cc
+++ b/src/third_party/blink/renderer/core/exported/web_view_impl.cc
@@ -1577,7 +1577,7 @@ void WebView::ApplyWebPreferences(const web_pref::WebPreferences& prefs,
       prefs.dont_send_key_events_to_javascript);
   settings->SetWebAppScope(WebString::FromASCII(prefs.web_app_scope.spec()));
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   settings->SetAllowCustomScrollbarInMainFrame(false);
   settings->SetAccessibilityFontScaleFactor(prefs.font_scale_factor);
   settings->SetDeviceScaleAdjustment(prefs.device_scale_adjustment);
diff --git a/src/third_party/blink/renderer/core/frame/local_frame_view.cc b/src/third_party/blink/renderer/core/frame/local_frame_view.cc
old mode 100644
new mode 100755
index 58fc719381..242a4ee59d
--- a/src/third_party/blink/renderer/core/frame/local_frame_view.cc
+++ b/src/third_party/blink/renderer/core/frame/local_frame_view.cc
@@ -216,7 +216,7 @@ constexpr int kCommitDelayDefaultInMs = 500;  // 30 frames @ 60hz
 // The maximum number of updatePlugins iterations that should be done before
 // returning.
 static const unsigned kMaxUpdatePluginsIterations = 2;
-
+static const float kInitialLayoutSizeRatio = 2.0;
 LocalFrameView::LocalFrameView(LocalFrame& frame)
     : LocalFrameView(frame, IntRect()) {
   Show();
@@ -1515,8 +1515,8 @@ void LocalFrameView::SetLayoutSize(const IntSize& size) {
   if (frame_->GetDocument() &&
       frame_->GetDocument()->Lifecycle().LifecyclePostponed())
     return;
-
-  SetLayoutSizeInternal(size);
+  IntSize size_tmp(size.Width() / kInitialLayoutSizeRatio, size.Height() / kInitialLayoutSizeRatio);
+  SetLayoutSizeInternal(size_tmp);
 }
 
 void LocalFrameView::SetLayoutSizeFixedToFrameSize(bool is_fixed) {
diff --git a/src/third_party/blink/renderer/core/page/drag_data.cc b/src/third_party/blink/renderer/core/page/drag_data.cc
index d5ace3a879..36ad9f68d3 100644
--- a/src/third_party/blink/renderer/core/page/drag_data.cc
+++ b/src/third_party/blink/renderer/core/page/drag_data.cc
@@ -131,8 +131,8 @@ DocumentFragment* DragData::AsFragment(LocalFrame* frame) const {
     platform_drag_data_->HtmlAndBaseURL(html, base_url);
     DCHECK(frame->GetDocument());
     if (DocumentFragment* fragment =
-            CreateFragmentFromMarkup(*frame->GetDocument(), html, base_url,
-                                     kDisallowScriptingAndPluginContent))
+            CreateSanitizedFragmentFromMarkupWithContext(
+                *frame->GetDocument(), html, 0, html.length(), base_url))
       return fragment;
   }
 
diff --git a/src/third_party/blink/renderer/modules/webdatabase/database_tracker.cc b/src/third_party/blink/renderer/modules/webdatabase/database_tracker.cc
index 8f2f867209..58970ecb82 100644
--- a/src/third_party/blink/renderer/modules/webdatabase/database_tracker.cc
+++ b/src/third_party/blink/renderer/modules/webdatabase/database_tracker.cc
@@ -78,9 +78,18 @@ bool DatabaseTracker::CanEstablishDatabase(DatabaseContext* database_context,
 String DatabaseTracker::FullPathForDatabase(const SecurityOrigin* origin,
                                             const String& name,
                                             bool) {
+#ifdef OS_OHOS
+    String fileName = "/data/storage/el2/base/" +
+        String(Platform::Current()->DatabaseCreateOriginIdentifier(WebSecurityOrigin(origin)));
+    if (mkdir(fileName.Utf8().c_str(), 0777) != 0) {
+      LOG(ERROR) << " database open directory failed;";
+    }
+    return fileName + "/" + name + ".db";
+#else
   return String(Platform::Current()->DatabaseCreateOriginIdentifier(
              WebSecurityOrigin(origin))) +
          "/" + name + "#";
+#endif
 }
 
 void DatabaseTracker::AddOpenDatabase(Database* database) {
diff --git a/src/third_party/blink/renderer/modules/webdatabase/sqlite/sqlite_database.cc b/src/third_party/blink/renderer/modules/webdatabase/sqlite/sqlite_database.cc
index b35b166477..19104b3812 100644
--- a/src/third_party/blink/renderer/modules/webdatabase/sqlite/sqlite_database.cc
+++ b/src/third_party/blink/renderer/modules/webdatabase/sqlite/sqlite_database.cc
@@ -46,10 +46,14 @@ std::tuple<int, sqlite3*> OpenDatabase(const String& filename) {
                               /*make_default=*/false);
 
   sqlite3* connection;
+#ifdef OS_OHOS
+   int status = sqlite3_open(filename.Utf8().c_str(), &connection);
+#else
   constexpr int open_flags =
       SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_PRIVATECACHE;
   int status = sqlite3_open_v2(filename.Utf8().c_str(), &connection, open_flags,
                                kSqliteVfsName);
+#endif
   if (status != SQLITE_OK) {
     // SQLite creates a connection handle in most cases where open fails.
     if (connection) {
diff --git a/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.cc b/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.cc
index 7aa139649f..2a46cd2464 100644
--- a/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.cc
+++ b/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.cc
@@ -31,13 +31,10 @@ class BlobBytesStreamer {
 
  public:
   BlobBytesStreamer(Vector<scoped_refptr<RawData>> data,
-                    mojo::ScopedDataPipeProducerHandle pipe,
-                    scoped_refptr<base::SequencedTaskRunner> task_runner)
+                    mojo::ScopedDataPipeProducerHandle pipe)
       : data_(std::move(data)),
         pipe_(std::move(pipe)),
-        watcher_(FROM_HERE,
-                 mojo::SimpleWatcher::ArmingPolicy::AUTOMATIC,
-                 std::move(task_runner)) {
+        watcher_(FROM_HERE, mojo::SimpleWatcher::ArmingPolicy::AUTOMATIC) {
     watcher_.Watch(pipe_.get(), MOJO_HANDLE_SIGNAL_WRITABLE,
                    MOJO_WATCH_CONDITION_SATISFIED,
                    WTF::BindRepeating(&BlobBytesStreamer::OnWritable,
@@ -45,6 +42,8 @@ class BlobBytesStreamer {
   }
 
   void OnWritable(MojoResult result, const mojo::HandleSignalsState& state) {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
     if (result == MOJO_RESULT_CANCELLED ||
         result == MOJO_RESULT_FAILED_PRECONDITION) {
       delete this;
@@ -84,15 +83,18 @@ class BlobBytesStreamer {
 
  private:
   // The index of the item currently being written.
-  size_t current_item_ = 0;
+  wtf_size_t current_item_ GUARDED_BY_CONTEXT(sequence_checker_) = 0;
   // The offset into the current item of the first byte not yet written to the
   // data pipe.
-  size_t current_item_offset_ = 0;
+  size_t current_item_offset_ GUARDED_BY_CONTEXT(sequence_checker_) = 0;
   // The data being written.
-  Vector<scoped_refptr<RawData>> data_;
+  Vector<scoped_refptr<RawData>> data_ GUARDED_BY_CONTEXT(sequence_checker_);
+
+  mojo::ScopedDataPipeProducerHandle pipe_
+      GUARDED_BY_CONTEXT(sequence_checker_);
+  mojo::SimpleWatcher watcher_ GUARDED_BY_CONTEXT(sequence_checker_);
 
-  mojo::ScopedDataPipeProducerHandle pipe_;
-  mojo::SimpleWatcher watcher_;
+  SEQUENCE_CHECKER(sequence_checker_);
 };
 
 // This keeps the process alive while blobs are being transferred.
@@ -118,31 +120,8 @@ void DecreaseChildProcessRefCount() {
 
 constexpr size_t BlobBytesProvider::kMaxConsolidatedItemSizeInBytes;
 
-// static
-BlobBytesProvider* BlobBytesProvider::CreateAndBind(
-    mojo::PendingReceiver<mojom::blink::BytesProvider> receiver) {
-  auto task_runner = base::ThreadPool::CreateSequencedTaskRunner(
-      {base::MayBlock(), base::TaskPriority::USER_VISIBLE});
-  auto provider = base::WrapUnique(new BlobBytesProvider(task_runner));
-  auto* result = provider.get();
-  // TODO(mek): Consider binding BytesProvider on the IPC thread instead, only
-  // using the MayBlock taskrunner for actual file operations.
-  PostCrossThreadTask(
-      *task_runner, FROM_HERE,
-      CrossThreadBindOnce(
-          [](std::unique_ptr<BlobBytesProvider> provider,
-             mojo::PendingReceiver<mojom::blink::BytesProvider> receiver) {
-            mojo::MakeSelfOwnedReceiver(std::move(provider),
-                                        std::move(receiver));
-          },
-          std::move(provider), std::move(receiver)));
-  return result;
-}
-
-// static
-std::unique_ptr<BlobBytesProvider> BlobBytesProvider::CreateForTesting(
-    scoped_refptr<base::SequencedTaskRunner> task_runner) {
-  return base::WrapUnique(new BlobBytesProvider(std::move(task_runner)));
+BlobBytesProvider::BlobBytesProvider() {
+  IncreaseChildProcessRefCount();
 }
 
 BlobBytesProvider::~BlobBytesProvider() {
@@ -150,6 +129,8 @@ BlobBytesProvider::~BlobBytesProvider() {
 }
 
 void BlobBytesProvider::AppendData(scoped_refptr<RawData> data) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
   if (!data_.IsEmpty()) {
     uint64_t last_offset = offsets_.IsEmpty() ? 0 : offsets_.back();
     offsets_.push_back(last_offset + data_.back()->length());
@@ -158,6 +139,8 @@ void BlobBytesProvider::AppendData(scoped_refptr<RawData> data) {
 }
 
 void BlobBytesProvider::AppendData(base::span<const char> data) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
   if (data_.IsEmpty() ||
       data_.back()->length() + data.size() > kMaxConsolidatedItemSizeInBytes) {
     AppendData(RawData::Create());
@@ -165,8 +148,30 @@ void BlobBytesProvider::AppendData(base::span<const char> data) {
   data_.back()->MutableData()->Append(data.data(), data.size());
 }
 
+void BlobBytesProvider::Bind(
+ std::unique_ptr<BlobBytesProvider> provider,
+     mojo::PendingReceiver<mojom::blink::BytesProvider> receiver) {
+      DCHECK_CALLED_ON_VALID_SEQUENCE(provider->sequence_checker_);
+        DETACH_FROM_SEQUENCE(provider->sequence_checker_);
+
+          auto task_runner = base::ThreadPool::CreateSequencedTaskRunner(
+                    {base::MayBlock(), base::TaskPriority::USER_VISIBLE});
+            // TODO(mek): Consider binding BytesProvider on the IPC thread instead, only
+            // using the MayBlock taskrunner for actual file operations.
+            PostCrossThreadTask(
+                *task_runner, FROM_HERE,
+                CrossThreadBindOnce(
+                   [](std::unique_ptr<BlobBytesProvider> provider,
+                        mojo::PendingReceiver<mojom::blink::BytesProvider> receiver) {
+                       DCHECK_CALLED_ON_VALID_SEQUENCE(provider->sequence_checker_);
+                       mojo::MakeSelfOwnedReceiver(std::move(provider),
+                                                   std::move(receiver));
+                    },
+                    std::move(provider), std::move(receiver)));
+}
+
 void BlobBytesProvider::RequestAsReply(RequestAsReplyCallback callback) {
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   // TODO(mek): Once better metrics are created we could experiment with ways
   // to reduce the number of copies of data that are made here.
   Vector<uint8_t> result;
@@ -177,9 +182,10 @@ void BlobBytesProvider::RequestAsReply(RequestAsReplyCallback callback) {
 
 void BlobBytesProvider::RequestAsStream(
     mojo::ScopedDataPipeProducerHandle pipe) {
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
   // BlobBytesStreamer will self delete when done.
-  new BlobBytesStreamer(std::move(data_), std::move(pipe), task_runner_);
+  new BlobBytesStreamer(std::move(data_), std::move(pipe));
 }
 
 void BlobBytesProvider::RequestAsFile(uint64_t source_offset,
@@ -187,7 +193,7 @@ void BlobBytesProvider::RequestAsFile(uint64_t source_offset,
                                       base::File file,
                                       uint64_t file_offset,
                                       RequestAsFileCallback callback) {
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
   if (!file.IsValid()) {
     std::move(callback).Run(base::nullopt);
@@ -255,10 +261,4 @@ void BlobBytesProvider::RequestAsFile(uint64_t source_offset,
   std::move(callback).Run(info.last_modified);
 }
 
-BlobBytesProvider::BlobBytesProvider(
-    scoped_refptr<base::SequencedTaskRunner> task_runner)
-    : task_runner_(std::move(task_runner)) {
-  IncreaseChildProcessRefCount();
-}
-
 }  // namespace blink
diff --git a/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.h b/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.h
index 59b019a6ce..eb4f778e72 100644
--- a/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.h
+++ b/src/third_party/blink/renderer/platform/blob/blob_bytes_provider.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_BLOB_BLOB_BYTES_PROVIDER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_BLOB_BLOB_BYTES_PROVIDER_H_
 
+#include "base/sequence_checker.h"
 #include "base/sequenced_task_runner.h"
 #include "third_party/blink/public/mojom/blob/blob_registry.mojom-blink-forward.h"
 #include "third_party/blink/public/mojom/blob/data_element.mojom-blink.h"
@@ -16,8 +17,8 @@ namespace blink {
 // making up a blob to the browser process, at the request of the blob service.
 //
 // Typical usage of this class creates and calls AppendData on one thread, and
-// then transfers ownership of the class to a different thread where it will be
-// bound to a mojo pipe, such that the various Request* methods are called on a
+// then transfers ownership of the class to a different thread using the `Bind`
+// method. This ensures that the various Request* methods are called on a
 // thread that is allowed to do File IO.
 class PLATFORM_EXPORT BlobBytesProvider : public mojom::blink::BytesProvider {
  public:
@@ -25,19 +26,17 @@ class PLATFORM_EXPORT BlobBytesProvider : public mojom::blink::BytesProvider {
   // data appended to the same item.
   static constexpr size_t kMaxConsolidatedItemSizeInBytes = 15 * 1024;
 
-  // Creates a new instance, and binds it on a new SequencedTaskRunner. The
-  // returned instance should only be considered valid as long as the request
-  // passed in to this method is still known to be valid.
-  static BlobBytesProvider* CreateAndBind(
-      mojo::PendingReceiver<mojom::blink::BytesProvider>);
-  static std::unique_ptr<BlobBytesProvider> CreateForTesting(
-      scoped_refptr<base::SequencedTaskRunner>);
-
+  BlobBytesProvider();
   ~BlobBytesProvider() override;
 
   void AppendData(scoped_refptr<RawData>);
   void AppendData(base::span<const char>);
 
+  // Binds `provider` to `receiver` on a threadpool task runner, transferring
+  // ownership.
+  static void Bind(std::unique_ptr<BlobBytesProvider> provider,
+                   mojo::PendingReceiver<mojom::blink::BytesProvider> receiver);
+
   // BytesProvider implementation:
   void RequestAsReply(RequestAsReplyCallback) override;
   void RequestAsStream(mojo::ScopedDataPipeProducerHandle) override;
@@ -50,17 +49,13 @@ class PLATFORM_EXPORT BlobBytesProvider : public mojom::blink::BytesProvider {
  private:
   FRIEND_TEST_ALL_PREFIXES(BlobBytesProviderTest, Consolidation);
 
-  BlobBytesProvider(scoped_refptr<base::SequencedTaskRunner>);
-
-  // The task runner this class is bound on, as well as what is used by the
-  // RequestAsStream method to monitor the data pipe.
-  scoped_refptr<base::SequencedTaskRunner> task_runner_;
-
-  Vector<scoped_refptr<RawData>> data_;
+  Vector<scoped_refptr<RawData>> data_ GUARDED_BY_CONTEXT(sequence_checker_);
   // |offsets_| always contains exactly one fewer item than |data_| (except when
   // |data_| itself is empty).
   // offsets_[x] is equal to the sum of data_[i].length for all i <= x.
-  Vector<uint64_t> offsets_;
+  Vector<uint64_t> offsets_ GUARDED_BY_CONTEXT(sequence_checker_);
+
+  SEQUENCE_CHECKER(sequence_checker_);
 };
 
 }  // namespace blink
diff --git a/src/third_party/blink/renderer/platform/blob/blob_bytes_provider_test.cc b/src/third_party/blink/renderer/platform/blob/blob_bytes_provider_test.cc
index abacfde3a7..1366396668 100644
--- a/src/third_party/blink/renderer/platform/blob/blob_bytes_provider_test.cc
+++ b/src/third_party/blink/renderer/platform/blob/blob_bytes_provider_test.cc
@@ -52,8 +52,7 @@ class BlobBytesProviderTest : public testing::Test {
 
   std::unique_ptr<BlobBytesProvider> CreateProvider(
       scoped_refptr<RawData> data = nullptr) {
-    auto result = BlobBytesProvider::CreateForTesting(
-        blink::scheduler::GetSequencedTaskRunnerForTesting());
+    auto result = std::make_unique<BlobBytesProvider>();
     if (data)
       result->AppendData(std::move(data));
     return result;
@@ -73,6 +72,7 @@ class BlobBytesProviderTest : public testing::Test {
 
 TEST_F(BlobBytesProviderTest, Consolidation) {
   auto data = CreateProvider();
+  DCHECK_CALLED_ON_VALID_SEQUENCE(data->sequence_checker_);
   data->AppendData(base::make_span("abc", 3));
   data->AppendData(base::make_span("def", 3));
   data->AppendData(base::make_span("ps1", 3));
diff --git a/src/third_party/blink/renderer/platform/blob/blob_data.cc b/src/third_party/blink/renderer/platform/blob/blob_data.cc
index a381dbc314..feeae4779a 100644
--- a/src/third_party/blink/renderer/platform/blob/blob_data.cc
+++ b/src/third_party/blink/renderer/platform/blob/blob_data.cc
@@ -106,6 +106,12 @@ BlobData::BlobData(FileCompositionStatus composition)
 BlobData::~BlobData() = default;
 
 Vector<mojom::blink::DataElementPtr> BlobData::ReleaseElements() {
+  if (last_bytes_provider_) {
+    DCHECK(last_bytes_provider_receiver_);
+    BlobBytesProvider::Bind(std::move(last_bytes_provider_),
+                            std::move(last_bytes_provider_receiver_));
+  }
+
   return std::move(elements_);
 }
 
@@ -140,16 +146,6 @@ std::unique_ptr<BlobData> BlobData::CreateForFileSystemURLWithUnknownSize(
   return data;
 }
 
-void BlobData::DetachFromCurrentThread() {
-  content_type_ = content_type_.IsolatedCopy();
-  for (auto& element : elements_) {
-    if (element->is_file_filesystem()) {
-      auto& file_element = element->get_file_filesystem();
-      file_element->url = file_element->url.Copy();
-    }
-  }
-}
-
 void BlobData::SetContentType(const String& content_type) {
   if (IsValidBlobType(content_type))
     content_type_ = content_type;
@@ -273,6 +269,7 @@ void BlobData::AppendDataInternal(base::span<const char> data,
   if (!elements_.IsEmpty() && elements_.back()->is_bytes()) {
     // Append bytes to previous element.
     DCHECK(last_bytes_provider_);
+    DCHECK(last_bytes_provider_receiver_);
     const auto& bytes_element = elements_.back()->get_bytes();
     bytes_element->length += data.size();
     if (should_embed_bytes && bytes_element->embedded_data) {
@@ -283,9 +280,18 @@ void BlobData::AppendDataInternal(base::span<const char> data,
       bytes_element->embedded_data = base::nullopt;
     }
   } else {
+    if (last_bytes_provider_) {
+      // If `last_bytes_provider_` is set, but the previous element is not a
+      // bytes element, a new BytesProvider will be created and we need to
+      // make sure to bind the previous one first.
+      DCHECK(last_bytes_provider_receiver_);
+      BlobBytesProvider::Bind(std::move(last_bytes_provider_),
+                              std::move(last_bytes_provider_receiver_));
+    }
     mojo::PendingRemote<BytesProvider> bytes_provider_remote;
-    last_bytes_provider_ = BlobBytesProvider::CreateAndBind(
-        bytes_provider_remote.InitWithNewPipeAndPassReceiver());
+    last_bytes_provider_ = std::make_unique<BlobBytesProvider>();
+    last_bytes_provider_receiver_ =
+        bytes_provider_remote.InitWithNewPipeAndPassReceiver();
 
     auto bytes_element = DataElementBytes::New(
         data.size(), base::nullopt, std::move(bytes_provider_remote));
diff --git a/src/third_party/blink/renderer/platform/blob/blob_data.h b/src/third_party/blink/renderer/platform/blob/blob_data.h
index 697c6ce501..0b627619e7 100644
--- a/src/third_party/blink/renderer/platform/blob/blob_data.h
+++ b/src/third_party/blink/renderer/platform/blob/blob_data.h
@@ -43,6 +43,7 @@
 #include "base/thread_annotations.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "mojo/public/cpp/bindings/struct_ptr.h"
+#include "third_party/blink/public/mojom/blob/data_element.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/weborigin/kurl.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/forward.h"
@@ -117,13 +118,12 @@ class PLATFORM_EXPORT BlobData {
       const KURL& file_system_url,
       const base::Optional<base::Time>& expected_modification_time);
 
-  // Detaches from current thread so that it can be passed to another thread.
-  void DetachFromCurrentThread();
+
 
   const String& ContentType() const { return content_type_; }
   void SetContentType(const String&);
 
-  const Vector<mojom::blink::DataElementPtr>& Elements() const {
+  const Vector<mojom::blink::DataElementPtr>& ElementsForTesting() const {
     return elements_;
   }
   Vector<mojom::blink::DataElementPtr> ReleaseElements();
@@ -165,7 +165,14 @@ class PLATFORM_EXPORT BlobData {
 
   Vector<mojom::blink::DataElementPtr> elements_;
   size_t current_memory_population_ = 0;
-  BlobBytesProvider* last_bytes_provider_ = nullptr;
+  // These two members are used to combine multiple consecutive 'bytes' elements
+  // (as created by `AppendBytes`, `AppendData` or `AppendText`) into a single
+  // element. When one has a value the other also has a value. Before using
+  // `elements_` to actually create a blob, `last_bytes_provider_` should be
+  // bound to `last_bytes_provider_receiver_`.
+  std::unique_ptr<BlobBytesProvider> last_bytes_provider_;
+  mojo::PendingReceiver<mojom::blink::BytesProvider>
+      last_bytes_provider_receiver_;
 
   DISALLOW_COPY_AND_ASSIGN(BlobData);
 };
diff --git a/src/third_party/blink/renderer/platform/blob/blob_data_test.cc b/src/third_party/blink/renderer/platform/blob/blob_data_test.cc
index b515e0b11a..b0e2aae532 100644
--- a/src/third_party/blink/renderer/platform/blob/blob_data_test.cc
+++ b/src/third_party/blink/renderer/platform/blob/blob_data_test.cc
@@ -313,7 +313,7 @@ TEST_F(BlobDataHandleTest, CreateFromMergedBytes) {
   auto data = std::make_unique<BlobData>();
   data->AppendBytes(medium_test_data_.data(), medium_test_data_.size());
   data->AppendBytes(small_test_data_.data(), small_test_data_.size());
-  EXPECT_EQ(1u, data->Elements().size());
+  EXPECT_EQ(1u, data->ElementsForTesting().size());
 
   Vector<uint8_t> expected_data = medium_test_data_;
   expected_data.AppendVector(small_test_data_);
@@ -329,7 +329,7 @@ TEST_F(BlobDataHandleTest, CreateFromMergedLargeAndSmallBytes) {
   auto data = std::make_unique<BlobData>();
   data->AppendBytes(large_test_data_.data(), large_test_data_.size());
   data->AppendBytes(small_test_data_.data(), small_test_data_.size());
-  EXPECT_EQ(1u, data->Elements().size());
+  EXPECT_EQ(1u, data->ElementsForTesting().size());
 
   Vector<uint8_t> expected_data = large_test_data_;
   expected_data.AppendVector(small_test_data_);
@@ -345,7 +345,7 @@ TEST_F(BlobDataHandleTest, CreateFromMergedSmallAndLargeBytes) {
   auto data = std::make_unique<BlobData>();
   data->AppendBytes(small_test_data_.data(), small_test_data_.size());
   data->AppendBytes(large_test_data_.data(), large_test_data_.size());
-  EXPECT_EQ(1u, data->Elements().size());
+  EXPECT_EQ(1u, data->ElementsForTesting().size());
 
   Vector<uint8_t> expected_data = small_test_data_;
   expected_data.AppendVector(large_test_data_);
diff --git a/src/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc b/src/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
index 8355cb96cb..04880ad2c1 100644
--- a/src/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
+++ b/src/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
@@ -3996,8 +3996,10 @@ bool WebGLImageConversion::ExtractTextureData(
   data.resize(width * height * bytes_per_pixel);
 
   unsigned image_size_in_bytes, skip_size_in_bytes;
-  ComputeImageSizeInBytes(format, type, width, height, 1, unpack_params,
-                          &image_size_in_bytes, nullptr, &skip_size_in_bytes);
+  if (ComputeImageSizeInBytes(format, type, width, height, 1, unpack_params,
+                              &image_size_in_bytes, nullptr,
+                              &skip_size_in_bytes) != GL_NO_ERROR)
+    return false;
   const uint8_t* src_data = static_cast<const uint8_t*>(pixels);
   if (skip_size_in_bytes) {
     src_data += skip_size_in_bytes;
diff --git a/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.cc b/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.cc
index 33552b6c6d..0642aabc26 100644
--- a/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.cc
+++ b/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.cc
@@ -16,6 +16,7 @@
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/mojom/devtools/console_message.mojom-blink.h"
 #include "third_party/blink/public/platform/platform.h"
+#include "third_party/blink/renderer/platform/heap/persistent.h"
 #include "third_party/blink/renderer/platform/instrumentation/histogram.h"
 #include "third_party/blink/renderer/platform/loader/fetch/console_logger.h"
 #include "third_party/blink/renderer/platform/loader/fetch/loading_behavior_observer.h"
@@ -23,6 +24,7 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/scheduler/public/aggregated_metric_reporter.h"
 #include "third_party/blink/renderer/platform/scheduler/public/frame_status.h"
+#include "third_party/blink/renderer/platform/wtf/functional.h"
 
 namespace blink {
 
@@ -104,7 +106,9 @@ ResourceLoadScheduler::ResourceLoadScheduler(
                                kTightLimitForRendererSideResourceScheduler);
 
   scheduler_observer_handle_ = frame_or_worker_scheduler->AddLifecycleObserver(
-      FrameScheduler::ObserverType::kLoader, this);
+      FrameScheduler::ObserverType::kLoader,
+      WTF::BindRepeating(&ResourceLoadScheduler::OnLifecycleStateChanged,
+                         WrapWeakPersistent(this)));
 }
 
 ResourceLoadScheduler::~ResourceLoadScheduler() = default;
diff --git a/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.h b/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.h
index 7d824a1b94..ca1fc48d8d 100644
--- a/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.h
+++ b/src/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.h
@@ -89,8 +89,7 @@ class PLATFORM_EXPORT ResourceLoadSchedulerClient
 //     and the milestones being experimented with are first paint and first
 //     contentful paint so far.
 class PLATFORM_EXPORT ResourceLoadScheduler final
-    : public GarbageCollected<ResourceLoadScheduler>,
-      public FrameOrWorkerScheduler::Observer {
+    : public GarbageCollected<ResourceLoadScheduler> {
  public:
   // An option to use in calling Request(). If kCanNotBeStoppedOrThrottled is
   // specified, the request should be granted and Run() should be called
@@ -176,7 +175,7 @@ class PLATFORM_EXPORT ResourceLoadScheduler final
                         FrameOrWorkerScheduler*,
                         DetachableConsoleLogger& console_logger,
                         LoadingBehaviorObserver* loading_behavior_observer);
-  ~ResourceLoadScheduler() override;
+  ~ResourceLoadScheduler();
 
   void Trace(Visitor*) const;
 
@@ -221,8 +220,8 @@ class PLATFORM_EXPORT ResourceLoadScheduler final
   }
   void SetOutstandingLimitForTesting(size_t tight_limit, size_t normal_limit);
 
-  // FrameOrWorkerScheduler::Observer overrides:
-  void OnLifecycleStateChanged(scheduler::SchedulingLifecycleState) override;
+  // FrameOrWorkerScheduler lifecycle observer callback.
+  void OnLifecycleStateChanged(scheduler::SchedulingLifecycleState);
 
   // The caller is the owner of the |clock|. The |clock| must outlive the
   // ResourceLoadScheduler.
diff --git a/src/third_party/blink/renderer/platform/runtime_enabled_features.json5 b/src/third_party/blink/renderer/platform/runtime_enabled_features.json5
index 955dd1ee1e..71b5be9b34 100644
--- a/src/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/src/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -1228,7 +1228,7 @@
     },
     {
       name: "MediaCapture",
-      status: {"Android": "stable"},
+      status: "stable",
     },
     {
       name: "MediaCaptureDepthVideoKind",
diff --git a/src/third_party/blink/renderer/platform/scheduler/common/frame_or_worker_scheduler.cc b/src/third_party/blink/renderer/platform/scheduler/common/frame_or_worker_scheduler.cc
index d84ae60ddc..ef22c49c9d 100644
--- a/src/third_party/blink/renderer/platform/scheduler/common/frame_or_worker_scheduler.cc
+++ b/src/third_party/blink/renderer/platform/scheduler/common/frame_or_worker_scheduler.cc
@@ -4,16 +4,20 @@
 
 #include "third_party/blink/renderer/platform/scheduler/public/frame_or_worker_scheduler.h"
 
+#include <memory>
+#include <utility>
+
+#include "base/callback.h"
+
 namespace blink {
 
 FrameOrWorkerScheduler::LifecycleObserverHandle::LifecycleObserverHandle(
-    FrameOrWorkerScheduler* scheduler,
-    Observer* observer)
-    : scheduler_(scheduler->GetWeakPtr()), observer_(observer) {}
+    FrameOrWorkerScheduler* scheduler)
+    : scheduler_(scheduler->GetWeakPtr()) {}
 
 FrameOrWorkerScheduler::LifecycleObserverHandle::~LifecycleObserverHandle() {
   if (scheduler_)
-    scheduler_->RemoveLifecycleObserver(observer_);
+    scheduler_->RemoveLifecycleObserver(this);
 }
 
 FrameOrWorkerScheduler::SchedulingAffectingFeatureHandle::
@@ -68,25 +72,28 @@ void FrameOrWorkerScheduler::RegisterStickyFeature(
 }
 
 std::unique_ptr<FrameOrWorkerScheduler::LifecycleObserverHandle>
-FrameOrWorkerScheduler::AddLifecycleObserver(ObserverType type,
-                                             Observer* observer) {
-  DCHECK(observer);
-  observer->OnLifecycleStateChanged(CalculateLifecycleState(type));
-  lifecycle_observers_.Set(observer, type);
-  return std::make_unique<LifecycleObserverHandle>(this, observer);
+FrameOrWorkerScheduler::AddLifecycleObserver(
+    ObserverType type,
+    OnLifecycleStateChangedCallback callback) {
+  callback.Run(CalculateLifecycleState(type));
+  auto handle = std::make_unique<LifecycleObserverHandle>(this);
+  lifecycle_observers_.Set(
+      handle.get(), std::make_unique<ObserverState>(type, std::move(callback)));
+  return handle;
 }
 
-void FrameOrWorkerScheduler::RemoveLifecycleObserver(Observer* observer) {
-  DCHECK(observer);
-  const auto found = lifecycle_observers_.find(observer);
+void FrameOrWorkerScheduler::RemoveLifecycleObserver(
+    LifecycleObserverHandle* handle) {
+  DCHECK(handle);
+  const auto found = lifecycle_observers_.find(handle);
   DCHECK(lifecycle_observers_.end() != found);
   lifecycle_observers_.erase(found);
 }
 
 void FrameOrWorkerScheduler::NotifyLifecycleObservers() {
   for (const auto& observer : lifecycle_observers_) {
-    observer.key->OnLifecycleStateChanged(
-        CalculateLifecycleState(observer.value));
+    observer.value->GetCallback().Run(
+        CalculateLifecycleState(observer.value->GetObserverType()));
   }
 }
 
@@ -99,4 +106,11 @@ base::WeakPtr<FrameOrWorkerScheduler> FrameOrWorkerScheduler::GetWeakPtr() {
   return weak_factory_.GetWeakPtr();
 }
 
+FrameOrWorkerScheduler::ObserverState::ObserverState(
+    FrameOrWorkerScheduler::ObserverType observer_type,
+    FrameOrWorkerScheduler::OnLifecycleStateChangedCallback callback)
+    : observer_type_(observer_type), callback_(callback) {}
+
+FrameOrWorkerScheduler::ObserverState::~ObserverState() = default;
+
 }  // namespace blink
diff --git a/src/third_party/blink/renderer/platform/scheduler/main_thread/frame_scheduler_impl_unittest.cc b/src/third_party/blink/renderer/platform/scheduler/main_thread/frame_scheduler_impl_unittest.cc
index b4be66f898..c6719f0fad 100644
--- a/src/third_party/blink/renderer/platform/scheduler/main_thread/frame_scheduler_impl_unittest.cc
+++ b/src/third_party/blink/renderer/platform/scheduler/main_thread/frame_scheduler_impl_unittest.cc
@@ -496,7 +496,7 @@ class FrameSchedulerImplStopInBackgroundDisabledTest
 
 namespace {
 
-class MockLifecycleObserver final : public FrameScheduler::Observer {
+class MockLifecycleObserver {
  public:
   MockLifecycleObserver()
       : not_throttled_count_(0u),
@@ -516,7 +516,7 @@ class MockLifecycleObserver final : public FrameScheduler::Observer {
     EXPECT_EQ(stopped_count_expectation, stopped_count_) << from.ToString();
   }
 
-  void OnLifecycleStateChanged(SchedulingLifecycleState state) override {
+  void OnLifecycleStateChanged(SchedulingLifecycleState state) {
     switch (state) {
       case SchedulingLifecycleState::kNotThrottled:
         not_throttled_count_++;
@@ -534,6 +534,11 @@ class MockLifecycleObserver final : public FrameScheduler::Observer {
     }
   }
 
+  FrameOrWorkerScheduler::OnLifecycleStateChangedCallback GetCallback() {
+    return base::BindRepeating(&MockLifecycleObserver::OnLifecycleStateChanged,
+                               base::Unretained(this));
+  }
+
  private:
   size_t not_throttled_count_;
   size_t hidden_count_;
@@ -1110,7 +1115,7 @@ TEST_F(FrameSchedulerImplTestWithUnfreezableLoading,
   EXPECT_EQ(2, counter);
 }
 
-// Tests if throttling observer interfaces work.
+// Tests if throttling observer callbacks work.
 TEST_F(FrameSchedulerImplTest, LifecycleObserver) {
   std::unique_ptr<MockLifecycleObserver> observer =
       std::make_unique<MockLifecycleObserver>();
@@ -1124,7 +1129,7 @@ TEST_F(FrameSchedulerImplTest, LifecycleObserver) {
                                throttled_count, stopped_count);
 
   auto observer_handle = frame_scheduler_->AddLifecycleObserver(
-      FrameScheduler::ObserverType::kLoader, observer.get());
+      FrameScheduler::ObserverType::kLoader, observer->GetCallback());
 
   // Initial state should be synchronously notified here.
   // We assume kNotThrottled is notified as an initial state, but it could
@@ -1223,10 +1228,11 @@ TEST_F(FrameSchedulerImplTest, SubesourceLoadingPaused) {
 
   // Adding the observers should recieve a non-throttled response
   auto loader_observer_handle = frame_scheduler_->AddLifecycleObserver(
-      FrameScheduler::ObserverType::kLoader, loader_observer.get());
+      FrameScheduler::ObserverType::kLoader, loader_observer->GetCallback());
 
   auto worker_observer_handle = frame_scheduler_->AddLifecycleObserver(
-      FrameScheduler::ObserverType::kWorkerScheduler, worker_observer.get());
+      FrameScheduler::ObserverType::kWorkerScheduler,
+      worker_observer->GetCallback());
 
   loader_observer->CheckObserverState(
       FROM_HERE, ++loader_not_throttled_count, loader_hidden_count,
@@ -1253,7 +1259,7 @@ TEST_F(FrameSchedulerImplTest, SubesourceLoadingPaused) {
     auto loader_observer_added_after_stopped_handle =
         frame_scheduler_->AddLifecycleObserver(
             FrameScheduler::ObserverType::kLoader,
-            loader_observer_added_after_stopped.get());
+            loader_observer_added_after_stopped->GetCallback());
     // This observer should see stopped when added.
     loader_observer_added_after_stopped->CheckObserverState(FROM_HERE, 0, 0, 0,
                                                             1u);
diff --git a/src/third_party/blink/renderer/platform/scheduler/public/frame_or_worker_scheduler.h b/src/third_party/blink/renderer/platform/scheduler/public/frame_or_worker_scheduler.h
index 8b7cf12337..e8c8ed5948 100644
--- a/src/third_party/blink/renderer/platform/scheduler/public/frame_or_worker_scheduler.h
+++ b/src/third_party/blink/renderer/platform/scheduler/public/frame_or_worker_scheduler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_SCHEDULER_PUBLIC_FRAME_OR_WORKER_SCHEDULER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_SCHEDULER_PUBLIC_FRAME_OR_WORKER_SCHEDULER_H_
 
+#include "base/callback.h"
 #include "base/memory/weak_ptr.h"
 #include "base/types/strong_alias.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -24,28 +25,19 @@ class PLATFORM_EXPORT FrameOrWorkerScheduler {
   // Observer type that regulates conditions to invoke callbacks.
   enum class ObserverType { kLoader, kWorkerScheduler };
 
-  // Observer interface to receive scheduling policy change events.
-  class Observer {
-   public:
-    virtual ~Observer() = default;
-
-    // Notified when throttling state is changed. May be called consecutively
-    // with the same value.
-    virtual void OnLifecycleStateChanged(
-        scheduler::SchedulingLifecycleState) = 0;
-  };
+// Callback type for receiving scheduling policy change events.
+  using OnLifecycleStateChangedCallback =
+      base::RepeatingCallback<void(scheduler::SchedulingLifecycleState)>;
 
   class PLATFORM_EXPORT LifecycleObserverHandle {
     USING_FAST_MALLOC(LifecycleObserverHandle);
 
    public:
-    LifecycleObserverHandle(FrameOrWorkerScheduler* scheduler,
-                            Observer* observer);
+    explicit LifecycleObserverHandle(FrameOrWorkerScheduler* scheduler);
     ~LifecycleObserverHandle();
 
    private:
     base::WeakPtr<FrameOrWorkerScheduler> scheduler_;
-    Observer* observer_;
 
     DISALLOW_COPY_AND_ASSIGN(LifecycleObserverHandle);
   };
@@ -109,14 +101,21 @@ class PLATFORM_EXPORT FrameOrWorkerScheduler {
   void RegisterStickyFeature(SchedulingPolicy::Feature feature,
                              SchedulingPolicy policy);
 
-  // Adds an Observer instance to be notified on scheduling policy changed.
-  // When an Observer is added, the initial state will be notified synchronously
-  // through the Observer interface.
-  // A RAII handle is returned and observer is unregistered when the handle is
-  // destroyed.
-  std::unique_ptr<LifecycleObserverHandle> AddLifecycleObserver(ObserverType,
-                                                                Observer*)
-      WARN_UNUSED_RESULT;
+  // Adds an observer callback to be notified on scheduling policy changed.
+  // When a callback is added, the initial state will be notified synchronously
+  // through the callback. The callback may be invoked consecutively with the
+  // same value. Returns a RAII handle that unregisters the callback when the
+  // handle is destroyed.
+  //
+  // New usage outside of platform/ should be rare. Prefer using
+  // ExecutionContextLifecycleStateObserver to observe paused and frozenness
+  // changes and PageVisibilityObserver to observe visibility changes. One
+  // exception is that this observer enables observing visibility changes of the
+  // associated page in workers, whereas PageVisibilityObserver does not
+  // (crbug.com/1286570).
+  std::unique_ptr<LifecycleObserverHandle> AddLifecycleObserver(
+      ObserverType,
+      OnLifecycleStateChangedCallback) WARN_UNUSED_RESULT;
 
   virtual FrameScheduler* ToFrameScheduler() { return nullptr; }
 
@@ -140,10 +139,25 @@ class PLATFORM_EXPORT FrameOrWorkerScheduler {
   virtual base::WeakPtr<FrameOrWorkerScheduler> GetDocumentBoundWeakPtr();
 
  private:
-  void RemoveLifecycleObserver(Observer* observer);
+  class ObserverState {
+   public:
+    ObserverState(ObserverType, OnLifecycleStateChangedCallback);
+    ObserverState(const ObserverState&) = delete;
+    ObserverState& operator=(const ObserverState&) = delete;
+    ~ObserverState();
+
+    ObserverType GetObserverType() const { return observer_type_; }
+    OnLifecycleStateChangedCallback& GetCallback() { return callback_; }
+
+   private:
+    ObserverType observer_type_;
+    OnLifecycleStateChangedCallback callback_;
+  };
+
+  void RemoveLifecycleObserver(LifecycleObserverHandle* handle);
 
-  // Observers are not owned by the scheduler.
-  HashMap<Observer*, ObserverType> lifecycle_observers_;
+  HashMap<LifecycleObserverHandle*, std::unique_ptr<ObserverState>>
+      lifecycle_observers_;
   base::WeakPtrFactory<FrameOrWorkerScheduler> weak_factory_{this};
 };
 
diff --git a/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.cc b/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.cc
index 3ff3afde1c..9d73ff80b2 100644
--- a/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.cc
+++ b/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.cc
@@ -16,7 +16,9 @@ namespace scheduler {
 WorkerSchedulerProxy::WorkerSchedulerProxy(FrameOrWorkerScheduler* scheduler) {
   DCHECK(scheduler);
   throttling_observer_handle_ = scheduler->AddLifecycleObserver(
-      FrameOrWorkerScheduler::ObserverType::kWorkerScheduler, this);
+      FrameOrWorkerScheduler::ObserverType::kWorkerScheduler,
+      base::BindRepeating(&WorkerSchedulerProxy::OnLifecycleStateChanged,
+                          base::Unretained(this)));
   if (FrameScheduler* frame_scheduler = scheduler->ToFrameScheduler()) {
     parent_frame_type_ = GetFrameOriginType(frame_scheduler);
     initial_frame_status_ = GetFrameStatus(frame_scheduler);
diff --git a/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.h b/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.h
index b72d4eddab..39662fff73 100644
--- a/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.h
+++ b/src/third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.h
@@ -30,17 +30,15 @@ class WorkerScheduler;
 // on the parent thread. It's passed to WorkerScheduler during its
 // construction. Given that DedicatedWorkerThread object outlives worker thread,
 // this class outlives worker thread too.
-class PLATFORM_EXPORT WorkerSchedulerProxy
-    : public FrameOrWorkerScheduler::Observer {
+class PLATFORM_EXPORT WorkerSchedulerProxy {
  public:
   explicit WorkerSchedulerProxy(FrameOrWorkerScheduler* scheduler);
-  ~WorkerSchedulerProxy() override;
+  ~WorkerSchedulerProxy();
 
   void OnWorkerSchedulerCreated(
       base::WeakPtr<WorkerScheduler> worker_scheduler);
 
-  void OnLifecycleStateChanged(
-      SchedulingLifecycleState lifecycle_state) override;
+  void OnLifecycleStateChanged(SchedulingLifecycleState lifecycle_state);
 
   // Accessed only during init.
   SchedulingLifecycleState lifecycle_state() const {
diff --git a/src/third_party/blink/web_tests/editing/pasteboard/drag-and-drop-svg-use-sanitize.html b/src/third_party/blink/web_tests/editing/pasteboard/drag-and-drop-svg-use-sanitize.html
new file mode 100644
index 0000000000..58551d2834
--- /dev/null
+++ b/src/third_party/blink/web_tests/editing/pasteboard/drag-and-drop-svg-use-sanitize.html
@@ -0,0 +1,47 @@
+<!doctype html>
+<script src="../../resources/testharness.js"></script>
+<script src="../../resources/testharnessreport.js"></script>
+
+<div id="drag-from" draggable=true>Drag from</div>
+<div id="drag-to" contenteditable>Drag to</div>
+
+<script>
+function computePoint(element) {
+  return {
+     x: element.offsetLeft + element.offsetWidth / 2,
+     y: element.offsetTop + element.offsetHeight / 2
+  };
+}
+
+let dragged = false;
+let executed = false;
+const payload = `
+  <svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg'&gt;&lt;image href='fake' onerror='executed=true' /&gt;&lt;/svg&gt;#x" />
+`;
+
+const dragFrom = document.getElementById('drag-from');
+dragFrom.ondragstart = event => {
+  dragged = true;
+  event.dataTransfer.setData('text/html', payload);
+}
+
+const dragTo = document.getElementById('drag-to');
+
+promise_test(async test => {
+  assert_own_property(window, 'eventSender', 'This test requires eventSender to simulate drag and drop');
+
+  const fromPoint = computePoint(dragFrom);
+  eventSender.mouseMoveTo(fromPoint.x, fromPoint.y);
+  eventSender.mouseDown();
+
+  const toPoint = computePoint(dragTo);
+  eventSender.mouseMoveTo(toPoint.x, toPoint.y);
+  eventSender.mouseUp();
+
+  assert_true(dragged, 'Element should be dragged');
+
+  // The 'error' event is dispatched asynchronously.
+  await new Promise(resolve => test.step_timeout(resolve, 100));
+  assert_false(executed, 'Script should be blocked');
+}, 'Script in SVG use href should be sanitized');
+</script>
diff --git a/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent-expected.txt b/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent-expected.txt
index 890dfe3338..d945321a90 100644
--- a/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent-expected.txt
+++ b/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent-expected.txt
@@ -34,4 +34,6 @@ keyCode: 16
 location: 2
 code: ShiftRight
 
+Expect error for invalid text or unmodifiedText:
+Error: Invalid 'text' parameter
 
diff --git a/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent.js b/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent.js
index 405a599a64..0a9846f6fa 100644
--- a/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent.js
+++ b/src/third_party/blink/web_tests/inspector-protocol/input/dispatchKeyEvent.js
@@ -80,5 +80,13 @@
   }));
 
   testRunner.log(await session.evaluate(`window.logs.join('\\n')`));
+
+  testRunner.log('Expect error for invalid text or unmodifiedText:')
+  dumpError(await dp.Input.dispatchKeyEvent({
+    type: 'char',
+    text: 'oops',
+    unmodifiedText: 'SNAP'
+  }));
+
   testRunner.completeTest();
 })
diff --git a/src/third_party/blink/web_tests/wpt_internal/fenced_frame/restrict-size.https.html b/src/third_party/blink/web_tests/wpt_internal/fenced_frame/restrict-size.https.html
new file mode 100644
index 0000000000..5668407d7e
--- /dev/null
+++ b/src/third_party/blink/web_tests/wpt_internal/fenced_frame/restrict-size.https.html
@@ -0,0 +1,15 @@
+<!DOCTYPE html>
+<title>Test fencedframe size restrictions in opaque ads mode.</title>
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="/common/utils.js"></script>
+<script src="/common/dispatcher/dispatcher.js"></script>
+<script src="resources/utils.js"></script>
+
+<body>
+<script>
+promise_test(async () => {
+  const frame = attachFencedFrameContext();
+}, 'restrict fencedframe size');
+</script>
+</body>
diff --git a/src/third_party/freetype-testing/src/fuzzing/corpora/truetype-render/oss-fuzz/CVE-2020-15999.ttf b/src/third_party/freetype-testing/src/fuzzing/corpora/truetype-render/oss-fuzz/CVE-2020-15999.ttf
deleted file mode 100644
index 202c1948b3..0000000000
Binary files a/src/third_party/freetype-testing/src/fuzzing/corpora/truetype-render/oss-fuzz/CVE-2020-15999.ttf and /dev/null differ
diff --git a/src/third_party/freetype/README.chromium b/src/third_party/freetype/README.chromium
index 8a5d441992..fadd7cdc14 100644
--- a/src/third_party/freetype/README.chromium
+++ b/src/third_party/freetype/README.chromium
@@ -1,7 +1,7 @@
 Name: FreeType
 URL: http://www.freetype.org/
-Version: VER-2-10-4-188-ge9c50fa77
-Revision: e9c50fa77de58b749b4b95706f7b55bfff0dd27f
+Version: VER-2-10-4-0
+Revision: 6a2b3e4007e794bfc6c91030d0ed987f925164a8
 CPEPrefix: cpe:/a:freetype:freetype:2.10.4
 License: Custom license "inspired by the BSD, Artistic, and IJG (Independent
          JPEG Group) licenses"
diff --git a/src/third_party/icu/README.chromium b/src/third_party/icu/README.chromium
index 4b1af52ae4..de327c3caf 100644
--- a/src/third_party/icu/README.chromium
+++ b/src/third_party/icu/README.chromium
@@ -316,3 +316,7 @@ D. Local Modifications
     patches/fuchsia.patch
     - context bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1184527
 
+19. Patch i18n/formatted_string_builder to fix int32_t overflow bug
+    patches/formatted_string_builder.patch
+  - https://github.com/unicode-org/icu/pull/2070
+  - https://unicode-org.atlassian.net/browse/ICU-22005
diff --git a/src/third_party/icu/patches/formatted_string_builder.patch b/src/third_party/icu/patches/formatted_string_builder.patch
index ce9111e5f5..07381496da 100644
--- a/src/third_party/icu/patches/formatted_string_builder.patch
+++ b/src/third_party/icu/patches/formatted_string_builder.patch
@@ -29,3 +29,128 @@ index 5aabc31c..b370f14f 100644
      uprv_memmove2(getCharPtr() + position,
              getCharPtr() + position + count,
              sizeof(char16_t) * (fLength - index - count));
+diff --git a/source/i18n/formatted_string_builder.cpp b/source/i18n/formatted_string_builder.cpp
+index 73407864..628fbea8 100644
+--- a/source/i18n/formatted_string_builder.cpp
++++ b/source/i18n/formatted_string_builder.cpp
+@@ -6,6 +6,7 @@
+ #if !UCONFIG_NO_FORMATTING
+ 
+ #include "formatted_string_builder.h"
++#include "putilimp.h"
+ #include "unicode/ustring.h"
+ #include "unicode/utf16.h"
+ #include "unicode/unum.h" // for UNumberFormatFields literals
+@@ -197,6 +198,9 @@ FormattedStringBuilder::splice(int32_t startThis, int32_t endThis,  const Unicod
+     int32_t thisLength = endThis - startThis;
+     int32_t otherLength = endOther - startOther;
+     int32_t count = otherLength - thisLength;
++    if (U_FAILURE(status)) {
++        return count;
++    }
+     int32_t position;
+     if (count > 0) {
+         // Overall, chars need to be added.
+@@ -221,6 +225,9 @@ int32_t FormattedStringBuilder::append(const FormattedStringBuilder &other, UErr
+ 
+ int32_t
+ FormattedStringBuilder::insert(int32_t index, const FormattedStringBuilder &other, UErrorCode &status) {
++    if (U_FAILURE(status)) {
++        return 0;
++    }
+     if (this == &other) {
+         status = U_ILLEGAL_ARGUMENT_ERROR;
+         return 0;
+@@ -255,12 +262,18 @@ int32_t FormattedStringBuilder::prepareForInsert(int32_t index, int32_t count, U
+     U_ASSERT(index >= 0);
+     U_ASSERT(index <= fLength);
+     U_ASSERT(count >= 0);
++    U_ASSERT(fZero >= 0);
++    U_ASSERT(fLength >= 0);
++    U_ASSERT(getCapacity() - fZero >= fLength);
++    if (U_FAILURE(status)) {
++        return count;
++    }
+     if (index == 0 && fZero - count >= 0) {
+         // Append to start
+         fZero -= count;
+         fLength += count;
+         return fZero;
+-    } else if (index == fLength && fZero + fLength + count < getCapacity()) {
++    } else if (index == fLength && count <= getCapacity() - fZero - fLength) {
+         // Append to end
+         fLength += count;
+         return fZero + fLength - count;
+@@ -275,18 +288,26 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
+     int32_t oldZero = fZero;
+     char16_t *oldChars = getCharPtr();
+     Field *oldFields = getFieldPtr();
+-    if (fLength + count > oldCapacity) {
+-        if ((fLength + count) > INT32_MAX / 2) {
+-            // If we continue, then newCapacity will overflow int32_t in the next line.
++    int32_t newLength;
++    if (uprv_add32_overflow(fLength, count, &newLength)) {
++        status = U_INPUT_TOO_LONG_ERROR;
++        return -1;
++    }
++    int32_t newZero;
++    if (newLength > oldCapacity) {
++        if (newLength > INT32_MAX / 2) {
++            // We do not support more than 1G char16_t in this code because
++            // dealing with >2G *bytes* can cause subtle bugs.
+             status = U_INPUT_TOO_LONG_ERROR;
+             return -1;
+         }
+-        int32_t newCapacity = (fLength + count) * 2;
+-        int32_t newZero = newCapacity / 2 - (fLength + count) / 2;
++        // Keep newCapacity also to at most 1G char16_t.
++        int32_t newCapacity = newLength * 2;
++        newZero = (newCapacity - newLength) / 2;
+ 
+         // C++ note: malloc appears in two places: here and in the assignment operator.
+-        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * newCapacity));
+-        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * newCapacity));
++        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * static_cast<size_t>(newCapacity)));
++        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * static_cast<size_t>(newCapacity)));
+         if (newChars == nullptr || newFields == nullptr) {
+             uprv_free(newChars);
+             uprv_free(newFields);
+@@ -315,10 +336,8 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
+         fChars.heap.capacity = newCapacity;
+         fFields.heap.ptr = newFields;
+         fFields.heap.capacity = newCapacity;
+-        fZero = newZero;
+-        fLength += count;
+     } else {
+-        int32_t newZero = oldCapacity / 2 - (fLength + count) / 2;
++        newZero = (oldCapacity - newLength) / 2;
+ 
+         // C++ note: memmove is required because src and dest may overlap.
+         // First copy the entire string to the location of the prefix, and then move the suffix
+@@ -331,18 +350,20 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
+         uprv_memmove2(oldFields + newZero + index + count,
+                 oldFields + newZero + index,
+                 sizeof(Field) * (fLength - index));
+-
+-        fZero = newZero;
+-        fLength += count;
+     }
+-    U_ASSERT((fZero + index) >= 0);
++    fZero = newZero;
++    fLength = newLength;
+     return fZero + index;
+ }
+ 
+ int32_t FormattedStringBuilder::remove(int32_t index, int32_t count) {
+-    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
++     U_ASSERT(0 <= index);
++     U_ASSERT(index <= fLength);
++     U_ASSERT(count <= (fLength - index));
++     U_ASSERT(index <= getCapacity() - fZero);
++
+     int32_t position = index + fZero;
+-    U_ASSERT(position >= 0);
++    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
+     uprv_memmove2(getCharPtr() + position,
+             getCharPtr() + position + count,
+             sizeof(char16_t) * (fLength - index - count));
diff --git a/src/third_party/icu/source/i18n/formatted_string_builder.cpp b/src/third_party/icu/source/i18n/formatted_string_builder.cpp
index b370f14f2a..e459c791ea 100644
--- a/src/third_party/icu/source/i18n/formatted_string_builder.cpp
+++ b/src/third_party/icu/source/i18n/formatted_string_builder.cpp
@@ -6,6 +6,7 @@
 #if !UCONFIG_NO_FORMATTING
 
 #include "formatted_string_builder.h"
+#include "putilimp.h"
 #include "unicode/ustring.h"
 #include "unicode/utf16.h"
 #include "unicode/unum.h" // for UNumberFormatFields literals
@@ -197,6 +198,9 @@ FormattedStringBuilder::splice(int32_t startThis, int32_t endThis,  const Unicod
     int32_t thisLength = endThis - startThis;
     int32_t otherLength = endOther - startOther;
     int32_t count = otherLength - thisLength;
+    if (U_FAILURE(status)) {
+        return count;
+    }
     int32_t position;
     if (count > 0) {
         // Overall, chars need to be added.
@@ -221,6 +225,9 @@ int32_t FormattedStringBuilder::append(const FormattedStringBuilder &other, UErr
 
 int32_t
 FormattedStringBuilder::insert(int32_t index, const FormattedStringBuilder &other, UErrorCode &status) {
+    if (U_FAILURE(status)) {
+        return 0;
+    }
     if (this == &other) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return 0;
@@ -255,12 +262,18 @@ int32_t FormattedStringBuilder::prepareForInsert(int32_t index, int32_t count, U
     U_ASSERT(index >= 0);
     U_ASSERT(index <= fLength);
     U_ASSERT(count >= 0);
+    U_ASSERT(fZero >= 0);
+    U_ASSERT(fLength >= 0);
+    U_ASSERT(getCapacity() - fZero >= fLength);
+    if (U_FAILURE(status)) {
+        return count;
+    }
     if (index == 0 && fZero - count >= 0) {
         // Append to start
         fZero -= count;
         fLength += count;
         return fZero;
-    } else if (index == fLength && fZero + fLength + count < getCapacity()) {
+    } else if (index == fLength && count <= getCapacity() - fZero - fLength) {
         // Append to end
         fLength += count;
         return fZero + fLength - count;
@@ -275,18 +288,26 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
     int32_t oldZero = fZero;
     char16_t *oldChars = getCharPtr();
     Field *oldFields = getFieldPtr();
-    if (fLength + count > oldCapacity) {
-        if ((fLength + count) > INT32_MAX / 2) {
-            // If we continue, then newCapacity will overlow int32_t in the next line.
+    int32_t newLength;
+    if (uprv_add32_overflow(fLength, count, &newLength)) {
+        status = U_INPUT_TOO_LONG_ERROR;
+        return -1;
+    }
+    int32_t newZero;
+    if (newLength > oldCapacity) {
+        if (newLength > INT32_MAX / 2) {
+            // We do not support more than 1G char16_t in this code because
+            // dealing with >2G *bytes* can cause subtle bugs.
             status = U_INPUT_TOO_LONG_ERROR;
             return -1;
         }
-        int32_t newCapacity = (fLength + count) * 2;
-        int32_t newZero = newCapacity / 2 - (fLength + count) / 2;
+	// Keep newCapacity also to at most 1G char16_t.
+        int32_t newCapacity = newLength * 2;
+        newZero = (newCapacity - newLength) / 2;
 
         // C++ note: malloc appears in two places: here and in the assignment operator.
-        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * newCapacity));
-        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * newCapacity));
+	auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * static_cast<size_t>(newCapacity)));
+        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * static_cast<size_t>(newCapacity)));
         if (newChars == nullptr || newFields == nullptr) {
             uprv_free(newChars);
             uprv_free(newFields);
@@ -315,11 +336,8 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
         fChars.heap.capacity = newCapacity;
         fFields.heap.ptr = newFields;
         fFields.heap.capacity = newCapacity;
-        fZero = newZero;
-        fLength += count;
     } else {
-        int32_t newZero = oldCapacity / 2 - (fLength + count) / 2;
-
+        newZero = (oldCapacity - newLength) / 2;
         // C++ note: memmove is required because src and dest may overlap.
         // First copy the entire string to the location of the prefix, and then move the suffix
         // to make room for the new chars that the caller wants to insert.
@@ -331,18 +349,19 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
         uprv_memmove2(oldFields + newZero + index + count,
                 oldFields + newZero + index,
                 sizeof(Field) * (fLength - index));
-
+        }
         fZero = newZero;
-        fLength += count;
-    }
-    U_ASSERT((fZero + index) >= 0);
+        fLength += newLength;
     return fZero + index;
 }
 
 int32_t FormattedStringBuilder::remove(int32_t index, int32_t count) {
-    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
+    U_ASSERT(0 <= index);
+    U_ASSERT(index <= fLength);
+    U_ASSERT(count <= (fLength - index));
+    U_ASSERT(index <= getCapacity() - fZero);
     int32_t position = index + fZero;
-    U_ASSERT(position >= 0);
+    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
     uprv_memmove2(getCharPtr() + position,
             getCharPtr() + position + count,
             sizeof(char16_t) * (fLength - index - count));
diff --git a/src/third_party/node/linux/node-linux-x64/bin/node b/src/third_party/node/linux/node-linux-x64/bin/node
index 8f9de130a6..229fef0ec7 100755
Binary files a/src/third_party/node/linux/node-linux-x64/bin/node and b/src/third_party/node/linux/node-linux-x64/bin/node differ
diff --git a/src/ui/views/controls/textfield/textfield.cc b/src/ui/views/controls/textfield/textfield.cc
index 6de25634ed..5dec2aada8 100644
--- a/src/ui/views/controls/textfield/textfield.cc
+++ b/src/ui/views/controls/textfield/textfield.cc
@@ -2577,6 +2577,12 @@ void Textfield::UpdateContextMenu() {
       MenuRunner::HAS_MNEMONICS | MenuRunner::CONTEXT_MENU);
 }
 
+void Textfield::InvalidateContextMenu() {
+  // Ensure that the Runner doesn't outlive the Model.
+  context_menu_runner_.reset();
+  context_menu_contents_.reset();
+}
+
 bool Textfield::ImeEditingAllowed() const {
   // Disallow input method editing of password fields.
   ui::TextInputType t = GetTextInputType();
diff --git a/src/ui/views/controls/textfield/textfield.h b/src/ui/views/controls/textfield/textfield.h
index 1d76407d6f..03671d5b3e 100644
--- a/src/ui/views/controls/textfield/textfield.h
+++ b/src/ui/views/controls/textfield/textfield.h
@@ -514,6 +514,11 @@ class VIEWS_EXPORT Textfield : public View,
   // Update the cursor position in the text field.
   void UpdateCursorViewPosition();
 
+  // If there's an existing context menu, invalidate it, maybe closing it if
+  // it's showing. This is required if part of the context menu's model is about
+  // to be destroyed.
+  void InvalidateContextMenu();
+
  private:
   friend class TextfieldTestApi;
 
diff --git a/src/url/url_util.cc b/src/url/url_util.cc
index d26124174f..6aa707ea10 100644
--- a/src/url/url_util.cc
+++ b/src/url/url_util.cc
@@ -430,6 +430,13 @@ bool DoReplaceComponents(const char* spec,
     // ref).
     Replacements<CHAR> replacements_no_scheme = replacements;
     replacements_no_scheme.SetScheme(NULL, Component());
+    // If the input URL has potentially dangling markup, set the flag on the
+    // output too. Note that in some cases the replacement gets rid of the
+    // potentially dangling markup, but this ok since the check will fail
+    // closed.
+    if (parsed.potentially_dangling_markup) {
+      out_parsed->potentially_dangling_markup = true;
+    }
     return DoReplaceComponents(recanonicalized.data(), recanonicalized.length(),
                                recanonicalized_parsed, replacements_no_scheme,
                                charset_converter, output, out_parsed);
diff --git a/src/url/url_util_unittest.cc b/src/url/url_util_unittest.cc
index ac28f6925b..572788a5ea 100644
--- a/src/url/url_util_unittest.cc
+++ b/src/url/url_util_unittest.cc
@@ -482,6 +482,26 @@ TEST_F(URLUtilTest, PotentiallyDanglingMarkup) {
   }
 }
 
+TEST_F(URLUtilTest, PotentiallyDanglingMarkupAfterSchemeOnlyReplacement) {
+  // Parse a URL with potentially dangling markup.
+  Parsed original_parsed;
+  RawCanonOutput<32> original;
+  const char* url = "http://example.com/\n/<path";
+  Canonicalize(url, strlen(url), false, nullptr, &original, &original_parsed);
+  ASSERT_TRUE(original_parsed.potentially_dangling_markup);
+
+  // Perform a replacement, and validate that the potentially_dangling_markup
+  // flag carried over to the new Parsed object.
+  Replacements<char> replacements;
+  const char* new_scheme = "https";
+  replacements.SetScheme(new_scheme, Component(0, strlen(new_scheme)));
+  Parsed replaced_parsed;
+  RawCanonOutput<32> replaced;
+  ReplaceComponents(original.data(), original.length(), original_parsed,
+                    replacements, nullptr, &replaced, &replaced_parsed);
+  EXPECT_TRUE(replaced_parsed.potentially_dangling_markup);
+}
+
 TEST_F(URLUtilTest, TestDomainIs) {
   const struct {
     const char* canonicalized_host;
diff --git a/src/v8/src/builtins/builtins-collections-gen.cc b/src/v8/src/builtins/builtins-collections-gen.cc
index 785a1af90a..8e343d9d2d 100644
--- a/src/v8/src/builtins/builtins-collections-gen.cc
+++ b/src/v8/src/builtins/builtins-collections-gen.cc
@@ -1752,6 +1752,9 @@ TF_BUILTIN(MapPrototypeDelete, CollectionsBuiltinsAssembler) {
   ThrowIfNotInstanceType(context, receiver, JS_MAP_TYPE,
                          "Map.prototype.delete");
 
+  // This check breaks a known exploitation technique. See crbug.com/1263462
+  CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant()));
+
   const TNode<OrderedHashMap> table =
       LoadObjectField<OrderedHashMap>(CAST(receiver), JSMap::kTableOffset);
 
@@ -1920,6 +1923,9 @@ TF_BUILTIN(SetPrototypeDelete, CollectionsBuiltinsAssembler) {
   ThrowIfNotInstanceType(context, receiver, JS_SET_TYPE,
                          "Set.prototype.delete");
 
+  // This check breaks a known exploitation technique. See crbug.com/1263462
+  CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant()));
+
   const TNode<OrderedHashSet> table =
       LoadObjectField<OrderedHashSet>(CAST(receiver), JSMap::kTableOffset);
 
@@ -2866,6 +2872,9 @@ TF_BUILTIN(WeakMapPrototypeDelete, CodeStubAssembler) {
   ThrowIfNotInstanceType(context, receiver, JS_WEAK_MAP_TYPE,
                          "WeakMap.prototype.delete");
 
+  // This check breaks a known exploitation technique. See crbug.com/1263462
+  CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant()));
+
   Return(CallBuiltin(Builtins::kWeakCollectionDelete, context, receiver, key));
 }
 
@@ -2914,6 +2923,9 @@ TF_BUILTIN(WeakSetPrototypeDelete, CodeStubAssembler) {
   ThrowIfNotInstanceType(context, receiver, JS_WEAK_SET_TYPE,
                          "WeakSet.prototype.delete");
 
+  // This check breaks a known exploitation technique. See crbug.com/1263462
+  CSA_CHECK(this, TaggedNotEqual(value, TheHoleConstant()));
+
   Return(
       CallBuiltin(Builtins::kWeakCollectionDelete, context, receiver, value));
 }
diff --git a/src/v8/src/compiler/escape-analysis.cc b/src/v8/src/compiler/escape-analysis.cc
index 7ff6ab684f..23dfb00184 100644
--- a/src/v8/src/compiler/escape-analysis.cc
+++ b/src/v8/src/compiler/escape-analysis.cc
@@ -5,10 +5,12 @@
 #include "src/compiler/escape-analysis.h"
 
 #include "src/codegen/tick-counter.h"
+#include "src/compiler/frame-states.h"
 #include "src/compiler/linkage.h"
 #include "src/compiler/node-matchers.h"
 #include "src/compiler/operator-properties.h"
 #include "src/compiler/simplified-operator.h"
+#include "src/compiler/state-values-utils.h"
 #include "src/handles/handles-inl.h"
 #include "src/init/bootstrapper.h"
 #include "src/objects/map-inl.h"
@@ -224,6 +226,11 @@ class EscapeAnalysisTracker : public ZoneObject {
       return tracker_->ResolveReplacement(
           NodeProperties::GetContextInput(current_node()));
     }
+    // Accessing the current node is fine for `FrameState nodes.
+    Node* CurrentNode() {
+      DCHECK_EQ(current_node()->opcode(), IrOpcode::kFrameState);
+      return current_node();
+    }
 
     void SetReplacement(Node* replacement) {
       replacement_ = replacement;
@@ -796,9 +803,30 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,
       break;
     }
     case IrOpcode::kStateValues:
-    case IrOpcode::kFrameState:
       // These uses are always safe.
       break;
+    case IrOpcode::kFrameState: {
+      // We mark the receiver as escaping due to the non-standard `.getThis`
+      // API.
+      FrameState frame_state{current->CurrentNode()};
+      FrameStateType type = frame_state.frame_state_info().type();
+      // This needs to be kept in sync with the frame types supported in
+      // `OptimizedFrame::Summarize`.
+      if (type != FrameStateType::kUnoptimizedFunction &&
+          type != FrameStateType::kJavaScriptBuiltinContinuation &&
+          type != FrameStateType::kJavaScriptBuiltinContinuationWithCatch) {
+        break;
+      }
+      StateValuesAccess::iterator it =
+          StateValuesAccess(frame_state.parameters()).begin();
+      if (!it.done()) {
+        if (Node* receiver = it.node()) {
+          current->SetEscaped(receiver);
+        }
+        current->SetEscaped(frame_state.function());
+      }
+      break;
+    }
     default: {
       // For unknown nodes, treat all value inputs as escaping.
       int value_input_count = op->ValueInputCount();
diff --git a/src/v8/src/objects/objects.cc b/src/v8/src/objects/objects.cc
old mode 100644
new mode 100755
index e2810f1337..fa3f9fc82d
--- a/src/v8/src/objects/objects.cc
+++ b/src/v8/src/objects/objects.cc
@@ -2529,6 +2529,12 @@ Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,
           Maybe<bool> result =
               JSObject::SetPropertyWithInterceptor(it, should_throw, value);
           if (result.IsNothing() || result.FromJust()) return result;
+          // Assuming that the callback have side effects, we use
+          // Object::SetSuperProperty() which works properly regardless on
+          // whether the property was present on the receiver or not when
+          // storing to the receiver.
+          // Proceed lookup from the next state.
+          it->Next();
         } else {
           Maybe<PropertyAttributes> maybe_attributes =
               JSObject::GetPropertyAttributesWithInterceptor(it);
@@ -2536,11 +2542,21 @@ Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,
           if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {
             return WriteToReadOnlyProperty(it, value, should_throw);
           }
-          if (maybe_attributes.FromJust() == ABSENT) break;
-          *found = false;
-          return Nothing<bool>();
+          // At this point we might have called interceptor's query or getter
+          // callback. Assuming that the callbacks have side effects, we use
+          // Object::SetSuperProperty() which works properly regardless on
+          // whether the property was present on the receiver or not when
+          // storing to the receiver.
+          if (maybe_attributes.FromJust() == ABSENT) {
+            // Proceed lookup from the next state.
+            it->Next();
+          } else {
+            // Finish lookup in order to make Object::SetSuperProperty() store
+            // property to the receiver.
+            it->NotFound();
+          }
         }
-        break;
+        return Object::SetSuperProperty(it, value, store_origin, should_throw);
       }
 
       case LookupIterator::ACCESSOR: {
@@ -2603,6 +2619,26 @@ Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,
   return Nothing<bool>();
 }
 
+bool Object::CheckContextualStoreToJSGlobalObject(
+    LookupIterator* it, Maybe<ShouldThrow> should_throw) {
+  Isolate* isolate = it->isolate();
+
+  if (it->GetReceiver()->IsJSGlobalObject(isolate) &&
+      (GetShouldThrow(isolate, should_throw) == ShouldThrow::kThrowOnError)) {
+    if (it->state() == LookupIterator::TRANSITION) {
+      // The property cell that we have created is garbage because we are going
+      // to throw now instead of putting it into the global dictionary. However,
+      // the cell might already have been stored into the feedback vector, so
+      // we must invalidate it nevertheless.
+      it->transition_cell()->ClearAndInvalidate(ReadOnlyRoots(isolate));
+    }
+    isolate->Throw(*isolate->factory()->NewReferenceError(
+        MessageTemplate::kNotDefined, it->GetName()));
+    return false;
+  }
+  return true;
+}
+
 Maybe<bool> Object::SetProperty(LookupIterator* it, Handle<Object> value,
                                 StoreOrigin store_origin,
                                 Maybe<ShouldThrow> should_throw) {
@@ -2613,24 +2649,9 @@ Maybe<bool> Object::SetProperty(LookupIterator* it, Handle<Object> value,
     if (found) return result;
   }
 
-  // If the receiver is the JSGlobalObject, the store was contextual. In case
-  // the property did not exist yet on the global object itself, we have to
-  // throw a reference error in strict mode.  In sloppy mode, we continue.
-  if (it->GetReceiver()->IsJSGlobalObject() &&
-      (GetShouldThrow(it->isolate(), should_throw) ==
-       ShouldThrow::kThrowOnError)) {
-    if (it->state() == LookupIterator::TRANSITION) {
-      // The property cell that we have created is garbage because we are going
-      // to throw now instead of putting it into the global dictionary. However,
-      // the cell might already have been stored into the feedback vector, so
-      // we must invalidate it nevertheless.
-      it->transition_cell()->ClearAndInvalidate(ReadOnlyRoots(it->isolate()));
-    }
-    it->isolate()->Throw(*it->isolate()->factory()->NewReferenceError(
-        MessageTemplate::kNotDefined, it->GetName()));
+  if (!CheckContextualStoreToJSGlobalObject(it, should_throw)) {
     return Nothing<bool>();
   }
-
   return AddDataProperty(it, value, NONE, should_throw, store_origin);
 }
 
@@ -2697,6 +2718,9 @@ Maybe<bool> Object::SetSuperProperty(LookupIterator* it, Handle<Object> value,
             JSReceiver::GetOwnPropertyDescriptor(&own_lookup, &desc);
         MAYBE_RETURN(owned, Nothing<bool>());
         if (!owned.FromJust()) {
+          if (!CheckContextualStoreToJSGlobalObject(&own_lookup, should_throw)) {
+            return Nothing<bool>();
+          }
           return JSReceiver::CreateDataProperty(&own_lookup, value,
                                                 should_throw);
         }
diff --git a/src/v8/src/objects/objects.h b/src/v8/src/objects/objects.h
old mode 100644
new mode 100755
index c68445597f..93624b7b39
--- a/src/v8/src/objects/objects.h
+++ b/src/v8/src/objects/objects.h
@@ -726,6 +726,8 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   V8_EXPORT_PRIVATE V8_WARN_UNUSED_RESULT static MaybeHandle<Object>
   ConvertToIndex(Isolate* isolate, Handle<Object> input,
                  MessageTemplate error_index);
+  V8_EXPORT_PRIVATE V8_WARN_UNUSED_RESULT static bool CheckContextualStoreToJSGlobalObject(
+    LookupIterator* it, Maybe<ShouldThrow> should_throw = Nothing<ShouldThrow>());
 };
 
 V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os, const Object& obj);
diff --git a/src/v8/src/regexp/regexp-utils.cc b/src/v8/src/regexp/regexp-utils.cc
index 8bb243d611..bf8479c5ec 100644
--- a/src/v8/src/regexp/regexp-utils.cc
+++ b/src/v8/src/regexp/regexp-utils.cc
@@ -49,7 +49,8 @@ MaybeHandle<Object> RegExpUtils::SetLastIndex(Isolate* isolate,
   Handle<Object> value_as_object =
       isolate->factory()->NewNumberFromInt64(value);
   if (HasInitialRegExpMap(isolate, *recv)) {
-    JSRegExp::cast(*recv).set_last_index(*value_as_object, SKIP_WRITE_BARRIER);
+    JSRegExp::cast(*recv).set_last_index(*value_as_object,
+                                         UPDATE_WRITE_BARRIER);
     return recv;
   } else {
     return Object::SetProperty(
diff --git a/src/v8/test/cctest/test-api-interceptors.cc b/src/v8/test/cctest/test-api-interceptors.cc
old mode 100644
new mode 100755
index af5858eaef..36ae3a4838
--- a/src/v8/test/cctest/test-api-interceptors.cc
+++ b/src/v8/test/cctest/test-api-interceptors.cc
@@ -5490,10 +5490,10 @@ void DatabaseGetter(Local<Name> name,
                     const v8::PropertyCallbackInfo<Value>& info) {
   ApiTestFuzzer::Fuzz();
   auto context = info.GetIsolate()->GetCurrentContext();
-  Local<v8::Object> db = info.Holder()
-                             ->GetRealNamedProperty(context, v8_str("db"))
-                             .ToLocalChecked()
-                             .As<v8::Object>();
+  v8::MaybeLocal<Value> maybe_db =
+      info.Holder()->GetRealNamedProperty(context, v8_str("db"));
+  if (maybe_db.IsEmpty()) return;
+  Local<v8::Object> db = maybe_db.ToLocalChecked().As<v8::Object>();
   if (!db->Has(context, name).FromJust()) return;
   info.GetReturnValue().Set(db->Get(context, name).ToLocalChecked());
 }
diff --git a/src/v8/test/unittests/api/interceptor-unittest.cc b/src/v8/test/unittests/api/interceptor-unittest.cc
old mode 100644
new mode 100755
index 8a1db3f823..bc00462a29
--- a/src/v8/test/unittests/api/interceptor-unittest.cc
+++ b/src/v8/test/unittests/api/interceptor-unittest.cc
@@ -170,8 +170,8 @@ TEST_F(InterceptorLoggingTest, DispatchTest) {
   EXPECT_EQ(Run("obj.foo"), "named getter");
   EXPECT_EQ(Run("obj[42]"), "indexed getter");
 
-  EXPECT_EQ(Run("obj.foo = null"), "named setter");
-  EXPECT_EQ(Run("obj[42] = null"), "indexed setter");
+  EXPECT_EQ(Run("obj.foo = null"), "named setter, named descriptor");
+  EXPECT_EQ(Run("obj[42] = null"), "indexed setter, indexed descriptor");
 
   EXPECT_EQ(Run("Object.getOwnPropertyDescriptor(obj, 'foo')"),
             "named descriptor");
