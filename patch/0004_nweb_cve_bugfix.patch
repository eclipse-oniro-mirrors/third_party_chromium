diff --git a/base/base_paths_ohos.cc b/base/base_paths_ohos.cc
index ec03cd53d7..fb6e3966f6 100644
--- a/base/base_paths_ohos.cc
+++ b/base/base_paths_ohos.cc
@@ -15,6 +15,11 @@
 #include "base/notreached.h"
 #include "base/process/process_metrics.h"
 
+#if defined(OS_OHOS)
+#include "base/command_line.h"
+#include "content/public/common/content_switches.h"
+#endif
+
 namespace base {
 
 bool PathProviderOHOS(int key, FilePath* result) {
@@ -49,10 +54,20 @@ bool PathProviderOHOS(int key, FilePath* result) {
       // set to /data/local directory for W|X permission.
       *result = FilePath("/data/local");
       return true;
-    case base::DIR_ASSETS:
+    case base::DIR_ASSETS: {
       // resource file packed to system images
-      *result = FilePath("/system/etc/webview");
+#if defined(OS_OHOS)
+      bool for_test = base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kForTest);
+      if (for_test) {
+        *result = FilePath("/data/app/el1/bundle/public/com.ohos.nweb/entry/resources/rawfile");
+      } else {
+        *result = FilePath("/data/storage/el1/bundle/nweb/entry/resources/rawfile");
+      }
+#else
+        *result = FilePath("/data/local");
+#endif
       return true;
+    }
     case base::DIR_OHOS_APP_DATA:
       *result = FilePath("/data/local");
       return true;
diff --git a/build/config/ohos/BUILD.gn b/build/config/ohos/BUILD.gn
index 534f0020d7..881d941065 100644
--- a/build/config/ohos/BUILD.gn
+++ b/build/config/ohos/BUILD.gn
@@ -131,12 +131,12 @@ config("runtime_library") {
   }
   if (use_musl) {
     ldflags += [
-      "-L" + rebase_path("$ohos_sysroot/usr/lib/arm-linux-ohosmusl", root_build_dir),
-      "-L" + rebase_path("$ohos_toolchain_root/lib/arm-linux-ohosmusl/c++", root_build_dir),
-      "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohosmusl", root_build_dir),
+      "-L" + rebase_path("$ohos_sysroot/usr/lib/arm-linux-ohos", root_build_dir),
+      "-L" + rebase_path("$ohos_toolchain_root/lib/arm-linux-ohos/c++", root_build_dir),
+      "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohos", root_build_dir),
     ]
-    ldflags += [ "-Wl,--dynamic-linker,/system/bin/ld-musl-arm.so.1" ]
-    libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohosmusl/libclang_rt.builtins.a"
+    ldflags += [ "-Wl,--dynamic-linker,/lib/ld-musl-arm.so.1" ]
+    libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohos/libclang_rt.builtins.a"
 
     libs += [
       rebase_path(libclang_rt_file),
diff --git a/build/config/ohos/config.gni b/build/config/ohos/config.gni
index c2d04f6262..6a2442e261 100644
--- a/build/config/ohos/config.gni
+++ b/build/config/ohos/config.gni
@@ -13,7 +13,11 @@ if (is_ohos) {
   }
 
   declare_args() {
-    build_chromium_with_ohos_src = false
+    build_chromium_with_ohos_src = true
+  }
+
+  declare_args() {
+    product_name = ""
   }
 
   # Defines the name the ohos build gives to the current host CPU
@@ -42,7 +46,7 @@ if (is_ohos) {
     ohos_build_root = "//../../.."
     if (use_musl) {
       ohos_toolchain_root = "$ohos_ndk_root/clang/ohos/linux-x86_64/llvm"
-      ohos_sysroot = "$ohos_build_root/out/ohos-arm-release/obj/third_party/musl"
+      ohos_sysroot = "$ohos_build_root/out/rk3568/obj/third_party/musl"
     } else {
       ohos_toolchain_root = "$ohos_ndk_root/clang/host/linux-x86/clang-r353983c"
       ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
@@ -70,9 +74,19 @@ if (is_ohos) {
       "$ohos_build_root/base/location/interfaces/innerkits/locator_standard/include",
       "$ohos_build_root/base/location/location_common/common/include",
       "$ohos_build_root/foundation/distributedschedule/samgr/interfaces/innerkits/samgr_proxy/include",
+      "$ohos_build_root/utils/system/safwk/native/include",
+      "$ohos_build_root/foundation/aafwk/standard/interfaces/innerkits/base/include",
+      "$ohos_build_root/foundation/aafwk/standard/interfaces/innerkits/want/include/ohos/aafwk/content",
+      "$ohos_build_root/foundation/appexecfwk/standard/common/log/include",
+      "$ohos_build_root/foundation/appexecfwk/standard/common/perf/include",
+      "$ohos_build_root/foundation/appexecfwk/standard/interfaces/innerkits/appexecfwk_base/include",
+      "$ohos_build_root/foundation/aafwk/standard/interfaces/innerkits/app_manager/include",
+      "$ohos_build_root/foundation/distributedschedule/dmsfwk/services/dtbschedmgr/include",
+      "$ohos_build_root/third_party/jsoncpp/include",
+      "$ohos_build_root/third_party/json/include"
     ]
     ohos_libs_dir = [
-      "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib",
+      "$ohos_build_root/out/rk3568/packages/phone/system/lib",
     ]
   } else {
     if (use_musl) {
diff --git a/cef/libcef/browser/native/menu_runner_linux.cc b/cef/libcef/browser/native/menu_runner_linux.cc
index 220d06c302..951deef09f 100644
--- a/cef/libcef/browser/native/menu_runner_linux.cc
+++ b/cef/libcef/browser/native/menu_runner_linux.cc
@@ -7,6 +7,7 @@
 #include "libcef/browser/alloy/alloy_browser_host_impl.h"
 
 #include "base/compiler_specific.h"
+#include "base/logging.h"
 #include "base/strings/string_util.h"
 #include "ui/gfx/geometry/point.h"
 
@@ -16,6 +17,7 @@ bool CefMenuRunnerLinux::RunContextMenu(
     AlloyBrowserHostImpl* browser,
     CefMenuModelImpl* model,
     const content::ContextMenuParams& params) {
+#if !defined(OS_OHOS) // will implement for ohos later
   menu_.reset(
       new views::MenuRunner(model->model(), views::MenuRunner::CONTEXT_MENU));
 
@@ -28,13 +30,18 @@ bool CefMenuRunnerLinux::RunContextMenu(
 
   menu_->RunMenuAt(parent_widget, nullptr, gfx::Rect(screen_point, gfx::Size()),
                    views::MenuAnchorPosition::kTopRight, ui::MENU_SOURCE_NONE);
+#else
+  LOG(INFO) << "context menu not implement for ohos yet!";
+#endif
 
   return true;
 }
 
 void CefMenuRunnerLinux::CancelContextMenu() {
+#if !defined(OS_OHOS) // will implement for ohos later
   if (menu_)
     menu_->Cancel();
+#endif
 }
 
 bool CefMenuRunnerLinux::FormatLabel(std::u16string& label) {
diff --git a/cef/libcef/browser/native/menu_runner_linux.h b/cef/libcef/browser/native/menu_runner_linux.h
index 503461370d..89bb3f51b1 100644
--- a/cef/libcef/browser/native/menu_runner_linux.h
+++ b/cef/libcef/browser/native/menu_runner_linux.h
@@ -22,7 +22,9 @@ class CefMenuRunnerLinux : public CefMenuRunner {
   bool FormatLabel(std::u16string& label) override;
 
  private:
+#if !defined(OS_OHOS) // will implement for ohos later
   std::unique_ptr<views::MenuRunner> menu_;
+#endif
 };
 
 #endif  // CEF_LIBCEF_BROWSER_NATIVE_MENU_RUNNER_LINUX_H_
diff --git a/cef/libcef/browser/net_service/cookie_helper.cc b/cef/libcef/browser/net_service/cookie_helper.cc
index 6b2adf40cc..0f0af971f7 100644
--- a/cef/libcef/browser/net_service/cookie_helper.cc
+++ b/cef/libcef/browser/net_service/cookie_helper.cc
@@ -192,7 +192,7 @@ void LoadCookies(content::BrowserContext* browser_context,
 
   if ((request.load_flags & net::LOAD_DO_NOT_SEND_COOKIES) ||
       request.credentials_mode == network::mojom::CredentialsMode::kOmit ||
-      request.url.IsAboutBlank()) {
+      request.url.IsAboutBlank() || !request.SendsCookies()) {
     // Continue immediately without loading cookies.
     std::move(done_callback).Run(0, {});
     return;
@@ -213,7 +213,8 @@ void SaveCookies(content::BrowserContext* browser_context,
 
   if (request.credentials_mode == network::mojom::CredentialsMode::kOmit ||
       request.url.IsAboutBlank() || !headers ||
-      !headers->HasHeader(net_service::kHTTPSetCookieHeaderName)) {
+      !headers->HasHeader(net_service::kHTTPSetCookieHeaderName) ||
+      !request.SavesCookies()) {
     // Continue immediately without saving cookies.
     std::move(done_callback).Run(0, {});
     return;
diff --git a/cef/libcef/browser/osr/render_widget_host_view_osr.cc b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
index b8ccb16d4f..f52387c298 100644
--- a/cef/libcef/browser/osr/render_widget_host_view_osr.cc
+++ b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
@@ -972,6 +972,7 @@ void CefRenderWidgetHostViewOSR::WasResized() {
 
   SynchronizeVisualProperties(cc::DeadlinePolicy::UseExistingDeadline(),
                               base::nullopt);
+  ReleaseResizeHold();
 }
 
 void CefRenderWidgetHostViewOSR::SynchronizeVisualProperties(
diff --git a/chrome/browser/background_fetch/background_fetch_delegate_impl.cc b/chrome/browser/background_fetch/background_fetch_delegate_impl.cc
index 23317546e6..d6236627e3 100644
--- a/chrome/browser/background_fetch/background_fetch_delegate_impl.cc
+++ b/chrome/browser/background_fetch/background_fetch_delegate_impl.cc
@@ -324,6 +324,7 @@ void BackgroundFetchDelegateImpl::DownloadUrl(
     const std::string& download_guid,
     const std::string& method,
     const GURL& url,
+    ::network::mojom::CredentialsMode credentials_mode,
     const net::NetworkTrafficAnnotationTag& traffic_annotation,
     const net::HttpRequestHeaders& headers,
     bool has_request_body) {
@@ -339,6 +340,7 @@ void BackgroundFetchDelegateImpl::DownloadUrl(
   params.request_params.method = method;
   params.request_params.url = url;
   params.request_params.request_headers = headers;
+  params.request_params.credentials_mode = credentials_mode;
   params.callback =
       base::BindRepeating(&BackgroundFetchDelegateImpl::OnDownloadReceived,
                           weak_ptr_factory_.GetWeakPtr());
diff --git a/chrome/browser/background_fetch/background_fetch_delegate_impl.h b/chrome/browser/background_fetch/background_fetch_delegate_impl.h
index 16629fb82d..dfffa83b42 100644
--- a/chrome/browser/background_fetch/background_fetch_delegate_impl.h
+++ b/chrome/browser/background_fetch/background_fetch_delegate_impl.h
@@ -97,6 +97,7 @@ class BackgroundFetchDelegateImpl
                    const std::string& guid,
                    const std::string& method,
                    const GURL& url,
+                   ::network::mojom::CredentialsMode credentials_mode,
                    const net::NetworkTrafficAnnotationTag& traffic_annotation,
                    const net::HttpRequestHeaders& headers,
                    bool has_request_body) override;
diff --git a/chrome/browser/chrome_content_browser_client_receiver_bindings.cc b/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
index 005625bb1c..127f6fb2c9 100644
--- a/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
+++ b/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
@@ -205,11 +205,9 @@ void ChromeContentBrowserClient::ExposeInterfacesToRenderer(
       ui_task_runner);
 #endif
 #if defined(OS_ANDROID)
-  Profile* profile =
-      Profile::FromBrowserContext(render_process_host->GetBrowserContext());
   registry->AddInterface(
       base::BindRepeating(&android::AvailableOfflineContentProvider::Create,
-                          profile),
+                          render_process_host->GetID()),
       content::GetUIThreadTaskRunner({}));
 #endif
 
diff --git a/chrome/browser/chrome_security_exploit_browsertest.cc b/chrome/browser/chrome_security_exploit_browsertest.cc
index fd8ec071c4..2ffc8f4b29 100644
--- a/chrome/browser/chrome_security_exploit_browsertest.cc
+++ b/chrome/browser/chrome_security_exploit_browsertest.cc
@@ -482,8 +482,8 @@ IN_PROC_BROWSER_TEST_F(ChromeSecurityExploitBrowserTestMojoBlobURLs,
 
   // If the process is killed, this test passes.
   EXPECT_EQ(
-      "Received bad user message: Non committable URL passed to "
-      "BlobURLStore::Register",
+      "Received bad user message: "
+      "URL with invalid origin passed to BlobURLStore::Register",
       crash_observer.Wait());
 }
 
@@ -518,7 +518,7 @@ IN_PROC_BROWSER_TEST_F(ChromeSecurityExploitBrowserTestMojoBlobURLs,
 
   // If the process is killed, this test passes.
   EXPECT_EQ(
-      "Received bad user message: Non committable URL passed to "
-      "BlobURLStore::Register",
+      "Received bad user message: "
+      "URL with invalid origin passed to BlobURLStore::Register",
       crash_observer.Wait());
 }
diff --git a/chrome/browser/download/android/available_offline_content_provider.cc b/chrome/browser/download/android/available_offline_content_provider.cc
index 355efc81c2..680d00ee6f 100644
--- a/chrome/browser/download/android/available_offline_content_provider.cc
+++ b/chrome/browser/download/android/available_offline_content_provider.cc
@@ -25,6 +25,7 @@
 #include "components/offline_items_collection/core/offline_item_state.h"
 #include "components/offline_pages/core/offline_page_feature.h"
 #include "components/prefs/pref_service.h"
+#include "content/public/browser/render_process_host.h"
 #include "mojo/public/cpp/bindings/self_owned_receiver.h"
 #include "ui/base/l10n/time_format.h"
 
@@ -217,14 +218,17 @@ chrome::mojom::AvailableOfflineContentPtr CreateAvailableOfflineContent(
 }  // namespace
 
 AvailableOfflineContentProvider::AvailableOfflineContentProvider(
-    Profile* profile)
-    : profile_(profile) {}
+    int render_process_host_id)
+    : render_process_host_id_(render_process_host_id) {}
 
 AvailableOfflineContentProvider::~AvailableOfflineContentProvider() = default;
 
 void AvailableOfflineContentProvider::List(ListCallback callback) {
+  Profile* profile = GetProfile();
+  if (!profile)
+    return;
   offline_items_collection::OfflineContentAggregator* aggregator =
-      OfflineContentAggregatorFactory::GetForKey(profile_->GetProfileKey());
+      OfflineContentAggregatorFactory::GetForKey(profile->GetProfileKey());
   aggregator->GetAllItems(
       base::BindOnce(&AvailableOfflineContentProvider::ListFinalize,
                      weak_ptr_factory_.GetWeakPtr(), std::move(callback),
@@ -236,12 +240,15 @@ void AvailableOfflineContentProvider::List(ListCallback callback) {
 void AvailableOfflineContentProvider::LaunchItem(
     const std::string& item_id,
     const std::string& name_space) {
+  Profile* profile = GetProfile();
+  if (!profile)
+    return;
   offline_items_collection::OfflineContentAggregator* aggregator =
-      OfflineContentAggregatorFactory::GetForKey(profile_->GetProfileKey());
+      OfflineContentAggregatorFactory::GetForKey(profile->GetProfileKey());
 
   offline_items_collection::OpenParams open_params(
       offline_items_collection::LaunchLocation::NET_ERROR_SUGGESTION);
-  open_params.open_in_incognito = profile_->IsOffTheRecord();
+  open_params.open_in_incognito = profile->IsOffTheRecord();
   aggregator->OpenItem(
       open_params, offline_items_collection::ContentId(name_space, item_id));
 }
@@ -254,20 +261,21 @@ void AvailableOfflineContentProvider::LaunchDownloadsPage(
 }
 
 void AvailableOfflineContentProvider::ListVisibilityChanged(bool is_visible) {
-  profile_->GetPrefs()->SetBoolean(feed::prefs::kArticlesListVisible,
-                                   is_visible);
+  Profile* profile = GetProfile();
+  if (!profile)
+    return;
+  profile->GetPrefs()->SetBoolean(feed::prefs::kArticlesListVisible,
+                                  is_visible);
 }
 
 // static
 void AvailableOfflineContentProvider::Create(
-    Profile* profile,
+    int render_process_host_id,
     mojo::PendingReceiver<chrome::mojom::AvailableOfflineContentProvider>
         receiver) {
-  // Self owned receiveres remain as long as the pipe is error free. The
-  // renderer is on the other side of the pipe, and the profile outlives the
-  // RenderProcessHost, so the profile will outlive the Mojo pipe.
+  // Self owned receiveres remain as long as the pipe is error free.
   mojo::MakeSelfOwnedReceiver(
-      std::make_unique<AvailableOfflineContentProvider>(profile),
+      std::make_unique<AvailableOfflineContentProvider>(render_process_host_id),
       std::move(receiver));
 }
 
@@ -276,6 +284,10 @@ void AvailableOfflineContentProvider::ListFinalize(
     AvailableOfflineContentProvider::ListCallback callback,
     offline_items_collection::OfflineContentAggregator* aggregator,
     const std::vector<OfflineItem>& all_items) {
+  Profile* profile = GetProfile();
+  if (!profile)
+    return;
+
   std::vector<OfflineItem> selected(kMinInterestingItemCount);
   const auto end = std::partial_sort_copy(all_items.begin(), all_items.end(),
                                           selected.begin(), selected.end(),
@@ -296,7 +308,7 @@ void AvailableOfflineContentProvider::ListFinalize(
     selected_ids.push_back(item.id);
 
   bool list_visible_by_prefs =
-      profile_->GetPrefs()->GetBoolean(feed::prefs::kArticlesListVisible);
+      profile->GetPrefs()->GetBoolean(feed::prefs::kArticlesListVisible);
 
   auto complete =
       [](AvailableOfflineContentProvider::ListCallback callback,
@@ -318,4 +330,12 @@ void AvailableOfflineContentProvider::ListFinalize(
                      list_visible_by_prefs));
 }
 
+Profile* AvailableOfflineContentProvider::GetProfile() {
+  content::RenderProcessHost* render_process_host =
+      content::RenderProcessHost::FromID(render_process_host_id_);
+  if (!render_process_host)
+    return nullptr;
+  return Profile::FromBrowserContext(render_process_host->GetBrowserContext());
+}
+
 }  // namespace android
diff --git a/chrome/browser/download/android/available_offline_content_provider.h b/chrome/browser/download/android/available_offline_content_provider.h
index c4024a463a..0888c0c487 100644
--- a/chrome/browser/download/android/available_offline_content_provider.h
+++ b/chrome/browser/download/android/available_offline_content_provider.h
@@ -27,7 +27,7 @@ class AvailableOfflineContentProvider
     : public chrome::mojom::AvailableOfflineContentProvider {
  public:
   // Public for testing.
-  explicit AvailableOfflineContentProvider(Profile* profile);
+  explicit AvailableOfflineContentProvider(int render_process_host_id);
   ~AvailableOfflineContentProvider() override;
 
   // chrome::mojom::AvailableOfflineContentProvider methods.
@@ -38,7 +38,7 @@ class AvailableOfflineContentProvider
   void ListVisibilityChanged(bool is_visible) override;
 
   static void Create(
-      Profile* profile,
+      int render_process_host_id,
       mojo::PendingReceiver<chrome::mojom::AvailableOfflineContentProvider>
           receiver);
 
@@ -48,7 +48,9 @@ class AvailableOfflineContentProvider
       offline_items_collection::OfflineContentAggregator* aggregator,
       const std::vector<offline_items_collection::OfflineItem>& all_items);
 
-  Profile* profile_;
+  Profile* GetProfile();
+
+  const int render_process_host_id_;
 
   base::WeakPtrFactory<AvailableOfflineContentProvider> weak_ptr_factory_{this};
 
diff --git a/chrome/browser/download/android/available_offline_content_provider_unittest.cc b/chrome/browser/download/android/available_offline_content_provider_unittest.cc
index 234760aff0..bce18ff21b 100644
--- a/chrome/browser/download/android/available_offline_content_provider_unittest.cc
+++ b/chrome/browser/download/android/available_offline_content_provider_unittest.cc
@@ -15,6 +15,7 @@
 #include "chrome/browser/offline_items_collection/offline_content_aggregator_factory.h"
 #include "chrome/browser/profiles/profile_key.h"
 #include "chrome/common/available_offline_content.mojom-test-utils.h"
+#include "chrome/test/base/chrome_render_view_host_test_harness.h"
 #include "chrome/test/base/testing_profile.h"
 #include "components/feed/core/shared_prefs/pref_names.h"
 #include "components/offline_items_collection/core/offline_content_aggregator.h"
@@ -124,13 +125,27 @@ OfflineItemVisuals TestThumbnail() {
   return visuals;
 }
 
-class AvailableOfflineContentTest : public testing::Test {
+class AvailableOfflineContentTest : public ChromeRenderViewHostTestHarness {
  protected:
   void SetUp() override {
+    ChromeRenderViewHostTestHarness::SetUp();
+
+    content_provider_ = std::make_unique<
+        offline_items_collection::MockOfflineContentProvider>();
+    provider_ = std::make_unique<AvailableOfflineContentProvider>(
+        main_rfh()->GetProcess()->GetID());
+
     aggregator_ =
-        OfflineContentAggregatorFactory::GetForKey(profile_.GetProfileKey());
-    aggregator_->RegisterProvider(kProviderNamespace, &content_provider_);
-    content_provider_.SetVisuals({});
+        OfflineContentAggregatorFactory::GetForKey(profile()->GetProfileKey());
+    aggregator_->RegisterProvider(kProviderNamespace, content_provider_.get());
+    content_provider_->SetVisuals({});
+  }
+
+  void TearDown() override {
+    provider_.release();
+    content_provider_.release();
+
+    ChromeRenderViewHostTestHarness::TearDown();
   }
 
   std::tuple<bool, std::vector<chrome::mojom::AvailableOfflineContentPtr>>
@@ -138,18 +153,17 @@ class AvailableOfflineContentTest : public testing::Test {
     bool list_visible_by_prefs;
     std::vector<chrome::mojom::AvailableOfflineContentPtr> suggestions;
     chrome::mojom::AvailableOfflineContentProviderAsyncWaiter waiter(
-        &provider_);
+        provider_.get());
     waiter.List(&list_visible_by_prefs, &suggestions);
     return std::make_tuple(list_visible_by_prefs, std::move(suggestions));
   }
 
-  content::BrowserTaskEnvironment task_environment_;
-  TestingProfile profile_;
   std::unique_ptr<base::test::ScopedFeatureList> scoped_feature_list_ =
       std::make_unique<base::test::ScopedFeatureList>();
   OfflineContentAggregator* aggregator_;
-  offline_items_collection::MockOfflineContentProvider content_provider_;
-  AvailableOfflineContentProvider provider_{&profile_};
+  std::unique_ptr<offline_items_collection::MockOfflineContentProvider>
+      content_provider_;
+  std::unique_ptr<AvailableOfflineContentProvider> provider_;
 };
 
 TEST_F(AvailableOfflineContentTest, NoContent) {
@@ -164,10 +178,10 @@ TEST_F(AvailableOfflineContentTest, NoContent) {
 TEST_F(AvailableOfflineContentTest, TooFewInterestingItems) {
   // Adds items so that we're one-ff of reaching the minimum required count so
   // that any extra item considered interesting would effect the results.
-  content_provider_.SetItems({UninterestingImageItem(), OfflinePageItem(),
-                              SuggestedOfflinePageItem(), VideoItem(),
-                              TransientItem(), OffTheRecordItem(),
-                              IncompleteItem(), DangerousItem()});
+  content_provider_->SetItems({UninterestingImageItem(), OfflinePageItem(),
+                               SuggestedOfflinePageItem(), VideoItem(),
+                               TransientItem(), OffTheRecordItem(),
+                               IncompleteItem(), DangerousItem()});
 
   // Call List().
   bool list_visible_by_prefs;
@@ -182,11 +196,11 @@ TEST_F(AvailableOfflineContentTest, TooFewInterestingItems) {
 
 TEST_F(AvailableOfflineContentTest, FourInterestingItems) {
   // We need at least 4 interesting items for anything to show up at all.
-  content_provider_.SetItems({UninterestingImageItem(), VideoItem(),
-                              SuggestedOfflinePageItem(), AudioItem(),
-                              OfflinePageItem()});
+  content_provider_->SetItems({UninterestingImageItem(), VideoItem(),
+                               SuggestedOfflinePageItem(), AudioItem(),
+                               OfflinePageItem()});
 
-  content_provider_.SetVisuals(
+  content_provider_->SetVisuals(
       {{SuggestedOfflinePageItem().id, TestThumbnail()}});
 
   // Call List().
@@ -226,14 +240,14 @@ TEST_F(AvailableOfflineContentTest, FourInterestingItems) {
 
 TEST_F(AvailableOfflineContentTest, ListVisibilityChanges) {
   // We need at least 4 interesting items for anything to show up at all.
-  content_provider_.SetItems({UninterestingImageItem(), VideoItem(),
-                              SuggestedOfflinePageItem(), AudioItem(),
-                              OfflinePageItem()});
+  content_provider_->SetItems({UninterestingImageItem(), VideoItem(),
+                               SuggestedOfflinePageItem(), AudioItem(),
+                               OfflinePageItem()});
 
-  content_provider_.SetVisuals(
+  content_provider_->SetVisuals(
       {{SuggestedOfflinePageItem().id, TestThumbnail()}});
   // Set pref to hide the list.
-  profile_.GetPrefs()->SetBoolean(feed::prefs::kArticlesListVisible, false);
+  profile()->GetPrefs()->SetBoolean(feed::prefs::kArticlesListVisible, false);
 
   // Call List().
   bool list_visible_by_prefs;
@@ -245,10 +259,10 @@ TEST_F(AvailableOfflineContentTest, ListVisibilityChanges) {
   EXPECT_FALSE(list_visible_by_prefs);
 
   // Simulate visibility changed by the user to "shown".
-  provider_.ListVisibilityChanged(true);
+  provider_->ListVisibilityChanged(true);
 
   EXPECT_TRUE(
-      profile_.GetPrefs()->GetBoolean(feed::prefs::kArticlesListVisible));
+      profile()->GetPrefs()->GetBoolean(feed::prefs::kArticlesListVisible));
 
   // Call List() again and check list is not visible.
   std::tie(list_visible_by_prefs, suggestions) = ListAndWait();
diff --git a/chrome/browser/download/save_page_browsertest.cc b/chrome/browser/download/save_page_browsertest.cc
index b5e3997002..ef21c3d4fc 100644
--- a/chrome/browser/download/save_page_browsertest.cc
+++ b/chrome/browser/download/save_page_browsertest.cc
@@ -49,6 +49,7 @@
 #include "components/prefs/pref_member.h"
 #include "components/prefs/pref_service.h"
 #include "components/security_state/core/security_state.h"
+#include "components/services/quarantine/test_support.h"
 #include "content/public/browser/download_manager.h"
 #include "content/public/browser/notification_service.h"
 #include "content/public/browser/notification_types.h"
@@ -433,6 +434,10 @@ IN_PROC_BROWSER_TEST_F(SavePageBrowserTest, SaveFileURL) {
   EXPECT_TRUE(base::PathExists(full_file_name));
   EXPECT_FALSE(base::PathExists(dir));
   EXPECT_TRUE(base::ContentsEqual(GetTestDirFile("text.txt"), full_file_name));
+#if defined(OS_WIN)
+  // Local file URL will not be quarantined.
+  EXPECT_FALSE(quarantine::IsFileQuarantined(full_file_name, GURL(), GURL()));
+#endif
 }
 
 IN_PROC_BROWSER_TEST_F(SavePageBrowserTest,
@@ -936,6 +941,25 @@ IN_PROC_BROWSER_TEST_F(SavePageBrowserTest, SaveUnauthorizedResource) {
   EXPECT_FALSE(base::PathExists(dir.AppendASCII("should-not-save.jpg")));
 }
 
+#if defined(OS_WIN)
+// Save a file and confirm that the file is correctly quarantined.
+IN_PROC_BROWSER_TEST_F(SavePageBrowserTest, SaveURLQuarantine) {
+  GURL url = embedded_test_server()->GetURL("/save_page/text.txt");
+  ui_test_utils::NavigateToURL(browser(), url);
+
+  base::FilePath full_file_name, dir;
+  SaveCurrentTab(url, content::SAVE_PAGE_TYPE_AS_ONLY_HTML, "test", 1, &dir,
+                 &full_file_name);
+  ASSERT_FALSE(HasFailure());
+
+  base::ScopedAllowBlockingForTesting allow_blocking;
+  EXPECT_TRUE(base::PathExists(full_file_name));
+  EXPECT_FALSE(base::PathExists(dir));
+  EXPECT_TRUE(base::ContentsEqual(GetTestDirFile("text.txt"), full_file_name));
+  EXPECT_TRUE(quarantine::IsFileQuarantined(full_file_name, url, GURL()));
+}
+#endif
+
 // Test suite that allows testing --site-per-process against cross-site frames.
 // See http://dev.chromium.org/developers/design-documents/site-isolation.
 class SavePageSitePerProcessBrowserTest : public SavePageBrowserTest {
diff --git a/chrome/browser/extensions/extension_messages_apitest.cc b/chrome/browser/extensions/extension_messages_apitest.cc
index 4caf88b061..496ae84131 100644
--- a/chrome/browser/extensions/extension_messages_apitest.cc
+++ b/chrome/browser/extensions/extension_messages_apitest.cc
@@ -1164,6 +1164,93 @@ IN_PROC_BROWSER_TEST_F(MessagingApiTest, MessagingUserGesture) {
           "});", receiver->id().c_str())));
 }
 
+IN_PROC_BROWSER_TEST_F(MessagingApiTest,
+                       RestrictedActivationTriggerBetweenExtensions) {
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      embedder_support::kDisablePopupBlocking);
+
+  const char kManifest[] = R"({
+    "name": "activation_state_thru_send_reply",
+    "version": "1.0",
+    "background": {
+      "scripts": ["background.js"]
+    },
+    "manifest_version": 2
+  })";
+
+  // The receiver replies back with its transient activation state after a
+  // delay.
+  TestExtensionDir receiver_dir;
+  receiver_dir.WriteManifest(kManifest);
+  receiver_dir.WriteFile(FILE_PATH_LITERAL("background.js"),
+                         R"(
+        chrome.runtime.onMessageExternal.addListener(
+          (msg, sender, callback) => {
+            setTimeout(() =>
+              callback({active:navigator.userActivation.isActive}), 200);
+          });
+      )");
+  const Extension* receiver = LoadExtension(receiver_dir.UnpackedPath());
+  ASSERT_TRUE(receiver);
+
+  TestExtensionDir sender_dir;
+  sender_dir.WriteManifest(kManifest);
+  sender_dir.WriteFile(FILE_PATH_LITERAL("background.js"), "");
+  const Extension* sender = LoadExtension(sender_dir.UnpackedPath());
+  ASSERT_TRUE(sender);
+
+  const char send_script_template[] = R"(
+    log = [];
+    log.push('sender-initial:' + navigator.userActivation.isActive);
+    chrome.runtime.sendMessage('%s', {}, response => {
+      log.push('receiver:' + response.active);
+      log.push('sender-received:' + navigator.userActivation.isActive);
+      window.domAutomationController.send(log.toString());
+    });
+    log.push('sender-sent:' + navigator.userActivation.isActive);
+  )";
+  std::string send_script =
+      base::StringPrintf(send_script_template, receiver->id().c_str());
+
+  // Without any user activation, neither the sender nor the receiver should be
+  // in active state at any moment.
+  EXPECT_EQ(
+      "sender-initial:false,sender-sent:false,receiver:false,"
+      "sender-received:false",
+      ExecuteScriptInBackgroundPage(
+          sender->id(), send_script,
+          extensions::browsertest_util::ScriptUserActivation::kDontActivate));
+
+  // With user activation before sending, the sender should be in active state
+  // all the time, and the receiver should be in active state.
+  //
+  // TODO(crbug.com/957633): The receiver should be inactive here.
+  EXPECT_EQ(
+      "sender-initial:true,sender-sent:true,receiver:true,"
+      "sender-received:true",
+      ExecuteScriptInBackgroundPage(
+          sender->id(), send_script,
+          extensions::browsertest_util::ScriptUserActivation::kActivate));
+
+  std::string send_and_consume_script = send_script + R"(
+    setTimeout(() => {
+      open().close();
+      log.push('sender-consumed:' + navigator.userActivation.isActive);
+    }, 0);
+  )";
+
+  // With user activation consumed right after sending, the sender should be in
+  // active state until consumption, and the receiver should be in active state.
+  //
+  // TODO(crbug.com/957633): The receiver should be inactive here.
+  EXPECT_EQ(
+      "sender-initial:true,sender-sent:true,sender-consumed:false,"
+      "receiver:true,sender-received:false",
+      ExecuteScriptInBackgroundPage(
+          sender->id(), send_and_consume_script,
+          extensions::browsertest_util::ScriptUserActivation::kActivate));
+}
+
 // Tests that a hosted app on a connectable site doesn't interfere with the
 // connectability of that site.
 IN_PROC_BROWSER_TEST_F(ExternallyConnectableMessagingTest, HostedAppOnWebsite) {
diff --git a/chrome/browser/external_protocol/external_protocol_handler.cc b/chrome/browser/external_protocol/external_protocol_handler.cc
index 94f799b5b4..fc54f9af7a 100644
--- a/chrome/browser/external_protocol/external_protocol_handler.cc
+++ b/chrome/browser/external_protocol/external_protocol_handler.cc
@@ -64,6 +64,7 @@ constexpr const char* kDeniedSchemes[] = {
     "hcp",
     "ie.http",
     "javascript",
+    "mk",
     "ms-help",
     "nntp",
     "res",
diff --git a/chrome/browser/external_protocol/external_protocol_handler_unittest.cc b/chrome/browser/external_protocol/external_protocol_handler_unittest.cc
index 08d35a1844..1aa83951b3 100644
--- a/chrome/browser/external_protocol/external_protocol_handler_unittest.cc
+++ b/chrome/browser/external_protocol/external_protocol_handler_unittest.cc
@@ -347,6 +347,10 @@ TEST_F(ExternalProtocolHandlerTest, TestGetBlockStateDefaultBlock) {
   block_state = ExternalProtocolHandler::GetBlockState("ie.http", nullptr,
                                                        profile_.get());
   EXPECT_EQ(ExternalProtocolHandler::BLOCK, block_state);
+  EXPECT_EQ("mk", GURL("mk:@FooBar:ie.http:res://foo.bar/baz").scheme());
+  block_state =
+      ExternalProtocolHandler::GetBlockState("mk", nullptr, profile_.get());
+  EXPECT_EQ(ExternalProtocolHandler::BLOCK, block_state);
   EXPECT_TRUE(
       profile_->GetPrefs()
           ->GetDictionary(prefs::kProtocolHandlerPerOriginAllowedProtocols)
diff --git a/chrome/browser/renderer_context_menu/render_view_context_menu.cc b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
index efcc2976aa..c012c830d9 100644
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -2298,7 +2298,9 @@ void RenderViewContextMenu::ExecuteCommand(int id, int event_flags) {
       break;
 
     case IDC_CONTENT_CONTEXT_OPENLINKOFFTHERECORD:
-      OpenURLWithExtraHeaders(params_.link_url, GURL(),
+      // Pass along the |referring_url| so we can show it in browser UI. Note
+      // that this won't and shouldn't be sent via the referrer header.
+      OpenURLWithExtraHeaders(params_.link_url, GetDocumentURL(params_),
                               WindowOpenDisposition::OFF_THE_RECORD,
                               ui::PAGE_TRANSITION_LINK, "" /* extra_headers */,
                               true /* started_from_context_menu */);
diff --git a/chrome/browser/signin/force_signin_verifier.cc b/chrome/browser/signin/force_signin_verifier.cc
index 98671562c4..721e34340c 100644
--- a/chrome/browser/signin/force_signin_verifier.cc
+++ b/chrome/browser/signin/force_signin_verifier.cc
@@ -64,7 +64,7 @@ void ForceSigninVerifier::OnAccessTokenFetchComplete(
       backoff_request_timer_.Start(
           FROM_HERE, backoff_entry_.GetTimeUntilRelease(),
           base::BindOnce(&ForceSigninVerifier::SendRequest,
-                         base::Unretained(this)));
+                         weak_factory_.GetWeakPtr()));
       access_token_fetcher_.reset();
     }
     return;
@@ -105,7 +105,7 @@ void ForceSigninVerifier::SendRequest() {
   if (content::GetNetworkConnectionTracker()->GetConnectionType(
           &type,
           base::BindOnce(&ForceSigninVerifier::SendRequestIfNetworkAvailable,
-                         base::Unretained(this)))) {
+                         weak_factory_.GetWeakPtr()))) {
     SendRequestIfNetworkAvailable(type);
   }
 }
@@ -119,13 +119,11 @@ void ForceSigninVerifier::SendRequestIfNetworkAvailable(
 
   signin::ScopeSet oauth2_scopes;
   oauth2_scopes.insert(GaiaConstants::kChromeSyncOAuth2Scope);
-  // It is safe to use Unretained(this) here given that the callback
-  // will not be invoked if this object is deleted.
   access_token_fetcher_ =
       std::make_unique<signin::PrimaryAccountAccessTokenFetcher>(
           "force_signin_verifier", identity_manager_, oauth2_scopes,
           base::BindOnce(&ForceSigninVerifier::OnAccessTokenFetchComplete,
-                         base::Unretained(this)),
+                         weak_factory_.GetWeakPtr()),
           signin::PrimaryAccountAccessTokenFetcher::Mode::kImmediate);
 }
 
diff --git a/chrome/browser/signin/force_signin_verifier.h b/chrome/browser/signin/force_signin_verifier.h
index 6afd376297..70331bf90e 100644
--- a/chrome/browser/signin/force_signin_verifier.h
+++ b/chrome/browser/signin/force_signin_verifier.h
@@ -76,6 +76,8 @@ class ForceSigninVerifier
   base::TimeTicks creation_time_;
 
   signin::IdentityManager* identity_manager_ = nullptr;
+  
+  base::WeakPtrFactory<ForceSigninVerifier> weak_factory_{this};
 
   DISALLOW_COPY_AND_ASSIGN(ForceSigninVerifier);
 };
diff --git a/chrome/browser/signin/force_signin_verifier_unittest.cc b/chrome/browser/signin/force_signin_verifier_unittest.cc
index 3528d687d5..6771b0b850 100644
--- a/chrome/browser/signin/force_signin_verifier_unittest.cc
+++ b/chrome/browser/signin/force_signin_verifier_unittest.cc
@@ -376,3 +376,28 @@ TEST(ForceSigninVerifierTest, ChangeNetworkFromWIFITo4GWithFinishedRequest) {
   // No more request because it's verfied already.
   EXPECT_EQ(nullptr, verifier.access_token_fetcher());
 }
+
+// Regression test for https://crbug.com/1259864
+TEST(ForceSigninVerifierTest, DeleteWithPendingRequestShouldNotCrash) {
+  base::test::TaskEnvironment scoped_task_env;
+  signin::IdentityTestEnvironment identity_test_env;
+  const AccountInfo account_info =
+      identity_test_env.MakePrimaryAccountAvailable(
+          "email@test.com", signin::ConsentLevel::kSync);
+
+  ConfigureNetworkConnectionTracker(NetworkConnectionType::Undecided,
+                                    NetworkResponseType::Asynchronous);
+
+  {
+    ForceSigninVerifierWithAccessToInternalsForTesting verifier(
+        identity_test_env.identity_manager());
+
+    // There is no network type at first.
+    ASSERT_EQ(nullptr, verifier.access_token_fetcher());
+
+    // Delete the verifier while the request is pending.
+  }
+
+  // Waiting for the network type returns, this should not crash.
+  SpinCurrentSequenceTaskRunner();
+}
diff --git a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
index 441d30c8d0..659af40f83 100644
--- a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
+++ b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
@@ -45,7 +45,7 @@ RecentlyUsedFoldersComboModel::Item::Item(const BookmarkNode* node,
       type(type) {
 }
 
-RecentlyUsedFoldersComboModel::Item::~Item() {}
+RecentlyUsedFoldersComboModel::Item::~Item() = default;
 
 bool RecentlyUsedFoldersComboModel::Item::operator==(const Item& item) const {
   return item.node == node && item.type == type;
@@ -54,8 +54,7 @@ bool RecentlyUsedFoldersComboModel::Item::operator==(const Item& item) const {
 RecentlyUsedFoldersComboModel::RecentlyUsedFoldersComboModel(
     BookmarkModel* model,
     const BookmarkNode* node)
-    : bookmark_model_(model),
-      node_parent_index_(0) {
+    : bookmark_model_(model), parent_node_(node->parent()) {
   bookmark_model_->AddObserver(this);
   // Use + 2 to account for bookmark bar and other node.
   std::vector<const BookmarkNode*> nodes =
@@ -87,10 +86,6 @@ RecentlyUsedFoldersComboModel::RecentlyUsedFoldersComboModel(
     items_.push_back(Item(model->mobile_node(), Item::TYPE_NODE));
   items_.push_back(Item(NULL, Item::TYPE_SEPARATOR));
   items_.push_back(Item(NULL, Item::TYPE_CHOOSE_ANOTHER_FOLDER));
-
-  auto it = std::find(items_.begin(), items_.end(),
-                      Item(node->parent(), Item::TYPE_NODE));
-  node_parent_index_ = static_cast<int>(it - items_.begin());
 }
 
 RecentlyUsedFoldersComboModel::~RecentlyUsedFoldersComboModel() {
@@ -122,7 +117,16 @@ bool RecentlyUsedFoldersComboModel::IsItemSeparatorAt(int index) const {
 }
 
 int RecentlyUsedFoldersComboModel::GetDefaultIndex() const {
-  return node_parent_index_;
+  // TODO(pbos): Ideally we shouldn't have to handle `parent_node_` removal
+  // here, the dialog should instead close immediately (and destroy `this`).
+  // If that can be resolved, this should DCHECK that it != items_.end() and
+  // a DCHECK should be added in the BookmarkModel observer methods to ensure
+  // that we don't remove `parent_node_`.
+  // TODO(pbos): Look at returning -1 here if there's no default index. Right
+  // now a lot of code in Combobox assumes an index within `items_` bounds.
+  auto it = std::find(items_.begin(), items_.end(),
+                      Item(parent_node_, Item::TYPE_NODE));
+  return it == items_.end() ? 0 : static_cast<int>(it - items_.begin());
 }
 
 void RecentlyUsedFoldersComboModel::AddObserver(
@@ -222,6 +226,7 @@ void RecentlyUsedFoldersComboModel::BookmarkAllUserNodesRemoved(
 void RecentlyUsedFoldersComboModel::MaybeChangeParent(
     const BookmarkNode* node,
     int selected_index) {
+  DCHECK_LT(selected_index, static_cast<int>(items_.size()));
   if (items_[selected_index].type != Item::TYPE_NODE)
     return;
 
@@ -234,7 +239,7 @@ void RecentlyUsedFoldersComboModel::MaybeChangeParent(
 
 const BookmarkNode* RecentlyUsedFoldersComboModel::GetNodeAt(int index) {
   if (index < 0 || index >= static_cast<int>(items_.size()))
-    return NULL;
+    return nullptr;
   return items_[index].node;
 }
 
diff --git a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.h b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.h
index 6db8245e9d..1b6e8d0b9c 100644
--- a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.h
+++ b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.h
@@ -83,10 +83,9 @@ class RecentlyUsedFoldersComboModel : public ui::ComboboxModel,
   struct Item;
   std::vector<Item> items_;
 
-  bookmarks::BookmarkModel* bookmark_model_;
+  bookmarks::BookmarkModel* const bookmark_model_;
 
-  // The index of the original parent folder.
-  int node_parent_index_;
+  const bookmarks::BookmarkNode* const parent_node_;
 
   base::ObserverList<ui::ComboboxModelObserver> observers_;
 
diff --git a/chrome/browser/ui/views/external_protocol_dialog_browsertest.cc b/chrome/browser/ui/views/external_protocol_dialog_browsertest.cc
index 4e8bc2e2ab..18a9372661 100644
--- a/chrome/browser/ui/views/external_protocol_dialog_browsertest.cc
+++ b/chrome/browser/ui/views/external_protocol_dialog_browsertest.cc
@@ -14,11 +14,15 @@
 #include "chrome/browser/ui/test/test_browser_dialog.h"
 #include "chrome/browser/ui/views/external_protocol_dialog.h"
 #include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/render_process_host.h"
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/test/browser_test.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/http_request.h"
+#include "net/test/embedded_test_server/http_response.h"
 #include "ui/views/controls/button/checkbox.h"
 #include "url/gurl.h"
 
@@ -41,6 +45,33 @@ class ExternalProtocolDialogTestApi {
 
 }  // namespace test
 
+namespace {
+constexpr char kInitiatingOrigin[] = "a.test";
+constexpr char kRedirectingOrigin[] = "b.test";
+
+class FakeDefaultProtocolClientWorker
+    : public shell_integration::DefaultProtocolClientWorker {
+ public:
+  explicit FakeDefaultProtocolClientWorker(const std::string& protocol)
+      : DefaultProtocolClientWorker(protocol) {}
+  FakeDefaultProtocolClientWorker(const FakeDefaultProtocolClientWorker&) =
+      delete;
+  FakeDefaultProtocolClientWorker& operator=(
+      const FakeDefaultProtocolClientWorker&) = delete;
+
+ private:
+  ~FakeDefaultProtocolClientWorker() override = default;
+  shell_integration::DefaultWebClientState CheckIsDefaultImpl() override {
+    return shell_integration::DefaultWebClientState::NOT_DEFAULT;
+  }
+
+  void SetAsDefaultImpl(base::OnceClosure on_finished_callback) override {
+    base::SequencedTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, std::move(on_finished_callback));
+  }
+};
+}  // namespace
+
 class ExternalProtocolDialogBrowserTest
     : public DialogBrowserTest,
       public ExternalProtocolHandler::Delegate {
@@ -72,11 +103,11 @@ class ExternalProtocolDialogBrowserTest
   // ExternalProtocolHander::Delegate:
   scoped_refptr<shell_integration::DefaultProtocolClientWorker>
   CreateShellWorker(const std::string& protocol) override {
-    return nullptr;
+    return base::MakeRefCounted<FakeDefaultProtocolClientWorker>(protocol);
   }
   ExternalProtocolHandler::BlockState GetBlockState(const std::string& scheme,
                                                     Profile* profile) override {
-    return ExternalProtocolHandler::DONT_BLOCK;
+    return ExternalProtocolHandler::UNKNOWN;
   }
   void BlockRequest() override {}
   void RunExternalProtocolDialog(
@@ -84,7 +115,10 @@ class ExternalProtocolDialogBrowserTest
       content::WebContents* web_contents,
       ui::PageTransition page_transition,
       bool has_user_gesture,
-      const base::Optional<url::Origin>& initiating_origin) override {}
+      const base::Optional<url::Origin>& initiating_origin) override {
+        url_did_launch_ = true;
+        launch_url_ = initiating_origin->host();
+      }
   void LaunchUrlWithoutSecurityCheck(
       const GURL& url,
       content::WebContents* web_contents) override {
@@ -99,6 +133,12 @@ class ExternalProtocolDialogBrowserTest
     blocked_state_ = state;
   }
 
+  void SetUpOnMainThread() override {
+    DialogBrowserTest::SetUpOnMainThread();
+    host_resolver()->AddRule(kInitiatingOrigin, "127.0.0.1");
+    host_resolver()->AddRule(kRedirectingOrigin, "127.0.0.1");
+  }
+
   base::HistogramTester histogram_tester_;
 
  protected:
@@ -107,6 +147,7 @@ class ExternalProtocolDialogBrowserTest
   url::Origin blocked_origin_;
   BlockState blocked_state_ = BlockState::UNKNOWN;
   bool url_did_launch_ = false;
+  std::string launch_url_;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(ExternalProtocolDialogBrowserTest);
@@ -232,3 +273,21 @@ IN_PROC_BROWSER_TEST_F(ExternalProtocolDialogBrowserTest, TestFocus) {
   const views::View* focused_view = focus_manager->GetFocusedView();
   EXPECT_TRUE(focused_view);
 }
+
+IN_PROC_BROWSER_TEST_F(ExternalProtocolDialogBrowserTest, OriginNameTest) {
+  ASSERT_TRUE(embedded_test_server()->Start());
+  content::WebContents* web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  EXPECT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), embedded_test_server()->GetURL("a.test", "/empty.html")));
+  EXPECT_TRUE(content::ExecJs(
+      web_contents,
+      content::JsReplace("location.href = $1",
+                         embedded_test_server()->GetURL(
+                             "b.test", "/server-redirect?ms-calc:"))));
+  content::WaitForLoadStop(web_contents);
+  EXPECT_TRUE(url_did_launch_);
+  // The url should be the url of the last redirecting server and not of the
+  // request initiator
+  EXPECT_EQ(launch_url_, "b.test");
+}
diff --git a/chrome/browser/ui/views/frame/webui_tab_strip_container_view.cc b/chrome/browser/ui/views/frame/webui_tab_strip_container_view.cc
index f22a3ce31b..fcdce3368a 100644
--- a/chrome/browser/ui/views/frame/webui_tab_strip_container_view.cc
+++ b/chrome/browser/ui/views/frame/webui_tab_strip_container_view.cc
@@ -807,8 +807,15 @@ void WebUITabStripContainerView::ShowEditDialogForGroupAtPoint(
     tab_groups::TabGroupId group) {
   ConvertPointToScreen(this, &point);
   rect.set_origin(point);
-  TabGroupEditorBubbleView::Show(browser_view_->browser(), group, nullptr, rect,
-                                 this);
+  editor_bubble_widget_ = TabGroupEditorBubbleView::Show(
+      browser_view_->browser(), group, nullptr, rect, this);
+  scoped_widget_observation_.Observe(editor_bubble_widget_);
+}
+
+void WebUITabStripContainerView::HideEditDialogForGroup() {
+  if (editor_bubble_widget_)
+    editor_bubble_widget_->CloseWithReason(
+        BrowserFrame::ClosedReason::kUnspecified);
 }
 
 TabStripUILayout WebUITabStripContainerView::GetLayout() {
@@ -907,6 +914,14 @@ void WebUITabStripContainerView::OnViewIsDeleting(View* observed_view) {
     tab_contents_container_ = nullptr;
 }
 
+void WebUITabStripContainerView::OnWidgetDestroying(views::Widget* widget) {
+  if (widget != editor_bubble_widget_)
+    return;
+
+  scoped_widget_observation_.Reset();
+  editor_bubble_widget_ = nullptr;
+}
+
 bool WebUITabStripContainerView::SetPaneFocusAndFocusDefault() {
   // Make sure the pane first receives focus, then send a WebUI event to the
   // front-end so the correct HTML element receives focus.
diff --git a/chrome/browser/ui/views/frame/webui_tab_strip_container_view.h b/chrome/browser/ui/views/frame/webui_tab_strip_container_view.h
index 536365f0a0..c5e03129ad 100644
--- a/chrome/browser/ui/views/frame/webui_tab_strip_container_view.h
+++ b/chrome/browser/ui/views/frame/webui_tab_strip_container_view.h
@@ -23,6 +23,7 @@
 #include "ui/views/accessible_pane_view.h"
 #include "ui/views/view.h"
 #include "ui/views/widget/widget.h"
+#include "ui/views/widget/widget_observer.h"
 
 #if !BUILDFLAG(ENABLE_WEBUI_TAB_STRIP)
 #error
@@ -47,6 +48,7 @@ class ImmersiveRevealedLock;
 class WebUITabStripContainerView : public TabStripUIEmbedder,
                                    public gfx::AnimationDelegate,
                                    public views::AccessiblePaneView,
+                                   public views::WidgetObserver,
                                    public views::ViewObserver {
  public:
   WebUITabStripContainerView(BrowserView* browser_view,
@@ -114,6 +116,7 @@ class WebUITabStripContainerView : public TabStripUIEmbedder,
   void ShowEditDialogForGroupAtPoint(gfx::Point point,
                                      gfx::Rect rect,
                                      tab_groups::TabGroupId group) override;
+  void HideEditDialogForGroup() override;
   TabStripUILayout GetLayout() override;
   SkColor GetColor(int id) const override;
   SkColor GetSystemColor(ui::NativeTheme::ColorId id) const override;
@@ -132,6 +135,9 @@ class WebUITabStripContainerView : public TabStripUIEmbedder,
   void OnViewBoundsChanged(View* observed_view) override;
   void OnViewIsDeleting(View* observed_view) override;
 
+  // views::WidgetObserver:
+  void OnWidgetDestroying(views::Widget* widget) override;
+
   // views::AccessiblePaneView
   bool SetPaneFocusAndFocusDefault() override;
 
@@ -171,6 +177,10 @@ class WebUITabStripContainerView : public TabStripUIEmbedder,
 
   base::ScopedMultiSourceObservation<views::View, views::ViewObserver>
       view_observations_{this};
+  base::ScopedObservation<views::Widget, views::WidgetObserver>
+      scoped_widget_observation_{this};
+
+  views::Widget* editor_bubble_widget_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_FRAME_WEBUI_TAB_STRIP_CONTAINER_VIEW_H_
diff --git a/chrome/browser/ui/webui/discards/discards_ui.h b/chrome/browser/ui/webui/discards/discards_ui.h
index 9f9baf35a0..187dc9573a 100644
--- a/chrome/browser/ui/webui/discards/discards_ui.h
+++ b/chrome/browser/ui/webui/discards/discards_ui.h
@@ -37,7 +37,6 @@ class DiscardsUI : public ui::MojoWebUIController {
 
  private:
   std::unique_ptr<discards::mojom::DetailsProvider> ui_handler_;
-  std::unique_ptr<discards::mojom::SiteDataProvider> site_data_provider_;
   std::string profile_id_;
 
   WEB_UI_CONTROLLER_TYPE_DECL();
diff --git a/chrome/browser/ui/webui/settings/settings_startup_pages_handler.cc b/chrome/browser/ui/webui/settings/settings_startup_pages_handler.cc
index 0509d30670..eb980b3208 100644
--- a/chrome/browser/ui/webui/settings/settings_startup_pages_handler.cc
+++ b/chrome/browser/ui/webui/settings/settings_startup_pages_handler.cc
@@ -136,7 +136,7 @@ void StartupPagesHandler::HandleEditStartupPage(const base::ListValue* args) {
   int index;
   CHECK(args->GetInteger(1, &index));
 
-  if (index < 0 || index > startup_custom_pages_table_model_.RowCount()) {
+  if (index < 0 || index >= startup_custom_pages_table_model_.RowCount()) {
     RejectJavascriptCallback(*callback_id, base::Value());
     NOTREACHED();
     return;
diff --git a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_browsertest.cc b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_browsertest.cc
index 13f082cfbb..cb9a610cc2 100644
--- a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_browsertest.cc
+++ b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_browsertest.cc
@@ -45,6 +45,7 @@ class MockTabStripUIEmbedder : public TabStripUIEmbedder {
                void(gfx::Point, std::unique_ptr<ui::MenuModel>));
   MOCK_METHOD3(ShowEditDialogForGroupAtPoint,
                void(gfx::Point, gfx::Rect, tab_groups::TabGroupId));
+  MOCK_METHOD0(HideEditDialogForGroup, void());
   MOCK_METHOD0(GetLayout, TabStripUILayout());
   MOCK_CONST_METHOD1(GetColor, SkColor(int));
   MOCK_CONST_METHOD1(GetSystemColor, SkColor(ui::NativeTheme::ColorId));
diff --git a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_embedder.h b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_embedder.h
index 980326cb29..d04fd92537 100644
--- a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_embedder.h
+++ b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_embedder.h
@@ -31,6 +31,8 @@ class TabStripUIEmbedder {
                                              gfx::Rect rect,
                                              tab_groups::TabGroupId group) = 0;
 
+  virtual void HideEditDialogForGroup() = 0;
+
   virtual TabStripUILayout GetLayout() = 0;
 
   virtual SkColor GetColor(int id) const = 0;
diff --git a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc
index 3ef87b45d4..b56ce1f842 100644
--- a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc
+++ b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc
@@ -228,6 +228,7 @@ void TabStripUIHandler::OnTabGroupChanged(const TabGroupChange& change) {
     }
 
     case TabGroupChange::kClosed: {
+      embedder_->HideEditDialogForGroup();
       FireWebUIListener("tab-group-closed",
                         base::Value(change.group.ToString()));
       break;
diff --git a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler_unittest.cc b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler_unittest.cc
index 8dcd0c0a7d..77e9657606 100644
--- a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler_unittest.cc
+++ b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler_unittest.cc
@@ -52,6 +52,7 @@ class StubTabStripUIEmbedder : public TabStripUIEmbedder {
                                      gfx::Rect rect,
                                      tab_groups::TabGroupId group_id) override {
   }
+  void HideEditDialogForGroup() override {}
   TabStripUILayout GetLayout() override { return TabStripUILayout(); }
   SkColor GetColor(int id) const override { return SK_ColorWHITE; }
   SkColor GetSystemColor(ui::NativeTheme::ColorId id) const override {
diff --git a/components/download/content/internal/download_driver_impl.cc b/components/download/content/internal/download_driver_impl.cc
index eb5d6fc2d0..668ae8488d 100644
--- a/components/download/content/internal/download_driver_impl.cc
+++ b/components/download/content/internal/download_driver_impl.cc
@@ -176,6 +176,7 @@ void DownloadDriverImpl::Start(
   download_url_params->set_guid(guid);
   download_url_params->set_transient(true);
   download_url_params->set_method(request_params.method);
+  download_url_params->set_credentials_mode(request_params.credentials_mode);
   download_url_params->set_file_path(file_path);
   if (request_params.fetch_error_body)
     download_url_params->set_fetch_error_body(true);
@@ -189,6 +190,10 @@ void DownloadDriverImpl::Start(
                           weak_ptr_factory_.GetWeakPtr(), guid));
   download_url_params->set_require_safety_checks(
       request_params.require_safety_checks);
+  if (request_params.isolation_info) {
+    download_url_params->set_isolation_info(
+        request_params.isolation_info.value());
+  }
   download_manager_coordinator_->DownloadUrl(std::move(download_url_params));
 }
 
diff --git a/components/download/database/DEPS b/components/download/database/DEPS
index 4e8777c36f..727aa9d8f9 100644
--- a/components/download/database/DEPS
+++ b/components/download/database/DEPS
@@ -1,5 +1,6 @@
 include_rules = [
   "+components/download/public/common",
   "+components/leveldb_proto",
-  "+services/metrics/public"
+  "+services/metrics/public",
+  "+services/network/public/mojom",
 ]
diff --git a/components/download/database/download_db_conversions.cc b/components/download/database/download_db_conversions.cc
index 2e6291671e..769db52d68 100644
--- a/components/download/database/download_db_conversions.cc
+++ b/components/download/database/download_db_conversions.cc
@@ -9,6 +9,7 @@
 #include "base/notreached.h"
 #include "base/pickle.h"
 #include "components/download/public/common/download_features.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 
 namespace download {
 namespace {
@@ -218,7 +219,8 @@ download_pb::InProgressInfo DownloadDBConversions::InProgressInfoToProto(
             in_progress_info.download_schedule.value()));
     proto.set_allocated_download_schedule(download_schedule_proto.release());
   }
-
+  proto.set_credentials_mode(
+      static_cast<int32_t>(in_progress_info.credentials_mode));
   return proto;
 }
 
@@ -275,6 +277,10 @@ InProgressInfo DownloadDBConversions::InProgressInfoFromProto(
         proto.download_schedule(), !proto.metered() /*only_on_wifi*/);
     DCHECK_NE(info.download_schedule->only_on_wifi(), info.metered);
   }
+  if (proto.has_credentials_mode()) {
+    info.credentials_mode = static_cast<::network::mojom::CredentialsMode>(
+        proto.credentials_mode());
+  }
 
   return info;
 }
diff --git a/components/download/database/download_db_conversions_unittest.cc b/components/download/database/download_db_conversions_unittest.cc
index a2b80872d1..13d1513df0 100644
--- a/components/download/database/download_db_conversions_unittest.cc
+++ b/components/download/database/download_db_conversions_unittest.cc
@@ -9,6 +9,7 @@
 #include "components/download/public/common/download_features.h"
 #include "components/download/public/common/download_schedule.h"
 #include "components/download/public/common/download_url_parameters.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace download {
@@ -52,6 +53,7 @@ InProgressInfo CreateInProgressInfo() {
       std::make_pair<std::string, std::string>("ABC", "def"));
   info.download_schedule = base::make_optional<DownloadSchedule>(
       false /*only_on_wifi*/, base::nullopt);
+  info.credentials_mode = ::network::mojom::CredentialsMode::kOmit;
   return info;
 }
 
diff --git a/components/download/database/in_progress/in_progress_info.cc b/components/download/database/in_progress/in_progress_info.cc
index 61a7afbd02..5ad63174a5 100644
--- a/components/download/database/in_progress/in_progress_info.cc
+++ b/components/download/database/in_progress/in_progress_info.cc
@@ -31,7 +31,8 @@ bool InProgressInfo::operator==(const InProgressInfo& other) const {
          interrupt_reason == other.interrupt_reason && paused == other.paused &&
          metered == other.metered && bytes_wasted == other.bytes_wasted &&
          auto_resume_count == other.auto_resume_count &&
-         download_schedule == other.download_schedule;
+         download_schedule == other.download_schedule &&
+         credentials_mode == other.credentials_mode;
 }
 
 }  // namespace download
diff --git a/components/download/database/in_progress/in_progress_info.h b/components/download/database/in_progress/in_progress_info.h
index 2b67686c04..358964e32c 100644
--- a/components/download/database/in_progress/in_progress_info.h
+++ b/components/download/database/in_progress/in_progress_info.h
@@ -13,6 +13,7 @@
 #include "components/download/public/common/download_item.h"
 #include "components/download/public/common/download_schedule.h"
 #include "components/download/public/common/download_url_parameters.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "url/gurl.h"
 
 namespace download {
@@ -126,6 +127,10 @@ struct InProgressInfo {
 
   // When to start the download. Used by download later feature.
   base::Optional<DownloadSchedule> download_schedule;
+
+  // The credentials mode of the request.
+  ::network::mojom::CredentialsMode credentials_mode =
+      ::network::mojom::CredentialsMode::kInclude;
 };
 
 }  // namespace download
diff --git a/components/download/database/proto/download_entry.proto b/components/download/database/proto/download_entry.proto
index af78857228..8cbc590dfd 100644
--- a/components/download/database/proto/download_entry.proto
+++ b/components/download/database/proto/download_entry.proto
@@ -79,6 +79,7 @@ message InProgressInfo {
   optional int64 bytes_wasted = 26;
   optional int32 auto_resume_count = 27;
   optional DownloadSchedule download_schedule = 28;
+  optional int32 credentials_mode = 30;  // network::mojom::CredentialsMode
 }
 
 // Stores various metadata related to a download.
diff --git a/components/download/internal/background_service/BUILD.gn b/components/download/internal/background_service/BUILD.gn
index e81d8f4668..6097be2417 100644
--- a/components/download/internal/background_service/BUILD.gn
+++ b/components/download/internal/background_service/BUILD.gn
@@ -89,6 +89,7 @@ static_library("internal") {
     "//components/download/public/background_service:public",
     "//components/leveldb_proto",
     "//net",
+    "//services/network/public/mojom:url_loader_base",
     "//services/network/public/cpp",
     "//storage/browser",
   ]
diff --git a/components/download/internal/background_service/in_memory_download.cc b/components/download/internal/background_service/in_memory_download.cc
index f5e369ff66..ccf54bdff7 100644
--- a/components/download/internal/background_service/in_memory_download.cc
+++ b/components/download/internal/background_service/in_memory_download.cc
@@ -204,6 +204,10 @@ void InMemoryDownloadImpl::SendRequest() {
     request->request_body = std::move(request_body_);
     request->enable_upload_progress = true;
   }
+  if (request_params_.isolation_info) {
+    request->site_for_cookies =
+        request_params_.isolation_info->site_for_cookies();
+  }
 
   url_chain_.push_back(request_params_.url);
 
diff --git a/components/download/internal/background_service/proto/request.proto b/components/download/internal/background_service/proto/request.proto
index 485bf6b6ae..346a201a5e 100644
--- a/components/download/internal/background_service/proto/request.proto
+++ b/components/download/internal/background_service/proto/request.proto
@@ -20,4 +20,5 @@ message RequestParams {
   repeated RequestHeader headers = 3;
   optional bool fetch_error_body = 4;
   optional bool require_safety_checks = 5 [default = true];
+  optional int32 credentials_mode = 6;  // network::mojom::CredentialsMode.
 }
diff --git a/components/download/internal/background_service/proto_conversions.cc b/components/download/internal/background_service/proto_conversions.cc
index 560fd484d0..1768714f0c 100644
--- a/components/download/internal/background_service/proto_conversions.cc
+++ b/components/download/internal/background_service/proto_conversions.cc
@@ -9,6 +9,7 @@
 #include "components/download/internal/background_service/proto_conversions.h"
 #include "net/http/http_request_headers.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 
 namespace download {
 
@@ -250,6 +251,14 @@ RequestParams ProtoConversions::RequestParamsFromProto(
   request_params.method = proto.method();
   request_params.fetch_error_body = proto.fetch_error_body();
   request_params.require_safety_checks = proto.require_safety_checks();
+  if (proto.has_credentials_mode()) {
+    request_params.credentials_mode =
+        static_cast<::network::mojom::CredentialsMode>(
+            proto.credentials_mode());
+  } else {
+    request_params.credentials_mode =
+        ::network::mojom::CredentialsMode::kInclude;
+  }
 
   for (int i = 0; i < proto.headers_size(); i++) {
     protodb::RequestHeader header = proto.headers(i);
@@ -265,6 +274,8 @@ void ProtoConversions::RequestParamsToProto(const RequestParams& request_params,
   proto->set_method(request_params.method);
   proto->set_fetch_error_body(request_params.fetch_error_body);
   proto->set_require_safety_checks(request_params.require_safety_checks);
+  proto->set_credentials_mode(
+      static_cast<int32_t>(request_params.credentials_mode));
 
   int i = 0;
   net::HttpRequestHeaders::Iterator iter(request_params.request_headers);
diff --git a/components/download/internal/background_service/proto_conversions_unittest.cc b/components/download/internal/background_service/proto_conversions_unittest.cc
index 4307d0cbfd..ef4b561bff 100644
--- a/components/download/internal/background_service/proto_conversions_unittest.cc
+++ b/components/download/internal/background_service/proto_conversions_unittest.cc
@@ -9,6 +9,7 @@
 #include "components/download/internal/background_service/entry.h"
 #include "components/download/internal/background_service/proto_conversions.h"
 #include "components/download/internal/background_service/test/entry_utils.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
@@ -99,6 +100,7 @@ TEST_F(ProtoConversionsTest, RequestParamsWithHeadersConversion) {
   expected.method = "GET";
   expected.fetch_error_body = true;
   expected.require_safety_checks = false;
+  expected.credentials_mode = ::network::mojom::CredentialsMode::kInclude;
   expected.request_headers.SetHeader("key1", "value1");
   expected.request_headers.SetHeader("key2", "value2");
 
@@ -110,6 +112,7 @@ TEST_F(ProtoConversionsTest, RequestParamsWithHeadersConversion) {
   EXPECT_EQ(expected.method, actual.method);
   EXPECT_EQ(expected.fetch_error_body, actual.fetch_error_body);
   EXPECT_EQ(expected.require_safety_checks, actual.require_safety_checks);
+  EXPECT_EQ(expected.credentials_mode, actual.credentials_mode);
 
   std::string out;
   actual.request_headers.GetHeader("key1", &out);
@@ -120,6 +123,19 @@ TEST_F(ProtoConversionsTest, RequestParamsWithHeadersConversion) {
             actual.request_headers.ToString());
 }
 
+TEST_F(ProtoConversionsTest, RequestParamsWithMissingCredentialsMode) {
+  RequestParams expected;
+  expected.url = GURL(TEST_URL);
+  expected.method = "GET";
+
+  protodb::RequestParams proto;
+  RequestParamsToProto(expected, &proto);
+  RequestParams actual = RequestParamsFromProto(proto);
+
+  EXPECT_EQ(expected.credentials_mode,
+            ::network::mojom::CredentialsMode::kInclude);
+}
+
 TEST_F(ProtoConversionsTest, EntryConversion) {
   Entry expected = test::BuildEntry(DownloadClient::TEST, base::GenerateGUID());
   Entry actual = EntryFromProto(EntryToProto(expected));
diff --git a/components/download/internal/common/download_create_info.cc b/components/download/internal/common/download_create_info.cc
index bba0342d59..c0c4f01d53 100644
--- a/components/download/internal/common/download_create_info.cc
+++ b/components/download/internal/common/download_create_info.cc
@@ -32,7 +32,9 @@ DownloadCreateInfo::DownloadCreateInfo(
       connection_info(net::HttpResponseInfo::CONNECTION_INFO_UNKNOWN),
       method("GET"),
       ukm_source_id(ukm::kInvalidSourceId),
-      is_content_initiated(false) {}
+      is_content_initiated(false),
+      credentials_mode(::network::mojom::CredentialsMode::kInclude),
+      isolation_info(base::nullopt) {}
 
 DownloadCreateInfo::DownloadCreateInfo()
     : DownloadCreateInfo(base::Time(), std::make_unique<DownloadSaveInfo>()) {}
diff --git a/components/download/internal/common/download_item_impl.cc b/components/download/internal/common/download_item_impl.cc
index f557ef8795..100493f1b5 100644
--- a/components/download/internal/common/download_item_impl.cc
+++ b/components/download/internal/common/download_item_impl.cc
@@ -234,7 +234,9 @@ DownloadItemImpl::RequestInfo::RequestInfo(
     ui::PageTransition transition_type,
     bool has_user_gesture,
     const std::string& remote_address,
-    base::Time start_time)
+    base::Time start_time,
+    ::network::mojom::CredentialsMode credentials_mode,
+    const base::Optional<net::IsolationInfo>& isolation_info)
     : url_chain(url_chain),
       referrer_url(referrer_url),
       site_url(site_url),
@@ -246,7 +248,9 @@ DownloadItemImpl::RequestInfo::RequestInfo(
       transition_type(transition_type),
       has_user_gesture(has_user_gesture),
       remote_address(remote_address),
-      start_time(start_time) {}
+      start_time(start_time),
+      credentials_mode(credentials_mode),
+      isolation_info(isolation_info) {}
 
 DownloadItemImpl::RequestInfo::RequestInfo(const GURL& url)
     : url_chain(std::vector<GURL>(1, url)), start_time(base::Time::Now()) {}
@@ -328,7 +332,9 @@ DownloadItemImpl::DownloadItemImpl(
                     ui::PAGE_TRANSITION_LINK,
                     false,
                     std::string(),
-                    start_time),
+                    start_time,
+                    ::network::mojom::CredentialsMode::kInclude,
+                    base::nullopt),
       guid_(guid),
       download_id_(download_id),
       mime_type_(mime_type),
@@ -389,7 +395,9 @@ DownloadItemImpl::DownloadItemImpl(DownloadItemImplDelegate* delegate,
                                          : ui::PAGE_TRANSITION_LINK,
                     info.has_user_gesture,
                     info.remote_address,
-                    info.start_time),
+                    info.start_time,
+                    info.credentials_mode,
+                    info.isolation_info),
       guid_(info.guid.empty() ? base::GenerateGUID() : info.guid),
       download_id_(download_id),
       response_headers_(info.response_headers),
@@ -1129,6 +1137,15 @@ const base::Optional<DownloadSchedule>& DownloadItemImpl::GetDownloadSchedule()
   return download_schedule_;
 }
 
+::network::mojom::CredentialsMode DownloadItemImpl::GetCredentialsMode() const {
+  return request_info_.credentials_mode;
+}
+
+const base::Optional<net::IsolationInfo>& DownloadItemImpl::GetIsolationInfo()
+    const {
+  return request_info_.isolation_info;
+}
+
 void DownloadItemImpl::OnContentCheckCompleted(DownloadDangerType danger_type,
                                                DownloadInterruptReason reason) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
diff --git a/components/download/internal/common/download_response_handler.cc b/components/download/internal/common/download_response_handler.cc
index a5f785aca0..8bdce0e0d2 100644
--- a/components/download/internal/common/download_response_handler.cc
+++ b/components/download/internal/common/download_response_handler.cc
@@ -75,6 +75,7 @@ DownloadResponseHandler::DownloadResponseHandler(
       request_origin_(request_origin),
       download_source_(download_source),
       has_strong_validators_(false),
+      credentials_mode_(resource_request->credentials_mode),
       is_partial_request_(save_info_->offset > 0),
       completed_(false),
       abort_reason_(DOWNLOAD_INTERRUPT_REASON_NONE),
@@ -84,6 +85,9 @@ DownloadResponseHandler::DownloadResponseHandler(
   }
   if (resource_request->request_initiator.has_value())
     request_initiator_ = resource_request->request_initiator;
+
+  if (resource_request->trusted_params)
+    isolation_info_ = resource_request->trusted_params->isolation_info;
 }
 
 DownloadResponseHandler::~DownloadResponseHandler() = default;
@@ -150,6 +154,8 @@ DownloadResponseHandler::CreateDownloadCreateInfo(
   create_info->request_origin = request_origin_;
   create_info->download_source = download_source_;
   create_info->request_initiator = request_initiator_;
+  create_info->credentials_mode = credentials_mode_;
+  create_info->isolation_info = isolation_info_;
 
   HandleResponseHeaders(head.headers.get(), create_info.get());
   return create_info;
diff --git a/components/download/internal/common/download_utils.cc b/components/download/internal/common/download_utils.cc
index 6ad1043959..5ef7d03541 100644
--- a/components/download/internal/common/download_utils.cc
+++ b/components/download/internal/common/download_utils.cc
@@ -438,6 +438,7 @@ DownloadDBEntry CreateDownloadDBEntryFromItem(const DownloadItemImpl& item) {
   in_progress_info.bytes_wasted = item.GetBytesWasted();
   in_progress_info.auto_resume_count = item.GetAutoResumeCount();
   in_progress_info.download_schedule = item.GetDownloadSchedule();
+  in_progress_info.credentials_mode = item.GetCredentialsMode();
 
   download_info.in_progress_info = in_progress_info;
 
diff --git a/components/download/public/background_service/BUILD.gn b/components/download/public/background_service/BUILD.gn
index 0e22c563e2..e4d3fad19b 100644
--- a/components/download/public/background_service/BUILD.gn
+++ b/components/download/public/background_service/BUILD.gn
@@ -27,7 +27,10 @@ source_set("public") {
     "service_config.h",
   ]
 
-  deps = [ "//components/keyed_service/core" ]
+  deps = [
+     "//components/keyed_service/core",
+     "//services/network/public/mojom:url_loader_base",
+  ]
 
   # TODO(xingliu): Create blob target that doesn't need to depend on blink.
   # Currently gn header check will fail even if the code is not built into any targets.
diff --git a/components/download/public/background_service/DEPS b/components/download/public/background_service/DEPS
index 4d8aa673f1..74b585b295 100644
--- a/components/download/public/background_service/DEPS
+++ b/components/download/public/background_service/DEPS
@@ -2,9 +2,11 @@ include_rules = [
   "-content",
   "+base",
   "+components/keyed_service",
+  "+net/base",
   "+net/http",
   "+net/traffic_annotation",
   "+services/network/public/cpp",
+  "+services/network/public/mojom",
   "+storage/browser",
   "+url",
 ]
diff --git a/components/download/public/background_service/download_params.cc b/components/download/public/background_service/download_params.cc
index 00a3ccbd9c..8a1a504a98 100644
--- a/components/download/public/background_service/download_params.cc
+++ b/components/download/public/background_service/download_params.cc
@@ -21,9 +21,13 @@ bool SchedulingParams::operator==(const SchedulingParams& rhs) const {
 }
 
 RequestParams::RequestParams()
-    : method("GET"), fetch_error_body(false), require_safety_checks(true) {}
+    : method("GET"),
+      fetch_error_body(false),
+      require_safety_checks(true),
+      credentials_mode(::network::mojom::CredentialsMode::kInclude) {}
 
 RequestParams::RequestParams(const RequestParams& other) = default;
+RequestParams::~RequestParams() = default;
 
 DownloadParams::DownloadParams() : client(DownloadClient::INVALID) {}
 
diff --git a/components/download/public/background_service/download_params.h b/components/download/public/background_service/download_params.h
index b16c150d8a..8aabeab939 100644
--- a/components/download/public/background_service/download_params.h
+++ b/components/download/public/background_service/download_params.h
@@ -8,8 +8,11 @@
 #include "base/callback.h"
 #include "base/time/time.h"
 #include "components/download/public/background_service/clients.h"
+#include "net/base/isolation_info.h"
 #include "net/http/http_request_headers.h"
 #include "net/traffic_annotation/network_traffic_annotation.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 #include "url/gurl.h"
 
 namespace download {
@@ -96,7 +99,7 @@ struct RequestParams {
  public:
   RequestParams();
   RequestParams(const RequestParams& other);
-  ~RequestParams() = default;
+  ~RequestParams();
 
   GURL url;
 
@@ -110,6 +113,12 @@ struct RequestParams {
 
   // Whether the download is not trustworthy and requires safe browsing checks.
   bool require_safety_checks;
+
+  // The credentials mode of the request.
+  ::network::mojom::CredentialsMode credentials_mode;
+  // The isolation info of the request, this won't be persisted to db and will
+  // be invalidate during download resumption in new browser session.
+  base::Optional<net::IsolationInfo> isolation_info;
 };
 
 // The parameters that describe a download request made to the DownloadService.
diff --git a/components/download/public/common/BUILD.gn b/components/download/public/common/BUILD.gn
index 3c8df71fb8..a0005014bf 100644
--- a/components/download/public/common/BUILD.gn
+++ b/components/download/public/common/BUILD.gn
@@ -79,6 +79,7 @@ component("public") {
     "//components/services/quarantine/public/mojom",
     "//mojo/public/cpp/bindings",
     "//services/network/public/cpp",
+    "//services/network/public/mojom:url_loader_base",
   ]
 
   deps = [
diff --git a/components/download/public/common/download_create_info.h b/components/download/public/common/download_create_info.h
index b8c6e21b1b..51d58903e0 100644
--- a/components/download/public/common/download_create_info.h
+++ b/components/download/public/common/download_create_info.h
@@ -25,6 +25,7 @@
 #include "net/http/http_response_info.h"
 #include "net/url_request/referrer_policy.h"
 #include "services/metrics/public/cpp/ukm_source_id.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "ui/base/page_transition_types.h"
 #include "url/gurl.h"
 #include "url/origin.h"
@@ -176,6 +177,11 @@ struct COMPONENTS_DOWNLOAD_EXPORT DownloadCreateInfo {
   // Whether download is initated by the content on the page.
   bool is_content_initiated;
 
+  ::network::mojom::CredentialsMode credentials_mode;
+
+  // Isolation info for the download request, mainly for same site cookies.
+  base::Optional<net::IsolationInfo> isolation_info;
+
  private:
   DISALLOW_COPY_AND_ASSIGN(DownloadCreateInfo);
 };
diff --git a/components/download/public/common/download_item.h b/components/download/public/common/download_item.h
index b561de01fb..5d4f74b742 100644
--- a/components/download/public/common/download_item.h
+++ b/components/download/public/common/download_item.h
@@ -33,6 +33,8 @@
 #include "components/download/public/common/download_interrupt_reasons.h"
 #include "components/download/public/common/download_schedule.h"
 #include "components/download/public/common/download_source.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
+#include "net/base/isolation_info.h"
 #include "ui/base/page_transition_types.h"
 #include "url/origin.h"
 
@@ -351,6 +353,13 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadItem : public base::SupportsUserData {
   // DownloadSource prompting this download.
   virtual DownloadSource GetDownloadSource() const = 0;
 
+  // The credentials mode of the request.
+  virtual ::network::mojom::CredentialsMode GetCredentialsMode() const = 0;
+
+  // The isolation mode of the request.
+  virtual const base::Optional<net::IsolationInfo>& GetIsolationInfo()
+      const = 0;
+
   //    Destination State accessors --------------------------------------------
 
   // Full path to the downloaded or downloading file. This is the path to the
diff --git a/components/download/public/common/download_item_impl.h b/components/download/public/common/download_item_impl.h
index 2868b25bd9..6d970f5630 100644
--- a/components/download/public/common/download_item_impl.h
+++ b/components/download/public/common/download_item_impl.h
@@ -31,6 +31,7 @@
 #include "components/download/public/common/url_loader_factory_provider.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "services/device/public/mojom/wake_lock_provider.mojom.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 
@@ -60,7 +61,9 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadItemImpl
                 ui::PageTransition transition_type,
                 bool has_user_gesture,
                 const std::string& remote_address,
-                base::Time start_time);
+                base::Time start_time,
+                ::network::mojom::CredentialsMode credentials_mode,
+                const base::Optional<net::IsolationInfo>& isolation_info);
     RequestInfo();
     explicit RequestInfo(const RequestInfo& other);
     explicit RequestInfo(const GURL& url);
@@ -104,6 +107,13 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadItemImpl
 
     // Time the download was started.
     base::Time start_time;
+
+    // The credentials mode of the request.
+    ::network::mojom::CredentialsMode credentials_mode =
+        ::network::mojom::CredentialsMode::kInclude;
+
+    // Isolation info for the request.
+    base::Optional<net::IsolationInfo> isolation_info;
   };
 
   // Information about the current state of the download destination.
@@ -301,6 +311,8 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadItemImpl
   bool IsParallelDownload() const override;
   DownloadCreationType GetDownloadCreationType() const override;
   const base::Optional<DownloadSchedule>& GetDownloadSchedule() const override;
+  ::network::mojom::CredentialsMode GetCredentialsMode() const override;
+  const base::Optional<net::IsolationInfo>& GetIsolationInfo() const override;
   void OnContentCheckCompleted(DownloadDangerType danger_type,
                                DownloadInterruptReason reason) override;
   void OnAsyncScanningCompleted(DownloadDangerType danger_type) override;
diff --git a/components/download/public/common/download_response_handler.h b/components/download/public/common/download_response_handler.h
index e7081025df..d39e0e1c7f 100644
--- a/components/download/public/common/download_response_handler.h
+++ b/components/download/public/common/download_response_handler.h
@@ -17,6 +17,7 @@
 #include "components/download/public/common/download_utils.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "net/cert/cert_status_flags.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "services/network/public/mojom/url_loader.mojom.h"
 #include "services/network/public/mojom/url_response_head.mojom.h"
 #include "url/origin.h"
@@ -100,6 +101,8 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadResponseHandler
   net::CertStatus cert_status_;
   bool has_strong_validators_;
   base::Optional<url::Origin> request_initiator_;
+  ::network::mojom::CredentialsMode credentials_mode_;
+  base::Optional<net::IsolationInfo> isolation_info_;
   bool is_partial_request_;
   bool completed_;
 
diff --git a/components/download/public/common/download_url_parameters.cc b/components/download/public/common/download_url_parameters.cc
index 0d898ac922..4ae3d9b207 100644
--- a/components/download/public/common/download_url_parameters.cc
+++ b/components/download/public/common/download_url_parameters.cc
@@ -19,6 +19,7 @@ DownloadUrlParameters::DownloadUrlParameters(
     : content_initiated_(false),
       use_if_range_(true),
       method_("GET"),
+      credentials_mode_(::network::mojom::CredentialsMode::kInclude),
       post_id_(-1),
       prefer_cache_(false),
       referrer_policy_(
diff --git a/components/download/public/common/download_url_parameters.h b/components/download/public/common/download_url_parameters.h
index 0be34e0e33..34dab4fae4 100644
--- a/components/download/public/common/download_url_parameters.h
+++ b/components/download/public/common/download_url_parameters.h
@@ -131,6 +131,12 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadUrlParameters {
   // HTTP method to use.
   void set_method(const std::string& method) { method_ = method; }
 
+  // The requests' credentials mode.
+  void set_credentials_mode(
+      ::network::mojom::CredentialsMode credentials_mode) {
+    credentials_mode_ = credentials_mode;
+  }
+
   // Body of the HTTP POST request.
   void set_post_body(scoped_refptr<network::ResourceRequestBody> post_body) {
     post_body_ = post_body;
@@ -266,6 +272,9 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadUrlParameters {
   const std::string& etag() const { return etag_; }
   bool use_if_range() const { return use_if_range_; }
   const std::string& method() const { return method_; }
+  ::network::mojom::CredentialsMode credentials_mode() const {
+    return credentials_mode_;
+  }
   scoped_refptr<network::ResourceRequestBody> post_body() { return post_body_; }
   int64_t post_id() const { return post_id_; }
   bool prefer_cache() const { return prefer_cache_; }
@@ -331,6 +340,7 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadUrlParameters {
   std::string etag_;
   bool use_if_range_;
   std::string method_;
+  ::network::mojom::CredentialsMode credentials_mode_;
   scoped_refptr<network::ResourceRequestBody> post_body_;
   BlobStorageContextGetter blob_storage_context_getter_;
   int64_t post_id_;
diff --git a/components/download/public/common/mock_download_item.h b/components/download/public/common/mock_download_item.h
index 2ca3726cbe..3db623e279 100644
--- a/components/download/public/common/mock_download_item.h
+++ b/components/download/public/common/mock_download_item.h
@@ -127,6 +127,11 @@ class MockDownloadItem : public DownloadItem {
   MOCK_CONST_METHOD0(GetDownloadCreationType, DownloadCreationType());
   MOCK_CONST_METHOD0(GetDownloadSchedule,
                      const base::Optional<DownloadSchedule>&());
+  MOCK_CONST_METHOD0(GetCredentialsMode, ::network::mojom::CredentialsMode());
+  MOCK_METHOD((const base::Optional<net::IsolationInfo>&),
+            GetIsolationInfo,
+            (),
+            (const override));
   MOCK_METHOD2(OnContentCheckCompleted,
                void(DownloadDangerType, DownloadInterruptReason));
   MOCK_METHOD1(SetOpenWhenComplete, void(bool));
diff --git a/components/page_load_metrics/browser/observers/back_forward_cache_page_load_metrics_observer.cc b/components/page_load_metrics/browser/observers/back_forward_cache_page_load_metrics_observer.cc
index 60212cae10..ade80fca4f 100644
--- a/components/page_load_metrics/browser/observers/back_forward_cache_page_load_metrics_observer.cc
+++ b/components/page_load_metrics/browser/observers/back_forward_cache_page_load_metrics_observer.cc
@@ -77,6 +77,8 @@ void BackForwardCachePageLoadMetricsObserver::
     OnFirstPaintAfterBackForwardCacheRestoreInPage(
         const page_load_metrics::mojom::BackForwardCacheTiming& timing,
         size_t index) {
+  if (index >= back_forward_cache_navigation_ids_.size())
+    return;
   auto first_paint = timing.first_paint_after_back_forward_cache_restore;
   DCHECK(!first_paint.is_zero());
   if (page_load_metrics::
@@ -109,6 +111,8 @@ void BackForwardCachePageLoadMetricsObserver::
     OnRequestAnimationFramesAfterBackForwardCacheRestoreInPage(
         const page_load_metrics::mojom::BackForwardCacheTiming& timing,
         size_t index) {
+  if (index >= back_forward_cache_navigation_ids_.size())
+    return;
   auto request_animation_frames =
       timing.request_animation_frames_after_back_forward_cache_restore;
   DCHECK_EQ(request_animation_frames.size(), 3u);
@@ -143,6 +147,8 @@ void BackForwardCachePageLoadMetricsObserver::
     OnFirstInputAfterBackForwardCacheRestoreInPage(
         const page_load_metrics::mojom::BackForwardCacheTiming& timing,
         size_t index) {
+  if (index >= back_forward_cache_navigation_ids_.size())
+    return;
   auto first_input_delay =
       timing.first_input_delay_after_back_forward_cache_restore;
   DCHECK(first_input_delay.has_value());
diff --git a/components/page_load_metrics/browser/page_load_tracker.cc b/components/page_load_metrics/browser/page_load_tracker.cc
index 846cfaa16b..f02129066b 100644
--- a/components/page_load_metrics/browser/page_load_tracker.cc
+++ b/components/page_load_metrics/browser/page_load_tracker.cc
@@ -12,6 +12,7 @@
 #include "base/check_op.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
+#include "base/strings/stringprintf.h"
 #include "base/time/default_tick_clock.h"
 #include "base/trace_event/trace_event.h"
 #include "components/page_load_metrics/browser/page_load_metrics_embedder_interface.h"
@@ -129,7 +130,13 @@ void DispatchEventsAfterBackForwardCacheRestore(
         last_timings,
     const std::vector<mojo::StructPtr<mojom::BackForwardCacheTiming>>&
         new_timings) {
-  DCHECK_GE(new_timings.size(), last_timings.size());
+  if (new_timings.size() < last_timings.size()) {
+    mojo::ReportBadMessage(base::StringPrintf(
+        "`new_timings.size()` (%zu) must be equal to or greater than "
+        "`last_timings.size()` (%zu) but is not",
+        new_timings.size(), last_timings.size()));
+    return;
+  }
 
   for (size_t i = 0; i < new_timings.size(); i++) {
     auto first_paint =
diff --git a/components/pdf/renderer/pdf_accessibility_tree.cc b/components/pdf/renderer/pdf_accessibility_tree.cc
index 3222c0aef7..269e76928d 100644
--- a/components/pdf/renderer/pdf_accessibility_tree.cc
+++ b/components/pdf/renderer/pdf_accessibility_tree.cc
@@ -1486,9 +1486,16 @@ content::RenderAccessibility* PdfAccessibilityTree::GetRenderAccessibility() {
   // If RenderAccessibility is unable to generate valid positive IDs,
   // we shouldn't use it. This can happen if Blink accessibility is disabled
   // after we started generating the accessible PDF.
+  base::WeakPtr<PdfAccessibilityTree> weak_this =
+      weak_ptr_factory_.GetWeakPtr();
   if (render_accessibility->GenerateAXID() <= 0)
     return nullptr;
 
+  // GenerateAXID() above can cause self deletion. Returning nullptr will cause
+  // callers to stop doing work.
+  if (!weak_this)
+    return nullptr;
+
   return render_accessibility;
 }
 
diff --git a/components/pdf/renderer/pdf_accessibility_tree.h b/components/pdf/renderer/pdf_accessibility_tree.h
index 16331d527b..55038a28bd 100644
--- a/components/pdf/renderer/pdf_accessibility_tree.h
+++ b/components/pdf/renderer/pdf_accessibility_tree.h
@@ -11,6 +11,7 @@
 #include <vector>
 
 #include "base/optional.h"
+#include "base/memory/weak_ptr.h"
 #include "content/public/renderer/plugin_ax_tree_source.h"
 #include "ppapi/c/pp_instance.h"
 #include "ppapi/c/private/ppb_pdf.h"
@@ -171,6 +172,8 @@ class PdfAccessibilityTree : public content::PluginAXTreeSource {
   // Index of the next expected PDF accessibility page info, used to ignore
   // outdated calls of SetAccessibilityPageInfo().
   uint32_t next_page_index_ = 0;
+
+  base::WeakPtrFactory<PdfAccessibilityTree> weak_ptr_factory_{this};
 };
 
 }  // namespace pdf
diff --git a/components/performance_manager/decorators/site_data_recorder_unittest.cc b/components/performance_manager/decorators/site_data_recorder_unittest.cc
index 003bea3d06..909533f41a 100644
--- a/components/performance_manager/decorators/site_data_recorder_unittest.cc
+++ b/components/performance_manager/decorators/site_data_recorder_unittest.cc
@@ -89,8 +89,9 @@ class MockDataCache : public SiteDataCache {
   }
   std::unique_ptr<SiteDataWriter> GetWriterForOrigin(
       const url::Origin& origin) override {
-    scoped_refptr<internal::SiteDataImpl> fake_impl = base::WrapRefCounted(
-        new internal::SiteDataImpl(origin, &delegate_, &data_store_));
+    scoped_refptr<internal::SiteDataImpl> fake_impl =
+        base::WrapRefCounted(new internal::SiteDataImpl(
+            origin, delegate_.GetWeakPtr(), &data_store_));
 
     return std::make_unique<MockDataWriter>(origin, fake_impl);
   }
diff --git a/components/performance_manager/persistence/site_data/site_data_cache_impl.cc b/components/performance_manager/persistence/site_data/site_data_cache_impl.cc
index e936a16c5d..547de3ca48 100644
--- a/components/performance_manager/persistence/site_data/site_data_cache_impl.cc
+++ b/components/performance_manager/persistence/site_data/site_data_cache_impl.cc
@@ -122,8 +122,8 @@ internal::SiteDataImpl* SiteDataCacheImpl::GetOrCreateFeatureImpl(
     return iter->second;
 
   // If not create a new one and add it to the map.
-  internal::SiteDataImpl* site_data =
-      new internal::SiteDataImpl(origin, this, data_store_.get());
+  internal::SiteDataImpl* site_data = new internal::SiteDataImpl(
+      origin, weak_factory_.GetWeakPtr(), data_store_.get());
 
   // internal::SiteDataImpl is a ref-counted object, it's safe to store a raw
   // pointer to it here as this class will get notified when it's about to be
diff --git a/components/performance_manager/persistence/site_data/site_data_cache_impl.h b/components/performance_manager/persistence/site_data/site_data_cache_impl.h
index c21c0bf72f..f7b6c462a5 100644
--- a/components/performance_manager/persistence/site_data/site_data_cache_impl.h
+++ b/components/performance_manager/persistence/site_data/site_data_cache_impl.h
@@ -15,6 +15,7 @@
 #include "base/files/file_path.h"
 #include "base/gtest_prod_util.h"
 #include "base/macros.h"
+#include "base/memory/weak_ptr.h"
 #include "base/scoped_observation.h"
 #include "base/sequence_checker.h"
 #include "components/performance_manager/persistence/site_data/site_data_cache.h"
@@ -102,6 +103,8 @@ class SiteDataCacheImpl : public SiteDataCache,
 
   SEQUENCE_CHECKER(sequence_checker_);
 
+  base::WeakPtrFactory<SiteDataCacheImpl> weak_factory_{this};
+
   DISALLOW_COPY_AND_ASSIGN(SiteDataCacheImpl);
 };
 
diff --git a/components/performance_manager/persistence/site_data/site_data_cache_impl_unittest.cc b/components/performance_manager/persistence/site_data/site_data_cache_impl_unittest.cc
index 54c692ef96..26ee928101 100644
--- a/components/performance_manager/persistence/site_data/site_data_cache_impl_unittest.cc
+++ b/components/performance_manager/persistence/site_data/site_data_cache_impl_unittest.cc
@@ -269,4 +269,19 @@ TEST_F(SiteDataCacheImplTest, InspectorWorks) {
                 browser_context_.UniqueId()));
 }
 
+// TODO(https://crbug.com/1231933): Turn this into a death test to verify that
+//     the data cache asserts that no readers outlive the cache.
+TEST_F(SiteDataCacheImplTest, NoUAFWhenReaderHeldAfterTeardown) {
+  {
+    // Hold on to this reader while destroying the data cache.
+    // This is a violation of the data cache contract. For the purpose
+    // of quick-fixing https://crbug.com/1231933, allow and survive this
+    // for now.
+    auto reader = data_cache_->GetReaderForOrigin(origin_);
+
+    // This should not UAF under ASAN.
+    data_cache_.reset();
+  }
+}
+
 }  // namespace performance_manager
diff --git a/components/performance_manager/persistence/site_data/site_data_impl.cc b/components/performance_manager/persistence/site_data/site_data_impl.cc
index eeb4a5da4c..738021a00a 100644
--- a/components/performance_manager/persistence/site_data/site_data_impl.cc
+++ b/components/performance_manager/persistence/site_data/site_data_impl.cc
@@ -169,7 +169,7 @@ SiteDataImpl::GetFeatureObservationWindowLengthForTesting() {
 }
 
 SiteDataImpl::SiteDataImpl(const url::Origin& origin,
-                           OnDestroyDelegate* delegate,
+                           base::WeakPtr<OnDestroyDelegate> delegate,
                            SiteDataStore* data_store)
     : load_duration_(kSampleWeightFactor),
       cpu_usage_estimate_(kSampleWeightFactor),
@@ -198,13 +198,19 @@ SiteDataImpl::~SiteDataImpl() {
   DCHECK(!IsLoaded());
   DCHECK_EQ(0U, loaded_tabs_in_background_count_);
 
-  DCHECK(delegate_);
-  delegate_->OnSiteDataImplDestroyed(this);
-
-  // TODO(sebmarchand): Some data might be lost here if the read operation has
-  // not completed, add some metrics to measure if this is really an issue.
-  if (is_dirty_ && fully_initialized_)
-    data_store_->WriteSiteDataIntoStore(origin_, FlushStateToProto());
+  // Make sure not to dispatch a notification to a deleted delegate, and gate
+  // the DB write on it too, as the delegate and the data store have the
+  // same lifetime.
+  // TODO(https://crbug.com/1231933): Fix this properly and restore the end of
+  //     life write here.
+  if (delegate_) {
+    delegate_->OnSiteDataImplDestroyed(this);
+
+    // TODO(sebmarchand): Some data might be lost here if the read operation has
+    // not completed, add some metrics to measure if this is really an issue.
+    if (is_dirty_ && fully_initialized_)
+      data_store_->WriteSiteDataIntoStore(origin_, FlushStateToProto());
+  }
 }
 
 base::TimeDelta SiteDataImpl::FeatureObservationDuration(
diff --git a/components/performance_manager/persistence/site_data/site_data_impl.h b/components/performance_manager/persistence/site_data/site_data_impl.h
index f48c7dd1a7..c50fe64925 100644
--- a/components/performance_manager/persistence/site_data/site_data_impl.h
+++ b/components/performance_manager/persistence/site_data/site_data_impl.h
@@ -172,7 +172,7 @@ class SiteDataImpl : public base::RefCounted<SiteDataImpl> {
   friend class performance_manager::MockDataCache;
 
   SiteDataImpl(const url::Origin& origin,
-               OnDestroyDelegate* delegate,
+               base::WeakPtr<OnDestroyDelegate> delegate,
                SiteDataStore* data_store);
 
   virtual ~SiteDataImpl();
@@ -283,7 +283,13 @@ class SiteDataImpl : public base::RefCounted<SiteDataImpl> {
 
   // The delegate that should get notified when this object is about to get
   // destroyed, it should outlive this object.
-  OnDestroyDelegate* const delegate_;
+  // The use of WeakPtr here is a temporary, minimally invasive fix for the UAF
+  // reported in https://crbug.com/1231933. By using a WeakPtr, the call-out
+  // is avoided in the case where the OnDestroyDelegate has been deleted before
+  // all SiteDataImpls have been released.
+  // The proper fix for this is going to be more invasive and less suitable
+  // for merging, should it come to that.
+  base::WeakPtr<OnDestroyDelegate> const delegate_;
 
   // Indicates if this object has been fully initialized, either because the
   // read operation from the database has completed or because it has been
diff --git a/components/performance_manager/persistence/site_data/site_data_impl_unittest.cc b/components/performance_manager/persistence/site_data/site_data_impl_unittest.cc
index 90edb917b2..0ce8da8a0b 100644
--- a/components/performance_manager/persistence/site_data/site_data_impl_unittest.cc
+++ b/components/performance_manager/persistence/site_data/site_data_impl_unittest.cc
@@ -26,9 +26,10 @@ class TestSiteDataImpl : public SiteDataImpl {
   using SiteDataImpl::site_characteristics_for_testing;
   using SiteDataImpl::TimeDeltaToInternalRepresentation;
 
-  explicit TestSiteDataImpl(const url::Origin& origin,
-                            SiteDataImpl::OnDestroyDelegate* delegate,
-                            SiteDataStore* data_store)
+  explicit TestSiteDataImpl(
+      const url::Origin& origin,
+      base::WeakPtr<SiteDataImpl::OnDestroyDelegate> delegate,
+      SiteDataStore* data_store)
       : SiteDataImpl(origin, delegate, data_store) {}
 
   base::TimeDelta FeatureObservationTimestamp(
@@ -90,7 +91,7 @@ class SiteDataImplTest : public ::testing::Test {
 
   scoped_refptr<TestSiteDataImpl> GetDataImpl(
       const url::Origin& origin,
-      SiteDataImpl::OnDestroyDelegate* destroy_delegate,
+      base::WeakPtr<SiteDataImpl::OnDestroyDelegate> destroy_delegate,
       SiteDataStore* data_store) {
     return base::MakeRefCounted<TestSiteDataImpl>(origin, destroy_delegate,
                                                   data_store);
@@ -100,7 +101,7 @@ class SiteDataImplTest : public ::testing::Test {
   // locally so it can be run later.
   scoped_refptr<TestSiteDataImpl> GetDataImplAndInterceptReadCallback(
       const url::Origin& origin,
-      SiteDataImpl::OnDestroyDelegate* destroy_delegate,
+      base::WeakPtr<SiteDataImpl::OnDestroyDelegate> destroy_delegate,
       MockDataStore* mock_data_store,
       SiteDataStore::ReadSiteDataFromStoreCallback* read_cb) {
     auto read_from_store_mock_impl =
@@ -113,7 +114,7 @@ class SiteDataImplTest : public ::testing::Test {
                 OnReadSiteDataFromStore(::testing::_, ::testing::_))
         .WillOnce(::testing::Invoke(read_from_store_mock_impl));
     auto local_site_data =
-        GetDataImpl(origin, &destroy_delegate_, mock_data_store);
+        GetDataImpl(origin, destroy_delegate_.GetWeakPtr(), mock_data_store);
     ::testing::Mock::VerifyAndClear(mock_data_store);
     return local_site_data;
   }
@@ -134,7 +135,7 @@ class SiteDataImplTest : public ::testing::Test {
 
 TEST_F(SiteDataImplTest, BasicTestEndToEnd) {
   auto local_site_data =
-      GetDataImpl(kDummyOrigin, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin, destroy_delegate_.GetWeakPtr(), &data_store);
 
   local_site_data->NotifySiteLoaded();
   local_site_data->NotifyLoadedSiteBackgrounded();
@@ -191,7 +192,7 @@ TEST_F(SiteDataImplTest, BasicTestEndToEnd) {
 
 TEST_F(SiteDataImplTest, LastLoadedTime) {
   auto local_site_data =
-      GetDataImpl(kDummyOrigin, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin, destroy_delegate_.GetWeakPtr(), &data_store);
 
   // Create a second instance of this object, simulates having several tab
   // owning it.
@@ -222,7 +223,7 @@ TEST_F(SiteDataImplTest, LastLoadedTime) {
 
 TEST_F(SiteDataImplTest, GetFeatureUsageForUnloadedSite) {
   auto local_site_data =
-      GetDataImpl(kDummyOrigin, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin, destroy_delegate_.GetWeakPtr(), &data_store);
 
   local_site_data->NotifySiteLoaded();
   local_site_data->NotifyLoadedSiteBackgrounded();
@@ -275,7 +276,7 @@ TEST_F(SiteDataImplTest, AllDurationGetSavedOnUnload) {
   // This test helps making sure that the observation/timestamp fields get saved
   // for all the features being tracked.
   auto local_site_data =
-      GetDataImpl(kDummyOrigin, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin, destroy_delegate_.GetWeakPtr(), &data_store);
 
   const base::TimeDelta kInterval = base::TimeDelta::FromSeconds(1);
   const auto kIntervalInternalRepresentation =
@@ -340,7 +341,7 @@ TEST_F(SiteDataImplTest, DestroyNotifiesDelegate) {
       strict_delegate;
   {
     auto local_site_data =
-        GetDataImpl(kDummyOrigin, &strict_delegate, &data_store);
+        GetDataImpl(kDummyOrigin, strict_delegate.GetWeakPtr(), &data_store);
     EXPECT_CALL(strict_delegate,
                 OnSiteDataImplDestroyed(local_site_data.get()));
   }
@@ -357,7 +358,7 @@ TEST_F(SiteDataImplTest, OnInitCallbackMergePreviousObservations) {
   SiteDataStore::ReadSiteDataFromStoreCallback read_cb;
 
   auto local_site_data = GetDataImplAndInterceptReadCallback(
-      kDummyOrigin, &destroy_delegate_, &mock_data_store, &read_cb);
+      kDummyOrigin, destroy_delegate_.GetWeakPtr(), &mock_data_store, &read_cb);
 
   // Simulates audio in background usage before the callback gets called.
   local_site_data->NotifySiteLoaded();
@@ -481,7 +482,7 @@ TEST_F(SiteDataImplTest, LateAsyncReadDoesntEraseData) {
   SiteDataStore::ReadSiteDataFromStoreCallback read_cb;
 
   auto local_site_data_writer = GetDataImplAndInterceptReadCallback(
-      kDummyOrigin, &destroy_delegate_, &mock_data_store, &read_cb);
+      kDummyOrigin, destroy_delegate_.GetWeakPtr(), &mock_data_store, &read_cb);
 
   local_site_data_writer->NotifySiteLoaded();
   local_site_data_writer->NotifyLoadedSiteBackgrounded();
@@ -510,7 +511,7 @@ TEST_F(SiteDataImplTest, LateAsyncReadDoesntBypassClearEvent) {
   SiteDataStore::ReadSiteDataFromStoreCallback read_cb;
 
   auto local_site_data = GetDataImplAndInterceptReadCallback(
-      kDummyOrigin, &destroy_delegate_, &mock_data_store, &read_cb);
+      kDummyOrigin, destroy_delegate_.GetWeakPtr(), &mock_data_store, &read_cb);
 
   local_site_data->NotifySiteLoaded();
   local_site_data->NotifyLoadedSiteBackgrounded();
@@ -527,7 +528,7 @@ TEST_F(SiteDataImplTest, LateAsyncReadDoesntBypassClearEvent) {
 
 TEST_F(SiteDataImplTest, BackgroundedCountTests) {
   auto local_site_data =
-      GetDataImpl(kDummyOrigin, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin, destroy_delegate_.GetWeakPtr(), &data_store);
 
   // By default the tabs are expected to be foregrounded.
   EXPECT_EQ(0U, local_site_data->loaded_tabs_in_background_count_for_testing());
@@ -585,7 +586,7 @@ TEST_F(SiteDataImplTest, OptionalFieldsNotPopulatedWhenClean) {
   SiteDataStore::ReadSiteDataFromStoreCallback read_cb;
 
   auto local_site_data = GetDataImplAndInterceptReadCallback(
-      kDummyOrigin, &destroy_delegate_, &mock_data_store, &read_cb);
+      kDummyOrigin, destroy_delegate_.GetWeakPtr(), &mock_data_store, &read_cb);
 
   EXPECT_EQ(0u, local_site_data->cpu_usage_estimate().num_datums());
   EXPECT_EQ(0u, local_site_data->private_footprint_kb_estimate().num_datums());
@@ -622,9 +623,9 @@ TEST_F(SiteDataImplTest, FlushingStateToProtoDoesntAffectData) {
   // calling FlushStateToProto doesn't affect the data that gets recorded.
 
   auto local_site_data =
-      GetDataImpl(kDummyOrigin, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin, destroy_delegate_.GetWeakPtr(), &data_store);
   auto local_site_data_ref =
-      GetDataImpl(kDummyOrigin2, &destroy_delegate_, &data_store);
+      GetDataImpl(kDummyOrigin2, destroy_delegate_.GetWeakPtr(), &data_store);
 
   local_site_data->NotifySiteLoaded();
   local_site_data->NotifyLoadedSiteBackgrounded();
@@ -663,7 +664,7 @@ TEST_F(SiteDataImplTest, DataLoadedCallbackInvoked) {
   SiteDataStore::ReadSiteDataFromStoreCallback read_cb;
 
   auto local_site_data = GetDataImplAndInterceptReadCallback(
-      kDummyOrigin, &destroy_delegate_, &mock_data_store, &read_cb);
+      kDummyOrigin, destroy_delegate_.GetWeakPtr(), &mock_data_store, &read_cb);
 
   EXPECT_FALSE(local_site_data->DataLoaded());
 
diff --git a/components/performance_manager/persistence/site_data/site_data_reader_unittest.cc b/components/performance_manager/persistence/site_data/site_data_reader_unittest.cc
index 7145a122c9..e3b85b5e6e 100644
--- a/components/performance_manager/persistence/site_data/site_data_reader_unittest.cc
+++ b/components/performance_manager/persistence/site_data/site_data_reader_unittest.cc
@@ -71,8 +71,9 @@ class SiteDataReaderTest : public ::testing::Test {
   // SiteDataImpl is protected and not visible to
   // base::MakeRefCounted.
   SiteDataReaderTest() {
-    test_impl_ = base::WrapRefCounted(new internal::SiteDataImpl(
-        url::Origin::Create(GURL("foo.com")), &delegate_, &data_store_));
+    test_impl_ = base::WrapRefCounted(
+        new internal::SiteDataImpl(url::Origin::Create(GURL("foo.com")),
+                                   delegate_.GetWeakPtr(), &data_store_));
     test_impl_->NotifySiteLoaded();
     test_impl_->NotifyLoadedSiteBackgrounded();
     SiteDataReader* reader = new SiteDataReader(test_impl_.get());
@@ -153,9 +154,9 @@ TEST_F(SiteDataReaderTest, FreeingReaderDoesntCauseWriteOperation) {
                               ::testing::_))
       .WillOnce(::testing::Invoke(read_from_store_mock_impl));
 
-  std::unique_ptr<SiteDataReader> reader =
-      base::WrapUnique(new SiteDataReader(base::WrapRefCounted(
-          new internal::SiteDataImpl(kOrigin, &delegate_, &data_store))));
+  std::unique_ptr<SiteDataReader> reader = base::WrapUnique(
+      new SiteDataReader(base::WrapRefCounted(new internal::SiteDataImpl(
+          kOrigin, delegate_.GetWeakPtr(), &data_store))));
   ::testing::Mock::VerifyAndClear(&data_store);
 
   EXPECT_TRUE(reader->impl_for_testing()->fully_initialized_for_testing());
@@ -177,7 +178,7 @@ TEST_F(SiteDataReaderTest, OnDataLoadedCallbackInvoked) {
                                                   kOrigin.Serialize()),
                               ::testing::_));
   scoped_refptr<internal::SiteDataImpl> impl = base::WrapRefCounted(
-      new internal::SiteDataImpl(kOrigin, &delegate_, &data_store));
+      new internal::SiteDataImpl(kOrigin, delegate_.GetWeakPtr(), &data_store));
 
   // Create the reader.
   std::unique_ptr<SiteDataReader> reader =
@@ -208,7 +209,7 @@ TEST_F(SiteDataReaderTest, DestroyingReaderCancelsPendingCallbacks) {
                                                   kOrigin.Serialize()),
                               ::testing::_));
   scoped_refptr<internal::SiteDataImpl> impl = base::WrapRefCounted(
-      new internal::SiteDataImpl(kOrigin, &delegate_, &data_store));
+      new internal::SiteDataImpl(kOrigin, delegate_.GetWeakPtr(), &data_store));
 
   // Create the reader.
   std::unique_ptr<SiteDataReader> reader =
diff --git a/components/performance_manager/persistence/site_data/site_data_writer_unittest.cc b/components/performance_manager/persistence/site_data/site_data_writer_unittest.cc
index 272089fd17..bc5500237b 100644
--- a/components/performance_manager/persistence/site_data/site_data_writer_unittest.cc
+++ b/components/performance_manager/persistence/site_data/site_data_writer_unittest.cc
@@ -24,7 +24,7 @@ class SiteDataWriterTest : public ::testing::Test {
   SiteDataWriterTest()
       : test_impl_(base::WrapRefCounted(
             new internal::SiteDataImpl(url::Origin::Create(GURL("foo.com")),
-                                       &delegate_,
+                                       delegate_.GetWeakPtr(),
                                        &data_store_))) {
     SiteDataWriter* writer = new SiteDataWriter(test_impl_.get());
     writer_ = base::WrapUnique(writer);
diff --git a/components/performance_manager/persistence/site_data/unittest_utils.h b/components/performance_manager/persistence/site_data/unittest_utils.h
index a5451e4fb3..75d7d698e7 100644
--- a/components/performance_manager/persistence/site_data/unittest_utils.h
+++ b/components/performance_manager/persistence/site_data/unittest_utils.h
@@ -9,6 +9,7 @@
 #include <vector>
 
 #include "base/macros.h"
+#include "base/memory/weak_ptr.h"
 #include "components/performance_manager/performance_manager_impl.h"
 #include "components/performance_manager/persistence/site_data/site_data_impl.h"
 #include "components/performance_manager/persistence/site_data/site_data_store.h"
@@ -27,7 +28,13 @@ class MockSiteDataImplOnDestroyDelegate
 
   MOCK_METHOD1(OnSiteDataImplDestroyed, void(internal::SiteDataImpl*));
 
+  base::WeakPtr<MockSiteDataImplOnDestroyDelegate> GetWeakPtr() {
+    return weak_factory_.GetWeakPtr();
+  }
+
  private:
+  base::WeakPtrFactory<MockSiteDataImplOnDestroyDelegate> weak_factory_{this};
+
   DISALLOW_COPY_AND_ASSIGN(MockSiteDataImplOnDestroyDelegate);
 };
 
diff --git a/components/permissions/permission_request_manager.cc b/components/permissions/permission_request_manager.cc
index f3148d318d..f41c73a8fc 100644
--- a/components/permissions/permission_request_manager.cc
+++ b/components/permissions/permission_request_manager.cc
@@ -545,13 +545,13 @@ void PermissionRequestManager::ScheduleDequeueRequestIfNeeded() {
 }
 
 void PermissionRequestManager::ShowBubble() {
-  // There is a race condition where the request might have been removed already
-  // so double-checking that there is a request in progress (crbug.com/1041222).
-  if (!IsRequestInProgress())
+  // There is a race condition where the request might have been removed
+  // already so double-checking that there is a request in progress.
+  //
+  // There is no need to show a new bubble if the previous one still exists.
+  if (!IsRequestInProgress() || view_)
     return;
 
-  DCHECK(!requests_.empty());
-  DCHECK(!view_);
   DCHECK(web_contents()->IsDocumentOnLoadCompletedInMainFrame());
   DCHECK(current_request_ui_to_use_);
 
diff --git a/components/renderer_context_menu/render_view_context_menu_base.cc b/components/renderer_context_menu/render_view_context_menu_base.cc
index bb98c91e7c..3250f7d556 100644
--- a/components/renderer_context_menu/render_view_context_menu_base.cc
+++ b/components/renderer_context_menu/render_view_context_menu_base.cc
@@ -466,9 +466,14 @@ void RenderViewContextMenuBase::OpenURLWithExtraHeaders(
     ui::PageTransition transition,
     const std::string& extra_headers,
     bool started_from_context_menu) {
+  // Do not send the referrer url to OTR windows. We still need the
+  // |referring_url| to populate the |initiator_origin| below for browser UI.
+  GURL referrer_url;
+  if (disposition != WindowOpenDisposition::OFF_THE_RECORD)
+    referrer_url = referring_url.GetAsReferrer();
+
   content::Referrer referrer = content::Referrer::SanitizeForRequest(
-      url, content::Referrer(referring_url.GetAsReferrer(),
-                             params_.referrer_policy));
+      url, content::Referrer(referrer_url, params_.referrer_policy));
 
   if (params_.link_url == url &&
       disposition != WindowOpenDisposition::OFF_THE_RECORD)
diff --git a/content/app/content_main_runner_impl.cc b/content/app/content_main_runner_impl.cc
index 9974db23eb..50ac01b8f5 100644
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -106,6 +106,7 @@
 #include "ui/base/ui_base_switches.h"
 #include "ui/display/display_switches.h"
 #include "ui/gfx/switches.h"
+#include "content/renderer/render_remote_proxy.h"
 
 #if defined(OS_WIN)
 #include <malloc.h>
@@ -909,6 +910,11 @@ int ContentMainRunnerImpl::Run(bool start_minimal_browser) {
     if (process_type != switches::kZygoteProcess) {
       // Zygotes will run this at a later point in time when the command line
       // has been updated.
+#if defined(OS_OHOS)
+      if (!RunRenderRemoteProxy(command_line)) {
+        return -1;
+      }
+#endif
       InitializeFieldTrialAndFeatureList();
       delegate_->PostFieldTrialInitialization();
 
@@ -1068,6 +1074,22 @@ int ContentMainRunnerImpl::RunBrowser(MainFunctionParams& main_params,
   return RunBrowserProcessMain(main_params, delegate_);
 }
 
+#if defined(OS_OHOS)
+bool ContentMainRunnerImpl::RunRenderRemoteProxy(
+    const base::CommandLine& command_line) {
+  std::string process_type =
+      command_line.GetSwitchValueASCII(switches::kProcessType);
+  if (process_type != switches::kRendererProcess) {
+    return true;
+  }
+  RenderRemoteProxy::CreateAndRegist(command_line);
+  if (!RenderRemoteProxy::WaitForBrowserFd()) {
+    return false;
+  }
+  return true;
+}
+#endif
+
 void ContentMainRunnerImpl::Shutdown() {
   DCHECK(is_initialized_);
   DCHECK(!is_shutdown_);
diff --git a/content/app/content_main_runner_impl.h b/content/app/content_main_runner_impl.h
index 090171f7db..6bef22cb2f 100644
--- a/content/app/content_main_runner_impl.h
+++ b/content/app/content_main_runner_impl.h
@@ -58,6 +58,9 @@ class CONTENT_EXPORT ContentMainRunnerImpl : public ContentMainRunner {
  private:
   int RunBrowser(MainFunctionParams& main_function_params,
                  bool start_minimal_browser);
+#if defined(OS_OHOS)
+  bool RunRenderRemoteProxy(const base::CommandLine& command_line);
+#endif
 
   bool is_browser_main_loop_started_ = false;
 
diff --git a/content/browser/background_fetch/background_fetch_cross_origin_filter.cc b/content/browser/background_fetch/background_fetch_cross_origin_filter.cc
index 50d79fe628..1fcc93ffdd 100644
--- a/content/browser/background_fetch/background_fetch_cross_origin_filter.cc
+++ b/content/browser/background_fetch/background_fetch_cross_origin_filter.cc
@@ -7,6 +7,7 @@
 #include <set>
 
 #include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
 #include "content/browser/background_fetch/background_fetch_request_info.h"
 #include "url/gurl.h"
 
@@ -15,6 +16,8 @@ namespace content {
 namespace {
 
 const char kAccessControlAllowOriginHeader[] = "access-control-allow-origin";
+const char kAccessControlAllowCredentialsHeader[] =
+    "access-control-allow-credentials";
 const char kAnyOriginValue[] = "*";
 
 // Parses the header list (including "any origin") value from a given response
@@ -67,20 +70,29 @@ BackgroundFetchCrossOriginFilter::BackgroundFetchCrossOriginFilter(
       response_header_map.find(kAccessControlAllowOriginHeader);
 
   if (access_control_allow_origin_iter != response_header_map.end()) {
-    bool access_control_allow_any_origin = false;
     std::set<url::Origin> access_control_allow_origins;
 
     if (ParseOriginListHeader(access_control_allow_origin_iter->second,
-                              &access_control_allow_any_origin,
+                              &access_control_allow_origin_any_,
                               &access_control_allow_origins)) {
-      access_control_allow_origin_ =
-          access_control_allow_any_origin ||
+      access_control_allow_origin_exact_ =
           access_control_allow_origins.count(source_origin) == 1;
     }
   }
 
-  // TODO(crbug.com/711354): Consider the Access-Control-Allow-Credentials
-  //                         header.
+  // Access-Control-Allow-Credentials checks. The header's values must be valid
+  // for it to not be completely discarded.
+  auto access_control_allow_credentials_iter =
+      response_header_map.find(kAccessControlAllowCredentialsHeader);
+  if (access_control_allow_credentials_iter != response_header_map.end()) {
+    access_control_allow_credentials_ =
+        base::ToLowerASCII(access_control_allow_credentials_iter->second) ==
+        "true";
+  }
+
+  include_credentials_ = request.fetch_request()->credentials_mode ==
+                         ::network::mojom::CredentialsMode::kInclude;
+
   // TODO(crbug.com/711354): Consider the Access-Control-Allow-Headers header.
   // TODO(crbug.com/711354): Consider the Access-Control-Allow-Methods header.
   // TODO(crbug.com/711354): Consider the Access-Control-Expose-Headers header.
@@ -89,12 +101,28 @@ BackgroundFetchCrossOriginFilter::BackgroundFetchCrossOriginFilter(
 BackgroundFetchCrossOriginFilter::~BackgroundFetchCrossOriginFilter() = default;
 
 bool BackgroundFetchCrossOriginFilter::CanPopulateBody() const {
-  // The body will be populated if:
-  //   (1) The source and the response share their origin.
-  //   (2) The Access-Control-Allow-Origin method allows any origin.
-  //   (3) The Access-Control-Allow-Origin method allows the source origin.
+  if (is_same_origin_) {
+    // Same origin requests are always OK.
+    return true;
+  }
+
+  // For cross-origin requests, the body will be populated if:
+
+  // (1) The Access-Control-Allow-Origin method allows the source origin / any
+  //     origin.
+  if (!access_control_allow_origin_exact_ &&
+      !access_control_allow_origin_any_) {
+    return false;
+  }
+
+  // (2) For requests with credentials, the Access-Control-Allow-Credentials is
+  //     set and the Access-Control-Allow-Origin contains the exact origin.
+  if (include_credentials_ && (!access_control_allow_credentials_ ||
+                               !access_control_allow_origin_exact_)) {
+    return false;
+  }
 
-  return is_same_origin_ || access_control_allow_origin_;
+  return true;
 }
 
 }  // namespace content
diff --git a/content/browser/background_fetch/background_fetch_cross_origin_filter.h b/content/browser/background_fetch/background_fetch_cross_origin_filter.h
index 042856bb56..20e14c2240 100644
--- a/content/browser/background_fetch/background_fetch_cross_origin_filter.h
+++ b/content/browser/background_fetch/background_fetch_cross_origin_filter.h
@@ -32,8 +32,19 @@ class CONTENT_EXPORT BackgroundFetchCrossOriginFilter {
   // Whether the response comes from the same origin as the requester.
   bool is_same_origin_ = false;
 
-  // Whether the Access-Control-Allow-Origin header includes the source origin.
-  bool access_control_allow_origin_ = false;
+  // Whether the Access-Control-Allow-Origin header includes the exact source
+  // origin.
+  bool access_control_allow_origin_exact_ = false;
+
+  // Whether the Access-Control-Allow-Origin header includes any source origin
+  // (*).
+  bool access_control_allow_origin_any_ = false;
+
+  // Whether the Access-Control-Allow-Credentials header is included.
+  bool access_control_allow_credentials_ = false;
+
+  // Whether credentials were included for cross-origin requests.
+  bool include_credentials_ = false;
 
   DISALLOW_COPY_AND_ASSIGN(BackgroundFetchCrossOriginFilter);
 };
diff --git a/content/browser/background_fetch/background_fetch_cross_origin_filter_unittest.cc b/content/browser/background_fetch/background_fetch_cross_origin_filter_unittest.cc
index ace470460c..7c5e41055e 100644
--- a/content/browser/background_fetch/background_fetch_cross_origin_filter_unittest.cc
+++ b/content/browser/background_fetch/background_fetch_cross_origin_filter_unittest.cc
@@ -20,6 +20,8 @@ const char kFirstOriginFile[] = "https://example.com/cat.jpg";
 const char kSecondOriginFile[] = "https://chrome.com/cat.jpg";
 
 const char kAccessControlAllowOriginHeader[] = "access-control-allow-origin";
+const char kAccessControlAllowCredentialsHeader[] =
+    "access-control-allow-credentials";
 
 class BackgroundFetchCrossOriginFilterTest : public ::testing::Test {
  public:
@@ -35,7 +37,8 @@ class BackgroundFetchCrossOriginFilterTest : public ::testing::Test {
       const char* response_url,
       std::initializer_list<
           typename std::map<std::string, std::string>::value_type>
-          response_headers) {
+          response_headers,
+      bool allow_credentials = false) {
     scoped_refptr<BackgroundFetchRequestInfo> request_info =
         base::MakeRefCounted<BackgroundFetchRequestInfo>(
             0 /* request_info */, blink::mojom::FetchAPIRequest::New(),
@@ -43,6 +46,13 @@ class BackgroundFetchCrossOriginFilterTest : public ::testing::Test {
 
     request_info->response_headers_ = response_headers;
     request_info->url_chain_ = {GURL(response_url)};
+    if (allow_credentials) {
+      request_info->fetch_request()->credentials_mode =
+          network::mojom::CredentialsMode::kInclude;
+    } else {
+      request_info->fetch_request()->credentials_mode =
+          network::mojom::CredentialsMode::kSameOrigin;
+    }
 
     return request_info;
   }
@@ -113,4 +123,54 @@ TEST_F(BackgroundFetchCrossOriginFilterTest, CrossOriginAllowSpecificOrigin) {
   }
 }
 
+TEST_F(BackgroundFetchCrossOriginFilterTest, CrossOriginCredentials) {
+  // 1: No headers.
+  {
+    auto request =
+        CreateRequestInfo(kSecondOriginFile, {}, /*include_credentials=*/true);
+    BackgroundFetchCrossOriginFilter filter(source_, *request);
+    EXPECT_FALSE(filter.CanPopulateBody());
+  }
+
+  // 2: Valid request.
+  {
+    auto request =
+        CreateRequestInfo(kSecondOriginFile,
+                          {{kAccessControlAllowOriginHeader, kFirstOrigin},
+                           {kAccessControlAllowCredentialsHeader, "true"}},
+                          /*include_credentials=*/true);
+    BackgroundFetchCrossOriginFilter filter(source_, *request);
+    EXPECT_TRUE(filter.CanPopulateBody());
+  }
+
+  // 3: Missing ACAO Header.
+  {
+    auto request = CreateRequestInfo(
+        kSecondOriginFile, {{kAccessControlAllowCredentialsHeader, "true"}},
+        /*include_credentials=*/true);
+    BackgroundFetchCrossOriginFilter filter(source_, *request);
+    EXPECT_FALSE(filter.CanPopulateBody());
+  }
+
+  // 4: Missing ACAC header.
+  {
+    auto request = CreateRequestInfo(
+        kSecondOriginFile, {{kAccessControlAllowOriginHeader, kFirstOrigin}},
+        /*include_credentials=*/true);
+    BackgroundFetchCrossOriginFilter filter(source_, *request);
+    EXPECT_FALSE(filter.CanPopulateBody());
+  }
+
+  // 5: ACAO any origin.
+  {
+    auto request =
+        CreateRequestInfo(kSecondOriginFile,
+                          {{kAccessControlAllowOriginHeader, "*"},
+                           {kAccessControlAllowCredentialsHeader, "true"}},
+                          /*include_credentials=*/true);
+    BackgroundFetchCrossOriginFilter filter(source_, *request);
+    EXPECT_FALSE(filter.CanPopulateBody());
+  }
+}
+
 }  // namespace content
diff --git a/content/browser/background_fetch/background_fetch_delegate_proxy.cc b/content/browser/background_fetch/background_fetch_delegate_proxy.cc
index 7fdbb99fbc..efcbcfcc19 100644
--- a/content/browser/background_fetch/background_fetch_delegate_proxy.cc
+++ b/content/browser/background_fetch/background_fetch_delegate_proxy.cc
@@ -160,7 +160,8 @@ class BackgroundFetchDelegateProxy::Core
 
     delegate->DownloadUrl(
         job_unique_id, request->download_guid(), fetch_request->method,
-        fetch_request->url, traffic_annotation, headers,
+        fetch_request->url, fetch_request->credentials_mode, traffic_annotation,
+        headers,
         /* has_request_body= */ request->request_body_size() > 0u);
   }
 
diff --git a/content/browser/background_fetch/background_fetch_delegate_proxy_unittest.cc b/content/browser/background_fetch/background_fetch_delegate_proxy_unittest.cc
index 9564453073..3a1d773294 100644
--- a/content/browser/background_fetch/background_fetch_delegate_proxy_unittest.cc
+++ b/content/browser/background_fetch/background_fetch_delegate_proxy_unittest.cc
@@ -55,6 +55,7 @@ class FakeBackgroundFetchDelegate : public BackgroundFetchDelegate {
                    const std::string& guid,
                    const std::string& method,
                    const GURL& url,
+                   ::network::mojom::CredentialsMode credentials_mode,
                    const net::NetworkTrafficAnnotationTag& traffic_annotation,
                    const net::HttpRequestHeaders& headers,
                    bool has_request_body) override {
diff --git a/content/browser/background_fetch/background_fetch_job_controller.cc b/content/browser/background_fetch/background_fetch_job_controller.cc
index f424cadba0..0d08d1f744 100644
--- a/content/browser/background_fetch/background_fetch_job_controller.cc
+++ b/content/browser/background_fetch/background_fetch_job_controller.cc
@@ -173,6 +173,8 @@ void BackgroundFetchJobController::DidStartRequest(
   // TODO(crbug.com/884672): Stop the fetch if the cross origin filter fails.
   BackgroundFetchCrossOriginFilter filter(registration_id_.origin(), *request);
   request->set_can_populate_body(filter.CanPopulateBody());
+  if (!request->can_populate_body())
+    has_failed_cors_request_ = true;
 }
 
 void BackgroundFetchJobController::DidUpdateRequest(const std::string& guid,
@@ -253,7 +255,14 @@ uint64_t BackgroundFetchJobController::GetInProgressUploadedBytes() {
 
 void BackgroundFetchJobController::AbortFromDelegate(
     BackgroundFetchFailureReason failure_reason) {
-  failure_reason_ = failure_reason;
+  if (failure_reason == BackgroundFetchFailureReason::DOWNLOAD_TOTAL_EXCEEDED &&
+      has_failed_cors_request_) {
+    // Don't expose that the download total has been exceeded. Use a less
+    // specific error.
+    failure_reason_ = BackgroundFetchFailureReason::FETCH_ERROR;
+  } else {
+    failure_reason_ = failure_reason;
+  }
 
   Finish(failure_reason_, base::DoNothing());
 }
diff --git a/content/browser/background_fetch/background_fetch_job_controller.h b/content/browser/background_fetch/background_fetch_job_controller.h
index e635c86c1e..66a1c94e9d 100644
--- a/content/browser/background_fetch/background_fetch_job_controller.h
+++ b/content/browser/background_fetch/background_fetch_job_controller.h
@@ -210,6 +210,10 @@ class CONTENT_EXPORT BackgroundFetchJobController
   blink::mojom::BackgroundFetchFailureReason failure_reason_ =
       blink::mojom::BackgroundFetchFailureReason::NONE;
 
+  // Whether one of the requests handled by the controller failed
+  // the CORS checks and should not have its response exposed.
+  bool has_failed_cors_request_ = false;
+
   // Custom callback that runs after the controller is finished.
   FinishedCallback finished_callback_;
 
diff --git a/content/browser/background_fetch/background_fetch_job_controller_unittest.cc b/content/browser/background_fetch/background_fetch_job_controller_unittest.cc
index ad9a313672..eb0e8fc337 100644
--- a/content/browser/background_fetch/background_fetch_job_controller_unittest.cc
+++ b/content/browser/background_fetch/background_fetch_job_controller_unittest.cc
@@ -433,6 +433,39 @@ TEST_F(BackgroundFetchJobControllerTest, Abort) {
             GetCompletionStatus(registration_id));
 }
 
+TEST_F(BackgroundFetchJobControllerTest, AbortDownloadExceededCrossOrigin) {
+  BackgroundFetchRegistrationId registration_id;
+
+  auto requests = CreateRegistrationForRequests(
+      &registration_id, {{GURL("https://example2.com/funny_cat.png"), "GET"}},
+      /* auto_complete_requests= */ true);
+
+  EXPECT_EQ(JobCompletionStatus::kRunning,
+            GetCompletionStatus(registration_id));
+
+  std::unique_ptr<BackgroundFetchJobController> controller =
+      CreateJobController(registration_id, requests.size());
+
+  controller->StartRequest(requests[0], base::DoNothing());
+
+  controller->DidStartRequest(
+      requests[0]->download_guid(),
+      std::make_unique<BackgroundFetchResponse>(
+          std::vector<GURL>{GURL("https://example2.com/funny_cat.png")},
+          nullptr));
+  EXPECT_FALSE(requests[0]->can_populate_body());
+
+  controller->AbortFromDelegate(
+      blink::mojom::BackgroundFetchFailureReason::DOWNLOAD_TOTAL_EXCEEDED);
+
+  base::RunLoop().RunUntilIdle();
+
+  EXPECT_EQ(JobCompletionStatus::kAborted,
+            GetCompletionStatus(registration_id));
+  EXPECT_EQ(finished_requests_[registration_id],
+            blink::mojom::BackgroundFetchFailureReason::FETCH_ERROR);
+}
+
 TEST_F(BackgroundFetchJobControllerTest, Progress) {
   BackgroundFetchRegistrationId registration_id;
 
diff --git a/content/browser/background_fetch/mock_background_fetch_delegate.cc b/content/browser/background_fetch/mock_background_fetch_delegate.cc
index 4ebfb985b7..c4bbfe9f43 100644
--- a/content/browser/background_fetch/mock_background_fetch_delegate.cc
+++ b/content/browser/background_fetch/mock_background_fetch_delegate.cc
@@ -88,6 +88,7 @@ void MockBackgroundFetchDelegate::DownloadUrl(
     const std::string& guid,
     const std::string& method,
     const GURL& url,
+    ::network::mojom::CredentialsMode credentials_mode,
     const net::NetworkTrafficAnnotationTag& traffic_annotation,
     const net::HttpRequestHeaders& headers,
     bool has_request_body) {
diff --git a/content/browser/background_fetch/mock_background_fetch_delegate.h b/content/browser/background_fetch/mock_background_fetch_delegate.h
index 499bca6eb7..8796655b9c 100644
--- a/content/browser/background_fetch/mock_background_fetch_delegate.h
+++ b/content/browser/background_fetch/mock_background_fetch_delegate.h
@@ -80,6 +80,7 @@ class MockBackgroundFetchDelegate : public BackgroundFetchDelegate {
                    const std::string& guid,
                    const std::string& method,
                    const GURL& url,
+                   ::network::mojom::CredentialsMode credentials_mode,
                    const net::NetworkTrafficAnnotationTag& traffic_annotation,
                    const net::HttpRequestHeaders& headers,
                    bool has_request_body) override;
diff --git a/content/browser/bad_message.h b/content/browser/bad_message.h
index c27331d1cb..583e54e218 100644
--- a/content/browser/bad_message.h
+++ b/content/browser/bad_message.h
@@ -268,6 +268,7 @@ enum BadMessageReason {
   WCI_INVALID_FULLSCREEN_OPTIONS = 240,
   PAYMENTS_WITHOUT_PERMISSION = 241,
   WEB_BUNDLE_INVALID_NAVIGATION_URL = 242,
+  RFH_CREATE_CHILD_FRAME_SANDBOX_FLAGS = 254,
 
   // Please add new elements here. The naming convention is abbreviated class
   // name (e.g. RenderFrameHost becomes RFH) plus a unique description of the
diff --git a/content/browser/blob_storage/blob_url_unittest.cc b/content/browser/blob_storage/blob_url_unittest.cc
index 0a7e8fb928..9c2bac10bb 100644
--- a/content/browser/blob_storage/blob_url_unittest.cc
+++ b/content/browser/blob_storage/blob_url_unittest.cc
@@ -182,15 +182,14 @@ class BlobURLTest : public testing::Test {
 
   void TestRequest(const std::string& method,
                    const net::HttpRequestHeaders& extra_headers) {
-    GURL url("blob:blah");
+    auto origin = url::Origin::Create(GURL("https://example.com"));
+    auto url = GURL("blob:" + origin.Serialize() + "/id1");
     network::ResourceRequest request;
     request.url = url;
     request.method = method;
     request.headers = extra_headers;
 
-    storage::MockBlobRegistryDelegate delegate;
-    storage::BlobURLStoreImpl url_store(blob_url_registry_.AsWeakPtr(),
-                                        &delegate);
+    storage::BlobURLStoreImpl url_store(origin, blob_url_registry_.AsWeakPtr());
 
     mojo::PendingRemote<blink::mojom::Blob> blob_remote;
     storage::BlobImpl::Create(
diff --git a/content/browser/browser_child_process_host_impl.cc b/content/browser/browser_child_process_host_impl.cc
index 9c39184123..d0073ca0c8 100644
--- a/content/browser/browser_child_process_host_impl.cc
+++ b/content/browser/browser_child_process_host_impl.cc
@@ -672,6 +672,9 @@ void BrowserChildProcessHostImpl::RegisterCoordinatorClient(
     mojo::PendingReceiver<memory_instrumentation::mojom::Coordinator> receiver,
     mojo::PendingRemote<memory_instrumentation::mojom::ClientProcess>
         client_process) {
+  // Intentionally disallow non-browser processes from getting a Coordinator.
+  receiver.reset();
+
   // The child process may have already terminated by the time this message is
   // dispatched. We do nothing in that case.
   if (!IsProcessLaunched())
diff --git a/content/browser/browser_interface_binders.cc b/content/browser/browser_interface_binders.cc
index 141a96c2ef..8ba6265041 100644
--- a/content/browser/browser_interface_binders.cc
+++ b/content/browser/browser_interface_binders.cc
@@ -377,10 +377,22 @@ void BindTextSuggestionHostForFrame(
 }
 #endif
 
+// Get the service worker's worker process ID and post a task to bind the
+// receiver on a USER_VISIBLE task runner.
+// This is necessary because:
+// - Binding the host itself and checking the ID on the task's thread may cause
+//   a UAF if the host has been deleted in the meantime.
+// - The process ID is not yet populated at the time `PopulateInterfaceBinders`
+//   is called.
 void BindFileUtilitiesHost(
-    const ServiceWorkerHost* host,
+    ServiceWorkerHost* host,
     mojo::PendingReceiver<blink::mojom::FileUtilitiesHost> receiver) {
-  FileUtilitiesHostImpl::Create(host->worker_process_id(), std::move(receiver));
+  auto task_runner = base::ThreadPool::CreateSequencedTaskRunner(
+      {base::MayBlock(), base::TaskPriority::USER_VISIBLE});
+  task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&FileUtilitiesHostImpl::Create, host->worker_process_id(),
+                     std::move(receiver)));
 }
 
 template <typename WorkerHost, typename Interface>
@@ -1166,9 +1178,7 @@ void PopulateServiceWorkerBinders(ServiceWorkerHost* host,
 
   // static binders
   map->Add<blink::mojom::FileUtilitiesHost>(
-      base::BindRepeating(&BindFileUtilitiesHost, host),
-      base::ThreadPool::CreateSequencedTaskRunner(
-          {base::MayBlock(), base::TaskPriority::USER_VISIBLE}));
+      base::BindRepeating(&BindFileUtilitiesHost, host));
   map->Add<shape_detection::mojom::BarcodeDetectionProvider>(
       base::BindRepeating(&BindBarcodeDetectionProvider));
   map->Add<shape_detection::mojom::FaceDetectionProvider>(
diff --git a/content/browser/cache_storage/legacy/legacy_cache_storage_cache.cc b/content/browser/cache_storage/legacy/legacy_cache_storage_cache.cc
index 634d72af38..c5be9cd6e5 100644
--- a/content/browser/cache_storage/legacy/legacy_cache_storage_cache.cc
+++ b/content/browser/cache_storage/legacy/legacy_cache_storage_cache.cc
@@ -446,10 +446,10 @@ blink::mojom::FetchAPIResponsePtr CreateResponse(
     padding = storage::ComputeRandomResponsePadding();
   }
 
-  // Note that |has_range_requested| can be safely set to false since it only
-  // affects HTTP 206 (Partial) responses, which are blocked from cache storage.
-  // See https://fetch.spec.whatwg.org/#main-fetch for usage of
-  // |has_range_requested|.
+  // While we block most partial responses from being stored, we can have
+  // partial responses for bgfetch or opaque responses.
+  bool has_range_requested = headers.contains(net::HttpRequestHeaders::kRange);
+
   return blink::mojom::FetchAPIResponse::New(
       url_list, metadata.response().status_code(),
       metadata.response().status_text(),
@@ -467,7 +467,7 @@ blink::mojom::FetchAPIResponsePtr CreateResponse(
       static_cast<net::HttpResponseInfo::ConnectionInfo>(
           metadata.response().connection_info()),
       alpn_negotiated_protocol, metadata.response().was_fetched_via_spdy(),
-      /*has_range_requested=*/false, /*auth_challenge_info=*/base::nullopt);
+      has_range_requested, /*auth_challenge_info=*/base::nullopt);
 }
 
 int64_t CalculateSideDataPadding(
@@ -1907,7 +1907,13 @@ void LegacyCacheStorageCache::PutDidCreateEntry(
   }
 
   proto::CacheResponse* response_metadata = metadata.mutable_response();
-  DCHECK_NE(put_context->response->status_code, net::HTTP_PARTIAL_CONTENT);
+  if (owner_ != storage::mojom::CacheStorageOwner::kBackgroundFetch &&
+      put_context->response->response_type !=
+          network::mojom::FetchResponseType::kOpaque &&
+      put_context->response->response_type !=
+          network::mojom::FetchResponseType::kOpaqueRedirect) {
+    DCHECK_NE(put_context->response->status_code, net::HTTP_PARTIAL_CONTENT);
+  }
   response_metadata->set_status_code(put_context->response->status_code);
   response_metadata->set_status_text(put_context->response->status_text);
   response_metadata->set_response_type(FetchResponseTypeToProtoResponseType(
diff --git a/content/browser/child_process_launcher_helper.h b/content/browser/child_process_launcher_helper.h
index 532b80efe9..7b78341112 100644
--- a/content/browser/child_process_launcher_helper.h
+++ b/content/browser/child_process_launcher_helper.h
@@ -47,6 +47,10 @@
 #include "content/public/common/zygote/zygote_handle.h"  // nogncheck
 #endif
 
+#if defined(OS_OHOS)
+#include "appmgr/app_mgr_client.h"
+#endif
+
 namespace base {
 class CommandLine;
 }
@@ -252,6 +256,10 @@ class ChildProcessLauncherHelper :
 #if defined(OS_FUCHSIA)
   std::unique_ptr<sandbox::policy::SandboxPolicyFuchsia> sandbox_policy_;
 #endif
+
+#if defined(OS_OHOS)
+  std::unique_ptr<OHOS::AppExecFwk::AppMgrClient> app_mgr_client_{nullptr};
+#endif
 };
 
 }  // namespace internal
diff --git a/content/browser/child_process_launcher_helper_linux.cc b/content/browser/child_process_launcher_helper_linux.cc
index 7efc41048b..422d3a0183 100644
--- a/content/browser/child_process_launcher_helper_linux.cc
+++ b/content/browser/child_process_launcher_helper_linux.cc
@@ -99,7 +99,37 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
   }
 
   Process process;
+#if defined(OS_OHOS)
+  bool for_test = base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kForTest);
+  if (for_test) {
+    process.process = base::LaunchProcess(*command_line(), options);
+  } else {
+    const std::vector<std::string> argv_str = command_line()->argv();
+    std::stringstream argv_ss;
+    const char separator = '#';
+    for (int i=0; i<argv_str.size()-1; ++i) {
+      argv_ss << argv_str[i] << separator;
+    }
+    argv_ss << argv_str[argv_str.size()-1];
+    constexpr int SHARED_FD_INDEX = 0;
+    constexpr int IPC_FD_INDEX = 1;
+    int32_t shared_fd = options.fds_to_remap[SHARED_FD_INDEX].first;
+    int32_t ipc_fd = options.fds_to_remap[IPC_FD_INDEX].first;
+    pid_t render_pid = 0;
+    if (app_mgr_client_ == nullptr) {
+      app_mgr_client_ = std::make_unique<OHOS::AppExecFwk::AppMgrClient>();
+    }
+    int ret = app_mgr_client_->StartRenderProcess(argv_ss.str(), ipc_fd, shared_fd, render_pid);
+    if (ret != 0) {
+      LOG(ERROR) << "start render process error, ret=" << ret << ", render pid=" << render_pid;
+      process.process = base::Process();
+    } else {
+      process.process = base::Process(render_pid);
+    }
+  }
+#else
   process.process = base::LaunchProcess(*command_line(), options);
+#endif
   *launch_result = process.process.IsValid() ? LAUNCH_RESULT_SUCCESS
                                              : LAUNCH_RESULT_FAILURE;
   return process;
diff --git a/content/browser/download/download_browsertest.cc b/content/browser/download/download_browsertest.cc
index 3c3fcebab8..fcfe6a0722 100644
--- a/content/browser/download/download_browsertest.cc
+++ b/content/browser/download/download_browsertest.cc
@@ -3596,6 +3596,53 @@ IN_PROC_BROWSER_TEST_F(DownloadContentTest, UpdateSiteForCookies) {
                                 site_a.GetURL("a.test", "/")));
 }
 
+// Verifies that isolation info set in DownloadUrlParameters can be populated.
+IN_PROC_BROWSER_TEST_F(DownloadContentTest,
+                       SiteForCookies_DownloadUrl_IsolationInfoPopulated) {
+  // Setup a server that sets cookie.
+  net::EmbeddedTestServer site_a;
+  base::StringPairs cookie_headers;
+  cookie_headers.push_back(std::make_pair(std::string("Set-Cookie"),
+                                          std::string("A=lax; SameSite=Lax")));
+  cookie_headers.push_back(std::make_pair(
+      std::string("Set-Cookie"), std::string("B=strict; SameSite=Strict")));
+  site_a.RegisterRequestHandler(CreateBasicResponseHandler(
+      "/sets-samesite-cookies", net::HTTP_OK, cookie_headers,
+      "application/octet-stream", "abcd"));
+  ASSERT_TRUE(site_a.Start());
+
+  // Download the file.
+  SetupEnsureNoPendingDownloads();
+  GURL download_url = site_a.GetURL("a.test", "/sets-samesite-cookies");
+  std::unique_ptr<download::DownloadUrlParameters> download_parameters(
+      DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(
+          shell()->web_contents(), download_url, TRAFFIC_ANNOTATION_FOR_TESTS));
+
+  // Mark this request a third party request, cookie should be blocked.
+  net::IsolationInfo isolation_info =
+      net::IsolationInfo::CreateForInternalRequest(
+          url::Origin::Create(GURL("http://www.example.com")));
+  download_parameters->set_isolation_info(isolation_info);
+
+  // Verify the isolation info.
+  std::unique_ptr<DownloadTestObserver> observer(CreateWaiter(shell(), 1));
+  ExpectRequestIsolationInfo(download_url, isolation_info,
+                             base::BindLambdaForTesting([&]() {
+                               DownloadManagerForShell(shell())->DownloadUrl(
+                                   std::move(download_parameters));
+                               observer->WaitForFinished();
+                             }));
+
+  // Get the important info from other threads and check it.
+  EXPECT_TRUE(EnsureNoPendingDownloads());
+
+  // Check no cookies are written for URL a.test since it's a third party
+  // cookie.
+  EXPECT_TRUE(content::GetCookies(shell()->web_contents()->GetBrowserContext(),
+                                  download_url)
+                  .empty());
+}
+
 // A filename suggestion specified via a @download attribute should not be
 // effective if the final download URL is in another origin from the original
 // download URL.
diff --git a/content/browser/download/download_manager_impl.h b/content/browser/download/download_manager_impl.h
index 69fcf9abbe..0deb3b7c77 100644
--- a/content/browser/download/download_manager_impl.h
+++ b/content/browser/download/download_manager_impl.h
@@ -170,6 +170,11 @@ class CONTENT_EXPORT DownloadManagerImpl
       int frame_tree_node_id,
       bool from_download_cross_origin_redirect);
 
+  // DownloadItemImplDelegate overrides.
+  download::QuarantineConnectionCallback GetQuarantineConnectionCallback()
+      override;
+  std::string GetApplicationClientIdForFileScanning() const override;
+
  private:
   using DownloadSet = std::set<download::DownloadItem*>;
   using DownloadGuidMap =
@@ -237,7 +242,6 @@ class CONTENT_EXPORT DownloadManagerImpl
   bool ShouldOpenDownload(download::DownloadItemImpl* item,
                           ShouldOpenDownloadCallback callback) override;
   void CheckForFileRemoval(download::DownloadItemImpl* download_item) override;
-  std::string GetApplicationClientIdForFileScanning() const override;
   void ResumeInterruptedDownload(
       std::unique_ptr<download::DownloadUrlParameters> params,
       const GURL& site_url) override;
@@ -249,8 +253,6 @@ class CONTENT_EXPORT DownloadManagerImpl
   void ReportBytesWasted(download::DownloadItemImpl* download) override;
   void BindWakeLockProvider(
       mojo::PendingReceiver<device::mojom::WakeLockProvider> receiver) override;
-  download::QuarantineConnectionCallback GetQuarantineConnectionCallback()
-      override;
   std::unique_ptr<download::DownloadItemRenameHandler>
   GetRenameHandlerForDownload(
       download::DownloadItemImpl* download_item) override;
diff --git a/content/browser/download/save_file.cc b/content/browser/download/save_file.cc
index 72331e60fc..110f66250e 100644
--- a/content/browser/download/save_file.cc
+++ b/content/browser/download/save_file.cc
@@ -63,10 +63,15 @@ void SaveFile::Finish() {
   file_.Finish();
 }
 
-void SaveFile::AnnotateWithSourceInformation() {
-  // TODO(gbillock): If this method is called, it should set the
-  // file_.SetClientGuid() method first.
-  NOTREACHED();
+void SaveFile::AnnotateWithSourceInformation(
+    const std::string& client_guid,
+    const GURL& source_url,
+    const GURL& referrer_url,
+    mojo::PendingRemote<quarantine::mojom::Quarantine> remote_quarantine,
+    download::BaseFile::OnAnnotationDoneCallback on_annotation_done_callback) {
+  file_.AnnotateWithSourceInformation(client_guid, source_url, referrer_url,
+                                      std::move(remote_quarantine),
+                                      std::move(on_annotation_done_callback));
 }
 
 base::FilePath SaveFile::FullPath() const {
diff --git a/content/browser/download/save_file.h b/content/browser/download/save_file.h
index 688574b07f..1893a0031f 100644
--- a/content/browser/download/save_file.h
+++ b/content/browser/download/save_file.h
@@ -34,7 +34,12 @@ class SaveFile {
   void Detach();
   void Cancel();
   void Finish();
-  void AnnotateWithSourceInformation();
+  void AnnotateWithSourceInformation(
+      const std::string& client_guid,
+      const GURL& source_url,
+      const GURL& referrer_url,
+      mojo::PendingRemote<quarantine::mojom::Quarantine> remote_quarantine,
+      download::BaseFile::OnAnnotationDoneCallback on_annotation_done_callback);
   base::FilePath FullPath() const;
   bool InProgress() const;
   int64_t BytesSoFar() const;
diff --git a/content/browser/download/save_file_manager.cc b/content/browser/download/save_file_manager.cc
index 91786d976f..2489b47cf8 100644
--- a/content/browser/download/save_file_manager.cc
+++ b/content/browser/download/save_file_manager.cc
@@ -50,6 +50,7 @@ static SaveFileManager* g_save_file_manager = nullptr;
 class SaveFileManager::SimpleURLLoaderHelper
     : public network::SimpleURLLoaderStreamConsumer {
  public:
+  using URLLoaderCompleteCallback = base::OnceCallback<void(bool success)>;
   static std::unique_ptr<SimpleURLLoaderHelper> CreateAndStartDownload(
       std::unique_ptr<network::ResourceRequest> resource_request,
       SaveItemId save_item_id,
@@ -58,11 +59,12 @@ class SaveFileManager::SimpleURLLoaderHelper
       int render_frame_routing_id,
       const net::NetworkTrafficAnnotationTag& annotation_tag,
       network::mojom::URLLoaderFactory* url_loader_factory,
-      SaveFileManager* save_file_manager) {
+      SaveFileManager* save_file_manager,
+      URLLoaderCompleteCallback on_complete_cb) {
     return std::unique_ptr<SimpleURLLoaderHelper>(new SimpleURLLoaderHelper(
         std::move(resource_request), save_item_id, save_package_id,
         render_process_id, render_frame_routing_id, annotation_tag,
-        url_loader_factory, save_file_manager));
+        url_loader_factory, save_file_manager, std::move(on_complete_cb)));
   }
 
   ~SimpleURLLoaderHelper() override = default;
@@ -76,10 +78,12 @@ class SaveFileManager::SimpleURLLoaderHelper
       int render_frame_routing_id,
       const net::NetworkTrafficAnnotationTag& annotation_tag,
       network::mojom::URLLoaderFactory* url_loader_factory,
-      SaveFileManager* save_file_manager)
+      SaveFileManager* save_file_manager,
+      URLLoaderCompleteCallback on_complete_cb)
       : save_file_manager_(save_file_manager),
         save_item_id_(save_item_id),
-        save_package_id_(save_package_id) {
+        save_package_id_(save_package_id),
+        on_complete_cb_(std::move(on_complete_cb)) {
     GURL url = resource_request->url;
     url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),
                                                    annotation_tag);
@@ -124,9 +128,7 @@ class SaveFileManager::SimpleURLLoaderHelper
 
   void OnComplete(bool success) override {
     download::GetDownloadTaskRunner()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&SaveFileManager::SaveFinished, save_file_manager_,
-                       save_item_id_, save_package_id_, success));
+        FROM_HERE, base::BindOnce(std::move(on_complete_cb_), success));
   }
 
   void OnRetry(base::OnceClosure start_retry) override {
@@ -138,6 +140,7 @@ class SaveFileManager::SimpleURLLoaderHelper
   SaveItemId save_item_id_;
   SavePackageId save_package_id_;
   std::unique_ptr<network::SimpleURLLoader> url_loader_;
+  URLLoaderCompleteCallback on_complete_cb_;
 
   DISALLOW_COPY_AND_ASSIGN(SimpleURLLoaderHelper);
 };
@@ -188,17 +191,20 @@ SavePackage* SaveFileManager::LookupPackage(SaveItemId save_item_id) {
 }
 
 // Call from SavePackage for starting a saving job
-void SaveFileManager::SaveURL(SaveItemId save_item_id,
-                              const GURL& url,
-                              const Referrer& referrer,
-                              int render_process_host_id,
-                              int render_view_routing_id,
-                              int render_frame_routing_id,
-                              SaveFileCreateInfo::SaveFileSource save_source,
-                              const base::FilePath& file_full_path,
-                              BrowserContext* context,
-                              StoragePartition* storage_partition,
-                              SavePackage* save_package) {
+void SaveFileManager::SaveURL(
+    SaveItemId save_item_id,
+    const GURL& url,
+    const Referrer& referrer,
+    int render_process_host_id,
+    int render_view_routing_id,
+    int render_frame_routing_id,
+    SaveFileCreateInfo::SaveFileSource save_source,
+    const base::FilePath& file_full_path,
+    BrowserContext* context,
+    StoragePartition* storage_partition,
+    SavePackage* save_package,
+    const std::string& client_guid,
+    mojo::PendingRemote<quarantine::mojom::Quarantine> remote_quarantine) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
   // Insert started saving job to tracking list.
@@ -285,11 +291,18 @@ void SaveFileManager::SaveURL(SaveItemId save_item_id,
       factory = storage_partition->GetURLLoaderFactoryForBrowserProcess().get();
     }
 
+    base::OnceCallback<void(bool /*success*/)> save_finished_cb =
+        base::BindOnce(&SaveFileManager::OnURLLoaderComplete, this,
+                       save_item_id, save_package->id(),
+                       context->IsOffTheRecord() ? GURL() : url,
+                       context->IsOffTheRecord() ? GURL() : referrer.url,
+                       client_guid, std::move(remote_quarantine));
+
     url_loader_helpers_[save_item_id] =
         SimpleURLLoaderHelper::CreateAndStartDownload(
             std::move(request), save_item_id, save_package->id(),
             render_process_host_id, render_frame_routing_id, traffic_annotation,
-            factory, this);
+            factory, this, std::move(save_finished_cb));
   } else {
     // We manually start the save job.
     auto info = std::make_unique<SaveFileCreateInfo>(
@@ -344,6 +357,36 @@ void SaveFileManager::SendCancelRequest(SaveItemId save_item_id) {
       base::BindOnce(&SaveFileManager::CancelSave, this, save_item_id));
 }
 
+void SaveFileManager::OnURLLoaderComplete(
+    SaveItemId save_item_id,
+    SavePackageId save_package_id,
+    const GURL& url,
+    const GURL& referrer_url,
+    const std::string& client_guid,
+    mojo::PendingRemote<quarantine::mojom::Quarantine> remote_quarantine,
+    bool is_success) {
+  DCHECK(download::GetDownloadTaskRunner()->RunsTasksInCurrentSequence());
+  SaveFile* save_file = LookupSaveFile(save_item_id);
+  if (!is_success || !save_file) {
+    SaveFinished(save_item_id, save_package_id, is_success);
+    return;
+  }
+
+  save_file->AnnotateWithSourceInformation(
+      client_guid, url, referrer_url, std::move(remote_quarantine),
+      base::BindOnce(&SaveFileManager::OnQuarantineComplete, this, save_item_id,
+                     save_package_id));
+}
+
+void SaveFileManager::OnQuarantineComplete(
+    SaveItemId save_item_id,
+    SavePackageId save_package_id,
+    download::DownloadInterruptReason result) {
+  DCHECK(download::GetDownloadTaskRunner()->RunsTasksInCurrentSequence());
+  SaveFinished(save_item_id, save_package_id,
+               result == download::DOWNLOAD_INTERRUPT_REASON_NONE);
+}
+
 // Notifications sent from the IO thread and run on the file thread:
 
 // The IO thread created |info|, but the file thread (this method) uses it
diff --git a/content/browser/download/save_file_manager.h b/content/browser/download/save_file_manager.h
index 51eb63a9b1..0d4290b273 100644
--- a/content/browser/download/save_file_manager.h
+++ b/content/browser/download/save_file_manager.h
@@ -61,6 +61,8 @@
 
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
+#include "components/download/public/common/download_interrupt_reasons.h"
+#include "components/services/quarantine/quarantine.h"
 #include "content/browser/download/save_types.h"
 #include "content/common/content_export.h"
 
@@ -90,17 +92,20 @@ class CONTENT_EXPORT SaveFileManager
 
   // Saves the specified URL |url|. |save_package| must not be deleted before
   // the call to RemoveSaveFile. Should be called on the UI thread,
-  void SaveURL(SaveItemId save_item_id,
-               const GURL& url,
-               const Referrer& referrer,
-               int render_process_host_id,
-               int render_view_routing_id,
-               int render_frame_routing_id,
-               SaveFileCreateInfo::SaveFileSource save_source,
-               const base::FilePath& file_full_path,
-               BrowserContext* context,
-               StoragePartition* storage_partition,
-               SavePackage* save_package);
+  void SaveURL(
+      SaveItemId save_item_id,
+      const GURL& url,
+      const Referrer& referrer,
+      int render_process_host_id,
+      int render_view_routing_id,
+      int render_frame_routing_id,
+      SaveFileCreateInfo::SaveFileSource save_source,
+      const base::FilePath& file_full_path,
+      BrowserContext* context,
+      StoragePartition* storage_partition,
+      SavePackage* save_package,
+      const std::string& client_guid,
+      mojo::PendingRemote<quarantine::mojom::Quarantine> remote_quarantine);
 
   // Notifications sent from the IO thread and run on the file thread:
   void StartSave(std::unique_ptr<SaveFileCreateInfo> info);
@@ -159,6 +164,21 @@ class CONTENT_EXPORT SaveFileManager
   // Help function for sending notification of canceling specific request.
   void SendCancelRequest(SaveItemId save_item_id);
 
+  // Called on the file thread when the URLLoader completes saving a SaveItem.
+  void OnURLLoaderComplete(
+      SaveItemId save_item_id,
+      SavePackageId save_package_id,
+      const GURL& url,
+      const GURL& referrer_url,
+      const std::string& client_guid,
+      mojo::PendingRemote<quarantine::mojom::Quarantine> remote_quarantine,
+      bool is_success);
+
+  // Called on the file thread when file quarantine finishes on a SaveItem.
+  void OnQuarantineComplete(SaveItemId save_item_id,
+                            SavePackageId save_package_id,
+                            download::DownloadInterruptReason result);
+
   // Notifications sent from the file thread and run on the UI thread.
 
   // Lookup the SaveManager for this WebContents' saving browser context and
diff --git a/content/browser/download/save_package.cc b/content/browser/download/save_package.cc
index 4ceea290dc..5eaed4a726 100644
--- a/content/browser/download/save_package.cc
+++ b/content/browser/download/save_package.cc
@@ -843,6 +843,12 @@ void SavePackage::SaveNextFile(bool process_all_remaining_items) {
     RenderFrameHostImpl* requester_frame =
         requester_frame_tree_node->current_frame_host();
 
+    mojo::PendingRemote<quarantine::mojom::Quarantine> quarantine;
+    auto quarantine_callback =
+        download_manager_->GetQuarantineConnectionCallback();
+    if (quarantine_callback)
+      quarantine_callback.Run(quarantine.InitWithNewPipeAndPassReceiver());
+
     file_manager_->SaveURL(
         save_item_ptr->id(), save_item_ptr->url(), save_item_ptr->referrer(),
         requester_frame->GetProcess()->GetID(),
@@ -854,7 +860,8 @@ void SavePackage::SaveNextFile(bool process_all_remaining_items) {
             ->GetRenderViewHost()
             ->GetProcess()
             ->GetStoragePartition(),
-        this);
+        this, download_manager_->GetApplicationClientIdForFileScanning(),
+        std::move(quarantine));
 
   } while (process_all_remaining_items && !waiting_item_queue_.empty());
 }
diff --git a/content/browser/file_system_access/file_system_access_manager_impl.cc b/content/browser/file_system_access/file_system_access_manager_impl.cc
index e58be73ae4..a47eceba37 100644
--- a/content/browser/file_system_access/file_system_access_manager_impl.cc
+++ b/content/browser/file_system_access/file_system_access_manager_impl.cc
@@ -448,6 +448,11 @@ void FileSystemAccessManagerImpl::ResolveDefaultDirectory(
                   std::move(callback))));
 }
 
+void FileSystemAccessManagerImpl::Shutdown() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  permission_context_ = nullptr;
+}
+
 void FileSystemAccessManagerImpl::SetDefaultPathAndShowPicker(
     const BindingContext& context,
     blink::mojom::FilePickerOptionsPtr options,
diff --git a/content/browser/file_system_access/file_system_access_manager_impl.h b/content/browser/file_system_access/file_system_access_manager_impl.h
index 4c9303aa11..e06a3d347f 100644
--- a/content/browser/file_system_access/file_system_access_manager_impl.h
+++ b/content/browser/file_system_access/file_system_access_manager_impl.h
@@ -257,6 +257,8 @@ class CONTENT_EXPORT FileSystemAccessManagerImpl
       PathType path_type,
       const base::FilePath& path);
 
+  void Shutdown();
+
  private:
   friend class FileSystemAccessFileHandleImpl;
 
diff --git a/content/browser/indexed_db/database_impl.cc b/content/browser/indexed_db/database_impl.cc
index d6ee1e0e10..037345a2f6 100644
--- a/content/browser/indexed_db/database_impl.cc
+++ b/content/browser/indexed_db/database_impl.cc
@@ -87,6 +87,13 @@ void DatabaseImpl::RenameObjectStore(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "RenameObjectStore was called after committing or aborting the "
+        "transaction");
+    return;
+  }
+
   transaction->ScheduleTask(
       blink::mojom::IDBTaskType::Preemptive,
       BindWeakOperation(&IndexedDBDatabase::RenameObjectStoreOperation,
@@ -175,6 +182,12 @@ void DatabaseImpl::Get(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "Get was called after committing or aborting the transaction");
+    return;
+  }
+
   blink::mojom::IDBDatabase::GetCallback aborting_callback =
       CreateCallbackAbortOnDestruct<blink::mojom::IDBDatabase::GetCallback,
                                     blink::mojom::IDBDatabaseGetResultPtr>(
@@ -225,6 +238,12 @@ void DatabaseImpl::GetAll(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "GetAll was called after committing or aborting the transaction");
+    return;
+  }
+
   // Hypothetically, this could pass the receiver to the callback immediately.
   // However, for result ordering issues, we need to PostTask to mimic
   // all of the other operations.
@@ -264,6 +283,12 @@ void DatabaseImpl::SetIndexKeys(
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "SetIndexKeys was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(
       blink::mojom::IDBTaskType::Preemptive,
       BindWeakOperation(&IndexedDBDatabase::SetIndexKeysOperation,
@@ -290,6 +315,13 @@ void DatabaseImpl::SetIndexesReady(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "SetIndexesReady was called after committing or aborting the "
+        "transaction");
+    return;
+  }
+
   transaction->ScheduleTask(
       blink::mojom::IDBTaskType::Preemptive,
       BindWeakOperation(&IndexedDBDatabase::SetIndexesReadyOperation,
@@ -327,6 +359,12 @@ void DatabaseImpl::OpenCursor(
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "OpenCursor was called after committing or aborting the transaction");
+    return;
+  }
+
   blink::mojom::IDBDatabase::OpenCursorCallback aborting_callback =
       CreateCallbackAbortOnDestruct<
           blink::mojom::IDBDatabase::OpenCursorCallback,
@@ -376,6 +414,12 @@ void DatabaseImpl::Count(
   if (!transaction)
     return;
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "Count was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(BindWeakOperation(
       &IndexedDBDatabase::CountOperation, connection_->database()->AsWeakPtr(),
       object_store_id, index_id,
@@ -401,6 +445,12 @@ void DatabaseImpl::DeleteRange(
   if (!transaction)
     return;
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "DeleteRange was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(BindWeakOperation(
       &IndexedDBDatabase::DeleteRangeOperation,
       connection_->database()->AsWeakPtr(), object_store_id,
@@ -424,6 +474,13 @@ void DatabaseImpl::GetKeyGeneratorCurrentNumber(
   if (!transaction)
     return;
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "GetKeyGeneratorCurrentNumber was called after committing or aborting "
+        "the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(BindWeakOperation(
       &IndexedDBDatabase::GetKeyGeneratorCurrentNumberOperation,
       connection_->database()->AsWeakPtr(), object_store_id,
@@ -447,6 +504,12 @@ void DatabaseImpl::Clear(
   if (!transaction)
     return;
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "Clear was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(BindWeakOperation(
       &IndexedDBDatabase::ClearOperation, connection_->database()->AsWeakPtr(),
       object_store_id, std::move(callbacks)));
@@ -474,6 +537,12 @@ void DatabaseImpl::CreateIndex(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "CreateIndex was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(
       blink::mojom::IDBTaskType::Preemptive,
       BindWeakOperation(&IndexedDBDatabase::CreateIndexOperation,
@@ -499,6 +568,12 @@ void DatabaseImpl::DeleteIndex(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "DeleteIndex was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(BindWeakOperation(
       &IndexedDBDatabase::DeleteIndexOperation,
       connection_->database()->AsWeakPtr(), object_store_id, index_id));
@@ -523,6 +598,12 @@ void DatabaseImpl::RenameIndex(int64_t transaction_id,
     return;
   }
 
+  if (!transaction->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "RenameIndex was called after committing or aborting the transaction");
+    return;
+  }
+
   transaction->ScheduleTask(
       BindWeakOperation(&IndexedDBDatabase::RenameIndexOperation,
                         connection_->database()->AsWeakPtr(), object_store_id,
diff --git a/content/browser/indexed_db/indexed_db_transaction.h b/content/browser/indexed_db/indexed_db_transaction.h
index 6acdd5db56..7536d35f00 100644
--- a/content/browser/indexed_db/indexed_db_transaction.h
+++ b/content/browser/indexed_db/indexed_db_transaction.h
@@ -67,6 +67,14 @@ class CONTENT_EXPORT IndexedDBTransaction {
   // Signals the transaction for commit.
   void SetCommitFlag();
 
+  // Returns false if the transaction has been signalled to commit, is in the
+  // process of committing, or finished committing or was aborted. Essentially
+  // when this returns false no tasks should be scheduled that try to modify
+  // the transaction.
+  bool IsAcceptingRequests() {
+    return !is_commit_pending_ && state_ != COMMITTING && state_ != FINISHED;
+  }
+
   // This transaction is ultimately backed by a LevelDBScope. Aborting a
   // transaction rolls back the LevelDBScopes, which (if LevelDBScopes is in
   // single-sequence mode) can fail. This returns the result of that rollback,
diff --git a/content/browser/indexed_db/transaction_impl.cc b/content/browser/indexed_db/transaction_impl.cc
index 1abde1c784..b0b19dd059 100644
--- a/content/browser/indexed_db/transaction_impl.cc
+++ b/content/browser/indexed_db/transaction_impl.cc
@@ -57,6 +57,13 @@ void TransactionImpl::CreateObjectStore(int64_t object_store_id,
     return;
   }
 
+  if (!transaction_->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "CreateObjectStore was called after committing or aborting the "
+        "transaction");
+    return;
+  }
+
   IndexedDBConnection* connection = transaction_->connection();
   if (!connection->IsConnected())
     return;
@@ -79,6 +86,13 @@ void TransactionImpl::DeleteObjectStore(int64_t object_store_id) {
     return;
   }
 
+  if (!transaction_->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "DeleteObjectStore was called after committing or aborting the "
+        "transaction");
+    return;
+  }
+
   IndexedDBConnection* connection = transaction_->connection();
   if (!connection->IsConnected())
     return;
@@ -111,6 +125,12 @@ void TransactionImpl::Put(
     return;
   }
 
+  if (!transaction_->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "Put was called after committing or aborting the transaction");
+    return;
+  }
+
   IndexedDBConnection* connection = transaction_->connection();
   if (!connection->IsConnected()) {
     IndexedDBDatabaseError error(blink::mojom::IDBException::kUnknownError,
@@ -170,6 +190,12 @@ void TransactionImpl::PutAll(int64_t object_store_id,
     return;
   }
 
+  if (!transaction_->IsAcceptingRequests()) {
+    mojo::ReportBadMessage(
+        "PutAll was called after committing or aborting the transaction");
+    return;
+  }
+
   std::vector<std::vector<IndexedDBExternalObject>> external_objects_per_put(
       puts.size());
   for (size_t i = 0; i < puts.size(); i++) {
@@ -268,6 +294,12 @@ void TransactionImpl::Commit(int64_t num_errors_handled) {
   if (!transaction_)
     return;
 
+  if (!transaction_->IsAcceptingRequests()) {
+    // This really shouldn't be happening, but seems to be happening anyway. So
+    // rather than killing the renderer, simply ignore the request.
+    return;
+  }
+
   IndexedDBConnection* connection = transaction_->connection();
   if (!connection->IsConnected())
     return;
diff --git a/content/browser/loader/navigation_url_loader_impl.cc b/content/browser/loader/navigation_url_loader_impl.cc
index 6b1bdfa3fd..552a9cfe82 100644
--- a/content/browser/loader/navigation_url_loader_impl.cc
+++ b/content/browser/loader/navigation_url_loader_impl.cc
@@ -620,6 +620,13 @@ NavigationURLLoaderImpl::PrepareForNonInterceptedRequest(
     if (known_schemes_.find(resource_request_->url.scheme()) ==
         known_schemes_.end()) {
       mojo::PendingRemote<network::mojom::URLLoaderFactory> loader_factory;
+      base::Optional<url::Origin> initiating_origin;
+      if (url_chain_.size() > 1) {
+        initiating_origin =
+            url::Origin::Create(url_chain_[url_chain_.size() - 2]);
+      } else {
+        initiating_origin = resource_request_->request_initiator;
+      }
       bool handled = GetContentClient()->browser()->HandleExternalProtocol(
           resource_request_->url, web_contents_getter_,
           ChildProcessHost::kInvalidUniqueID, frame_tree_node_id_,
@@ -628,7 +635,7 @@ NavigationURLLoaderImpl::PrepareForNonInterceptedRequest(
               static_cast<int>(blink::mojom::ResourceType::kMainFrame),
           static_cast<ui::PageTransition>(resource_request_->transition_type),
           resource_request_->has_user_gesture,
-          resource_request_->request_initiator, &loader_factory);
+          initiating_origin, &loader_factory);
 
       if (!handled) {
         handled = GetContentClient()->browser()->HandleExternalProtocol(
diff --git a/content/browser/media/ohos/ohos_media_player_renderer.cc b/content/browser/media/ohos/ohos_media_player_renderer.cc
index 69bbd72e2f..54db096c88 100644
--- a/content/browser/media/ohos/ohos_media_player_renderer.cc
+++ b/content/browser/media/ohos/ohos_media_player_renderer.cc
@@ -123,15 +123,21 @@ void OHOSMediaPlayerRenderer::FinishPaint(int32_t fd) {
 
 void OHOSMediaPlayerRenderer::OnFrameAvailable(int fd,
                                                uint32_t size,
-                                               int32_t width,
-                                               int32_t height) {
+                                               int32_t coded_width,
+                                               int32_t coded_height,
+                                               int32_t visible_width,
+                                               int32_t visible_height,
+                                               int32_t format) {
   if (client_extension_) {
     auto ohos_buffer = media::mojom::OhosSurfaceBufferHandle::New();
     ohos_buffer->buffer_size = size;
     base::ScopedFD buffer_fd(dup(fd));
     ohos_buffer->fd_browser = fd;
-    ohos_buffer->width = width;
-    ohos_buffer->height = height;
+    ohos_buffer->coded_width = coded_width;
+    ohos_buffer->coded_height = coded_height;
+    ohos_buffer->visible_width = visible_width;
+    ohos_buffer->visible_height = visible_height;
+    ohos_buffer->format = format;
     ohos_buffer->buffer_fd = mojo::PlatformHandle(std::move(buffer_fd));
     client_extension_->OnFrameUpdate(std::move(ohos_buffer));
   }
diff --git a/content/browser/media/ohos/ohos_media_player_renderer.h b/content/browser/media/ohos/ohos_media_player_renderer.h
index 38c5d0c224..21753d6ccd 100644
--- a/content/browser/media/ohos/ohos_media_player_renderer.h
+++ b/content/browser/media/ohos/ohos_media_player_renderer.h
@@ -58,8 +58,11 @@ class CONTENT_EXPORT OHOSMediaPlayerRenderer
   // media::OHOSMediaPlayerBridge::Client implementation
   void OnFrameAvailable(int fd,
                         uint32_t size,
-                        int32_t width,
-                        int32_t height) override;
+                        int32_t coded_width,
+                        int32_t coded_height,
+                        int32_t visible_width,
+                        int32_t visible_height,
+                        int32_t format) override;
   void OnMediaDurationChanged(base::TimeDelta duration) override;
   void OnPlaybackComplete() override;
   void OnError(int error) override;
diff --git a/content/browser/renderer_host/frame_tree_node.cc b/content/browser/renderer_host/frame_tree_node.cc
index b0b02bf700..2a9ce12ff0 100644
--- a/content/browser/renderer_host/frame_tree_node.cc
+++ b/content/browser/renderer_host/frame_tree_node.cc
@@ -475,6 +475,12 @@ bool FrameTreeNode::HasPendingCrossDocumentNavigation() const {
 
 bool FrameTreeNode::CommitFramePolicy(
     const blink::FramePolicy& new_frame_policy) {
+  // Documents create iframes, iframes host new documents. Both are associated
+  // with sandbox flags. They are required to be stricter or equal to their
+  // owner when they change, as we go down.
+  // TODO(https://crbug.com/1262061). Enforce the invariant mentioned above,
+  // once the interactions with FencedIframe has been tested and clarified.
+
   bool did_change_flags = new_frame_policy.sandbox_flags !=
                           replication_state_->frame_policy.sandbox_flags;
   bool did_change_container_policy =
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index f86413d26f..7bca1e9446 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -826,9 +826,11 @@ enum class VerifyDidCommitParamsDifference {
 };
 
 bool ValidateCSPAttribute(const std::string& value) {
+  static const size_t kMaxLengthCSPAttribute = 4096;
   if (!base::IsStringASCII(value))
     return false;
-  if (value.find('\n') != std::string::npos ||
+  if (value.length() > kMaxLengthCSPAttribute ||
+      value.find('\n') != std::string::npos ||
       value.find('\r') != std::string::npos) {
     return false;
   }
@@ -2781,6 +2783,16 @@ void RenderFrameHostImpl::CreateChildFrame(
     return;
   }
 
+  // Documents create iframes, iframes host new documents. Both are associated
+  // with sandbox flags. They are required to be stricter or equal to their
+  // owner when they are created, as we go down.
+  if (frame_policy.sandbox_flags !=
+      (frame_policy.sandbox_flags | active_sandbox_flags())) {
+    bad_message::ReceivedBadMessage(
+        GetProcess(), bad_message::RFH_CREATE_CHILD_FRAME_SANDBOX_FLAGS);
+    return;
+  }
+
   // TODO(crbug.com/1145708). The interface exposed to tests should
   // match the mojo interface.
   OnCreateChildFrame(new_routing_id, std::move(frame_remote),
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index d186f75e51..f0e8942562 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -2581,6 +2581,9 @@ void RenderProcessHostImpl::RegisterCoordinatorClient(
     mojo::PendingReceiver<memory_instrumentation::mojom::Coordinator> receiver,
     mojo::PendingRemote<memory_instrumentation::mojom::ClientProcess>
         client_process) {
+  // Intentionally disallow non-browser processes from getting a Coordinator.
+  receiver.reset();
+
   if (!GetProcess().IsValid()) {
     // If the process dies before we get this message. we have no valid PID
     // and there's nothing to register.
@@ -3341,6 +3344,9 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
 #endif
 #if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
     switches::kSchedulerBoostUrgent,
+#endif
+#if defined(OS_OHOS)
+    switches::kForTest,
 #endif
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
diff --git a/content/browser/security_exploit_browsertest.cc b/content/browser/security_exploit_browsertest.cc
index 2ff6de6333..cfef02b3a1 100644
--- a/content/browser/security_exploit_browsertest.cc
+++ b/content/browser/security_exploit_browsertest.cc
@@ -680,7 +680,7 @@ IN_PROC_BROWSER_TEST_F(SecurityExploitBrowserTestMojoBlobURLs,
   // If the process is killed, this test passes.
   EXPECT_EQ(
       "Received bad user message: "
-      "Non committable URL passed to BlobURLStore::Register",
+      "URL with invalid origin passed to BlobURLStore::Register",
       crash_observer.Wait());
 }
 
diff --git a/content/browser/service_worker/service_worker_fetch_dispatcher.cc b/content/browser/service_worker/service_worker_fetch_dispatcher.cc
index 99753b0b4b..c0c6f1ecaf 100644
--- a/content/browser/service_worker/service_worker_fetch_dispatcher.cc
+++ b/content/browser/service_worker/service_worker_fetch_dispatcher.cc
@@ -449,8 +449,10 @@ class ServiceWorkerFetchDispatcher::URLLoaderAssets
   // NetworkService.
   URLLoaderAssets(
       scoped_refptr<network::SharedURLLoaderFactory> shared_url_loader_factory,
+      mojo::PendingRemote<network::mojom::URLLoader> url_loader,
       std::unique_ptr<DelegatingURLLoaderClient> url_loader_client)
       : shared_url_loader_factory_(std::move(shared_url_loader_factory)),
+        url_loader_(std::move(url_loader)),
         url_loader_client_(std::move(url_loader_client)) {}
 
   void MaybeReportToDevTools(std::pair<int, int> worker_id,
@@ -467,6 +469,7 @@ class ServiceWorkerFetchDispatcher::URLLoaderAssets
 
   // NetworkService:
   scoped_refptr<network::SharedURLLoaderFactory> shared_url_loader_factory_;
+  mojo::PendingRemote<network::mojom::URLLoader> url_loader_;
 
   // Both:
   std::unique_ptr<DelegatingURLLoaderClient> url_loader_client_;
@@ -625,7 +628,8 @@ void ServiceWorkerFetchDispatcher::DispatchFetchEvent() {
   auto params = blink::mojom::DispatchFetchEventParams::New();
   params->request = std::move(request_);
   params->client_id = client_id_;
-  params->preload_handle = std::move(preload_handle_);
+  params->preload_url_loader_client_receiver =
+      std::move(preload_url_loader_client_receiver_);
   params->is_offline_capability_check = is_offline_capability_check_;
 
   // TODO(https://crbug.com/900700): Make the remote connected to a receiver
@@ -710,13 +714,9 @@ bool ServiceWorkerFetchDispatcher::MaybeStartNavigationPreload(
   // When the fetch event is for an offline capability check, respond to the
   // navigation preload with a network disconnected error, to simulate offline.
   if (is_offline_capability_check_) {
-    mojo::PendingRemote<network::mojom::URLLoader> url_loader_to_pass;
     mojo::Remote<network::mojom::URLLoaderClient> url_loader_client;
-    auto dummy_receiver = url_loader_to_pass.InitWithNewPipeAndPassReceiver();
 
-    preload_handle_ = blink::mojom::FetchEventPreloadHandle::New();
-    preload_handle_->url_loader = std::move(url_loader_to_pass);
-    preload_handle_->url_loader_client_receiver =
+    preload_url_loader_client_receiver_ =
         url_loader_client.BindNewPipeAndPassReceiver();
 
     url_loader_client->OnComplete(
@@ -755,12 +755,10 @@ bool ServiceWorkerFetchDispatcher::MaybeStartNavigationPreload(
   factory = base::MakeRefCounted<network::WrapperSharedURLLoaderFactory>(
       std::move(network_factory));
 
-  preload_handle_ = blink::mojom::FetchEventPreloadHandle::New();
-
   // Create the DelegatingURLLoaderClient, which becomes the
   // URLLoaderClient for the navigation preload network request.
   mojo::PendingRemote<network::mojom::URLLoaderClient> inner_url_loader_client;
-  preload_handle_->url_loader_client_receiver =
+  preload_url_loader_client_receiver_ =
       inner_url_loader_client.InitWithNewPipeAndPassReceiver();
   auto url_loader_client = std::make_unique<DelegatingURLLoaderClient>(
       std::move(inner_url_loader_client), resource_request);
@@ -795,11 +793,9 @@ bool ServiceWorkerFetchDispatcher::MaybeStartNavigationPreload(
       net::MutableNetworkTrafficAnnotationTag(
           kNavigationPreloadTrafficAnnotation));
 
-  preload_handle_->url_loader = std::move(url_loader);
-
   DCHECK(!url_loader_assets_);
   url_loader_assets_ = base::MakeRefCounted<URLLoaderAssets>(
-      std::move(factory), std::move(url_loader_client));
+      std::move(factory), std::move(url_loader), std::move(url_loader_client));
   return true;
 }
 
diff --git a/content/browser/service_worker/service_worker_fetch_dispatcher.h b/content/browser/service_worker/service_worker_fetch_dispatcher.h
index d436dbfba3..056b1ec439 100644
--- a/content/browser/service_worker/service_worker_fetch_dispatcher.h
+++ b/content/browser/service_worker/service_worker_fetch_dispatcher.h
@@ -123,10 +123,11 @@ class CONTENT_EXPORT ServiceWorkerFetchDispatcher {
 
   scoped_refptr<URLLoaderAssets> url_loader_assets_;
 
-  // |preload_handle_| holds the URLLoader and URLLoaderClient for the service
-  // worker to receive the navigation preload response. It's passed to the
-  // service worker along with the fetch event.
-  blink::mojom::FetchEventPreloadHandlePtr preload_handle_;
+  // Holds the URLLoaderClient for the service worker to receive the navigation
+  // preload response. It's passed to the service worker along with the fetch
+  // event.
+  mojo::PendingReceiver<network::mojom::URLLoaderClient>
+      preload_url_loader_client_receiver_;
 
   // Whether to dispatch an offline-capability-check fetch event.
   const bool is_offline_capability_check_ = false;
diff --git a/content/browser/storage_partition_impl.cc b/content/browser/storage_partition_impl.cc
index 65c4f1049f..7a517fe224 100644
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -1064,6 +1064,9 @@ StoragePartitionImpl::~StoragePartitionImpl() {
                                   GetDatabaseTracker()));
   }
 
+  if (GetFileSystemAccessManager())
+    GetFileSystemAccessManager()->Shutdown();
+
   if (GetFileSystemContext())
     GetFileSystemContext()->Shutdown();
 
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 3e19bacca3..e3a9179342 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -2586,7 +2586,7 @@ void WebContentsImpl::SetSlowWebPreferences(
     // Otherwise default is disabled.
     std::string touch_enabled_default_switch =
         switches::kTouchEventFeatureDetectionDisabled;
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
     touch_enabled_default_switch = switches::kTouchEventFeatureDetectionEnabled;
 #endif  // defined(OS_ANDROID)
     const std::string touch_enabled_switch =
diff --git a/content/browser/webauth/authenticator_common.cc b/content/browser/webauth/authenticator_common.cc
index 069543a490..16d3a019fa 100644
--- a/content/browser/webauth/authenticator_common.cc
+++ b/content/browser/webauth/authenticator_common.cc
@@ -894,6 +894,13 @@ void AuthenticatorCommon::MakeCredential(
     return;
   }
 
+  if (!security_checker_->DeduplicateCredentialDescriptorListAndValidateLength(
+          &options->exclude_credentials)) {
+    mojo::ReportBadMessage("invalid exclude_credentials length");
+    InvokeCallbackAndCleanup(std::move(callback), blink::mojom::AuthenticatorStatus::NOT_ALLOWED_ERROR);
+    return;
+  }
+
   request_delegate_ = CreateRequestDelegate();
   if (!request_delegate_) {
     InvokeCallbackAndCleanup(std::move(callback),
@@ -1155,6 +1162,13 @@ void AuthenticatorCommon::GetAssertion(
     return;
   }
 
+  if (!security_checker_->DeduplicateCredentialDescriptorListAndValidateLength(
+          &options->allow_credentials)) {
+    mojo::ReportBadMessage("invalid allow_credentials length");
+    InvokeCallbackAndCleanup(std::move(callback), blink::mojom::AuthenticatorStatus::NOT_ALLOWED_ERROR);
+    return;
+  }
+
   request_delegate_ = CreateRequestDelegate();
   if (!request_delegate_) {
     InvokeCallbackAndCleanup(std::move(callback),
diff --git a/content/browser/webauth/authenticator_impl_unittest.cc b/content/browser/webauth/authenticator_impl_unittest.cc
index 333d020662..fd43d3902d 100644
--- a/content/browser/webauth/authenticator_impl_unittest.cc
+++ b/content/browser/webauth/authenticator_impl_unittest.cc
@@ -67,6 +67,7 @@
 #include "device/fido/multiple_virtual_fido_device_factory.h"
 #include "device/fido/pin.h"
 #include "device/fido/public_key.h"
+#include "device/fido/public_key_credential_descriptor.h"
 #include "device/fido/test_callback_receiver.h"
 #include "device/fido/virtual_fido_device.h"
 #include "device/fido/virtual_fido_device_factory.h"
@@ -459,6 +460,9 @@ class AuthenticatorTestBase : public content::RenderViewHostTestHarness {
   void SetUp() override {
     content::RenderViewHostTestHarness::SetUp();
 
+    mojo::SetDefaultProcessErrorHandler(base::BindRepeating(
+        &AuthenticatorTestBase::OnMojoError, base::Unretained(this)));
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     chromeos::U2FClient::InitializeFake();
 #endif
@@ -469,6 +473,8 @@ class AuthenticatorTestBase : public content::RenderViewHostTestHarness {
   void TearDown() override {
     content::RenderViewHostTestHarness::TearDown();
 
+  mojo::SetDefaultProcessErrorHandler(base::NullCallback());
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     chromeos::U2FClient::Shutdown();
 #endif
@@ -483,7 +489,23 @@ class AuthenticatorTestBase : public content::RenderViewHostTestHarness {
             std::move(virtual_device_factory));
   }
 
+  void SetMojoErrorHandler(
+      base::RepeatingCallback<void(const std::string&)> callback) {
+    mojo_error_handler_ = callback;
+  }
+
   device::test::VirtualFidoDeviceFactory* virtual_device_factory_;
+
+ private:
+  void OnMojoError(const std::string& error) {
+    if (mojo_error_handler_) {
+      mojo_error_handler_.Run(error);
+      return;
+    }
+    FAIL() << "Unhandled mojo error: " << error;
+  }
+
+  base::RepeatingCallback<void(const std::string&)> mojo_error_handler_;
 };
 
 class AuthenticatorImplTest : public AuthenticatorTestBase {
@@ -632,18 +654,17 @@ class AuthenticatorImplTest : public AuthenticatorTestBase {
     scoped_feature_list_->InitAndDisableFeature(feature);
   }
 
- protected:
+  scoped_refptr<::testing::NiceMock<device::MockBluetoothAdapter>>
+      mock_adapter_ = base::MakeRefCounted<
+          ::testing::NiceMock<device::MockBluetoothAdapter>>();
+
+ private:
   std::unique_ptr<AuthenticatorImpl> authenticator_impl_;
   base::Optional<base::test::ScopedFeatureList> scoped_feature_list_;
   std::unique_ptr<device::BluetoothAdapterFactory::GlobalValuesForTesting>
       bluetooth_global_values_ =
           device::BluetoothAdapterFactory::Get()->InitGlobalValuesForTesting();
-  scoped_refptr<::testing::NiceMock<device::MockBluetoothAdapter>>
-      mock_adapter_ = base::MakeRefCounted<
-          ::testing::NiceMock<device::MockBluetoothAdapter>>();
   data_decoder::test::InProcessDataDecoder data_decoder_service_;
-
- private:
   url::ScopedSchemeRegistryForTests scoped_registry_;
 };
 
@@ -3523,7 +3544,7 @@ TEST_F(AuthenticatorImplTest, AllowListWithOnlyOversizedCredentialIds) {
 
   for (const bool has_app_id : {false, true}) {
     SCOPED_TRACE(has_app_id);
-    virtual_device_factory_->mutable_state()->allow_list_sizes.clear();
+    virtual_device_factory_->mutable_state()->allow_list_history.clear();
 
     PublicKeyCredentialRequestOptionsPtr options =
         GetTestPublicKeyCredentialRequestOptions();
@@ -3535,14 +3556,200 @@ TEST_F(AuthenticatorImplTest, AllowListWithOnlyOversizedCredentialIds) {
 
     EXPECT_EQ(AuthenticatorGetAssertion(std::move(options)).status,
               AuthenticatorStatus::NOT_ALLOWED_ERROR);
-    const auto& allow_list_sizes =
-        virtual_device_factory_->mutable_state()->allow_list_sizes;
+    const auto& allow_list_history =
+        virtual_device_factory_->mutable_state()->allow_list_history;
     // No empty allow-list requests should have been made.
-    EXPECT_TRUE(std::none_of(allow_list_sizes.cbegin(), allow_list_sizes.cend(),
-                             [](size_t size) { return size == 0; }));
+    EXPECT_TRUE(std::none_of(
+        allow_list_history.cbegin(), allow_list_history.cend(),
+        [](const std::vector<device::PublicKeyCredentialDescriptor>&
+               allow_list) { return allow_list.empty(); }));
   }
 }
 
+// Tests that duplicate credential IDs are filtered from an assertion allow_list
+// parameter.
+TEST_F(AuthenticatorImplTest, AllowListWithDuplicateCredentialIds) {
+  NavigateAndCommit(GURL(kTestOrigin1));
+
+  device::VirtualCtap2Device::Config config;
+  config.u2f_support = true;
+  config.max_credential_id_length = kTestCredentialIdLength;
+  config.max_credential_count_in_list = 10;
+  virtual_device_factory_->SetCtap2Config(config);
+
+  device::PublicKeyCredentialDescriptor cred_a(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 1), {});
+  device::PublicKeyCredentialDescriptor cred_b(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 2),
+      {device::FidoTransportProtocol::kUsbHumanInterfaceDevice});
+  // Same ID as `cred_a` and `cred_b` but with different transports.
+  device::PublicKeyCredentialDescriptor cred_c(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 1),
+      {device::FidoTransportProtocol::kBluetoothLowEnergy});
+  device::PublicKeyCredentialDescriptor cred_d(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 2),
+      {device::FidoTransportProtocol::kBluetoothLowEnergy});
+
+  ASSERT_TRUE(virtual_device_factory_->mutable_state()->InjectRegistration(
+      cred_b.id(), kTestRelyingPartyId));
+
+  PublicKeyCredentialRequestOptionsPtr options =
+      GetTestPublicKeyCredentialRequestOptions();
+  options->allow_credentials.clear();
+  options->allow_credentials.insert(options->allow_credentials.end(), 5,
+                                    cred_a);
+  options->allow_credentials.push_back(cred_b);
+  options->allow_credentials.insert(options->allow_credentials.end(), 3,
+                                    cred_c);
+  options->allow_credentials.insert(options->allow_credentials.end(), 2,
+                                    cred_d);
+
+  EXPECT_EQ(AuthenticatorGetAssertion(std::move(options)).status,
+            AuthenticatorStatus::SUCCESS);
+  EXPECT_EQ(virtual_device_factory_->mutable_state()->allow_list_history.size(),
+            1u);
+  // Transport hints from descriptors with equal IDs should be merged.
+  device::PublicKeyCredentialDescriptor cred_a_and_c(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 1),
+      // The union of the empty transports in `cred_a` plus the non-empty set
+      // from `cred_c` should still be empty, since empty set is interpreted to
+      // mean "any available transport".
+      {});
+  device::PublicKeyCredentialDescriptor cred_b_and_d(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 2),
+      {device::FidoTransportProtocol::kUsbHumanInterfaceDevice,
+       device::FidoTransportProtocol::kBluetoothLowEnergy});
+  EXPECT_THAT(
+      virtual_device_factory_->mutable_state()->allow_list_history.at(0),
+      testing::UnorderedElementsAre(cred_a_and_c, cred_b_and_d));
+}
+
+// Tests that duplicate credential IDs are filtered from a registration
+// exclude_list parameter.
+TEST_F(AuthenticatorImplTest, ExcludeListWithDuplicateCredentialIds) {
+  NavigateAndCommit(GURL(kTestOrigin1));
+
+  device::VirtualCtap2Device::Config config;
+  config.u2f_support = true;
+  config.max_credential_id_length = kTestCredentialIdLength;
+  config.max_credential_count_in_list = 100;
+  virtual_device_factory_->SetCtap2Config(config);
+
+  device::PublicKeyCredentialDescriptor cred_a(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 1), {});
+  device::PublicKeyCredentialDescriptor cred_b(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 2),
+      {device::FidoTransportProtocol::kUsbHumanInterfaceDevice});
+  // Same ID as `cred_a` and `cred_b` but with different transports.
+  device::PublicKeyCredentialDescriptor cred_c(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 1),
+      {device::FidoTransportProtocol::kBluetoothLowEnergy});
+  device::PublicKeyCredentialDescriptor cred_d(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 2),
+      {device::FidoTransportProtocol::kBluetoothLowEnergy});
+
+  PublicKeyCredentialCreationOptionsPtr options =
+      GetTestPublicKeyCredentialCreationOptions();
+  options->exclude_credentials.clear();
+  options->exclude_credentials.insert(options->exclude_credentials.end(), 5,
+                                      cred_a);
+  options->exclude_credentials.push_back(cred_b);
+  options->exclude_credentials.insert(options->exclude_credentials.end(), 3,
+                                      cred_c);
+  options->exclude_credentials.insert(options->exclude_credentials.end(), 2,
+                                      cred_d);
+
+  EXPECT_EQ(AuthenticatorMakeCredential(std::move(options)).status,
+            AuthenticatorStatus::SUCCESS);
+  EXPECT_EQ(
+      virtual_device_factory_->mutable_state()->exclude_list_history.size(),
+      1u);
+  // Transport hints from descriptors with equal IDs should be merged.
+  device::PublicKeyCredentialDescriptor cred_a_and_c(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 1),
+      // The union of the empty transports in `cred_a` plus the non-empty set
+      // from `cred_c` should still be empty, since empty set is interpreted to
+      // mean "any available transport".
+      {});
+  device::PublicKeyCredentialDescriptor cred_b_and_d(
+      device::CredentialType::kPublicKey,
+      std::vector<uint8_t>(kTestCredentialIdLength, 2),
+      {device::FidoTransportProtocol::kUsbHumanInterfaceDevice,
+       device::FidoTransportProtocol::kBluetoothLowEnergy});
+  EXPECT_THAT(
+      virtual_device_factory_->mutable_state()->exclude_list_history.at(0),
+      testing::UnorderedElementsAre(cred_a_and_c, cred_b_and_d));
+}
+
+// Test that allow lists over 64 entries are verboten.
+TEST_F(AuthenticatorImplTest, OversizedAllowList) {
+  NavigateAndCommit(GURL(kTestOrigin1));
+
+  device::VirtualCtap2Device::Config config;
+  config.u2f_support = true;
+  config.max_credential_id_length = kTestCredentialIdLength;
+  config.max_credential_count_in_list = 100;
+  virtual_device_factory_->SetCtap2Config(config);
+
+  auto test_credentials = GetTestCredentials(
+      /*num_credentials=*/blink::mojom::
+          kPublicKeyCredentialDescriptorListMaxSize +
+      1);
+  ASSERT_TRUE(virtual_device_factory_->mutable_state()->InjectRegistration(
+      test_credentials.at(0).id(), kTestRelyingPartyId));
+
+  PublicKeyCredentialRequestOptionsPtr options =
+      GetTestPublicKeyCredentialRequestOptions();
+  options->allow_credentials = test_credentials;
+
+  bool has_mojo_error = false;
+  SetMojoErrorHandler(base::BindLambdaForTesting(
+      [&](const std::string& error) { has_mojo_error = true; }));
+
+  EXPECT_EQ(AuthenticatorGetAssertion(std::move(options)).status,
+            AuthenticatorStatus::NOT_ALLOWED_ERROR);
+  EXPECT_TRUE(has_mojo_error);
+}
+
+// Test that exclude lists over 64 entries are verboten.
+TEST_F(AuthenticatorImplTest, OversizedExcludeList) {
+  NavigateAndCommit(GURL(kTestOrigin1));
+
+  device::VirtualCtap2Device::Config config;
+  config.u2f_support = true;
+  config.max_credential_id_length = kTestCredentialIdLength;
+  config.max_credential_count_in_list = 100;
+  virtual_device_factory_->SetCtap2Config(config);
+
+  auto test_credentials = GetTestCredentials(
+      /*num_credentials=*/blink::mojom::
+          kPublicKeyCredentialDescriptorListMaxSize +
+      1);
+
+  PublicKeyCredentialCreationOptionsPtr options =
+      GetTestPublicKeyCredentialCreationOptions();
+  options->exclude_credentials = test_credentials;
+
+  bool has_mojo_error = false;
+  SetMojoErrorHandler(base::BindLambdaForTesting(
+      [&](const std::string& error) { has_mojo_error = true; }));
+
+  EXPECT_EQ(AuthenticatorMakeCredential(std::move(options)).status,
+            AuthenticatorStatus::NOT_ALLOWED_ERROR);
+  EXPECT_TRUE(has_mojo_error);
+}
+
 TEST_F(AuthenticatorImplTest, NoUnexpectedAuthenticatorExtensions) {
   NavigateAndCommit(GURL(kTestOrigin1));
 
diff --git a/content/browser/webauth/webauth_browsertest.cc b/content/browser/webauth/webauth_browsertest.cc
index 038bd22a6e..cb80baef7d 100644
--- a/content/browser/webauth/webauth_browsertest.cc
+++ b/content/browser/webauth/webauth_browsertest.cc
@@ -124,6 +124,14 @@ constexpr char kCrossOriginAncestorMessage[] =
     "storage/retrieval of 'PasswordCredential' and 'FederatedCredential', "
     "storage of 'PublicKeyCredential'.";
 
+constexpr char kAllowCredentialsRangeErrorMessage[] =
+    "webauth: RangeError: The `allowCredentials` attribute exceeds the maximum "
+    "allowed size (64).";
+
+constexpr char kExcludeCredentialsRangeErrorMessage[] =
+    "webauth: RangeError: The `excludeCredentials` attribute exceeds the "
+    "maximum allowed size (64).";
+
 // Templates to be used with base::ReplaceStringPlaceholders. Can be
 // modified to include up to 9 replacements. The default values for
 // any additional replacements added should also be added to the
@@ -139,14 +147,14 @@ constexpr char kCreatePublicKeyTemplate[] =
     "    icon: '$8'},"
     "  pubKeyCredParams: [{ type: 'public-key', alg: '$4'}],"
     "  timeout: _timeout_,"
-    "  excludeCredentials: [],"
+    "  excludeCredentials: $9,"
     "  authenticatorSelection: {"
     "     requireResidentKey: $1,"
     "     userVerification: '$2',"
     "     authenticatorAttachment: '$5',"
     "  },"
     "  attestation: '$6',"
-    "}}).then(c => window.domAutomationController.send('webauth: OK' + $9),"
+    "}}).then(c => window.domAutomationController.send('webauth: OK'),"
     "         e => window.domAutomationController.send("
     "                  'webauth: ' + e.toString()));";
 
@@ -161,40 +169,33 @@ constexpr char kCreatePublicKeyWithAbortSignalTemplate[] =
     "    icon: '$8'},"
     "  pubKeyCredParams: [{ type: 'public-key', alg: '$4'}],"
     "  timeout: _timeout_,"
-    "  excludeCredentials: [],"
+    "  excludeCredentials: $9,"
     "  authenticatorSelection: {"
     "     requireResidentKey: $1,"
     "     userVerification: '$2',"
     "     authenticatorAttachment: '$5',"
     "  },"
     "  attestation: '$6',"
-    "}, signal: $9}"
+    "}, signal: _signal_}"
     ").then(c => window.domAutomationController.send('webauth: OK'),"
     "       e => window.domAutomationController.send("
     "                'webauth: ' + e.toString()));";
 
-constexpr char kPlatform[] = "platform";
-constexpr char kCrossPlatform[] = "cross-platform";
-constexpr char kPreferredVerification[] = "preferred";
-constexpr char kRequiredVerification[] = "required";
 constexpr char kShortTimeout[] = "100";
 
 // Default values for kCreatePublicKeyTemplate.
 struct CreateParameters {
-  const char* rp_id = "acme.com";
+  std::string rp_id = "acme.com";
   bool require_resident_key = false;
-  const char* user_verification = kPreferredVerification;
-  const char* authenticator_attachment = kCrossPlatform;
-  const char* algorithm_identifier = "-7";
-  const char* attestation = "none";
-  const char* rp_icon = "https://pics.acme.com/00/p/aBjjjpqPb.png";
-  const char* user_icon = "https://pics.acme.com/00/p/aBjjjpqPb.png";
-  const char* signal = "";
-  // extra_ok_output is a Javascript expression which must evaluate to a string.
-  // It can use the |PublicKeyCredential| object named |c| to extract useful
-  // fields.
-  const char* extra_ok_output = "''";
-  const char* timeout = "1000";
+  std::string user_verification = "preferred";
+  std::string authenticator_attachment = "cross-platform";
+  std::string algorithm_identifier = "-7";
+  std::string attestation = "none";
+  std::string rp_icon = "https://pics.acme.com/00/p/aBjjjpqPb.png";
+  std::string user_icon = "https://pics.acme.com/00/p/aBjjjpqPb.png";
+  std::string exclude_credentials = "[]";
+  std::string signal = "";
+  std::string timeout = "1000";
 };
 
 std::string BuildCreateCallWithParameters(const CreateParameters& parameters) {
@@ -207,16 +208,17 @@ std::string BuildCreateCallWithParameters(const CreateParameters& parameters) {
   substitutions.push_back(parameters.attestation);
   substitutions.push_back(parameters.rp_icon);
   substitutions.push_back(parameters.user_icon);
+  substitutions.push_back(parameters.exclude_credentials);
 
   std::string result;
-  if (strlen(parameters.signal) == 0) {
-    substitutions.push_back(parameters.extra_ok_output);
+  if (parameters.signal.empty()) {
     result = base::ReplaceStringPlaceholders(kCreatePublicKeyTemplate,
                                              substitutions, nullptr);
   } else {
-    substitutions.push_back(parameters.signal);
     result = base::ReplaceStringPlaceholders(
         kCreatePublicKeyWithAbortSignalTemplate, substitutions, nullptr);
+    base::ReplaceFirstSubstringAfterOffset(&result, 0, "_signal_",
+                                           parameters.signal);
   }
 
   base::ReplaceFirstSubstringAfterOffset(&result, 0, "_timeout_",
@@ -227,45 +229,40 @@ std::string BuildCreateCallWithParameters(const CreateParameters& parameters) {
 constexpr char kGetPublicKeyTemplate[] =
     "navigator.credentials.get({ publicKey: {"
     "  challenge: new TextEncoder().encode('climb a mountain'),"
-    "  timeout: $4,"
     "  userVerification: '$1',"
-    "  $2}"
-    "}).then(c => window.domAutomationController.send('webauth: OK' + $3),"
+    "  allowCredentials: $2,"
+    "  timeout: $3}"
+    "}).then(c => window.domAutomationController.send('webauth: OK'),"
     "        e => window.domAutomationController.send("
     "                  'webauth: ' + e.toString()));";
 
 constexpr char kGetPublicKeyWithAbortSignalTemplate[] =
     "navigator.credentials.get({ publicKey: {"
     "  challenge: new TextEncoder().encode('climb a mountain'),"
-    "  timeout: $4,"
     "  userVerification: '$1',"
-    "  $2},"
-    "  signal: $5"
-    "}).catch(c => window.domAutomationController.send("
+    "  allowCredentials: $2,"
+    "  timeout: $3,"
+    "}, signal: $4}"
+    ").catch(c => window.domAutomationController.send("
     "                  'webauth: ' + c.toString()));";
 
 // Default values for kGetPublicKeyTemplate.
 struct GetParameters {
-  const char* user_verification = kPreferredVerification;
-  const char* allow_credentials =
-      "allowCredentials: [{ type: 'public-key',"
-      "     id: new TextEncoder().encode('allowedCredential'),"
-      "     transports: ['usb', 'nfc', 'ble']}]";
-  const char* signal = "";
-  const char* timeout = "1000";
-  // extra_ok_output is a Javascript expression which must evaluate to a string.
-  // It can use the |PublicKeyCredential| object named |c| to extract useful
-  // fields.
-  const char* extra_ok_output = "''";
+  std::string user_verification = "preferred";
+  std::string allow_credentials =
+      "[{type: 'public-key',"
+      "  id: new TextEncoder().encode('allowedCredential'),"
+      "  transports: ['usb', 'nfc', 'ble']}]";
+  std::string signal = "";
+  std::string timeout = "1000";
 };
 
 std::string BuildGetCallWithParameters(const GetParameters& parameters) {
   std::vector<std::string> substitutions;
   substitutions.push_back(parameters.user_verification);
   substitutions.push_back(parameters.allow_credentials);
-  substitutions.push_back(parameters.extra_ok_output);
   substitutions.push_back(parameters.timeout);
-  if (strlen(parameters.signal) == 0) {
+  if (parameters.signal.empty()) {
     return base::ReplaceStringPlaceholders(kGetPublicKeyTemplate, substitutions,
                                            nullptr);
   }
@@ -886,7 +883,7 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
     virtual_device_factory->SetSupportedProtocol(protocol);
 
     CreateParameters parameters;
-    parameters.user_verification = kRequiredVerification;
+    parameters.user_verification = "required";
     parameters.timeout = kShortTimeout;
     std::string result;
     ASSERT_TRUE(content::ExecuteScriptAndExtractString(
@@ -944,7 +941,7 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
     virtual_device_factory->SetSupportedProtocol(protocol);
 
     CreateParameters parameters;
-    parameters.authenticator_attachment = kPlatform;
+    parameters.authenticator_attachment = "platform";
     parameters.timeout = kShortTimeout;
     std::string result;
     ASSERT_TRUE(content::ExecuteScriptAndExtractString(
@@ -1052,7 +1049,7 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
 
   GetParameters parameters;
   parameters.allow_credentials =
-      "allowCredentials: [{"
+      "[{"
       "  type: 'public-key',"
       "  id: new TextEncoder().encode('allowedCredential'),"
       "  transports: ['carrierpigeon'],"
@@ -1071,7 +1068,7 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
                        GetPublicKeyCredentialEmptyAllowCredentialsList) {
   InjectVirtualFidoDeviceFactory();
   GetParameters parameters;
-  parameters.allow_credentials = "";
+  parameters.allow_credentials = "[]";
   std::string result;
   ASSERT_TRUE(content::ExecuteScriptAndExtractString(
       shell()->web_contents()->GetMainFrame(),
@@ -1252,16 +1249,14 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
       EXPECT_EQ(kCrossOriginAncestorMessage, result);
     }
 
+    GetParameters get_params;
     const int credential_id =
         test.cross_origin ? kInnerCredentialID : kOuterCredentialID;
-    const std::string allow_credentials = base::StringPrintf(
-        "allowCredentials: "
+    get_params.allow_credentials = base::StringPrintf(
         "[{ type: 'public-key',"
         "   id: new Uint8Array([%d]),"
         "}]",
         credential_id);
-    GetParameters get_params;
-    get_params.allow_credentials = allow_credentials.c_str();
     ASSERT_TRUE(content::ExecuteScriptAndExtractString(
         iframe, BuildGetCallWithParameters(get_params), &result));
     if (test.get_should_work) {
@@ -1369,7 +1364,7 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
   InjectVirtualFidoDeviceFactory();
   GetParameters parameters;
   parameters.allow_credentials =
-      "allowCredentials: [{ type: 'public-key',"
+      "[{ type: 'public-key',"
       "  id: new TextEncoder().encode('allowedCredential'),"
       "  transports: ['cable']}],"
       "extensions: {"
@@ -1466,8 +1461,7 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest, WinGetAssertion) {
 
   GetParameters get_parameters;
   get_parameters.allow_credentials =
-      "allowCredentials: [{ type: 'public-key', id: new "
-      "TextEncoder().encode('AAA')}]";
+      "[{ type: 'public-key', id: new TextEncoder().encode('AAA')}]";
 
   base::Optional<std::string> result = ExecuteScriptAndExtractPrefixedString(
       shell()->web_contents(), BuildGetCallWithParameters(get_parameters),
@@ -1505,6 +1499,39 @@ IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
 }
 #endif
 
+IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
+                       GetAssertionOversizedAllowList) {
+  EXPECT_TRUE(
+      NavigateToURL(shell(), GetHttpsURL("www.acme.com", "/title1.html")));
+
+  GetParameters get_parameters;
+  get_parameters.allow_credentials =
+      "Array(65).fill({ type: 'public-key', id: new "
+      "TextEncoder().encode('A')})";
+
+  absl::optional<std::string> result = ExecuteScriptAndExtractPrefixedString(
+      shell()->web_contents(), BuildGetCallWithParameters(get_parameters),
+      "webauth: ");
+  ASSERT_TRUE(result);
+  ASSERT_EQ(kAllowCredentialsRangeErrorMessage, *result);
+}
+
+IN_PROC_BROWSER_TEST_F(WebAuthJavascriptClientBrowserTest,
+                       MakeCredentialOversizedExcludeList) {
+  EXPECT_TRUE(
+      NavigateToURL(shell(), GetHttpsURL("www.acme.com", "/title1.html")));
+
+  CreateParameters parameters;
+  parameters.exclude_credentials =
+      "Array(65).fill({type: 'public-key', id: new TextEncoder().encode('A')})";
+
+  absl::optional<std::string> result = ExecuteScriptAndExtractPrefixedString(
+      shell()->web_contents(), BuildCreateCallWithParameters(parameters),
+      "webauth: ");
+  ASSERT_TRUE(result);
+  ASSERT_EQ(kExcludeCredentialsRangeErrorMessage, *result);
+}
+
 class WebAuthLocalClientBackForwardCacheBrowserTest
     : public WebAuthLocalClientBrowserTest {
  protected:
diff --git a/content/browser/webauth/webauth_request_security_checker.cc b/content/browser/webauth/webauth_request_security_checker.cc
index 57201e51bc..e4db00509e 100644
--- a/content/browser/webauth/webauth_request_security_checker.cc
+++ b/content/browser/webauth/webauth_request_security_checker.cc
@@ -10,6 +10,7 @@
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/common/content_features.h"
 #include "device/fido/features.h"
+#include "device/fido/fido_transport_protocol.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "services/network/public/cpp/is_potentially_trustworthy.h"
 #include "third_party/blink/public/mojom/permissions_policy/permissions_policy_feature.mojom.h"
@@ -185,4 +186,51 @@ WebAuthRequestSecurityChecker::ValidateAPrioriAuthenticatedUrl(
   return blink::mojom::AuthenticatorStatus::SUCCESS;
 }
 
+bool WebAuthRequestSecurityChecker::
+    DeduplicateCredentialDescriptorListAndValidateLength(
+        std::vector<device::PublicKeyCredentialDescriptor>* list) {
+  // Credential descriptor lists should not exceed 64 entries, which is enforced
+  // by renderer code. Any duplicate entries they contain should be ignored.
+  // This is to guard against sites trying to amplify small timing differences
+  // in the processing of different types of credentials when sending probing
+  // requests to physical security keys (https://crbug.com/1248862).
+  if (list->size() > blink::mojom::kPublicKeyCredentialDescriptorListMaxSize) {
+    return false;
+  }
+  auto credential_descriptor_compare_without_transport =
+      [](const device::PublicKeyCredentialDescriptor& a,
+         const device::PublicKeyCredentialDescriptor& b) {
+        return a.credential_type() < b.credential_type() ||
+               (a.credential_type() == b.credential_type() && a.id() < b.id());
+      };
+  std::set<device::PublicKeyCredentialDescriptor,
+           decltype(credential_descriptor_compare_without_transport)>
+      unique_credential_descriptors(
+          credential_descriptor_compare_without_transport);
+  for (const auto& credential_descriptor : *list) {
+    auto it = unique_credential_descriptors.find(credential_descriptor);
+    if (it == unique_credential_descriptors.end()) {
+      unique_credential_descriptors.insert(credential_descriptor);
+    } else {
+      // Combine transport hints of descriptors with identical IDs. Empty
+      // transport list means _any_ transport, so the union should still be
+      // empty.
+      base::flat_set<device::FidoTransportProtocol> merged_transports;
+      if (!it->transports().empty() &&
+          !credential_descriptor.transports().empty()) {
+        base::ranges::set_union(
+            it->transports(), credential_descriptor.transports(),
+            std::inserter(merged_transports, merged_transports.begin()));
+      }
+      unique_credential_descriptors.erase(it);
+      unique_credential_descriptors.insert(
+          {credential_descriptor.credential_type(), credential_descriptor.id(),
+           std::move(merged_transports)});
+    }
+  }
+  *list = {unique_credential_descriptors.begin(),
+           unique_credential_descriptors.end()};
+  return true;
+}
+
 }  // namespace content
diff --git a/content/browser/webauth/webauth_request_security_checker.h b/content/browser/webauth/webauth_request_security_checker.h
index d1cb8f730e..9e26ed2524 100644
--- a/content/browser/webauth/webauth_request_security_checker.h
+++ b/content/browser/webauth/webauth_request_security_checker.h
@@ -10,6 +10,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/optional.h"
 #include "content/common/content_export.h"
+#include "device/fido/public_key_credential_descriptor.h"
 #include "third_party/blink/public/mojom/webauthn/authenticator.mojom.h"
 
 namespace url {
@@ -71,6 +72,10 @@ class CONTENT_EXPORT WebAuthRequestSecurityChecker
   blink::mojom::AuthenticatorStatus ValidateAPrioriAuthenticatedUrl(
       const GURL& url);
 
+  bool DeduplicateCredentialDescriptorListAndValidateLength(
+      std::vector<device::PublicKeyCredentialDescriptor>* list)
+      WARN_UNUSED_RESULT;
+
  protected:
   friend class RefCounted<WebAuthRequestSecurityChecker>;
   virtual ~WebAuthRequestSecurityChecker();
diff --git a/content/public/browser/background_fetch_delegate.h b/content/public/browser/background_fetch_delegate.h
index 09436ef773..02e1255480 100644
--- a/content/public/browser/background_fetch_delegate.h
+++ b/content/public/browser/background_fetch_delegate.h
@@ -16,6 +16,7 @@
 #include "base/optional.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/web_contents.h"
+#include "services/network/public/mojom/fetch_api.mojom-shared.h"
 #include "third_party/blink/public/mojom/background_fetch/background_fetch.mojom.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 
@@ -140,6 +141,7 @@ class CONTENT_EXPORT BackgroundFetchDelegate {
       const std::string& download_guid,
       const std::string& method,
       const GURL& url,
+      ::network::mojom::CredentialsMode credentials_mode,
       const net::NetworkTrafficAnnotationTag& traffic_annotation,
       const net::HttpRequestHeaders& headers,
       bool has_request_body) = 0;
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index f2f81b235f..b4ae72f795 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1718,10 +1718,12 @@ class CONTENT_EXPORT ContentBrowserClient {
   // Otherwise child_id will be the process id and |navigation_ui_data| will be
   // nullptr.
   //
-  // |initiating_origin| is the origin that initiated the navigation to the
-  // external protocol, and may be null, e.g. in the case of browser-initiated
-  // navigations. The initiating origin is intended to help users make security
-  // decisions about whether to allow an external application to launch.
+  // |initiating_origin| is the origin of the last redirecting server (falling
+  // back to the request initiator if there were no redirects / if the request
+  // goes straight to an external protocol, or null, e.g. in the case of
+  // browser-initiated navigations. The initiating origin is intended to help
+  // users make security decisions about whether to allow an external
+  // application to launch.
   virtual bool HandleExternalProtocol(
       const GURL& url,
       base::OnceCallback<WebContents*()> web_contents_getter,
diff --git a/content/public/common/content_features.cc b/content/public/common/content_features.cc
index 3e6645553b..b07486bc45 100644
--- a/content/public/common/content_features.cc
+++ b/content/public/common/content_features.cc
@@ -649,7 +649,7 @@ const base::Feature kServiceWorkerTerminationOnNoControllee{
 // isolated renderers.
 const base::Feature kSharedArrayBuffer {
   "SharedArrayBuffer",
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       base::FEATURE_DISABLED_BY_DEFAULT
 #else
       base::FEATURE_ENABLED_BY_DEFAULT
@@ -814,7 +814,7 @@ const base::Feature kWebAssemblyTiering{"WebAssemblyTiering",
 // isolated renderers.
 const base::Feature kWebAssemblyThreads {
   "WebAssemblyThreads",
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       base::FEATURE_DISABLED_BY_DEFAULT
 #else
       base::FEATURE_ENABLED_BY_DEFAULT
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index f543db60a3..61ccb23398 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -973,6 +973,7 @@ const char kEnableSpeechDispatcher[] = "enable-speech-dispatcher";
 
 #if defined(OS_OHOS)
 const char kEnableMultiRendererProcess[] = "enable-multi-renderer-process";
+const char kForTest[] = "for-test";
 #endif
 
 #if defined(OS_WIN)
diff --git a/content/public/common/content_switches.h b/content/public/common/content_switches.h
index 31d0a72c4b..deb45f55a2 100644
--- a/content/public/common/content_switches.h
+++ b/content/public/common/content_switches.h
@@ -267,6 +267,7 @@ CONTENT_EXPORT extern const char kRendererWaitForJavaDebugger[];
 // of lacros-chrome is complete.
 #if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 CONTENT_EXPORT extern const char kEnableSpeechDispatcher[];
+CONTENT_EXPORT extern const char kForTest[];
 #endif
 
 #if defined(OS_OHOS)
diff --git a/content/public/test/fake_download_item.cc b/content/public/test/fake_download_item.cc
index 5cd2ba5ff4..5bc7cc74f4 100644
--- a/content/public/test/fake_download_item.cc
+++ b/content/public/test/fake_download_item.cc
@@ -207,6 +207,15 @@ FakeDownloadItem::GetDownloadSchedule() const {
   return download_schedule_;
 }
 
+::network::mojom::CredentialsMode FakeDownloadItem::GetCredentialsMode() const {
+  return ::network::mojom::CredentialsMode::kInclude;
+}
+
+const absl::optional<net::IsolationInfo>& FakeDownloadItem::GetIsolationInfo()
+    const {
+  return isolation_info_;
+}
+
 void FakeDownloadItem::SetIsDone(bool is_done) {
   is_done_ = is_done;
 }
diff --git a/content/public/test/fake_download_item.h b/content/public/test/fake_download_item.h
index 7d6bb806ca..caa7ebc255 100644
--- a/content/public/test/fake_download_item.h
+++ b/content/public/test/fake_download_item.h
@@ -59,6 +59,8 @@ class FakeDownloadItem : public download::DownloadItem {
   DownloadCreationType GetDownloadCreationType() const override;
   const base::Optional<download::DownloadSchedule>& GetDownloadSchedule()
       const override;
+  ::network::mojom::CredentialsMode GetCredentialsMode() const override;
+  const absl::optional<net::IsolationInfo>& GetIsolationInfo() const override;
   bool IsDone() const override;
   const std::string& GetETag() const override;
   const std::string& GetLastModifiedTime() const override;
@@ -186,6 +188,7 @@ class FakeDownloadItem : public download::DownloadItem {
   std::string last_modified_time_;
   std::string hash_;
   base::Optional<download::DownloadSchedule> download_schedule_;
+  absl::optional<net::IsolationInfo> isolation_info_;
 
   // The members below are to be returned by methods, which return by reference.
   std::string dummy_string;
diff --git a/content/renderer/BUILD.gn b/content/renderer/BUILD.gn
index dd529be39b..9325b96383 100644
--- a/content/renderer/BUILD.gn
+++ b/content/renderer/BUILD.gn
@@ -19,6 +19,26 @@ if (is_component_build) {
   link_target_type = "static_library"
 }
 
+if (is_ohos) {
+  import("//build/config/ohos/config.gni")
+  config("ohos_system_libs") {
+    libs = [
+      "hilog",
+      "utils.z",
+      "eventhandler.z",
+      "app_manager.z",
+      "base.z",
+      "want.z",
+      "appexecfwk_common.z",
+      "appexecfwk_base.z",
+      "samgr_proxy.z",
+      "ipc_core.z",
+    ]
+    include_dirs = ohos_src_includes
+    lib_dirs = ohos_libs_dir
+  }
+}
+
 target(link_target_type, "renderer") {
   # Only the public target should depend on this. All other targets (even
   # internal content ones) should depend on the public one.
@@ -216,11 +236,14 @@ target(link_target_type, "renderer") {
   }
 
   if (is_ohos) {
+    configs += [ ":ohos_system_libs" ]
     sources += [
       "media/ohos/ohos_media_player_renderer_client.cc",
       "media/ohos/ohos_media_player_renderer_client.h",
       "media/ohos/ohos_media_player_renderer_client_factory.cc",
       "media/ohos/ohos_media_player_renderer_client_factory.h",
+      "render_remote_proxy.h",
+      "render_remote_proxy.cc",
     ]
   }
 
diff --git a/content/renderer/media/ohos/ohos_media_player_renderer_client.cc b/content/renderer/media/ohos/ohos_media_player_renderer_client.cc
index 4f2b9c1043..666e08857c 100644
--- a/content/renderer/media/ohos/ohos_media_player_renderer_client.cc
+++ b/content/renderer/media/ohos/ohos_media_player_renderer_client.cc
@@ -8,6 +8,8 @@
 #include <sys/stat.h>
 #include <utility>
 
+#include <display_type.h>
+#include <cerrno>
 #include "base/logging.h"
 #include "media/base/video_frame.h"
 
@@ -30,7 +32,7 @@ OHOSMediaPlayerRendererClient::OHOSMediaPlayerRendererClient(
 
 OHOSMediaPlayerRendererClient::~OHOSMediaPlayerRendererClient() {
   while (!cached_buffers_.empty()) {
-    CachedBuffer &temp_buffer = cached_buffers_.front();
+    CachedBuffer& temp_buffer = cached_buffers_.front();
     munmap(temp_buffer.mapped_, temp_buffer.buffer_size_);
     close(temp_buffer.fd_);
     cached_buffers_.pop_front();
@@ -73,7 +75,7 @@ void OHOSMediaPlayerRendererClient::OnFinishPaintCallback() {
     return;
   }
   if (cached_buffers_.size() > 1) {
-    CachedBuffer &temp_buffer = cached_buffers_.front();
+    CachedBuffer& temp_buffer = cached_buffers_.front();
     munmap(temp_buffer.mapped_, temp_buffer.buffer_size_);
     close(temp_buffer.fd_);
     renderer_extension_remote_->FinishPaint(temp_buffer.fd_browser_);
@@ -120,21 +122,69 @@ void OHOSMediaPlayerRendererClient::OnFrameUpdate(
   auto fd = ohos_surface_buffer_handle->buffer_fd.TakeFD().release();
   uint32_t buffer_size = ohos_surface_buffer_handle->buffer_size;
   int fd_browser = ohos_surface_buffer_handle->fd_browser;
-  int32_t width = ohos_surface_buffer_handle->width;
-  int32_t height = ohos_surface_buffer_handle->height;
-
+  int32_t coded_width = ohos_surface_buffer_handle->coded_width;
+  int32_t coded_height = ohos_surface_buffer_handle->coded_height;
+  int32_t visible_width = ohos_surface_buffer_handle->visible_width;
+  int32_t visible_height = ohos_surface_buffer_handle->visible_height;
+  int32_t src_format = ohos_surface_buffer_handle->format;
+  errno = 0;
   uint8_t* mapped =
       (uint8_t*)mmap(NULL, buffer_size, PROT_READ, MAP_SHARED, fd, 0);
+  int temp_errno = errno;
+  if (temp_errno != 0) {
+    LOG(ERROR) << "Render client map failed err:" << temp_errno
+               << " coded_width:" << coded_width
+               << " coded_height:" << coded_height
+               << " visible_width:" << visible_width
+               << " visible_height:" << visible_height
+               << " mmap:" << (void*)mapped
+               << " fd:" << fd
+               << " format:" << src_format << " size:" << buffer_size;
+  }
+  gfx::Size coded_size = gfx::Size(coded_width, coded_height);
+  gfx::Rect visible_rect = gfx::Rect(0, 0, visible_width, visible_height);
+  gfx::Size natural_size = gfx::Size(visible_width, visible_height);
   const base::TimeDelta kZero;
+  if (src_format == PIXEL_FMT_YCBCR_420_SP) {
+    PaintNV12VideoFrame(coded_size, visible_rect, natural_size, mapped,
+                        buffer_size, fd, fd_browser);
+  } else {
+    scoped_refptr<media::VideoFrame> dst_frame =
+        media::VideoFrame::WrapExternalData(
+            media::VideoPixelFormat::PIXEL_FORMAT_ABGR, coded_size,
+            visible_rect, natural_size, mapped, buffer_size, kZero);
+    sink_->PaintSingleFrame(std::move(dst_frame));
+    cached_buffers_.push_back(
+        CachedBuffer{fd_browser, fd, mapped, buffer_size});
+  }
+}
 
-  media::VideoPixelFormat format = media::VideoPixelFormat::PIXEL_FORMAT_ABGR;
-  gfx::Size size = gfx::Size(width, height);
-  scoped_refptr<media::VideoFrame> frame = media::VideoFrame::WrapExternalData(
-      format, size, gfx::Rect(size), size, mapped, buffer_size, kZero);
-
-  auto unique_frame = media::VideoFrame::WrapVideoFrame(
-      frame, frame->format(), frame->visible_rect(), frame->natural_size());
-  sink_->PaintSingleFrame(std::move(unique_frame));
+void OHOSMediaPlayerRendererClient::PaintNV12VideoFrame(
+    const gfx::Size& coded_size,
+    const gfx::Rect& visible_rect,
+    const gfx::Size& natural_size,
+    uint8_t* mapped,
+    const uint32_t& buffer_size,
+    const int& fd,
+    const int& fd_browser) {
+  const base::TimeDelta kZero;
+  scoped_refptr<media::VideoFrame> src_frame =
+      media::VideoFrame::WrapExternalData(
+          media::VideoPixelFormat::PIXEL_FORMAT_NV12, coded_size, visible_rect,
+          natural_size, mapped, buffer_size, kZero);
+  scoped_refptr<media::VideoFrame> dst_frame = media::VideoFrame::CreateFrame(
+      media::VideoPixelFormat::PIXEL_FORMAT_I420, coded_size, visible_rect,
+      natural_size, src_frame->timestamp());
+  auto convert_status =
+      media::ConvertAndScaleFrame(*src_frame, *dst_frame, resize_buf_);
+  if (!convert_status.is_ok()) {
+    LOG(ERROR) << "Convert failed msg:" << convert_status.message();
+    munmap(mapped, buffer_size);
+    close(fd);
+    renderer_extension_remote_->FinishPaint(fd_browser);
+    return;
+  }
+  sink_->PaintSingleFrame(std::move(dst_frame));
   cached_buffers_.push_back(CachedBuffer{fd_browser, fd, mapped, buffer_size});
 }
 
diff --git a/content/renderer/media/ohos/ohos_media_player_renderer_client.h b/content/renderer/media/ohos/ohos_media_player_renderer_client.h
index 8f1f6cf0da..040f39fc9f 100644
--- a/content/renderer/media/ohos/ohos_media_player_renderer_client.h
+++ b/content/renderer/media/ohos/ohos_media_player_renderer_client.h
@@ -16,6 +16,7 @@
 #include "media/base/renderer.h"
 #include "media/base/renderer_client.h"
 #include "media/base/video_renderer_sink.h"
+#include "media/base/video_util.h"
 #include "media/mojo/clients/mojo_renderer.h"
 #include "media/mojo/clients/mojo_renderer_wrapper.h"
 #include "media/mojo/mojom/renderer_extensions.mojom.h"
@@ -62,6 +63,14 @@ class OHOSMediaPlayerRendererClient
   void OnRemoteRendererInitialized(media::PipelineStatus status);
   void OnFinishPaintCallback();
 
+  void PaintNV12VideoFrame(const gfx::Size& coded_size,
+                           const gfx::Rect& visible_rect,
+                           const gfx::Size& natural_size,
+                           uint8_t* mapped,
+                           const uint32_t& buffer_size,
+                           const int& fd,
+                           const int& fd_browser);
+
   media::MediaResource* media_resource_;
 
   std::deque<CachedBuffer> cached_buffers_;
@@ -74,6 +83,8 @@ class OHOSMediaPlayerRendererClient
 
   media::PipelineStatusCallback init_cb_;
 
+  std::vector<uint8_t> resize_buf_;
+
   // This class is constructed on the main task runner, and used on
   // |media_task_runner_|. These member are used to delay calls to Bind() for
   // |renderer_extension_ptr_| and |client_extension_binding_|, until we are on
diff --git a/content/renderer/render_remote_proxy.cc b/content/renderer/render_remote_proxy.cc
new file mode 100644
index 0000000000..2fada4e83b
--- /dev/null
+++ b/content/renderer/render_remote_proxy.cc
@@ -0,0 +1,78 @@
+// Copyright 2022 The Huawei Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "render_remote_proxy.h"
+
+#include <thread>
+#include "appmgr/app_mgr_client.h"
+#include "base/command_line.h"
+#include "base/posix/global_descriptors.h"
+#include "content/public/common/content_descriptors.h"
+#include "content/public/common/content_switches.h"
+#include "refbase.h"
+
+namespace content {
+std::unique_ptr<OHOS::AppExecFwk::AppMgrClient> g_app_mgr_client{nullptr};
+OHOS::sptr<RenderRemoteProxy> g_render_remote_proxy{nullptr};
+
+std::mutex RenderRemoteProxy::browser_fd_mtx_;
+std::condition_variable RenderRemoteProxy::browser_fd_cv_;
+bool RenderRemoteProxy::is_browser_fd_received_{false};
+bool RenderRemoteProxy::is_for_test_{false};
+
+void RenderRemoteProxy::NotifyBrowserFd(int32_t ipcFd, int32_t sharedFd) {
+  base::GlobalDescriptors* g_fds = base::GlobalDescriptors::GetInstance();
+  if (g_fds != nullptr) {
+    int new_ipc_fd;
+    if ((new_ipc_fd = dup(ipcFd)) < 0) {
+      LOG(ERROR) << "ipcFd duplicate error";
+      g_fds->Set(kMojoIPCChannel, ipcFd);
+      ipc_fd_ = ipcFd;
+    } else {
+      g_fds->Set(kMojoIPCChannel, new_ipc_fd);
+      ipc_fd_ = new_ipc_fd;
+      close(ipcFd);
+    }
+
+    int new_shared_fd;
+    if ((new_shared_fd = dup(sharedFd)) < 0) {
+      LOG(ERROR) << "sharedFd duplicate error";
+      g_fds->Set(kFieldTrialDescriptor, sharedFd);
+      shared_fd_ = sharedFd;
+    } else {
+      g_fds->Set(kFieldTrialDescriptor, new_shared_fd);
+      shared_fd_ = new_shared_fd;
+      close(sharedFd);
+    }
+  }
+  RenderRemoteProxy::is_browser_fd_received_ = true;
+  RenderRemoteProxy::browser_fd_cv_.notify_one();
+}
+
+void RenderRemoteProxy::CreateAndRegist(const base::CommandLine& command_line) {
+  is_for_test_ = command_line.HasSwitch(switches::kForTest);
+  if (!is_for_test_) {
+    g_app_mgr_client = std::make_unique<OHOS::AppExecFwk::AppMgrClient>();
+    g_render_remote_proxy = new RenderRemoteProxy();
+    g_app_mgr_client->AttachRenderProcess(g_render_remote_proxy);
+  }
+}
+
+bool RenderRemoteProxy::WaitForBrowserFd() {
+  if (is_for_test_) {
+    return true;
+  }
+  LOG(INFO) << "wait for browser fd start";
+  std::unique_lock<std::mutex> lk(browser_fd_mtx_);
+  constexpr int kTimeOutDur = 5;  // seconds
+  if (!browser_fd_cv_.wait_for(lk, std::chrono::seconds(kTimeOutDur),
+                               []() { return is_browser_fd_received_; })) {
+    LOG(ERROR) << "wait for browser fd timeout(" << kTimeOutDur << "s)";
+    return false;
+  }
+  LOG(INFO) << "wait for browser fd end";
+  return true;
+}
+
+} // namespace content
\ No newline at end of file
diff --git a/content/renderer/render_remote_proxy.h b/content/renderer/render_remote_proxy.h
new file mode 100644
index 0000000000..1127280fbf
--- /dev/null
+++ b/content/renderer/render_remote_proxy.h
@@ -0,0 +1,39 @@
+// Copyright 2022 The Huawei Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_RENDERER_RENDER_REMOTE_PROXY_H_
+#define CONTENT_RENDERER_RENDER_REMOTE_PROXY_H_
+
+#include <condition_variable>
+#include <mutex>
+#include "appmgr/render_scheduler_host.h"
+
+namespace base {
+class CommandLine;
+}
+
+namespace content {
+class RenderRemoteProxy : public OHOS::AppExecFwk::RenderSchedulerHost {
+ public:
+  RenderRemoteProxy() = default;
+  ~RenderRemoteProxy() = default;
+
+  virtual void NotifyBrowserFd(int32_t ipcFd, int32_t sharedFd) override;
+
+  static void CreateAndRegist(const base::CommandLine& command_line);
+  static bool WaitForBrowserFd();
+
+ private:
+  int32_t ipc_fd_ = 0;
+  int32_t shared_fd_ = 0;
+
+  static std::mutex browser_fd_mtx_;
+  static std::condition_variable browser_fd_cv_;
+  static bool is_browser_fd_received_;
+  static bool is_for_test_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_RENDERER_RENDER_REMOTE_PROXY_H_
\ No newline at end of file
diff --git a/content/renderer/service_worker/navigation_preload_request.cc b/content/renderer/service_worker/navigation_preload_request.cc
index 231e947e15..0e8d77666e 100644
--- a/content/renderer/service_worker/navigation_preload_request.cc
+++ b/content/renderer/service_worker/navigation_preload_request.cc
@@ -17,12 +17,12 @@ NavigationPreloadRequest::NavigationPreloadRequest(
     ServiceWorkerContextClient* owner,
     int fetch_event_id,
     const GURL& url,
-    blink::mojom::FetchEventPreloadHandlePtr preload_handle)
+    mojo::PendingReceiver<network::mojom::URLLoaderClient>
+        preload_url_loader_client_receiver)
     : owner_(owner),
       fetch_event_id_(fetch_event_id),
       url_(url),
-      url_loader_(std::move(preload_handle->url_loader)),
-      receiver_(this, std::move(preload_handle->url_loader_client_receiver)) {}
+      receiver_(this, std::move(preload_url_loader_client_receiver)) {}
 
 NavigationPreloadRequest::~NavigationPreloadRequest() = default;
 
diff --git a/content/renderer/service_worker/navigation_preload_request.h b/content/renderer/service_worker/navigation_preload_request.h
index 639cc6f086..fc9c5c66b4 100644
--- a/content/renderer/service_worker/navigation_preload_request.h
+++ b/content/renderer/service_worker/navigation_preload_request.h
@@ -34,7 +34,8 @@ class NavigationPreloadRequest final : public network::mojom::URLLoaderClient {
       ServiceWorkerContextClient* owner,
       int fetch_event_id,
       const GURL& url,
-      blink::mojom::FetchEventPreloadHandlePtr preload_handle);
+      mojo::PendingReceiver<network::mojom::URLLoaderClient>
+          preload_url_loader_client_receiver);
   ~NavigationPreloadRequest() override;
 
   // network::mojom::URLLoaderClient:
@@ -58,11 +59,10 @@ class NavigationPreloadRequest final : public network::mojom::URLLoaderClient {
   void ReportErrorToOwner(const std::string& message,
                           blink::WebServiceWorkerError::Mode error_mode);
 
-  ServiceWorkerContextClient* owner_;
+  ServiceWorkerContextClient* owner_ = nullptr;
 
-  const int fetch_event_id_;
+  const int fetch_event_id_ = -1;
   const GURL url_;
-  mojo::Remote<network::mojom::URLLoader> url_loader_;
   mojo::Receiver<network::mojom::URLLoaderClient> receiver_;
 
   std::unique_ptr<blink::WebURLResponse> response_;
diff --git a/content/renderer/service_worker/service_worker_context_client.cc b/content/renderer/service_worker/service_worker_context_client.cc
index 79334c2ebf..9a1e9a6594 100644
--- a/content/renderer/service_worker/service_worker_context_client.cc
+++ b/content/renderer/service_worker/service_worker_context_client.cc
@@ -475,14 +475,14 @@ void ServiceWorkerContextClient::SendWorkerStarted(
 void ServiceWorkerContextClient::SetupNavigationPreload(
     int fetch_event_id,
     const blink::WebURL& url,
-    std::unique_ptr<blink::WebFetchEventPreloadHandle> preload_handle) {
+    blink::CrossVariantMojoReceiver<
+        network::mojom::URLLoaderClientInterfaceBase>
+        preload_url_loader_client_receiver) {
   DCHECK(worker_task_runner_->RunsTasksInCurrentSequence());
   DCHECK(context_);
   auto preload_request = std::make_unique<NavigationPreloadRequest>(
       this, fetch_event_id, GURL(url),
-      blink::mojom::FetchEventPreloadHandle::New(
-          std::move(preload_handle->url_loader),
-          std::move(preload_handle->url_loader_client_receiver)));
+      std::move(preload_url_loader_client_receiver));
   context_->preload_requests.AddWithID(std::move(preload_request),
                                        fetch_event_id);
 }
diff --git a/content/renderer/service_worker/service_worker_context_client.h b/content/renderer/service_worker/service_worker_context_client.h
index 8191aaec6e..5abd533c6c 100644
--- a/content/renderer/service_worker/service_worker_context_client.h
+++ b/content/renderer/service_worker/service_worker_context_client.h
@@ -159,8 +159,9 @@ class CONTENT_EXPORT ServiceWorkerContextClient
                             const blink::WebString& source_url) override;
   void SetupNavigationPreload(int fetch_event_id,
                               const blink::WebURL& url,
-                              std::unique_ptr<blink::WebFetchEventPreloadHandle>
-                                  preload_handle) override;
+                              blink::CrossVariantMojoReceiver<
+                                  network::mojom::URLLoaderClientInterfaceBase>
+                                  preload_url_loader_client_receiver) override;
   void RequestTermination(RequestTerminationCallback callback) override;
   scoped_refptr<blink::WebServiceWorkerFetchContext>
   CreateWorkerFetchContextOnInitiatorThread() override;
diff --git a/content/test/data/gpu/webgpu-stress-request-device-and-remove-loop.html b/content/test/data/gpu/webgpu-stress-request-device-and-remove-loop.html
new file mode 100644
index 0000000000..715688a634
--- /dev/null
+++ b/content/test/data/gpu/webgpu-stress-request-device-and-remove-loop.html
@@ -0,0 +1,58 @@
+<!--
+  This is a stress test for crbug.com/1242269.
+  In the bug, a flaky use-after-free could happen depending on the ordering of
+  the Javascript ExecutionContext ContextDestroyed notification and GC finalization
+  of the GPUDevice in the page. Repeatingly creating an iframe, initializing a GPUDevice,
+  and then destroying the iframe can sometimes hit this and crash. This test does this
+  repeatedly with many iframes at once for 90 seconds.
+-->
+<head>
+  <script>
+    const iframes = [];
+    function removeOneIframe() {
+      setTimeout(function () {
+        document.body.removeChild(iframes.shift());
+      }, Math.random() * 500);
+    }
+
+    async function run() {
+      if (window.domAutomationController) {
+        window.domAutomationController.send('LOADED');
+        setTimeout(() => {
+          // Succeed if don't crash within 90 seconds.
+          window.domAutomationController.send('SUCCESS');
+        }, 90 * 1000);
+      }
+
+      while (true) {
+        const iframe = document.createElement("iframe");
+        iframe.setAttribute("id", "iframe");
+        document.body.appendChild(iframe);
+
+        iframes.push(iframe);
+
+        const head = iframe.contentWindow.document.getElementsByTagName('head')[0];
+        const script = iframe.contentWindow.document.createElement('script');
+        script.type = 'text/javascript';
+        script.innerText = `
+          navigator.gpu.requestAdapter().then((adapter) => {
+            adapter.requestDevice().then((val) => {
+              parent.removeOneIframe();
+            });
+          });
+        `;
+        head.appendChild(script);
+
+        // Wait a bit to yield to the event loop.
+        await new Promise(resolve => setTimeout(resolve, 0));
+
+        // Avoid having too many iframes in flight.
+        while (iframes.length > 100) {
+          await new Promise(resolve => setTimeout(resolve, 100));
+        }
+      }
+    }
+  </script>
+</head>
+
+<body onload="run()"></body>
diff --git a/content/test/gpu/gpu_tests/context_lost_integration_test.py b/content/test/gpu/gpu_tests/context_lost_integration_test.py
index 6a3d4717c7..9096205323 100644
--- a/content/test/gpu/gpu_tests/context_lost_integration_test.py
+++ b/content/test/gpu/gpu_tests/context_lost_integration_test.py
@@ -148,6 +148,8 @@ class ContextLostIntegrationTest(gpu_integration_test.GpuIntegrationTest):
               'gpu_process_crash.html'),
              ('ContextLost_WebGPUContextLostFromGPUProcessExit',
               'webgpu-context-lost.html?query=kill_after_notification'),
+             ('ContextLost_WebGPUStressRequestDeviceAndRemoveLoop',
+              'webgpu-stress-request-device-and-remove-loop.html'),
              ('ContextLost_WebGLContextLostFromGPUProcessExit',
               'webgl.html?query=kill_after_notification'),
              ('ContextLost_WebGLContextLostFromLoseContextExtension',
@@ -339,6 +341,15 @@ class ContextLostIntegrationTest(gpu_integration_test.GpuIntegrationTest):
     self._KillGPUProcess(1, False, timeout=180)
     self._RestartBrowser('must restart after tests that kill the GPU process')
 
+  def _ContextLost_WebGPUStressRequestDeviceAndRemoveLoop(self, test_path):
+    self.RestartBrowserIfNecessaryWithArgs([
+        '--enable-unsafe-webgpu',
+    ])
+    self._NavigateAndWaitForLoad(test_path)
+
+    # Test runs for 90 seconds; wait for 120 seconds.
+    self._WaitForTabAndCheckCompletion(timeout=120000)
+
   def _ContextLost_WebGLContextLostFromLoseContextExtension(self, test_path):
     self.RestartBrowserIfNecessaryWithArgs(
         [cba.DISABLE_DOMAIN_BLOCKING_FOR_3D_APIS])
diff --git a/content/web_test/browser/web_test_background_fetch_delegate.cc b/content/web_test/browser/web_test_background_fetch_delegate.cc
index c26c3bd236..befa7f1b50 100644
--- a/content/web_test/browser/web_test_background_fetch_delegate.cc
+++ b/content/web_test/browser/web_test_background_fetch_delegate.cc
@@ -293,6 +293,7 @@ void WebTestBackgroundFetchDelegate::DownloadUrl(
     const std::string& download_guid,
     const std::string& method,
     const GURL& url,
+    ::network::mojom::CredentialsMode credentials_mode,
     const net::NetworkTrafficAnnotationTag& traffic_annotation,
     const net::HttpRequestHeaders& headers,
     bool has_request_body) {
diff --git a/content/web_test/browser/web_test_background_fetch_delegate.h b/content/web_test/browser/web_test_background_fetch_delegate.h
index e307e86e32..106df11659 100644
--- a/content/web_test/browser/web_test_background_fetch_delegate.h
+++ b/content/web_test/browser/web_test_background_fetch_delegate.h
@@ -39,6 +39,7 @@ class WebTestBackgroundFetchDelegate : public BackgroundFetchDelegate {
                    const std::string& download_guid,
                    const std::string& method,
                    const GURL& url,
+                   ::network::mojom::CredentialsMode credentials_mode,
                    const net::NetworkTrafficAnnotationTag& traffic_annotation,
                    const net::HttpRequestHeaders& headers,
                    bool has_request_body) override;
diff --git a/device/fido/public_key_credential_descriptor.cc b/device/fido/public_key_credential_descriptor.cc
index 5c0328f855..bcda0c7659 100644
--- a/device/fido/public_key_credential_descriptor.cc
+++ b/device/fido/public_key_credential_descriptor.cc
@@ -4,6 +4,7 @@
 
 #include <utility>
 
+#include "device/fido/fido_transport_protocol.h"
 #include "device/fido/public_key_credential_descriptor.h"
 
 namespace device {
@@ -13,6 +14,7 @@ namespace {
 // Keys for storing credential descriptor information in CBOR map.
 constexpr char kCredentialIdKey[] = "id";
 constexpr char kCredentialTypeKey[] = "type";
+constexpr char kTransportsKey[] = "transports";
 
 }  // namespace
 
@@ -33,8 +35,29 @@ PublicKeyCredentialDescriptor::CreateFromCBORValue(const cbor::Value& cbor) {
   if (id == map.end() || !id->second.is_bytestring())
     return base::nullopt;
 
+  auto transports_it = map.find(cbor::Value(kTransportsKey));
+  if (transports_it == map.end())
+    return PublicKeyCredentialDescriptor(CredentialType::kPublicKey,
+                                         id->second.GetBytestring());
+
+  if (!transports_it->second.is_array())
+    return base::nullopt;
+
+  base::flat_set<FidoTransportProtocol> transports;
+  for (const cbor::Value& transport_name : transports_it->second.GetArray()) {
+    if (!transport_name.is_string()) {
+      return base::nullopt;
+    }
+    base::Optional<FidoTransportProtocol> transport =
+        ConvertToFidoTransportProtocol(transport_name.GetString());
+    if (!transport) {
+      continue;
+    }
+    transports.insert(*transport);
+  }
   return PublicKeyCredentialDescriptor(CredentialType::kPublicKey,
-                                       id->second.GetBytestring());
+                                       id->second.GetBytestring(),
+                                       std::move(transports));
 }
 
 PublicKeyCredentialDescriptor::PublicKeyCredentialDescriptor() = default;
@@ -42,14 +65,7 @@ PublicKeyCredentialDescriptor::PublicKeyCredentialDescriptor() = default;
 PublicKeyCredentialDescriptor::PublicKeyCredentialDescriptor(
     CredentialType credential_type,
     std::vector<uint8_t> id)
-    : PublicKeyCredentialDescriptor(
-          credential_type,
-          std::move(id),
-          {FidoTransportProtocol::kUsbHumanInterfaceDevice,
-           FidoTransportProtocol::kBluetoothLowEnergy,
-           FidoTransportProtocol::kNearFieldCommunication,
-           FidoTransportProtocol::kCloudAssistedBluetoothLowEnergy,
-           FidoTransportProtocol::kInternal}) {}
+    : PublicKeyCredentialDescriptor(credential_type, std::move(id), {}) {}
 
 PublicKeyCredentialDescriptor::PublicKeyCredentialDescriptor(
     CredentialType credential_type,
@@ -84,6 +100,14 @@ cbor::Value AsCBOR(const PublicKeyCredentialDescriptor& desc) {
   cbor_descriptor_map[cbor::Value(kCredentialIdKey)] = cbor::Value(desc.id());
   cbor_descriptor_map[cbor::Value(kCredentialTypeKey)] =
       cbor::Value(CredentialTypeToString(desc.credential_type()));
+  std::vector<cbor::Value> transports;
+  for (FidoTransportProtocol transport : desc.transports()) {
+    transports.emplace_back(cbor::Value(ToString(transport)));
+  }
+  if (!transports.empty()) {
+    cbor_descriptor_map[cbor::Value(kTransportsKey)] =
+        cbor::Value(std::move(transports));
+  }
   return cbor::Value(std::move(cbor_descriptor_map));
 }
 
diff --git a/device/fido/virtual_ctap2_device.cc b/device/fido/virtual_ctap2_device.cc
index e027b8fbc5..d4cd188452 100644
--- a/device/fido/virtual_ctap2_device.cc
+++ b/device/fido/virtual_ctap2_device.cc
@@ -965,6 +965,8 @@ base::Optional<CtapDeviceResponseCode> VirtualCtap2Device::OnMakeCredential(
   }
   CtapMakeCredentialRequest request = std::move(*opt_request);
 
+  mutable_state()->exclude_list_history.push_back(request.exclude_list);
+
   bool user_verified = false;
   const base::Optional<CtapDeviceResponseCode> uv_error = CheckUserVerification(
       /*is_make_credential=*/true, *device_info_, request.rp.id,
@@ -1222,7 +1224,7 @@ base::Optional<CtapDeviceResponseCode> VirtualCtap2Device::OnGetAssertion(
   }
   CtapGetAssertionRequest request = std::move(*opt_request);
 
-  mutable_state()->allow_list_sizes.push_back(request.allow_list.size());
+  mutable_state()->allow_list_history.push_back(request.allow_list);
 
   bool user_verified;
   const base::Optional<CtapDeviceResponseCode> uv_error = CheckUserVerification(
diff --git a/device/fido/virtual_fido_device.h b/device/fido/virtual_fido_device.h
index 4526c4786a..7a9aef82d3 100644
--- a/device/fido/virtual_fido_device.h
+++ b/device/fido/virtual_fido_device.h
@@ -21,6 +21,7 @@
 #include "device/fido/fido_constants.h"
 #include "device/fido/fido_device.h"
 #include "device/fido/fido_parsing_utils.h"
+#include "device/fido/public_key_credential_descriptor.h"
 #include "device/fido/public_key_credential_rp_entity.h"
 #include "device/fido/public_key_credential_user_entity.h"
 #include "net/cert/x509_util.h"
@@ -234,10 +235,16 @@ class COMPONENT_EXPORT(DEVICE_FIDO) VirtualFidoDevice : public FidoDevice {
     // to return from a previous authenticatorCredentialManagement command.
     std::list<cbor::Value::MapValue> pending_registrations;
 
-    // allow_list_sizes contains the lengths of the allow_lists that have been
-    // seen in assertion requests. This is for tests to confirm that the
-    // expected sequence of requests was sent.
-    std::vector<size_t> allow_list_sizes;
+    // allow_list_history contains the allow_list values that have been seen in
+    // assertion requests. This is for tests to confirm that the expected
+    // sequence of requests was sent.
+    std::vector<std::vector<PublicKeyCredentialDescriptor>> allow_list_history;
+
+    // exclude_list_history contains the exclude_list values that have been seen
+    // in registration requests. This is for tests to confirm that the expected
+    // sequence of requests was sent.
+    std::vector<std::vector<PublicKeyCredentialDescriptor>>
+        exclude_list_history;
 
     // The large-blob array.
     std::vector<uint8_t> large_blob;
diff --git a/device/gamepad/gamepad_monitor.cc b/device/gamepad/gamepad_monitor.cc
index 4a35a61d8b..9e1227f43d 100644
--- a/device/gamepad/gamepad_monitor.cc
+++ b/device/gamepad/gamepad_monitor.cc
@@ -54,6 +54,8 @@ void GamepadMonitor::GamepadStartPolling(GamepadStartPollingCallback callback) {
   GamepadService* service = GamepadService::GetInstance();
   if (!service->ConsumerBecameActive(this)) {
     mojo::ReportBadMessage("GamepadMonitor::GamepadStartPolling failed");
+    std::move(callback).Run(base::ReadOnlySharedMemoryRegion());
+    return;
   }
   std::move(callback).Run(service->DuplicateSharedMemoryRegion());
 }
diff --git a/extensions/browser/api/file_system/file_system_api.cc b/extensions/browser/api/file_system/file_system_api.cc
index 37d1f413ca..f047bc6c48 100644
--- a/extensions/browser/api/file_system/file_system_api.cc
+++ b/extensions/browser/api/file_system/file_system_api.cc
@@ -197,6 +197,9 @@ void PassFileInfoToUIThread(FileInfoOptCallback callback,
 content::WebContents* GetWebContentsForRenderFrameHost(
     content::BrowserContext* browser_context,
     content::RenderFrameHost* render_frame_host) {
+  if (!render_frame_host)
+    return nullptr;
+
   content::WebContents* web_contents =
       content::WebContents::FromRenderFrameHost(render_frame_host);
   // Check if there is an app window associated with the web contents; if not,
@@ -508,15 +511,6 @@ void FileSystemChooseEntryFunction::FilesSelected(
   }
 
   if (is_directory_) {
-    // Get the WebContents for the app window to be the parent window of the
-    // confirmation dialog if necessary.
-    content::WebContents* const web_contents = GetWebContentsForRenderFrameHost(
-        browser_context(), render_frame_host());
-    if (!web_contents) {
-      Respond(Error(kInvalidCallingPage));
-      return;
-    }
-
     DCHECK_EQ(paths.size(), 1u);
     bool non_native_path = false;
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -530,7 +524,7 @@ void FileSystemChooseEntryFunction::FilesSelected(
         FROM_HERE, {base::MayBlock(), base::TaskPriority::BEST_EFFORT},
         base::BindOnce(
             &FileSystemChooseEntryFunction::ConfirmDirectoryAccessAsync, this,
-            non_native_path, paths, web_contents));
+            non_native_path, paths));
     return;
   }
 
@@ -543,8 +537,7 @@ void FileSystemChooseEntryFunction::FileSelectionCanceled() {
 
 void FileSystemChooseEntryFunction::ConfirmDirectoryAccessAsync(
     bool non_native_path,
-    const std::vector<base::FilePath>& paths,
-    content::WebContents* web_contents) {
+    const std::vector<base::FilePath>& paths) {
   const base::FilePath check_path =
       non_native_path ? paths[0] : base::MakeAbsoluteFilePath(paths[0]);
   if (check_path.empty()) {
@@ -576,7 +569,7 @@ void FileSystemChooseEntryFunction::ConfirmDirectoryAccessAsync(
         FROM_HERE,
         base::BindOnce(
             &FileSystemChooseEntryFunction::ConfirmSensitiveDirectoryAccess,
-            this, paths, web_contents));
+            this, paths));
     return;
   }
 
@@ -587,8 +580,7 @@ void FileSystemChooseEntryFunction::ConfirmDirectoryAccessAsync(
 }
 
 void FileSystemChooseEntryFunction::ConfirmSensitiveDirectoryAccess(
-    const std::vector<base::FilePath>& paths,
-    content::WebContents* web_contents) {
+    const std::vector<base::FilePath>& paths) {
   if (ExtensionsBrowserClient::Get()->IsShuttingDown()) {
     FileSelectionCanceled();
     return;
@@ -601,6 +593,13 @@ void FileSystemChooseEntryFunction::ConfirmSensitiveDirectoryAccess(
     return;
   }
 
+  content::WebContents* const web_contents =
+      GetWebContentsForRenderFrameHost(browser_context(), render_frame_host());
+  if (!web_contents) {
+    Respond(Error(kInvalidCallingPage));
+    return;
+  }
+
   delegate->ConfirmSensitiveDirectoryAccess(
       app_file_handler_util::HasFileSystemWritePermission(extension_.get()),
       base::UTF8ToUTF16(extension_->name()), web_contents,
diff --git a/extensions/browser/api/file_system/file_system_api.h b/extensions/browser/api/file_system/file_system_api.h
index ae1588ce85..0895a174a0 100644
--- a/extensions/browser/api/file_system/file_system_api.h
+++ b/extensions/browser/api/file_system/file_system_api.h
@@ -19,10 +19,6 @@
 #include "extensions/common/api/file_system.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-namespace content {
-class WebContents;
-}  // namespace content
-
 namespace extensions {
 class ExtensionPrefs;
 
@@ -168,13 +164,12 @@ class FileSystemChooseEntryFunction : public FileSystemEntryFunction {
   // directory. If so, calls ConfirmSensitiveDirectoryAccess. Otherwise, calls
   // OnDirectoryAccessConfirmed.
   void ConfirmDirectoryAccessAsync(bool non_native_path,
-                                   const std::vector<base::FilePath>& paths,
-                                   content::WebContents* web_contents);
+                                   const std::vector<base::FilePath>& paths);
 
   // Shows a dialog to confirm whether the user wants to open the directory.
   // Calls OnDirectoryAccessConfirmed or FileSelectionCanceled.
-  void ConfirmSensitiveDirectoryAccess(const std::vector<base::FilePath>& paths,
-                                       content::WebContents* web_contents);
+  void ConfirmSensitiveDirectoryAccess(
+      const std::vector<base::FilePath>& paths);
 
   void OnDirectoryAccessConfirmed(const std::vector<base::FilePath>& paths);
 
diff --git a/extensions/renderer/messaging_util.cc b/extensions/renderer/messaging_util.cc
index f6bf874f98..7e9a0f124d 100644
--- a/extensions/renderer/messaging_util.cc
+++ b/extensions/renderer/messaging_util.cc
@@ -124,9 +124,13 @@ std::unique_ptr<Message> MessageFromJSONString(v8::Isolate* isolate,
     return nullptr;
   }
 
-  bool has_transient_user_activation =
-      web_frame ? web_frame->HasTransientUserActivation() : false;
-  return std::make_unique<Message>(message, has_transient_user_activation,
+  // The message should carry user activation information only if the last
+  // activation in |web_frame| was triggered by a real user interaction.  See
+  // |UserActivationState::LastActivationWasRestricted()|.
+  bool has_unrestricted_user_activation =
+      web_frame && web_frame->HasTransientUserActivation() &&
+      !web_frame->LastActivationWasRestricted();
+  return std::make_unique<Message>(message, has_unrestricted_user_activation,
                                    privileged_context);
 }
 
diff --git a/ipc/ipc_mojo_bootstrap.cc b/ipc/ipc_mojo_bootstrap.cc
index 1fc3b955bf..9e22317c68 100644
--- a/ipc/ipc_mojo_bootstrap.cc
+++ b/ipc/ipc_mojo_bootstrap.cc
@@ -931,10 +931,14 @@ class ChannelAssociatedGroupController
     if (!client)
       return;
 
+    if (!endpoint->task_runner()->RunsTasksInCurrentSequence() &&
+        !proxy_task_runner_->RunsTasksInCurrentSequence()) {
+      return;
+    }
+
     // Using client->interface_name() is safe here because this is a static
     // string defined for each mojo interface.
     TRACE_EVENT0("mojom", client->interface_name());
-    DCHECK(endpoint->task_runner()->RunsTasksInCurrentSequence());
 
     // Sync messages should never make their way to this method.
     DCHECK(!message.has_flag(mojo::Message::kFlagIsSync));
@@ -965,10 +969,15 @@ class ChannelAssociatedGroupController
     if (!client)
       return;
 
+    if (!endpoint->task_runner()->RunsTasksInCurrentSequence() &&
+        !proxy_task_runner_->RunsTasksInCurrentSequence()) {
+      return;
+    }
+
     // Using client->interface_name() is safe here because this is a static
     // string defined for each mojo interface.
     TRACE_EVENT0("mojom", client->interface_name());
-    DCHECK(endpoint->task_runner()->RunsTasksInCurrentSequence());
+
     MessageWrapper message_wrapper = endpoint->PopSyncMessage(message_id);
 
     // The message must have already been dequeued by the endpoint waking up
diff --git a/media/base/ohos/ohos_media_player_bridge.cc b/media/base/ohos/ohos_media_player_bridge.cc
index 882a855a4c..e2c6cab24b 100644
--- a/media/base/ohos/ohos_media_player_bridge.cc
+++ b/media/base/ohos/ohos_media_player_bridge.cc
@@ -139,9 +139,9 @@ void OHOSMediaPlayerBridge::FinishPaint(int fd) {
     return;
   }
 
-  if (cached_buffers_.front()->GetBufferHandle()->reserve[0] != fd) {
+  if (cached_buffers_.front()->GetBufferHandle()->fd != fd) {
     LOG(ERROR) << "match fd error render fd=" << fd << "  browser fd="
-               << cached_buffers_.front()->GetBufferHandle()->reserve[0];
+               << cached_buffers_.front()->GetBufferHandle()->fd;
   }
   OHOS::SurfaceError ret =
       consumer_surface_->ReleaseBuffer(cached_buffers_.front(), -1);
@@ -187,9 +187,31 @@ void OHOSMediaPlayerBridge::OnBufferAvailable(
                        weak_factory_.GetWeakPtr(), std::move(buffer)));
     return;
   }
-  client_->OnFrameAvailable(buffer->GetBufferHandle()->reserve[0],
-                            buffer->GetSize(), buffer->GetWidth(),
-                            buffer->GetHeight());
+
+  // int32_t coded_height;
+  // int32_t coded_width;
+
+  // // video frame height must be 32*N
+  // const int step_height = 32;
+  // // argb format video frame should divided by 4
+  // const int argb_stride_step = 4;
+  // if (buffer->GetHeight() % step_height == 0) {
+  //   coded_height = buffer->GetHeight();
+  // } else {
+  //   coded_height = (buffer->GetHeight() / step_height + 1) * step_height;
+  // }
+  // if (buffer->GetFormat() == PIXEL_FMT_RGBA_8888) {
+  //   coded_width = buffer->GetStride() / argb_stride_step;
+  // } else {
+  //   coded_width = buffer->GetStride();
+  // }
+  if (buffer->GetBufferHandle()->fd <= 0) {
+    LOG(ERROR)<<"Unavailble fd frome meidaplayer";
+  }
+  client_->OnFrameAvailable(buffer->GetBufferHandle()->fd,
+                            buffer->GetSize(), buffer->GetWidth(), buffer->GetHeight(),
+                            buffer->GetWidth(), buffer->GetHeight(),
+                            buffer->GetFormat());
   cached_buffers_.push_back(buffer);
 }
 
diff --git a/media/base/ohos/ohos_media_player_bridge.h b/media/base/ohos/ohos_media_player_bridge.h
index 2446a5dec1..631af9c93e 100644
--- a/media/base/ohos/ohos_media_player_bridge.h
+++ b/media/base/ohos/ohos_media_player_bridge.h
@@ -22,8 +22,11 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
    public:
     virtual void OnFrameAvailable(int fd,
                                   uint32_t size,
-                                  int32_t width,
-                                  int32_t height) = 0;
+                                  int32_t coded_width,
+                                  int32_t coded_height,
+                                  int32_t visible_width,
+                                  int32_t visible_height,
+                                  int32_t format) = 0;
 
     // Called when media duration is first detected or changes.
     virtual void OnMediaDurationChanged(base::TimeDelta duration) = 0;
@@ -73,7 +76,6 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
   void OnPlayerStateUpdate(OHOS::Media::PlayerStates player_state);
 
  private:
-
   int32_t SetFdSource(const std::string& path);
 
   const std::string surfaceFormat = "SURFACE_FORMAT";
diff --git a/media/base/ohos/ohos_media_player_listener.cc b/media/base/ohos/ohos_media_player_listener.cc
index bb08070c17..5e2e5db877 100644
--- a/media/base/ohos/ohos_media_player_listener.cc
+++ b/media/base/ohos/ohos_media_player_listener.cc
@@ -4,6 +4,7 @@
 
 #include "media/base/ohos/ohos_media_player_listener.h"
 
+#include <display_type.h>
 namespace media {
 
 OHOSMediaPlayerListener::OHOSMediaPlayerListener(
@@ -32,9 +33,16 @@ void OHOSMediaPlayerListener::OnBufferAvailable() {
     LOG(ERROR) << "acquire buffer fail, ret=" << ret;
     return;
   }
-  task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&OHOSMediaPlayerBridge::OnBufferAvailable,
-                                media_player_, buffer));
+
+  if (buffer->GetFormat() == PIXEL_FMT_RGBA_8888 ||
+      buffer->GetFormat() == PIXEL_FMT_YCBCR_420_SP) {
+    task_runner_->PostTask(
+        FROM_HERE, base::BindOnce(&OHOSMediaPlayerBridge::OnBufferAvailable,
+                                  media_player_, buffer));
+  } else {
+    LOG(ERROR) << "Unsupport format for:" << buffer->GetFormat();
+    surface_temp->ReleaseBuffer(buffer, -1);
+  }
 }
 
 }  // namespace media
diff --git a/media/mojo/mojom/renderer_extensions.mojom b/media/mojo/mojom/renderer_extensions.mojom
index 8d8e58cda5..07bd82171d 100644
--- a/media/mojo/mojom/renderer_extensions.mojom
+++ b/media/mojo/mojom/renderer_extensions.mojom
@@ -13,8 +13,11 @@ import "ui/gfx/geometry/mojom/geometry.mojom";
 struct OhosSurfaceBufferHandle {
   uint32 buffer_size;
   int32 fd_browser;
-  int32 width;
-  int32 height;
+  int32 coded_width;
+  int32 coded_height;
+  int32 visible_width;
+  int32 visible_height;
+  int32 format;
   handle<platform> buffer_fd;
 };
 
diff --git a/mojo/core/handle_table.cc b/mojo/core/handle_table.cc
index 9426281d73..a044f1c8e3 100644
--- a/mojo/core/handle_table.cc
+++ b/mojo/core/handle_table.cc
@@ -65,13 +65,19 @@ bool HandleTable::AddDispatchersFromTransit(
     const std::vector<Dispatcher::DispatcherInTransit>& dispatchers,
     MojoHandle* handles) {
   // Oops, we're out of handles.
-  if (next_available_handle_ == MOJO_HANDLE_INVALID)
+  if (next_available_handle_ == MOJO_HANDLE_INVALID) {
     return false;
+  }
+
+  // MOJO_HANDLE_INVALID is zero.
+  DCHECK_GE(next_available_handle_, 1u);
 
-  DCHECK_LE(dispatchers.size(), std::numeric_limits<uint32_t>::max());
   // If this insertion would cause handle overflow, we're out of handles.
-  if (next_available_handle_ + dispatchers.size() < next_available_handle_)
+  const uint32_t num_handles_available =
+      std::numeric_limits<uint32_t>::max() - next_available_handle_ + 1;
+  if (num_handles_available < dispatchers.size()) {
     return false;
+  }
 
   for (size_t i = 0; i < dispatchers.size(); ++i) {
     MojoHandle handle = MOJO_HANDLE_INVALID;
diff --git a/mojo/public/cpp/bindings/README.md b/mojo/public/cpp/bindings/README.md
index 05581aa626..d3ecb7e55a 100644
--- a/mojo/public/cpp/bindings/README.md
+++ b/mojo/public/cpp/bindings/README.md
@@ -1709,6 +1709,9 @@ C++ sources can depend on shared sources only, by referencing the
 `"${target_name}_shared"` target, e.g. `"//foo/mojom:mojom_shared"` in the
 example above.
 
+For converting between Blink and non-Blink variants, please see
+`//third_party/blink/public/platform/cross_variant_mojo_util.h`.
+
 ## Versioning Considerations
 
 For general documentation of versioning in the Mojom IDL see
diff --git a/mojo/public/cpp/bindings/lib/message_fragment.h b/mojo/public/cpp/bindings/lib/message_fragment.h
index 226c364468..b380da4131 100644
--- a/mojo/public/cpp/bindings/lib/message_fragment.h
+++ b/mojo/public/cpp/bindings/lib/message_fragment.h
@@ -149,8 +149,7 @@ class MessageFragment<Array_Data<T>> {
     static_assert(
         std::numeric_limits<uint32_t>::max() > Traits::kMaxNumElements,
         "Max num elements castable to 32bit");
-    if (num_elements > Traits::kMaxNumElements)
-      return;
+    CHECK_LE(num_elements, Traits::kMaxNumElements);
 
     const uint32_t num_bytes =
         Traits::GetStorageSize(static_cast<uint32_t>(num_elements));
diff --git a/net/BUILD.gn b/net/BUILD.gn
index edc7e8f38d..6232aeac47 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -1688,6 +1688,7 @@ source_set("net_deps") {
 
   public_deps = [
     ":constants",
+    ":isolation_info_proto",
     ":net_export_header",
     ":net_resources",
     ":preload_decoder",
@@ -1805,6 +1806,10 @@ proto_library("net_nqe_proto") {
   extra_configs = [ "//build/config/compiler:wexit_time_destructors" ]
 }
 
+proto_library("isolation_info_proto") {
+  sources = [ "base/isolation_info.proto" ]
+}
+
 component("extras") {
   sources = [
     "extras/sqlite/cookie_crypto_delegate.h",
diff --git a/net/base/isolation_info.cc b/net/base/isolation_info.cc
index e51644b222..3eb150b577 100644
--- a/net/base/isolation_info.cc
+++ b/net/base/isolation_info.cc
@@ -5,6 +5,7 @@
 #include "net/base/isolation_info.h"
 
 #include "base/check_op.h"
+#include "net/base/isolation_info.pb.h"
 
 namespace net {
 
@@ -126,6 +127,35 @@ IsolationInfo IsolationInfo::CreateOpaqueAndNonTransient() {
                        base::nullopt /* party_context */);
 }
 
+base::Optional<IsolationInfo> IsolationInfo::Deserialize(
+    const std::string& serialized) {
+  proto::IsolationInfo proto;
+  if (!proto.ParseFromString(serialized))
+    return base::nullopt;
+
+  base::Optional<url::Origin> top_frame_origin;
+  if (proto.has_top_frame_origin())
+    top_frame_origin = url::Origin::Create(GURL(proto.top_frame_origin()));
+
+  base::Optional<url::Origin> frame_origin;
+  if (proto.has_frame_origin())
+    frame_origin = url::Origin::Create(GURL(proto.frame_origin()));
+
+  base::Optional<std::set<SchemefulSite>> party_context;
+  if (proto.has_party_context()) {
+    party_context = std::set<SchemefulSite>();
+    for (const auto& site : proto.party_context().site()) {
+      party_context->insert(SchemefulSite::Deserialize(site));
+    }
+  }
+
+  return IsolationInfo::CreateIfConsistent(
+      static_cast<RequestType>(proto.request_type()),
+      std::move(top_frame_origin), std::move(frame_origin),
+      SiteForCookies::FromUrl(GURL(proto.site_for_cookies())),
+      false /* opaque_and_non_transient */, std::move(party_context));
+}
+
 IsolationInfo IsolationInfo::Create(
     RequestType request_type,
     const url::Origin& top_frame_origin,
@@ -219,6 +249,35 @@ IsolationInfo IsolationInfo::ToDoUseTopFrameOriginAsWell(
       std::set<SchemefulSite>() /* party_context */);
 }
 
+std::string IsolationInfo::Serialize() const {
+  if (network_isolation_key().IsTransient())
+    return "";
+
+  if (opaque_and_non_transient_)
+    return "";
+
+  proto::IsolationInfo info;
+
+  info.set_request_type(static_cast<int32_t>(request_type_));
+
+  if (top_frame_origin_)
+    info.set_top_frame_origin(top_frame_origin_->Serialize());
+
+  if (frame_origin_)
+    info.set_frame_origin(frame_origin_->Serialize());
+
+  info.set_site_for_cookies(site_for_cookies_.RepresentativeUrl().spec());
+
+  if (party_context_) {
+    auto* pc = info.mutable_party_context();
+    for (const auto& site : *party_context_) {
+      pc->add_site(site.Serialize());
+    }
+  }
+
+  return info.SerializeAsString();
+}
+
 IsolationInfo::IsolationInfo(
     RequestType request_type,
     const base::Optional<url::Origin>& top_frame_origin,
diff --git a/net/base/isolation_info.h b/net/base/isolation_info.h
index 28d6b1c7f7..f33bd4bb99 100644
--- a/net/base/isolation_info.h
+++ b/net/base/isolation_info.h
@@ -6,6 +6,7 @@
 #define NET_BASE_ISOLATION_INFO_H_
 
 #include <set>
+#include <string>
 
 #include "base/optional.h"
 #include "net/base/net_export.h"
@@ -96,6 +97,11 @@ class NET_EXPORT IsolationInfo {
   // allows use of the disk cache with a transient NIK.
   static IsolationInfo CreateOpaqueAndNonTransient();
 
+  // Creates an IsolationInfo from the serialized contents. Returns a nullopt
+  // if deserialization fails or if data is inconsistent.
+  static base::Optional<IsolationInfo> Deserialize(
+      const std::string& serialized);
+
   // Creates an IsolationInfo with the provided parameters. If the parameters
   // are inconsistent, DCHECKs. In particular:
   // * If |request_type| is kMainFrame, |top_frame_origin| must equal
@@ -198,6 +204,10 @@ class NET_EXPORT IsolationInfo {
 
   bool IsEqualForTesting(const IsolationInfo& other) const;
 
+  // Serialize the `IsolationInfo` into a string. Fails if transient, returning
+  // an empty string.
+  std::string Serialize() const;
+
  private:
   IsolationInfo(RequestType request_type,
                 const base::Optional<url::Origin>& top_frame_origin,
diff --git a/net/base/isolation_info.proto b/net/base/isolation_info.proto
new file mode 100644
index 0000000000..252b738245
--- /dev/null
+++ b/net/base/isolation_info.proto
@@ -0,0 +1,19 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+syntax = "proto2";
+
+option optimize_for = LITE_RUNTIME;
+
+package net.proto;
+
+message IsolationInfo {
+  optional int32 request_type = 1;  // net::IsolationInfo::RequestType
+  optional string top_frame_origin = 2;
+  optional string frame_origin = 3;
+  optional string site_for_cookies = 4;
+
+  message PartyContext { repeated string site = 1; }
+  optional PartyContext party_context = 5;
+}
\ No newline at end of file
diff --git a/net/base/isolation_info_unittest.cc b/net/base/isolation_info_unittest.cc
index 5c6461ea6b..bf8cd296ca 100644
--- a/net/base/isolation_info_unittest.cc
+++ b/net/base/isolation_info_unittest.cc
@@ -48,6 +48,9 @@ class IsolationInfoTest : public testing::Test {
       std::set<net::SchemefulSite>{net::SchemefulSite(kOrigin2)};
   const base::Optional<std::set<net::SchemefulSite>> kPartyContext3 =
       std::set<net::SchemefulSite>{net::SchemefulSite(kOrigin3)};
+  const base::Optional<std::set<net::SchemefulSite>> kPartyContextMultiple =
+      std::set<net::SchemefulSite>{net::SchemefulSite(kOrigin1),
+                                   net::SchemefulSite(kOrigin2)};
 };
 
 TEST_F(IsolationInfoTest, RequestTypeMainFrame) {
@@ -502,6 +505,62 @@ TEST_F(IsolationInfoTest, CreateForRedirectPartyContext) {
   }
 }
 
+TEST_F(IsolationInfoTest, Serialization) {
+  EXPECT_FALSE(IsolationInfo::Deserialize(""));
+  EXPECT_FALSE(IsolationInfo::Deserialize("garbage"));
+
+  const IsolationInfo kPositiveTestCases[] = {
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            kOrigin2, SiteForCookies::FromOrigin(kOrigin1),
+                            kPartyContext1),
+      // Null party context
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            kOrigin2, SiteForCookies::FromOrigin(kOrigin1),
+                            kPartyContextNull),
+      // Empty party context
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            kOrigin2, SiteForCookies::FromOrigin(kOrigin1),
+                            kPartyContextEmpty),
+      // Multiple party context entries.
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            kOrigin2, SiteForCookies::FromOrigin(kOrigin1),
+                            kPartyContextMultiple),
+      // Without SiteForCookies
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            kOrigin2, SiteForCookies(), base::nullopt),
+      // Request type kOther
+      IsolationInfo::Create(IsolationInfo::RequestType::kOther, kOrigin1,
+                            kOrigin1, SiteForCookies::FromOrigin(kOrigin1),
+                            base::nullopt),
+      // Request type kMainframe
+      IsolationInfo::Create(IsolationInfo::RequestType::kMainFrame, kOrigin1,
+                            kOrigin1, SiteForCookies::FromOrigin(kOrigin1),
+                            base::nullopt),
+  };
+  for (const auto& info : kPositiveTestCases) {
+    auto rt = IsolationInfo::Deserialize(info.Serialize());
+    ASSERT_TRUE(rt);
+    EXPECT_TRUE(rt->IsEqualForTesting(info));
+  }
+
+  const IsolationInfo kNegativeTestCases[] = {
+      IsolationInfo::CreateTransient(),
+      IsolationInfo::CreateOpaqueAndNonTransient(),
+      // With nonce (i.e transient).
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            kOrigin2, SiteForCookies::FromOrigin(kOrigin1),
+                            kPartyContext1, &kNonce1),
+      // With an opaque origin (i.e transient)
+      IsolationInfo::Create(IsolationInfo::RequestType::kSubFrame, kOrigin1,
+                            url::Origin(), SiteForCookies::FromOrigin(kOrigin1),
+                            base::nullopt),
+
+  };
+  for (const auto& info : kNegativeTestCases) {
+    EXPECT_TRUE(info.Serialize().empty());
+  }
+}
+
 }  // namespace
 
 }  // namespace net
diff --git a/net/cert/cert_verify_proc_ohos.cc b/net/cert/cert_verify_proc_ohos.cc
index b36b8d9022..82d219d37d 100644
--- a/net/cert/cert_verify_proc_ohos.cc
+++ b/net/cert/cert_verify_proc_ohos.cc
@@ -3,9 +3,19 @@
 // found in the LICENSE file.
 
 #include "net/cert/cert_verify_proc_ohos.h"
-
+#include <string>
+#include <vector>
+#include "base/logging.h"
 #include "net/cert/cert_net_fetcher.h"
+#include "net/cert/x509_certificate.h"
+#include "net/cert/x509_util.h"
+#include "openssl/err.h"
+#include "openssl/ossl_typ.h"
+#include "openssl/x509.h"
+#include "openssl/x509_vfy.h"
 
+#define ROOT_CERT "/etc/ssl/certs/cacert.pem"
+#define MIN_CERT_NUM 1
 namespace net {
 CertVerifyProcOHOS::CertVerifyProcOHOS(
     scoped_refptr<CertNetFetcher> cert_net_fetcher)
@@ -17,6 +27,131 @@ bool CertVerifyProcOHOS::SupportsAdditionalTrustAnchors() const {
   return false;
 }
 
+void GetChainDEREncodedBytes(X509Certificate* cert,
+                             std::vector<std::string>* chain_bytes) {
+  chain_bytes->reserve(1 + cert->intermediate_buffers().size());
+  chain_bytes->emplace_back(
+      net::x509_util::CryptoBufferAsStringPiece(cert->cert_buffer()));
+  for (const auto& handle : cert->intermediate_buffers()) {
+    chain_bytes->emplace_back(
+        net::x509_util::CryptoBufferAsStringPiece(handle.get()));
+  }
+}
+
+void X509_d2i_free(X509* server_cert[], uint32_t server_cert_sum) {
+  uint32_t i;
+  for (i = 0; i < server_cert_sum; i++) {
+    X509_free(server_cert[i]);
+  }
+}
+
+bool CertChainVerify(X509* server_cert[],
+                     uint32_t server_cert_sum,
+                     X509_STORE* root_store) {
+  uint32_t i;
+  STACK_OF(X509)* ca_stack = nullptr;
+  X509_STORE_CTX* ctx = nullptr;
+
+  // certificate chain verify
+  for (i = server_cert_sum - 1; i > 0; i--) {
+    // Create certificate store context function
+    ctx = X509_STORE_CTX_new();
+    if (ctx == nullptr) {
+      LOG(ERROR) << "Create certificate store context function failed";
+      X509_d2i_free(server_cert, server_cert_sum);
+      X509_STORE_free(root_store);
+      return false;
+    }
+
+    // Initialize the certificate chain
+    X509_STORE_CTX_init(ctx, root_store, server_cert[i], ca_stack);
+
+    // If verification fails, for detailed error information, see
+    // X509_verify_cert_error_string
+    if (!X509_verify_cert(ctx)) {
+      LOG(ERROR) << "Certificate verify error: " << ctx->error
+                 << "\nCertificate verify info: "
+                 << X509_verify_cert_error_string(ctx->error)
+                 << "\nTotal number of server certificates: " << server_cert_sum
+                 << "\nserver certificates count: " << i;
+      X509_d2i_free(server_cert, server_cert_sum);
+      X509_STORE_CTX_free(ctx);
+      X509_STORE_free(root_store);
+      return false;
+    }
+
+    X509_STORE_CTX_free(ctx);
+  }
+
+  X509_d2i_free(server_cert, server_cert_sum);
+  X509_STORE_free(root_store);
+
+  return true;
+}
+
+bool CertVerify(std::vector<std::string>& cert_bytes) {
+  uint32_t server_cert_sum;
+  const unsigned char* der_encoded_tmp = nullptr;
+  uint32_t i;
+  int root_cert_sum = 0;
+  X509_STORE* root_store = nullptr;
+  X509_LOOKUP* look_up = nullptr;
+
+  server_cert_sum = cert_bytes.size();
+  if (server_cert_sum < MIN_CERT_NUM) {
+    LOG(ERROR) << "Total number of server certificates is error";
+    return false;
+  }
+
+  // Convert cert_bytes to internal X509 data structure(server_cert[]), If the
+  // conversion fails, see ERR_reason_error_string()/kLibraryNames
+  X509* server_cert[server_cert_sum];
+  for (i = 0; i < server_cert_sum; i++) {
+    der_encoded_tmp = (unsigned char*)cert_bytes[i].c_str();
+    server_cert[i] = d2i_X509(nullptr, &der_encoded_tmp, cert_bytes[i].size());
+    if (server_cert[i] == nullptr) {
+      LOG(ERROR)
+          << "Server certificate DEREncoded converted to X509 error, Reason: "
+          << ERR_reason_error_string(ERR_get_error())
+          << "\nTotal number of server certificates: " << server_cert_sum
+          << "\nError certificate count:" << i;
+      ERR_clear_error();
+      X509_d2i_free(server_cert, i);
+      return false;
+    }
+  }
+
+  // Create X509 certificate store
+  root_store = X509_STORE_new();
+  if (root_store == nullptr) {
+    LOG(ERROR) << "Create X509 certificate store failed";
+    X509_d2i_free(server_cert, server_cert_sum);
+    return false;
+  }
+
+  // Create X509_LOOKUP, the store_ctx member of this data structure is
+  // associated with the newly created certificate store root_store
+  look_up = X509_STORE_add_lookup(root_store, X509_LOOKUP_file());
+  if (look_up == nullptr) {
+    LOG(ERROR) << "Create X509 LOOKUP failed";
+    X509_d2i_free(server_cert, server_cert_sum);
+    X509_STORE_free(root_store);
+    return false;
+  }
+
+  // Parse the root certificate file
+  root_cert_sum =
+      X509_load_cert_crl_file(look_up, ROOT_CERT, X509_FILETYPE_PEM);
+  if (root_cert_sum == 0) {
+    LOG(ERROR) << "Root certificate number is 0";
+    X509_d2i_free(server_cert, server_cert_sum);
+    X509_STORE_free(root_store);
+    return false;
+  }
+
+  return CertChainVerify(server_cert, server_cert_sum, root_store);
+}
+
 int CertVerifyProcOHOS::VerifyInternal(
     X509Certificate* cert,
     const std::string& hostname,
@@ -27,7 +162,14 @@ int CertVerifyProcOHOS::VerifyInternal(
     const CertificateList& additional_trust_anchors,
     CertVerifyResult* verify_result,
     const NetLogWithSource& net_log) {
-  //TODO: no implement
+  std::vector<std::string> cert_bytes;
+
+  GetChainDEREncodedBytes(cert, &cert_bytes);
+
+  if (!CertVerify(cert_bytes)) {
+    return ERR_FAILED;
+  }
+
   return OK;
 }
 
diff --git a/ohos_ndk_aosp/includes/common/graphic_common.h b/ohos_ndk_aosp/includes/common/graphic_common.h
new file mode 100644
index 0000000000..e6c675222b
--- /dev/null
+++ b/ohos_ndk_aosp/includes/common/graphic_common.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_COMMON_GRAPHIC_COMMON_H
+#define INTERFACES_INNERKITS_COMMON_GRAPHIC_COMMON_H
+
+#ifdef __cplusplus
+#include <cstdint>
+#include <cstring>
+#include <map>
+#include <string>
+#include <ostream>
+
+namespace OHOS {
+#endif
+
+#include "graphic_common_c.h"
+
+#ifdef __cplusplus
+static const std::map<GSError, std::string> GSErrorStrs = {
+    {GSERROR_OK,                    "<200 ok>"},
+    {GSERROR_INVALID_ARGUMENTS,     "<400 invalid arguments>"},
+    {GSERROR_NO_PERMISSION,         "<403 no permission>"},
+    {GSERROR_CONNOT_CONNECT_SAMGR,  "<404 connot connect to samgr>"},
+    {GSERROR_CONNOT_CONNECT_SERVER, "<404 connot connect to server>"},
+    {GSERROR_CONNOT_CONNECT_WESTON, "<404 connot connect to weston>"},
+    {GSERROR_NO_BUFFER,             "<406 no buffer>"},
+    {GSERROR_NO_ENTRY,              "<406 no entry>"},
+    {GSERROR_OUT_OF_RANGE,          "<406 out of range>"},
+    {GSERROR_NO_SCREEN,             "<406 no screen>"},
+    {GSERROR_INVALID_OPERATING,     "<412 invalid operating>"},
+    {GSERROR_NO_CONSUMER,           "<412 no consumer>"},
+    {GSERROR_NOT_INIT,              "<412 not init>"},
+    {GSERROR_TYPE_ERROR,            "<412 type error>"},
+    {GSERROR_API_FAILED,            "<500 api call failed>"},
+    {GSERROR_INTERNEL,              "<500 internal error>"},
+    {GSERROR_NO_MEM,                "<500 no memory>"},
+    {GSERROR_PROXY_NOT_INCLUDE,     "<500 proxy not include>"},
+    {GSERROR_SERVER_ERROR,          "<500 server occur error>"},
+    {GSERROR_ANIMATION_RUNNING,     "<500 animation is running>"},
+    {GSERROR_NOT_IMPLEMENT,         "<501 not implement>"},
+    {GSERROR_NOT_SUPPORT,           "<501 not support>"},
+    {GSERROR_BINDER,                "<504 binder occur error>"},
+};
+
+static inline std::string LowErrorStrSpecial(GSError err)
+{
+    if (err == LOWERROR_INVALID) {
+        char num[] = {err / 0x64 % 0xa, err / 0xa % 0xa, err % 0xa, 0}; // int to string (in 1000)
+        return std::string("with low error <") + num + ">";
+    } else if (err == LOWERROR_FAILURE) {
+        return "with low error <failure>";
+    }
+    return "";
+}
+
+static inline std::string LowErrorStr(GSError lowerr)
+{
+    std::string lowError = LowErrorStrSpecial(lowerr);
+    if (lowError == "" && lowerr != 0) {
+        char buf[256] = {0}; // 256 mean buffer max length
+        strerror_r(lowerr, buf, sizeof buf);
+        lowError = std::string("with low error <") + buf + ">";
+    }
+    return lowError;
+}
+
+static inline std::string GSErrorStr(GSError err)
+{
+    GSError diff = static_cast<GSError>(err % LOWERROR_MAX);
+    auto it = GSErrorStrs.find(static_cast<GSError>(err - diff));
+    if (it == GSErrorStrs.end()) {
+        return "<GSError error index out of range>";
+    }
+    return it->second + LowErrorStr(diff);
+}
+
+static inline std::string WMErrorStr(GSError err)
+{
+    return GSErrorStr(err);
+}
+
+static inline std::string SurfaceErrorStr(GSError err)
+{
+    return GSErrorStr(err);
+}
+
+static inline std::string VsyncErrorStr(GSError err)
+{
+    return GSErrorStr(err);
+}
+
+static inline std::ostream &operator <<(std::ostream &os, const GSError &err)
+{
+    os << GSErrorStr(err);
+    return os;
+}
+
+static inline bool operator ==(GSError a, GSError b)
+{
+    return static_cast<int32_t>(a) / LOWERROR_MAX == static_cast<int32_t>(b) / LOWERROR_MAX;
+}
+
+static inline bool operator !=(GSError a, GSError b)
+{
+    return static_cast<int32_t>(a) / LOWERROR_MAX != static_cast<int32_t>(b) / LOWERROR_MAX;
+}
+
+using WMError = GSError;
+using SurfaceError = GSError;
+using VsyncError = GSError;
+} // namespace OHOS
+#endif // __cplusplus
+
+#endif // INTERFACES_INNERKITS_COMMON_GRAPHIC_COMMON_H
diff --git a/ohos_ndk_aosp/includes/common/graphic_common_c.h b/ohos_ndk_aosp/includes/common/graphic_common_c.h
new file mode 100644
index 0000000000..4ea8c48fc9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/common/graphic_common_c.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_COMMON_GRAPHIC_COMMON_C_H
+#define INTERFACES_INNERKITS_COMMON_GRAPHIC_COMMON_C_H
+
+// GraphicStandard Error, number just find fast, it may change
+const int LOWERROR_MAX = 1000;
+const int LOWERROR_FAILURE = 999;
+const int LOWERROR_INVALID = 998;
+enum GSError {
+    GSERROR_OK                    = 0,
+
+    // 400 BAD_REQUEST
+    GSERROR_INVALID_ARGUMENTS     = 40001000,
+
+    // 403 FORBIDDEN
+    GSERROR_NO_PERMISSION         = 40301000,
+
+    // 404 NOT_FOUND
+    GSERROR_CONNOT_CONNECT_SAMGR  = 40401000,
+    GSERROR_CONNOT_CONNECT_SERVER = 40402000,
+    GSERROR_CONNOT_CONNECT_WESTON = 40403000,
+
+    // 406 NOT_ACCEPTABLE
+    GSERROR_NO_BUFFER             = 40601000,
+    GSERROR_NO_ENTRY              = 40602000,
+    GSERROR_OUT_OF_RANGE          = 40603000,
+    GSERROR_NO_SCREEN             = 40604000,
+
+    // 412 PRECONDITION_FAILED
+    GSERROR_INVALID_OPERATING     = 41201000,
+    GSERROR_NO_CONSUMER           = 41202000,
+    GSERROR_NOT_INIT              = 41203000,
+    GSERROR_TYPE_ERROR            = 41204000,
+    GSERROR_DESTROYED_OBJECT      = 41205000,
+
+    // 500 INTERNAL ERROR
+    GSERROR_API_FAILED            = 50001000,
+    GSERROR_INTERNEL              = 50002000,
+    GSERROR_NO_MEM                = 50003000,
+    GSERROR_PROXY_NOT_INCLUDE     = 50004000,
+    GSERROR_SERVER_ERROR          = 50005000,
+    GSERROR_ANIMATION_RUNNING     = 50006000,
+
+    // 501 NOT_IMPLEMENTED
+    GSERROR_NOT_IMPLEMENT         = 50101000,
+    GSERROR_NOT_SUPPORT           = 50102000,
+
+    // 504 GATEWAY ERROR
+    GSERROR_BINDER                = 50401000,
+
+    WM_OK = GSERROR_OK,
+    WM_ERROR_SAMGR = GSERROR_CONNOT_CONNECT_SAMGR,
+    WM_ERROR_WMS_NOT_FOUND = GSERROR_CONNOT_CONNECT_SERVER,
+    WM_ERROR_NOT_INIT = GSERROR_NOT_INIT,
+    WM_ERROR_API_FAILED = GSERROR_API_FAILED,
+    WM_ERROR_NEW = GSERROR_NO_MEM,
+    WM_ERROR_INNER = GSERROR_INTERNEL,
+    WM_ERROR_NULLPTR = GSERROR_INVALID_ARGUMENTS,
+    WM_ERROR_INVALID_PARAM = GSERROR_INVALID_ARGUMENTS,
+    WM_ERROR_CONNOT_CONNECT_WESTON = GSERROR_CONNOT_CONNECT_WESTON,
+    WM_ERROR_SERVER = GSERROR_SERVER_ERROR,
+    WM_ERROR_NOT_SUPPORT = GSERROR_NOT_SUPPORT,
+    WM_ERROR_DESTROYED_OBJECT = GSERROR_DESTROYED_OBJECT,
+
+    SURFACE_ERROR_OK = GSERROR_OK,
+    SURFACE_ERROR_ERROR = GSERROR_INTERNEL,
+    SURFACE_ERROR_BINDER_ERROR = GSERROR_BINDER,
+    SURFACE_ERROR_NULLPTR = GSERROR_INVALID_ARGUMENTS,
+    SURFACE_ERROR_NO_ENTRY = GSERROR_NO_ENTRY,
+    SURFACE_ERROR_INVALID_OPERATING = GSERROR_INVALID_OPERATING,
+    SURFACE_ERROR_NO_BUFFER = GSERROR_NO_BUFFER,
+    SURFACE_ERROR_INVALID_PARAM = GSERROR_INVALID_ARGUMENTS,
+    SURFACE_ERROR_INIT = GSERROR_INTERNEL,
+    SURFACE_ERROR_NOMEM = GSERROR_NO_MEM,
+    SURFACE_ERROR_API_FAILED = GSERROR_API_FAILED,
+    SURFACE_ERROR_NOT_SUPPORT = GSERROR_NOT_SUPPORT,
+    SURFACE_ERROR_OUT_OF_RANGE = GSERROR_OUT_OF_RANGE,
+    SURFACE_ERROR_TYPE_ERROR = GSERROR_TYPE_ERROR,
+    SURFACE_ERROR_NO_CONSUMER = GSERROR_NO_CONSUMER,
+
+    VSYNC_ERROR_OK = GSERROR_OK,
+    VSYNC_ERROR_API_FAILED = GSERROR_API_FAILED,
+    VSYNC_ERROR_INVALID_OPERATING = GSERROR_INVALID_OPERATING,
+    VSYNC_ERROR_NULLPTR = GSERROR_INVALID_ARGUMENTS,
+    VSYNC_ERROR_BINDER_ERROR = GSERROR_BINDER,
+    VSYNC_ERROR_SAMGR = GSERROR_CONNOT_CONNECT_SAMGR,
+    VSYNC_ERROR_SERVICE_NOT_FOUND = GSERROR_SERVER_ERROR,
+    VSYNC_ERROR_PROXY_NOT_INCLUDE = GSERROR_PROXY_NOT_INCLUDE,
+    VSYNC_ERROR_INNER = GSERROR_INTERNEL,
+    VSYNC_ERROR_INVALID_ARGUMENTS = GSERROR_INVALID_ARGUMENTS,
+};
+
+#endif // INTERFACES_INNERKITS_COMMON_GRAPHIC_COMMON_H
diff --git a/ohos_ndk_aosp/includes/display/display_device.h b/ohos_ndk_aosp/includes/display/display_device.h
new file mode 100644
index 0000000000..35f4988588
--- /dev/null
+++ b/ohos_ndk_aosp/includes/display/display_device.h
@@ -0,0 +1,688 @@
+/*
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Display
+ * @{
+ *
+ * @brief Defines driver functions of the display module.
+ *
+ * This module provides driver functions for the graphics subsystem, including graphics layer management,
+ * device control, graphics hardware acceleration, display memory management, and callbacks.
+ * @since 1.0
+ * @version 2.0
+ */
+ 
+ /**
+ * @file display_device.h
+ *
+ * @brief Declares control functions of the display device.
+ *
+ * @since 1.0
+ * @version 2.0
+ */
+
+#ifndef DISPLAY_DEVICE_H
+#define DISPLAY_DEVICE_H
+#include "display_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *
+ * @brief Called when a hot plug event occurs.
+ *
+ * This callback must be registered by calling <b>RegHotPlugCallback</b>.
+ *
+ * @param devId Indicates the ID of the display device. This ID is generated by the HDI implementation layer and
+ * transferred to the graphics service through the current callback. It identifies the display device to connect.
+ * @param connected Indicates the connection status of the display device. The value <b>true</b> means that the
+ * display device is connected, and <b>false</b> means the opposite.
+ * @param data Indicates the private data carried by the graphics service. This parameter carries the private data
+ * address transferred when <b>RegHotPlugCallback</b> is called. For details, see {@link RegHotPlugCallback}.
+ *  
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+typedef void (*HotPlugCallback)(uint32_t devId, bool connected, void *data);
+
+/* *
+ * @brief Called when a VBLANK event occurs.
+ *
+ * This callback must be registered by calling <b>RegDisplayVBlankCallback</b>.
+ *
+ * @param sequence Indicates the VBLANK sequence, which is an accumulated value.
+ * @param ns Indicates the timestamp (in ns) of the VBLANK event.
+ * @param data Indicates the pointer to the private data carried by the graphics service. This parameter carries
+ * the address passed when <b>RegDisplayVBlankCallback</b> is called.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+typedef void (*VBlankCallback)(unsigned int sequence, uint64_t ns, void *data);
+
+/* *
+ * @brief Called when the graphics service needs to refresh data frames.
+ *
+ * This callback must be registered by calling <b>RegDisplayRefreshCallback</b>.
+ *
+ * @param devId Indicates the ID of the display device.
+ * @param data Indicates the pointer to the private data carried by the graphics service. This parameter carries
+ * the address passed when <b>RegDisplayRefreshCallback</b> is called.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+typedef void (*RefreshCallback)(uint32_t devId, void *data);
+
+/**
+ * @brief  Defines pointers to the functions of the display device.
+ */
+typedef struct {
+    /* *
+     * @brief Registers the callback to be invoked when a hot plug event occurs.
+     *
+     * @param callback Indicates the instance used to notify the graphics service of a hot plug event occurred.
+     * @param data Indicates the pointer to the private data returned to the graphics service in the
+     * <b>HotPlugCallback</b> callback.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*RegHotPlugCallback)(HotPlugCallback callback, void *data);
+
+    /* *
+     * @brief Registers the callback to be invoked when a VBLANK event occurs.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param callback Indicates the instance used to notify the graphics service of the VBLANK event occurred when
+     * <b>DisplayVsync</b> is enabled.
+     * @param data Indicates the pointer to the private data returned to the graphics service in the
+     * <b>VBlankCallback</b> callback.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*RegDisplayVBlankCallback)(uint32_t devId, VBlankCallback callback, void *data);
+
+    /* *
+     * @brief Called when the graphics service needs to refresh data frames.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param callback Indicates the instance used to notify the graphics service of the request for refreshing
+     * data frames.
+     * @param data Indicates the pointer to the private data returned to the graphics service in the
+     * <b>RefreshCallback</b> callback.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*RegDisplayRefreshCallback)(uint32_t devId, RefreshCallback callback, void *data);
+
+    /* *
+     * @brief Obtains the capabilities of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param info Indicates the pointer to the capabilities supported by the display device. For details,
+     * see {@link DisplayCapability}.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayCapability)(uint32_t devId, DisplayCapability *info);
+
+    /* *
+     * @brief Obtains the display modes supported by a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the pointer to the number of modes supported by the display device.
+     * @param modes Indicates the pointer to the information about all modes supported by the display device,
+     * including all supported resolutions and refresh rates. Each mode has an ID, which will be used when
+     * the mode is set or obtained. For details, see {@link DisplayModeInfo}.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplaySupportedModes)(uint32_t devId, uint32_t *num, DisplayModeInfo *modes);
+
+    /* *
+     * @brief Obtains the current display mode of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param modeId indicates the pointer to the ID of the current display mode of the device. The display mode ID
+     * is written by this API.
+     *
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayMode)(uint32_t devId, uint32_t *modeId);
+
+    /* *
+     * @brief Sets the display mode of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param modeId Indicates the ID of the display mode. The device is switched to the display mode specified by
+     * this parameter in this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayMode)(uint32_t devId, uint32_t modeId);
+
+    /* *
+     * @brief Obtains the power status of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param status Indicates the pointer to the power status of the device. The status is written by this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayPowerStatus)(uint32_t devId, DispPowerStatus *status);
+
+    /* *
+     * @brief Sets the power status of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param status Indicates the power status to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayPowerStatus)(uint32_t devId, DispPowerStatus status);
+
+    /* *
+     * @brief Obtains the backlight value of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param level Indicates the pointer to the backlight value of the device. The backlight value is written
+     * by this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayBacklight)(uint32_t devId, uint32_t *level);
+
+    /* *
+     * @brief Sets the backlight value for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param level Indicates the backlight value to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayBacklight)(uint32_t devId, uint32_t level);
+
+    /* *
+     * @brief Obtains the property for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param id Indicates the property ID returned by <b>GetDisplayCapability</b>.
+     * @param level Indicates the pointer to the property corresponding to the property ID. The property value is
+     * written by this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayProperty)(uint32_t devId, uint32_t id, uint64_t *value);
+
+    /* *
+     * @brief Sets the property for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param id Indicates the property ID returned by <b>GetDisplayCapability</b>.
+     * @param value Indicates the property to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayProperty)(uint32_t devId, uint32_t id, uint64_t value);
+
+    /* *
+    * @brief Prepares for the composition to be performed by a display device.
+    *
+    * Before the composition, the graphics service needs to notify the display device of the preparation to be made
+    * through this interface.
+    *
+    * @param devId Indicates the ID of the display device.
+    * @param needFlushFb Indicates the pointer that specifies whether the graphics service needs to reset the display
+    * framebuffer by using <b>SetDisplayClientBuffer</b> before the commit operation.
+    * The value <b>true</b> means that the framebuffer needs to be reset, and <b>false</b> means the opposite.
+    *
+    * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+    * in {@link DispErrCode} otherwise.
+    * @since 1.0
+    * @version 1.0
+    */
+    int32_t (*PrepareDisplayLayers)(uint32_t devId, bool *needFlushFb);
+
+    /* *
+     * @brief Obtains the layers whose composition types have changed.
+     *
+     * In the preparation for composition, the display device changes the composition type for each layer based on
+     * the composition capability of the device. This function returns the layers whose composition types have changed.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the pointer to the number of layers whose composition types have changed.
+     * @param Layers Indicates the pointer to the start address of the layer array.
+     * @param Layers Indicates the pointer to the start address of the composition type array.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayCompChange)(uint32_t devId, uint32_t *num, uint32_t *Layers, int32_t *type);
+
+    /* *
+     * @brief Sets the cropped region for a display device.
+     *
+     * You can use this interface to set the cropped region of the client buffer of the display device.
+     * The cropped region cannot exceed the size of the client buffer.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param rect Indicates the pointer to the cropped region of the client buffer.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayClientCrop)(uint32_t devId, IRect *rect);
+
+    /* *
+     * @brief Sets the display region for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param rect Indicates the pointer to the display region.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayClientDestRect)(uint32_t devId, IRect *rect);
+
+    /* *
+     * @brief Sets the display buffer for a display device.
+     *
+     * The display buffer stores the hardware composition result of the display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param buffer Indicates the pointer to the display buffer.
+     * @param fence Indicates the sync fence that specifies whether the display buffer can be accessed. The display
+     * buffer is created and released by the graphics service. It can be accessed only when the sync fence is in the
+     * signaled state.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayClientBuffer)(uint32_t devId, const BufferHandle *buffer, int32_t fence);
+
+    /* *
+     * @brief Sets the dirty region for a display device.
+     *
+     * The dirty region consists of multiple rectangular regions. The rectangular regions can be refreshed based on
+     * the settings.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the number of rectangles.
+     * @param rect Indicates the pointer to the start address of the rectangle array.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayClientDamage)(uint32_t devId, uint32_t num, IRect *rect);
+
+    /* *
+     * @brief Enables or disables the vertical sync signal.
+     *
+     * When the vertical sync signal is generated, the <b>VBlankCallback</b> callback registered
+     * by <b>RegDisplayVBlankCallback</b> will be invoked. The vertical sync signal must be enabled when the graphics
+     * service needs to refresh the display, and disabled when display refresh is not required. The display does not
+     * need to refresh when <b>VBlankCallback</b> is invoked and the graphics service composes layers and sends the
+     * composition result to the device for display.
+     * 
+     * @param devId Indicates the ID of the display device.
+     * @param enabled Specifies whether to enable the vertical sync signal. The value <b>true</b> means to enable the
+     * vertical sync signal, and <b>false</b> means to disable it.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode}otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayVsyncEnabled)(uint32_t devId, bool enabled);
+
+    /* *
+     * @brief Obtains the fences of the display layers after the commit operation.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the pointer to the number of layers.
+     * @param layers Indicates the pointer to the start address of the layer array.
+     * @param fences Indicates the pointer to the start address of the fence array.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayReleaseFence)(uint32_t devId, uint32_t *num, uint32_t *layers, int32_t *fences);
+
+    /* *
+     * @brief Obtains the color gamuts supported by a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the pointer to the number of color gamuts supported by the display device.
+     * @param gamuts Indicates the pointer to the information about all color gamuts supported by the display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplaySupportedColorGamuts)(uint32_t devId, uint32_t *num, ColorGamut *gamuts);
+
+    /* *
+     * @brief Obtains the color gamut of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param gamut Indicates the pointer to the color gamut of the device. The color gamut is written
+     * by this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayColorGamut)(uint32_t devId, ColorGamut *gamut);
+
+    /* *
+     * @brief Sets the color gamut for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param gamut Indicates the color gamut to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayColorGamut)(uint32_t devId, ColorGamut gamut);
+
+    /* *
+     * @brief Obtains the gamut map of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param gamutMap Indicates the pointer to the gamut map of the device. The gamut map is written
+     * by this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayGamutMap)(uint32_t devId, GamutMap *gamutMap);
+
+    /* *
+     * @brief Sets the gamut map for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param gamutMap Indicates the gamut map to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayGamutMap)(uint32_t devId, GamutMap gamutMap);
+
+    /* *
+     * @brief Sets a 4x4 color transformation matrix for a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param matrix Indicates the pointer to the 4x4 color transformation matrix to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetDisplayColorTransform)(uint32_t devId, const float *matrix);
+
+    /* *
+     * @brief Obtains the HDR capability of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param info Indicates the pointer to the HDR capability of the device. The <b>info</b> is written
+     * by this interface.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetHDRCapabilityInfos)(uint32_t devId, HDRCapability *info);
+
+    /* *
+     * @brief Obtains the HDR metadata keys supported by a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the pointer to the number of metadata keys supported by the display device.
+     * @param keys Indicates the pointer to the information about all HDR metadata keys supported by the display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetSupportedMetadataKey)(uint32_t devId, uint32_t *num, HDRMetadataKey *keys);
+
+    /* *
+     * @brief Commits the request for composition and display.
+     *
+     * If there is a hardware composition layer, the composition is performed and the composition result is sent to
+     * the hardware for display.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param num Indicates the pointer to the number of layers.
+     * @param layers Indicates the pointer to the start address of the layer array.
+     * @param fences Indicates the pointer to the start address of the fence array.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*Commit)(uint32_t devId, int32_t *fence);
+
+    /* *
+     * @brief Invokes the display device commands.
+     *
+     * This function extends the APIs between the graphics service and implementation layer, eliminating the need
+     * to add new APIs.
+     *
+     * @param devId Indicates the ID of the display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*InvokeDisplayCmd)(uint32_t devId, ...);
+
+    /* *
+     * @brief Creates a virtual display device.
+     *
+     * @param width Indicates the pixel width of the display device.
+     * @param height Indicates the pixel height of the display device.
+     * @param format Indicates the pointer to the pixel format of the display device.
+     * For details, see {@link PixelFormat}. The <b>format</b> can be modified based on hardware requirements and
+     * returned to the graphics service.
+     * @param devId Indicates the pointer to the ID of the virtual display device created.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*CreateVirtualDisplay)(uint32_t width, uint32_t height, int32_t *format, uint32_t *devId);
+
+    /* *
+     * @brief Destroys a virtual display device.
+     * 
+     * @param devId Indicates the ID of the display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DestroyVirtualDisplay)(uint32_t devId);
+
+    /* *
+     * @brief Sets the output buffer for a virtual display device.
+     *
+     * This buffer stores the output of the virtual display device. The buffer can be used only after the sync fence
+     * is in the signaled state.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param buffer Indicates the pointer to the output buffer.
+     * @param fence Indicates the sync fence.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetVirtualDisplayBuffer)(uint32_t devId, BufferHandle *buffer, int32_t fence);
+
+    /* *
+     * @brief Obtains the writeback frame of a display device.
+     *
+     * This function is used to obtain data of the writeback endpoint specified by <b>devId</b>. The data is written
+     * to the specified buffer by this interface.
+     *
+     * @param devId Indicates the ID of the display device.
+     * @param buffer Indicates the pointer to the buffer of the writeback endpoint data.
+     * @param fence Indicates the pointer to the sync fence. When calling this interface, the graphics service needs
+     * to pass the <b>release fence</b> of the buffer to
+     * specify whether data can be written to the buffer. Then, <b>acquire fence</b> of the buffer needs to be written
+     * and sent to the graphics service to specify whether the writeback data has been written to the buffer.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetWriteBackFrame)(uint32_t devId, BufferHandle *buffer, int32_t *fence);
+
+    /* *
+     * @brief Creates a writeback endpoint for a display device.
+     *
+     * If the number of writeback endpoints exceeds the limit, a failure message will be returned.
+     *
+     * @param devId Indicates the pointer to the ID of the display device. After a writeback endpoint is created, the
+     * device ID of the writeback endpoint is written in this parameter and returned to the graphics service.
+     * @param width Indicates the writeback pixel width.
+     * @param height Indicates the writeback pixel height.
+     * @param format Indicates the pointer to the writeback point data format. For details, see {@link PixelFormat}.
+     * The <b>format</b> can be modified based on hardware requirements and returned to the graphics service.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*CreateWriteBack)(uint32_t *devId, uint32_t width, uint32_t height, int32_t *format);
+
+    /* *
+     * @brief Destroys the writeback endpoint of a display device.
+     *
+     * @param devId Indicates the ID of the display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+     * in {@link DispErrCode} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DestroyWriteBack)(uint32_t devId);
+} DeviceFuncs;
+
+/**
+ * @brief Initializes the control functions of a display device. You can apply for resources for
+ * using control functions and then operate the display device by using the control functions.
+ *
+ * @param funcs Indicates the double pointer to the control functions of the display device. The caller obtains
+ * the double pointer to operate the display device. The memory is allocated during initialization, and therefore
+ * the caller does not need to allocate the memory.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+ * in {@link DispErrCode} otherwise.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t DeviceInitialize(DeviceFuncs **funcs);
+
+/**
+ * @brief Uninitializes control functions of the display device. The resources used by the control functions will be
+ * released. In other words, the memory allocated during initialization of the control functions will be released.
+ *
+ * @param funcs Indicates the double pointer to the control functions of the display device.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined
+ * in {@link DispErrCode} otherwise.
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t DeviceUninitialize(DeviceFuncs *funcs);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/* @} */
diff --git a/ohos_ndk_aosp/includes/display/display_gfx.h b/ohos_ndk_aosp/includes/display/display_gfx.h
new file mode 100644
index 0000000000..1b9e770fc3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/display/display_gfx.h
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Display
+ * @{
+ *
+ * @brief Defines driver functions of the display module.
+ *
+ * This module provides driver functions for the graphics subsystem, including graphics layer management,
+ * device control, graphics hardware acceleration, display memory management, and callbacks.
+ *
+ * @since 1.0
+ * @version 2.0
+ */
+
+/**
+ * @file display_gfx.h
+ *
+ * @brief Declares the driver functions for implementing hardware acceleration.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+
+#ifndef DISPLAY_GFX_H
+#define DISPLAY_GFX_H
+#include "display_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Defines pointers to the hardware acceleration driver functions.
+ */
+typedef struct {
+    /**
+     * @brief Initializes hardware acceleration.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see DeinitGfx
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*InitGfx)(void);
+
+    /**
+     * @brief Deinitializes hardware acceleration.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see InitGfx
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DeinitGfx)(void);
+
+    /**
+     * @brief Fills a rectangle with a given color on the canvas.
+     *
+     * @param surface Indicates the pointer to the canvas.
+     * @param rect Indicates the pointer to the rectangle to fill.
+     * @param color Indicates the color to fill.
+     * @param opt Indicates the pointer to the hardware acceleration option.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*FillRect)(ISurface *surface, IRect *rect, uint32_t color, GfxOpt *opt);
+
+    /**
+     * @brief Draws a rectangle with a given color on the canvas.
+     *
+     * @param surface Indicates the pointer to the canvas.
+     * @param rect Indicates the pointer to the rectangle to draw.
+     * @param color Indicates the color to draw.
+     * @param opt Indicates the pointer to the hardware acceleration option.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DrawRectangle)(ISurface *surface, Rectangle *rect, uint32_t color, GfxOpt *opt);
+
+    /**
+     * @brief Draws a straight line with a given color on the canvas.
+     *
+     * @param surface Indicates the pointer to the canvas.
+     * @param line Indicates the pointer to the line to draw.
+     * @param opt Indicates the pointer to the hardware acceleration option.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DrawLine)(ISurface *surface, ILine *line, GfxOpt *opt);
+
+    /**
+     * @brief Draws a circle with a specified center and radius on the canvas using a given color.
+     *
+     * @param surface Indicates the pointer to the canvas.
+     * @param circle Indicates the pointer to the circle to draw.
+     * @param opt Indicates the pointer to the hardware acceleration option.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DrawCircle)(ISurface *surface, ICircle *circle, GfxOpt *opt);
+
+    /**
+     * @brief Blits bitmaps.
+     *
+     * During bit blit, color space conversion (CSC), scaling, and rotation can be implemented.
+     *
+     * @param srcSurface Indicates the pointer to the source bitmap.
+     * @param srcRect Indicates the pointer to the rectangle of the source bitmap.
+     * @param dstSurface Indicates the pointer to the destination bitmap.
+     * @param dstRect Indicates the pointer to the rectangle of the destination bitmap.
+     * @param opt Indicates the pointer to the hardware acceleration option.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*Blit)(ISurface *srcSurface, IRect *srcRect, ISurface *dstSurface, IRect *dstRect, GfxOpt *opt);
+
+    /**
+     * @brief Synchronizes hardware acceleration when it is used to draw and blit bitmaps.
+     *
+     * This function blocks the process until hardware acceleration is complete.
+     *
+     * @param timeOut Indicates the timeout duration for hardware acceleration synchronization. The value <b>0</b>
+     * indicates no timeout, so the process waits until hardware acceleration is complete.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*Sync)(int32_t timeOut);
+} GfxFuncs;
+
+/**
+ * @brief Initializes the hardware acceleration module to obtain the pointer to functions for hardware acceleration
+ * operations.
+ *
+ * @param funcs Indicates the double pointer to functions for hardware acceleration operations. Memory is allocated
+ * automatically when you initiate the hardware acceleration module, so you can simply use the pointer to gain access
+ * to the functions.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+ * otherwise.
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t GfxInitialize(GfxFuncs **funcs);
+
+/**
+ * @brief Deinitializes the hardware acceleration module to release the pointer to functions for hardware
+ * acceleration operations.
+ *
+ * @param funcs Indicates the pointer to the functions for hardware acceleration operations.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+ * otherwise.
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t GfxUninitialize(GfxFuncs *funcs);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/** @} */
diff --git a/ohos_ndk_aosp/includes/display/display_gralloc.h b/ohos_ndk_aosp/includes/display/display_gralloc.h
new file mode 100644
index 0000000000..44617418b4
--- /dev/null
+++ b/ohos_ndk_aosp/includes/display/display_gralloc.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Display
+ * @{
+ *
+ * @brief Defines driver functions of the display module.
+ *
+ * This module provides driver functions for the graphics subsystem, including graphics layer management,
+ * device control, graphics hardware acceleration, display memory management, and callbacks.
+ * @since 1.0
+ * @version 2.0
+ */
+
+
+/**
+ * @file display_gralloc.h
+ *
+ * @brief Declares the driver functions for memory.
+ *
+ * @since 1.0
+ * @version 2.0
+ */
+
+#ifndef DISPLAY_GRALLOC_H
+#define DISPLAY_GRALLOC_H
+#include "display_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Defines pointers to the memory driver functions.
+ */
+typedef struct {
+    /**
+     * @brief Allocates memory based on the parameters passed by the GUI.
+     *
+     * @param info Indicates the pointer to the description info of the memory to allocate.
+     *
+     * @param handle Indicates the double pointer to the buffer of the memory to allocate.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*AllocMem)(const AllocInfo* info, BufferHandle** handle);
+
+    /**
+     * @brief Releases memory.
+     *
+     * @param handle Indicates the pointer to the buffer of the memory to release.
+     *
+     * @since 1.0
+     * @version 1.0
+     */
+    void (*FreeMem)(BufferHandle *handle);
+
+    /**
+     * @brief Maps memory to memory without cache in the process's address space.
+     *
+     * @param handle Indicates the pointer to the buffer of the memory to map.
+     *
+     * @return Returns the pointer to a valid address if the operation is successful; returns <b>NULL</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    void *(*Mmap)(BufferHandle *handle);
+
+    /**
+     * @brief Maps memory to memory with cache in the process's address space.
+     *
+     * @param handle Indicates the pointer to the buffer of the memory to map.
+     *
+     * @return Returns the pointer to a valid address if the operation is successful; returns <b>NULL</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    void *(*MmapCache)(BufferHandle *handle);
+
+    /**
+     * @brief Unmaps memory, that is, removes any mappings in the process's address space.
+     *
+     * @param handle Indicates the pointer to the buffer of the memory to unmap.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*Unmap)(BufferHandle *handle);
+
+    /**
+     * @brief Flushes data from the cache to memory and invalidates the data in the cache.
+     *
+     * @param handle Indicates the pointer to the buffer of the cache to flush.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*FlushCache)(BufferHandle *handle);
+
+    /**
+     * @brief Flushes data from the cache mapped via {@link Mmap} to memory and invalidates the data in the cache.
+     *
+     * @param handle Indicates the pointer to the buffer of the cache to flush.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*FlushMCache)(BufferHandle *handle);
+
+    /**
+     * @brief Invalidate the Cache, it will update the cache from memory.
+     *
+     * @param handle Indicates the pointer to the buffer of the cache which will been invalidated
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*InvalidateCache)(BufferHandle* handle);
+} GrallocFuncs;
+
+/**
+ * @brief Initializes the memory module to obtain the pointer to functions for memory operations.
+ *
+ * @param funcs Indicates the double pointer to functions for memory operations. Memory is allocated automatically when
+ * you initiate the memory module initialization, so you can simply use the pointer to gain access to the functions.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+ * otherwise.
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t GrallocInitialize(GrallocFuncs **funcs);
+
+/**
+ * @brief Deinitializes the memory module to release the memory allocated to the pointer to functions for memory
+ * operations.
+ *
+ * @param funcs Indicates the pointer to functions for memory operations.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+ * otherwise.
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t GrallocUninitialize(GrallocFuncs *funcs);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/** @} */
diff --git a/ohos_ndk_aosp/includes/display/display_layer.h b/ohos_ndk_aosp/includes/display/display_layer.h
new file mode 100644
index 0000000000..8fe2c95df3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/display/display_layer.h
@@ -0,0 +1,749 @@
+/*
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Display
+ * @{
+ *
+ * @brief Defines driver functions of the display module.
+ *
+ * This module provides driver functions for the graphics subsystem, including graphics layer management,
+ * device control, graphics hardware acceleration, display memory management, and callbacks.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+
+/**
+ * @file display_layer.h
+ *
+ * @brief Declares the driver functions for implementing layer operations.
+ *
+ * @since 1.0
+ * @version 2.0
+ */
+
+#ifndef DISPLAY_LAYTER_H
+#define DISPLAY_LAYTER_H
+#include "display_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Defines pointers to the layer driver functions.
+ */
+typedef struct {
+    /**
+     * @brief Initializes a display device.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see DeinitDisplay
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*InitDisplay)(uint32_t devId);
+
+    /**
+     * @brief Deinitializes a display device.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see InitDisplay
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*DeinitDisplay)(uint32_t devId);
+
+    /**
+     * @brief Obtains information about a display device.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param dispInfo Indicates the pointer to the display device information obtained.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetDisplayInfo)(uint32_t devId, DisplayInfo *dispInfo);
+
+    /**
+     * @brief Opens a layer on a specified display device.
+     *
+     * Before using a layer on the GUI, you must open the layer based on the layer information. After the layer is
+     * opened, you can obtain the layer ID and then use other functions based on the layer ID.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerInfo Indicates the pointer to the layer information passed to open a layer, including the layer
+     * type, layer size, and pixel format.
+     * @param layerId Indicates the pointer to the layer ID, which uniquely identifies a layer. The layer ID is returned
+     * to the GUI after the layer is successfully opened.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see CloseLayer
+     * @since 1.0
+     * @version 1.0
+     */
+
+    int32_t (*CreateLayer)(uint32_t devId, const LayerInfo *layerInfo, uint32_t *layerId);
+    /**
+     * @brief Closes a layer that is no longer required on a specified display device.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see OpenLayer
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*CloseLayer)(uint32_t devId, uint32_t layerId);
+
+    /**
+     * @brief Sets whether a layer is visible.
+     *
+     * A visible layer is displayed on the screen, whereas an invisible layer is not displayed on the screen.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param visible Indicates the visibility to set for the layer. The value <b>true</b> means to set the layer to be
+     * visible, and <b>false</b> means the opposite.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerVisibleState
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerVisible)(uint32_t devId, uint32_t layerId, bool visible);
+
+    /**
+     * @brief Checks whether a layer is visible.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param visible Indicates the pointer to the obtained layer visibility. The value <b>true</b> indicates that the
+     * layer is visible, and <b>false</b> indicates that the layer is invisible.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerVisible
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerVisibleState)(uint32_t devId, uint32_t layerId, bool *visible);
+
+    /**
+     * @brief Sets the size of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param rect Indicates the pointer to the layer size to set, in pixels.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerSize
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerSize)(uint32_t devId, uint32_t layerId, IRect *rect);
+
+    /**
+     * @brief Obtains the size of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param rect Indicates the pointer to the obtained layer size.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerSize
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerSize)(uint32_t devId, uint32_t layerId, IRect *rect);
+
+    /**
+     * @brief Sets the rectangular area to crop for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param rect Indicates the pointer to the rectangular area to crop.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerCrop)(uint32_t devId, uint32_t layerId, IRect *rect);
+
+    /**
+     * @brief Sets the z-order for a layer.
+     *
+     * A larger z-order value indicates a higher layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param zorder Indicates the z-order to set. The value is an integer ranging from 0 to 255.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerZorder
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerZorder)(uint32_t devId, uint32_t layerId, uint32_t zorder);
+
+    /**
+     * @brief Obtains the z-order of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param zorder Indicates the pointer to the obtained z-order. The value is an integer ranging from 0 to 255.
+     * A larger z-order value indicates a higher layer.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerZorder
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerZorder)(uint32_t devId, uint32_t layerId, uint32_t *zorder);
+
+    /**
+     * @brief Sets layer premultiplication.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param preMul Specifies whether to enable layer premultiplication. The value <b>1</b> means to enable layer
+     * premultiplication, and <b>0</b> means the opposite.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerPreMulti
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerPreMulti)(uint32_t devId, uint32_t layerId, bool preMul);
+
+    /**
+     * @brief Obtains the premultiplication flag of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param preMul Indicates the pointer to the obtained layer premultiplication flag.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerPreMulti
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerPreMulti)(uint32_t devId, uint32_t layerId, bool *preMul);
+
+    /**
+     * @brief Sets the alpha value for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param alpha Indicates the pointer to the alpha value to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerAlpha
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerAlpha)(uint32_t devId, uint32_t layerId, LayerAlpha *alpha);
+
+    /**
+     * @brief Obtains the alpha value of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param alpha Indicates the pointer to the obtained alpha value.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerAlpha
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerAlpha)(uint32_t devId, uint32_t layerId, LayerAlpha *alpha);
+
+    /**
+     * @brief Sets the color key for a layer. The color key is used during layer overlay.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param enable Specify whether to enable the color key.
+     * @param key Indicates the color key.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerColorKey
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerColorKey)(uint32_t devId, uint32_t layerId, bool enable, uint32_t key);
+
+    /**
+     * @brief Obtains the color key of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param enable Indicates the pointer to the color key enable bit.
+     * @param key Indicates the pointer to the color key.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerColorKey
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerColorKey)(uint32_t devId, uint32_t layerId, bool *enable, uint32_t *key);
+
+    /**
+     * @brief Sets the palette for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param palette Indicates the pointer to the palette to set.
+     * @param len Indicates the length of the palette.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerPalette
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerPalette)(uint32_t devId, uint32_t layerId, uint32_t *palette, uint32_t len);
+
+    /**
+     * @brief Obtains the palette of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param palette Indicates the pointer to the obtained palette.
+     * @param len Indicates the length of the palette.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerPalette
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerPalette)(uint32_t devId, uint32_t layerId, uint32_t *palette, uint32_t len);
+
+    /**
+     * @brief Sets the transform mode for rotating, scaling, or moving a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param type Indicates the transformation mode to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetTransformMode)(uint32_t devId, uint32_t layerId, TransformType type);
+
+    /**
+     * @brief Sets the compression feature for a layer.
+     *
+     * In specific scenarios, images need to be compressed. You can set whether to enable layer compression.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param compType Specifies whether to enable the compression feature. The value <b>true>/b> means to enable
+     * compression, and <b>false> means the opposite.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see GetLayerCompression
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerCompression)(uint32_t devId, uint32_t layerId, int32_t compType);
+
+    /**
+     * @brief Checks whether the compression feature is enabled for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param compType Indicates the pointer to the variable specifying whether the compression feature is enabled.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see SetLayerCompression
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerCompression)(uint32_t devId, uint32_t layerId, int32_t *compType);
+
+    /**
+     * @brief Sets the flushing area for a layer.
+     *
+     * After the GUI draws an image, you must set the layer flushing area before calling the {@link Flush} function to
+     * flush the screen.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param region Indicates the pointer to the flushing area to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerDirtyRegion)(uint32_t devId, uint32_t layerId, IRect *region);
+
+    /**
+     * @brief Obtains the buffer of a layer.
+     *
+     * After drawing a picture in the buffer, the application calls the {@link Flush} function to display the picture
+     * on the screen.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param buffer Indicates the pointer to the obtained buffer.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @see Flush
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerBuffer)(uint32_t devId, uint32_t layerId, LayerBuffer *buffer);
+
+    /**
+     * @brief Flushes a layer.
+     *
+     * Display data in the buffer is flushed to a specified layer so that the image data is displayed on the screen.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param buffer Indicates the pointer to the buffer in which the display data is to flush.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*Flush)(uint32_t devId, uint32_t layerId, LayerBuffer *buffer);
+
+    /**
+     * @brief Waits for the arrival of vertical blanking.
+     *
+     * This function blocks the process until vertical blanking arrives, implementing the synchronization between
+     * software and hardware.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param timeOut Indicates the maximum duration that the process waits for the arrival of vertical blanking.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*WaitForVBlank)(uint32_t devId, uint32_t layerId, int32_t timeOut);
+
+    /**
+     * @brief Implements the snapshot feature.
+     *
+     * This function saves the screenshot of image data on the display device to the buffer for debugging or as
+     * requested by applications.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param buffer Indicates the pointer to the buffer for saving screenshots.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SnapShot)(uint32_t devId, LayerBuffer *buffer);
+
+    /**
+     * @brief Set the visible region for a layer
+     *
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param num Indiactes the count of rect. the region contains multiple IRect, the num means how much rects in the
+     * region.
+     * @param rect Indiactes the pointer of the rectes.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 2.0
+     * @version 2.0
+     */
+    int32_t (*SetLayerVisibleRegion)(uint32_t devId, uint32_t layerId, uint32_t num, IRect *rect);
+
+    /**
+     * @brief Set the buffer for a layer.
+     *
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param buffer Indiactes pointer of the buffer handle, the buffer handle should contain all the information of the
+     * buffer which will been used for composition
+     * @param fence Indiactes the fd of a sync file
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 2.0
+     * @version 2.0
+     */
+    int32_t (*SetLayerBuffer)(uint32_t devId, uint32_t layerId, const BufferHandle *buffer, int32_t fence);
+
+    /**
+     * @brief Extension interface
+     *
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param cmd Indiactes externsion cmd, the implement will use it to identify different intention
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 2.0
+     * @version 2.0
+     */
+    int32_t (*InvokeLayerCmd)(uint32_t devId, uint32_t layerId, uint32_t cmd, ...);
+
+    /**
+     * @brief set the composition type which the client expect
+     *
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param type Indicates composition type which the client expect, it may be chagne by the implement
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 2.0
+     * @version 2.0
+     */
+    int32_t (*SetLayerCompositionType)(uint32_t devId, uint32_t layerId, CompositionType type);
+
+    /**
+     * @brief set the blend type
+     *
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param type Indicates blend type
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 2.0
+     * @version 2.0
+     */
+    int32_t (*SetLayerBlendType)(uint32_t devId, uint32_t layerId, BlendType type);
+
+    /**
+     * @brief Sets a 4x4 color transformation matrix.
+     *
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param matrix Indicates the 4x4 color transformation matrix.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerColorTransform)(uint32_t devId, uint32_t layerId, const float *matrix);
+
+    /**
+     * @brief Sets a color data space for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param colorSpace Indicates the color data space to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerColorDataSpace)(uint32_t devId, uint32_t layerId, ColorDataSpace colorSpace);
+
+    /**
+     * @brief Obtains the color data space of a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param colorSpace Indicates the pointer to the color data space obtained.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*GetLayerColorDataSpace)(uint32_t devId, uint32_t layerId, ColorDataSpace *colorSpace);
+
+    /**
+     * @brief Sets metadata for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param num Indicates the number of metadata records.
+     * @param metaData Indicates the pointer to the metadata to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerMetaData)(uint32_t devId, uint32_t layerId, uint32_t num, const HDRMetaData *metaData);
+
+    /**
+     * @brief Sets a metadata set for a layer.
+     *
+     * @param devId Indicates the ID of the display device. The value ranges from 0 to 4, where 0 indicates the first
+     * display device, and 4 indicates the last display device.
+     * @param layerId Indicates the layer ID, which uniquely identifies a layer. You can perform operations on the layer
+     * with the specified layer ID.
+     * @param key Indicates the metadata key.
+     * @param num Indicates the number of metadata records.
+     * @param metaData Indicates the pointer to the metadata set of the uint8_t type to set.
+     *
+     * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+     * otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    int32_t (*SetLayerMetaDataSet)(uint32_t devId, uint32_t layerId, HDRMetadataKey key, uint32_t num,
+                                   const uint8_t *metaData);
+} LayerFuncs;
+
+/**
+ * @brief Initializes the layer to apply for resources used by the layer and obtain the pointer to functions for
+ * layer operations.
+ *
+ * @param funcs Indicates the double pointer to functions for layer operations. Memory is allocated automatically when
+ * you initiate the layer module, so you can simply use the pointer to gain access to the functions.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+ * otherwise.
+ * @see LayerUninitialize
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t LayerInitialize(LayerFuncs **funcs);
+
+/**
+ * @brief Deinitializes the layer module to release the memory allocated to the pointer to functions for
+ * layer operations.
+ *
+ * @param funcs Indicates the pointer to functions for layer operations.
+ *
+ * @return Returns <b>0</b> if the operation is successful; returns an error code defined in {@link DispErrCode}
+ * otherwise.
+ * @see LayerInitialize
+ * @since 1.0
+ * @version 1.0
+ */
+int32_t LayerUninitialize(LayerFuncs *funcs);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/** @} */
diff --git a/ohos_ndk_aosp/includes/display/display_type.h b/ohos_ndk_aosp/includes/display/display_type.h
new file mode 100644
index 0000000000..438f1dd2e7
--- /dev/null
+++ b/ohos_ndk_aosp/includes/display/display_type.h
@@ -0,0 +1,608 @@
+/*
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @addtogroup Display
+ * @{
+ *
+ * @brief Defines driver functions of the display module.
+ *
+ * This module provides driver functions for the graphics subsystem, including graphics layer management,
+ * device control, graphics hardware acceleration, display memory management, and callbacks.
+ *
+ * @since 1.0
+ * @version 2.0
+ */
+
+/**
+ * @file display_type.h
+ *
+ * @brief Declares the data types used by the display driver functions.
+ *
+ * @since 1.0
+ * @version 2.0
+ */
+
+#ifndef DISPLAY_TYPE_H
+#define DISPLAY_TYPE_H
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/prctl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdint.h>
+#include "buffer_handle.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Enumerates return values of the functions.
+ *
+ */
+typedef enum {
+    DISPLAY_SUCCESS = 0,           /**< Success */
+    DISPLAY_FAILURE = -1,          /**< Failure */
+    DISPLAY_FD_ERR = -2,           /**< File handle (FD) error */
+    DISPLAY_PARAM_ERR = -3,        /**< Parameter error */
+    DISPLAY_NULL_PTR = -4,         /**< Null pointer */
+    DISPLAY_NOT_SUPPORT = -5,      /**< Unsupported feature */
+    DISPLAY_NOMEM = -6,            /**< Insufficient memory */
+    DISPLAY_SYS_BUSY = -7,         /**< System busy */
+    DISPLAY_NOT_PERM = -8          /**< Forbidden operation */
+} DispErrCode;
+
+/**
+ * @brief Enumerates layer types.
+ *
+ */
+typedef enum {
+    LAYER_TYPE_GRAPHIC,         /**< Graphic layer */
+    LAYER_TYPE_OVERLAY,         /**< Overlay layer */
+    LAYER_TYPE_SDIEBAND,        /**< Sideband layer */
+    LAYER_TYPE_CURSOR,          /**< Cursor Layer */
+    LAYER_TYPE_BUTT             /**< Empty layer */
+} LayerType;
+
+/* *
+ * @brief Defines the buffer usage.
+ *
+ */
+enum {
+    HBM_USE_CPU_READ = (1 << 0),        /**< CPU will read the memory */
+    HBM_USE_CPU_WRITE = (1 << 1),       /**< CPU will write the memory */
+    HBM_USE_MEM_MMZ = (1 << 2),         /**< will use mmz to allocate memory */
+    HBM_USE_MEM_DMA = (1 << 3),         /**< the allocator should support dma buffer */
+    HBM_USE_MEM_SHARE = (1 << 4),       /**< the allocator should support shared memory buffer*/
+    HBM_USE_MEM_MMZ_CACHE = (1 << 5),   /**< will use mmz to allocate memory with cache*/
+    HBM_USE_MEM_FB = (1 << 6),          /**< the buffer allocate for framebuffer */
+    HBM_USE_ASSIGN_SIZE = (1 << 7),     /**< assign memory size from requester */
+};
+
+/**
+ * @brief Enumerates pixel formats.
+ *
+ */
+typedef enum {
+    PIXEL_FMT_CLUT8 = 0,        /**< CLUT8 format */
+    PIXEL_FMT_CLUT1,            /**< CLUT1 format */
+    PIXEL_FMT_CLUT4,            /**< CLUT4 format */
+    PIXEL_FMT_RGB_565,          /**< RGB565 format */
+    PIXEL_FMT_RGBA_5658,        /**< RGBA5658 format */
+    PIXEL_FMT_RGBX_4444,        /**< RGBX4444 format */
+    PIXEL_FMT_RGBA_4444,        /**< RGBA4444 format */
+    PIXEL_FMT_RGB_444,          /**< RGB444 format */
+    PIXEL_FMT_RGBX_5551,        /**< RGBX5551 format */
+    PIXEL_FMT_RGBA_5551,        /**< RGBA5551 format */
+    PIXEL_FMT_RGB_555,          /**< RGB555 format */
+    PIXEL_FMT_RGBX_8888,        /**< RGBX8888 format */
+    PIXEL_FMT_RGBA_8888,        /**< RGBA8888 format */
+    PIXEL_FMT_RGB_888,          /**< RGB888 format */
+    PIXEL_FMT_BGR_565,          /**< BGR565 format */
+    PIXEL_FMT_BGRX_4444,        /**< BGRX4444 format */
+    PIXEL_FMT_BGRA_4444,        /**< BGRA4444 format */
+    PIXEL_FMT_BGRX_5551,        /**< BGRX5551 format */
+    PIXEL_FMT_BGRA_5551,        /**< BGRA5551 format */
+    PIXEL_FMT_BGRX_8888,        /**< BGRX8888 format */
+    PIXEL_FMT_BGRA_8888,        /**< BGRA8888 format */
+    PIXEL_FMT_YUV_422_I,        /**< YUV422 interleaved format */
+    PIXEL_FMT_YCBCR_422_SP,     /**< YCBCR422 semi-planar format */
+    PIXEL_FMT_YCRCB_422_SP,     /**< YCRCB422 semi-planar format */
+    PIXEL_FMT_YCBCR_420_SP,     /**< YCBCR420 semi-planar format */
+    PIXEL_FMT_YCRCB_420_SP,     /**< YCRCB420 semi-planar format */
+    PIXEL_FMT_YCBCR_422_P,      /**< YCBCR422 planar format */
+    PIXEL_FMT_YCRCB_422_P,      /**< YCRCB422 planar format */
+    PIXEL_FMT_YCBCR_420_P,      /**< YCBCR420 planar format */
+    PIXEL_FMT_YCRCB_420_P,      /**< YCRCB420 planar format */
+    PIXEL_FMT_YUYV_422_PKG,     /**< YUYV422 packed format */
+    PIXEL_FMT_UYVY_422_PKG,     /**< UYVY422 packed format */
+    PIXEL_FMT_YVYU_422_PKG,     /**< YVYU422 packed format */
+    PIXEL_FMT_VYUY_422_PKG,     /**< VYUY422 packed format */
+    PIXEL_FMT_BUTT              /**< Invalid pixel format */
+} PixelFormat;
+
+/**
+ * @brief Enumerates transform types of images.
+ *
+ */
+typedef enum {
+    ROTATE_NONE = 0,        /**< No rotation */
+    ROTATE_90,              /**< Rotation by 90 degrees */
+    ROTATE_180,             /**< Rotation by 180 degrees */
+    ROTATE_270,             /**< Rotation by 270 degrees */
+    ROTATE_BUTT             /**< Invalid operation */
+} TransformType;
+
+/**
+ * @brief Enumerates image blending types.
+ *
+ * The system combines images based on a specified blending type during hardware acceleration.
+ *
+ */
+typedef enum {
+    BLEND_NONE = 0,         /**< No blending */
+    BLEND_CLEAR,            /**< CLEAR blending */
+    BLEND_SRC,              /**< SRC blending */
+    BLEND_SRCOVER,          /**< SRC_OVER blending */
+    BLEND_DSTOVER,          /**< DST_OVER blending */
+    BLEND_SRCIN,            /**< SRC_IN blending */
+    BLEND_DSTIN,            /**< DST_IN blending */
+    BLEND_SRCOUT,           /**< SRC_OUT blending */
+    BLEND_DSTOUT,           /**< DST_OUT blending */
+    BLEND_SRCATOP,          /**< SRC_ATOP blending */
+    BLEND_DSTATOP,          /**< DST_ATOP blending */
+    BLEND_ADD,              /**< ADD blending */
+    BLEND_XOR,              /**< XOR blending */
+    BLEND_DST,              /**< DST blending */
+    BLEND_AKS,              /**< AKS blending */
+    BLEND_AKD,              /**< AKD blending */
+    BLEND_BUTT              /**< Null operation */
+} BlendType;
+
+/**
+ * @brief Enumerates ROP types supported by hardware acceleration.
+ *
+ * ROP performs bitwise Boolean operations (including bitwise AND and bitwise OR) on the RGB color and
+ * alpha values of the foreground bitmap with those of the background bitmap, and then outputs the result.
+ *
+ */
+typedef enum {
+    ROP_BLACK = 0,          /**< Blackness */
+    ROP_NOTMERGEPEN,        /**< ~(S2+S1) */
+    ROP_MASKNOTPEN,         /**< ~S2&S1 */
+    ROP_NOTCOPYPEN,         /**< ~S2 */
+    ROP_MASKPENNOT,         /**< S2&~S1 */
+    ROP_NOT,                /**< ~S1 */
+    ROP_XORPEN,             /**< S2^S1 */
+    ROP_NOTMASKPEN,         /**< ~(S2&S1) */
+    ROP_MASKPEN,            /**< S2&S1 */
+    ROP_NOTXORPEN,          /**< ~(S2^S1) */
+    ROP_NOP,                /**< S1 */
+    ROP_MERGENOTPEN,        /**< ~S2+S1 */
+    ROP_COPYPE,             /**< S2 */
+    ROP_MERGEPENNOT,        /**< S2+~S1 */
+    ROP_MERGEPEN,           /**< S2+S1 */
+    ROP_WHITE,              /**< Whiteness */
+    ROP_BUTT                /**< Invalid ROP type */
+} RopType;
+
+/**
+ * @brief Enumerates color key types supported by hardware acceleration.
+ *
+ */
+typedef enum {
+    CKEY_NONE = 0,      /**< No color key */
+    CKEY_SRC,           /**< Source color key */
+    CKEY_DST,           /**< Destination color key */
+    CKEY_BUTT           /**< Null operation */
+} ColorKey;
+
+/**
+ * @brief Enumerates mirror types supported by hardware acceleration.
+ *
+ */
+typedef enum {
+    MIRROR_NONE = 0,      /**< No mirror */
+    MIRROR_LR,            /**< Left and right mirrors */
+    MIRROR_TB,            /**< Top and bottom mirrors */
+    MIRROR_BUTT           /**< Null operation */
+} MirrorType;
+
+/**
+ * @brief Enumerates connection types of hot plugging.
+ *
+ */
+typedef enum {
+    INVALID = 0,         /**< Invalid connection */
+    CONNECTED,           /**< Connected */
+    DISCONNECTED         /**< Disconnected */
+} Connection;
+
+/**
+ * @brief Defines display information.
+ *
+ */
+typedef struct {
+    uint32_t width;              /**< Display width */
+    uint32_t height;             /**< Display height */
+    int32_t rotAngle;            /**< Rotation angle of the display */
+} DisplayInfo;
+
+/**
+ * @brief Defines layer information.
+ *
+ * <b>LayerInfo</b> must be passed to the {@link OpenLayer} function, which creates a layer based on the layer
+ * information.
+ *
+ */
+typedef struct {
+    int32_t width;              /**< Layer width */
+    int32_t height;             /**< Layer height */
+    LayerType type;             /**< Layer type, which can be a graphic layer, overlay layer, or sideband layer */
+    int32_t bpp;                /**< Number of bits occupied by each pixel */
+    PixelFormat pixFormat;      /**< Pixel format of the layer */
+} LayerInfo;
+
+/**
+ * @brief Defines alpha information about a layer.
+ *
+ */
+typedef struct {
+    bool enGlobalAlpha;   /**< Global alpha enable bit */
+    bool enPixelAlpha;    /**< Pixel alpha enable bit */
+    uint8_t alpha0;       /**< Alpha0 value, ranging from 0 to 255 */
+    uint8_t alpha1;       /**< Alpha1 value, ranging from 0 to 255 */
+    uint8_t gAlpha;       /**< Global alpha value, ranging from 0 to 255 */
+} LayerAlpha;
+
+
+/**
+ * @brief Defines buffer data of a layer, including the virtual and physical memory addresses.
+ *
+ */
+typedef struct {
+    uint64_t phyAddr;     /**< Physical memory address */
+    void *virAddr;        /**< Virtual memory address */
+} BufferData;
+
+/**
+ * @brief Defines the buffer, which is used to store layer data.
+ *
+ */
+typedef struct {
+    int32_t fenceId;          /**< Fence ID of the buffer */
+    int32_t width;            /**< Buffer width */
+    int32_t height;           /**< Buffer height */
+    int32_t pitch;            /**< Number of bytes from one row of pixels in memory to the next */
+    PixelFormat pixFormat;    /**< Pixel format of the buffer */
+    BufferData data;          /**< Layer buffer data */
+    BufferHandle* hdl;        /**< Layer buffer handle */
+} LayerBuffer;
+
+/**
+ * @brief Defines the information about a rectangle.
+ *
+ */
+typedef struct {
+    int32_t x;      /**< Start X coordinate of the rectangle */
+    int32_t y;      /**< Start Y coordinate of the rectangle */
+    int32_t w;      /**< Width of the rectangle */
+    int32_t h;      /**< Height of the rectangle */
+} IRect;
+
+/**
+ * @brief Stores surface information for hardware acceleration, such as draw image and bit blit.
+ *
+ */
+typedef struct {
+    uint64_t phyAddr;         /**< Start physical address of an image */
+    int32_t height;           /**< Image height */
+    int32_t width;            /**< Image width */
+    int32_t stride;           /**< Image stride */
+    PixelFormat enColorFmt;   /**< Image format */
+    bool bYCbCrClut;          /**< Whether the color lookup table (CLUT) is in the YCbCr space */
+    bool bAlphaMax255;        /**< Maximum alpha value of an image (255 or 128) */
+    bool bAlphaExt1555;       /**< ARGB1555 alpha extension enable bit */
+    uint8_t alpha0;           /**< Value of alpha0, ranging from 0 to 255 */
+    uint8_t alpha1;           /**< Value of alpha1, ranging from 0 to 255 */
+    uint64_t cbcrPhyAddr;     /**< CbCr physical address */
+    int32_t cbcrStride;       /**< CbCr stride */
+    uint64_t clutPhyAddr;     /**< Start physical address of the CLUT, used for color extension or correction */
+} ISurface;
+
+/**
+ * @brief Describes a line to help draw lines in hardware acceleration.
+ *
+ */
+typedef struct {
+    int32_t x0;                 /**< X coordinate of the start point of a line */
+    int32_t y0;                 /**< Y coordinate of the start point of a line */
+    int32_t x1;                 /**< X coordinate of the end point of a line */
+    int32_t y1;                 /**< Y coordinate of the end point of a line */
+    uint32_t color;             /**< Line color */
+} ILine;
+
+/**
+ * @brief Describes a circle to help draw circles in hardware acceleration.
+ *
+ */
+typedef struct {
+    int32_t x;                  /**< X coordinate of a circle center */
+    int32_t y;                  /**< Y coordinate of a circle center */
+    int32_t r;                  /**< Radius of a circle */
+    uint32_t color;             /**< Circle color */
+} ICircle;
+
+/**
+ * @brief Describes a rectangle to help draw rectangles in hardware acceleration.
+ *
+ */
+typedef struct {
+    IRect rect;                 /**< Bounds of a rectangle */
+    uint32_t color;             /**< Rectangle color */
+} Rectangle;
+
+/**
+ * @brief Defines hardware acceleration options.
+ *
+ */
+typedef struct {
+    bool enGlobalAlpha;         /**< Golbal alpha enable bit */
+    uint32_t globalAlpha;       /**< Global alpha value */
+    bool enPixelAlpha;          /**< Pixel alpha enable bit */
+    BlendType blendType;        /**< Blending type */
+    ColorKey colorKeyFrom;      /**< Color key mode */
+    bool enableRop;             /**< Raster operations pipeline (ROP) enable bit */
+    RopType colorRopType;       /**< Color ROP type */
+    RopType alphaRopType;       /**< Alpha ROP type */
+    bool enableScale;           /**< Scaling enable bit */
+    TransformType rotateType;   /**< Rotation type */
+    MirrorType mirrorType;      /**< Mirror type */
+} GfxOpt;
+
+#define PROPERTY_NAME_LEN  50
+
+/**
+ * @brief Defines property object which contains name, property id and value.
+ *
+ */
+typedef struct {
+    char name[PROPERTY_NAME_LEN]; /**< Name of the property */
+    uint32_t propId;     /**< Property id which was decided in the DRM internal */
+    uint64_t value;      /**< the value of property  */
+} PropertyObject;
+
+/**
+ * @brief Enumerates interface types.
+ *
+ */
+typedef enum {
+    DISP_INTF_HDMI = 0,       /**< HDMI interface */
+    DISP_INTF_LCD,            /**< LCD interface */
+    DISP_INTF_BT1120,         /**< BT1120 interface */
+    DISP_INTF_BT656,          /**< BT656 interface */
+    DISP_INTF_YPBPR,          /**< YPBPR interface */
+    DISP_INTF_RGB,            /**< RGB interface */
+    DISP_INTF_CVBS,           /**< CVBS interface */
+    DISP_INTF_SVIDEO,         /**< SVIDEO interface */
+    DISP_INTF_VGA,            /**< VGA interface */
+    DISP_INTF_MIPI,           /**< MIPI interface */
+    DISP_INTF_PANEL,          /**< PANEL interface */
+    DISP_INTF_BUTT,
+} InterfaceType;
+
+/**
+ * @brief Defines the capability of the output.
+ */
+typedef struct {
+    char name[PROPERTY_NAME_LEN];       /**< name of output */
+    InterfaceType type;                 /**< interface type of output */
+    uint32_t phyWidth;                  /**< Physical width */
+    uint32_t phyHeight;                 /**< Physical width */
+    uint32_t supportLayers;             /**< BitMask of LayerType */
+    uint32_t virtualDispCount;          /**< the count of virtual displays supported*/
+    bool supportWriteBack;              /**< wether support writeback*/
+    uint32_t propertyCount;             /**< Count of properties */
+    PropertyObject* props;              /**< Array of property objects */
+} DisplayCapability;
+
+/**
+ * @brief Defines output mode info
+ */
+typedef struct {
+    int32_t width;      /**< width in pixel */
+    int32_t height;     /**< height in pixel */
+    uint32_t freshRate; /**< fresh rate in one second */
+    int32_t id;         /**< the id of the mode */
+} DisplayModeInfo;
+
+/**
+ * @brief Defines information for allocate memory
+ *
+ */
+typedef struct {
+    uint32_t width;               /**< The width of the request allocation */
+    uint32_t height;              /**< The height of the request allocation */
+    uint64_t usage;               /**< The usage of the request allocation */
+    PixelFormat format;           /**< The format of the request allocation */
+    uint32_t expectedSize;        /**< The size assigned by memory requester */
+} AllocInfo;
+/**
+ * @brief Enumerates power status.
+ */
+
+typedef enum {
+    POWER_STATUS_ON,              /**< The power status is on */
+    POWER_STATUS_STANDBY,         /**< The power status is standby */
+    POWER_STATUS_SUSPEND,         /**< The power status is suspend */
+    POWER_STATUS_OFF,             /**< The power status is off */
+    POWER_STATUS_BUTT
+} DispPowerStatus;
+
+/**
+ * @brief Enumerates composition type for special layer
+ */
+typedef enum {
+    COMPOSITION_CLIENT,       /**< client composistion type, the composer should been cpu or gpu */
+    COMPOSITION_DEVICE,       /**< device composistion type, the composer should been a hardware */
+    COMPOSITION_CURSOR,       /**< cursor composistion type. it should been used for cursor */
+    COMPOSITION_VIDEO,        /**< cursor composistion type. it should been used for video */
+    COMPOSITION_BUTT
+} CompositionType;
+
+/**
+ * @brief Enumerates the color gamuts.
+ *
+ */
+typedef enum {
+    COLOR_GAMUT_INVALID = -1,            /**< Invalid */
+    COLOR_GAMUT_NATIVE = 0,              /**< Native or default */
+    COLOR_GAMUT_SATNDARD_BT601 = 1,      /**< Standard BT601 */
+    COLOR_GAMUT_STANDARD_BT709 = 2,      /**< Standard BT709 */
+    COLOR_GAMUT_DCI_P3 = 3,              /**< DCI P3 */
+    COLOR_GAMUT_SRGB = 4,                /**< SRGB */
+    COLOR_GAMUT_ADOBE_RGB = 5,           /**< Adobe RGB */
+    COLOR_GAMUT_DISPLAY_P3 = 6,          /**< display P3 */
+    COLOR_GAMUT_BT2020 = 7,              /**< BT2020 */
+    COLOR_GAMUT_BT2100_PQ = 8,           /**< BT2100 PQ */
+    COLOR_GAMUT_BT2100_HLG = 9,          /**< BT2100 HLG */
+    COLOR_GAMUT_DISPLAY_BT2020 = 10,     /**< Display BT2020 */
+} ColorGamut;
+
+/**
+ * @brief Enumerates the color gamut maps.
+ *
+ */
+typedef enum {
+    GAMUT_MAP_CONSTANT = 0,
+    GAMUT_MAP_EXPANSION = 1,
+    GAMUT_MAP_HDR_CONSTANT = 2,
+    GAMUT_MAP_HDR_EXPANSION = 3,
+} GamutMap;
+
+/**
+ * @brief Enumerates the color data spaces.
+ *
+ */
+
+typedef enum {
+    COLOR_DATA_SPACE_UNKNOWN = 0,
+    GAMUT_BT601 = 0x00000001,
+    GAMUT_BT709 = 0x00000002,
+    GAMUT_DCI_P3 = 0x00000003,
+    GAMUT_SRGB = 0x00000004,
+    GAMUT_ADOBE_RGB = 0x00000005,
+    GAMUT_DISPLAY_P3 = 0x00000006,
+    GAMUT_BT2020 = 0x00000007,
+    GAMUT_BT2100_PQ = 0x00000008,
+    GAMUT_BT2100_HLG = 0x00000009,
+    GAMUT_DISPLAY_BT2020 = 0x0000000a,
+    TRANSFORM_FUNC_UNSPECIFIED = 0x00000100,
+    TRANSFORM_FUNC_LINEAR = 0x00000200,
+    TRANSFORM_FUNC_SRGB = 0x00000300,
+    TRANSFORM_FUNC_SMPTE_170M = 0x00000400,
+    TRANSFORM_FUNC_GM2_2 = 0x00000500,
+    TRANSFORM_FUNC_GM2_6 = 0x00000600,
+    TRANSFORM_FUNC_GM2_8 = 0x00000700,
+    TRANSFORM_FUNC_ST2084 = 0x00000800,
+    TRANSFORM_FUNC_HLG = 0x00000900,
+    PRECISION_UNSPECIFIED = 0x00010000,
+    PRECISION_FULL = 0x00020000,
+    PRESION_LIMITED = 0x00030000,
+    PRESION_EXTENDED = 0x00040000,
+    BT601_SMPTE170M_FULL = GAMUT_BT601 | TRANSFORM_FUNC_SMPTE_170M | PRECISION_FULL,
+    BT601_SMPTE170M_LIMITED = GAMUT_BT601 | TRANSFORM_FUNC_SMPTE_170M | PRESION_LIMITED,
+    BT709_LINEAR_FULL = GAMUT_BT709 | TRANSFORM_FUNC_LINEAR | PRECISION_FULL,
+    BT709_LINEAR_EXTENDED = GAMUT_BT709 | TRANSFORM_FUNC_LINEAR | PRESION_EXTENDED,
+    BT709_SRGB_FULL = GAMUT_BT709 | TRANSFORM_FUNC_SRGB | PRECISION_FULL,
+    BT709_SRGB_EXTENDED = GAMUT_BT709 | TRANSFORM_FUNC_SRGB | PRESION_EXTENDED,
+    BT709_SMPTE170M_LIMITED = GAMUT_BT709 | TRANSFORM_FUNC_SMPTE_170M | PRESION_LIMITED,
+    DCI_P3_LINEAR_FULL = GAMUT_DCI_P3 | TRANSFORM_FUNC_LINEAR | PRECISION_FULL,
+    DCI_P3_GAMMA26_FULL = GAMUT_DCI_P3 | TRANSFORM_FUNC_GM2_6 | PRECISION_FULL,
+    DISPLAY_P3_LINEAR_FULL = GAMUT_DISPLAY_P3 | TRANSFORM_FUNC_LINEAR | PRECISION_FULL,
+    DCI_P3_SRGB_FULL = GAMUT_DCI_P3 | TRANSFORM_FUNC_SRGB | PRECISION_FULL,
+    ADOBE_RGB_GAMMA22_FULL = GAMUT_ADOBE_RGB | TRANSFORM_FUNC_GM2_2 | PRECISION_FULL,
+    BT2020_LINEAR_FULL = GAMUT_BT2020 | TRANSFORM_FUNC_LINEAR | PRECISION_FULL,
+    BT2020_SRGB_FULL = GAMUT_BT2020 | TRANSFORM_FUNC_SRGB | PRECISION_FULL,
+    BT2020_SMPTE170M_FULL = GAMUT_BT2020 | TRANSFORM_FUNC_SMPTE_170M | PRECISION_FULL,
+    BT2020_ST2084_FULL = GAMUT_BT2020 | TRANSFORM_FUNC_ST2084 | PRECISION_FULL,
+    BT2020_HLG_FULL = GAMUT_BT2020 | TRANSFORM_FUNC_HLG | PRECISION_FULL,
+    BT2020_ST2084_LIMITED = GAMUT_BT2020 | TRANSFORM_FUNC_ST2084 | PRESION_LIMITED,
+} ColorDataSpace;
+
+/**
+ * @brief Enumerates the HDR formats.
+ *
+ */
+typedef enum {
+    NOT_SUPPORT_HDR = 0,
+    DOLBY_VISION = 1,
+    HDR10 = 2,
+    HLG = 3,
+    HDR10_PLUS = 4,
+    HDR_VIVID = 5,
+} HDRFormat;
+
+/**
+ * @brief Defines the HDR capability.
+ *
+ */
+typedef struct {
+    uint32_t formatCount;
+    HDRFormat* formats;
+    float maxLum;
+    float maxAverageLum;
+    float minLum;
+} HDRCapability;
+
+/**
+ * @brief Enumerates the HDR metadata keys.
+ *
+ */
+typedef enum {
+    MATAKEY_RED_PRIMARY_X = 0,
+    MATAKEY_RED_PRIMARY_Y = 1,
+    MATAKEY_GREEN_PRIMARY_X = 2,
+    MATAKEY_GREEN_PRIMARY_Y = 3,
+    MATAKEY_BLUE_PRIMARY_X = 4,
+    MATAKEY_BLUE_PRIMARY_Y = 5,
+    MATAKEY_WHITE_PRIMARY_X = 6,
+    MATAKEY_WHITE_PRIMARY_Y = 7,
+    MATAKEY_MAX_LUMINANCE = 8,
+    MATAKEY_MIN_LUMINANCE = 9,
+    MATAKEY_MAX_CONTENT_LIGHT_LEVEL = 10,
+    MATAKEY_MAX_FRAME_AVERAGE_LIGHT_LEVEL = 11,
+    MATAKEY_HDR10_PLUS = 12,
+    MATAKEY_HDR_VIVID = 13,
+} HDRMetadataKey;
+
+/**
+ * @brief Defines the HDR metadata.
+ *
+ */
+typedef struct {
+    HDRMetadataKey key;
+    float value;
+} HDRMetaData;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/* @} */
diff --git a/ohos_ndk_aosp/includes/display/display_vgu.h b/ohos_ndk_aosp/includes/display/display_vgu.h
new file mode 100644
index 0000000000..6214bfaa1a
--- /dev/null
+++ b/ohos_ndk_aosp/includes/display/display_vgu.h
@@ -0,0 +1,769 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* *
+ * @addtogroup Display
+ * @{
+ *
+ * @brief Defines driver functions of the display module.
+ *
+ * This module provides driver functions for the graphics subsystem, including graphics layer management,
+ * device control, graphics hardware acceleration, display memory management, and callbacks.
+ *
+ * @since 3.0
+ */
+
+/* *
+ * @file display_vgu.h
+ *
+ * @brief Declares the driver functions for implementing 2D vector hardware acceleration.
+ *
+ * @since 3.0
+ */
+
+#ifndef DISPLAY_VGU_H
+#define DISPLAY_VGU_H
+#include "display_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#undef HDI_VGU_SCALAR_IS_FLOAT
+#define HDI_VGU_SCALAR_IS_FLOAT 1
+
+#ifdef HDI_VGU_SCALAR_IS_FLOAT
+typedef float VGUScalar;
+#else
+typedef int32_t VGUScalar;
+#endif
+
+typedef PixelFormat VGUPixelFormat;     /* < Pixel formats */
+typedef BlendType VGUBlendType;         /* < Blend types supported by hardware acceleration */
+
+/* *
+ * @brief Enumerates data types of paths.
+ *
+ */
+typedef enum {
+    VGU_DATA_TYPE_S16 = 0,  /* < Integer (2 bytes) */
+    VGU_DATA_TYPE_S32,      /* < Integer (4 bytes) */
+    VGU_DATA_TYPE_F32       /* < Floating point number (4 bytes) */
+} VGUPathDataType;
+
+/* *
+ * @brief Enumerates supported hardware acceleration capabilities.
+ *
+ */
+typedef enum {
+    VGU_CAP_BLIT = (1 << 0),        /* < Bit blit */
+    VGU_CAP_BLIT_NUM = (1 << 1),    /* < Maximum number of images that can be combined during bit blit */
+    VGU_CAP_PATH = (1 << 2),        /* < Path filling and stroking */
+    VGU_CAP_FILTER_BLUR = (1 << 3), /* < Blur filter */
+} VGUCapability;
+
+/* *
+ * @brief Enumerates result codes that may return.
+ *
+ */
+typedef enum {
+    VGU_SUCCESS = 0,            /* < The operation is successful. */
+    VGU_NO_SUPPORT = -1,        /* < This feature is not supported. */
+    VGU_OPERATION_FAILED = -2,   /* < The operation failed. */
+    VGU_OUT_OF_MEMORY = -3,     /* < The operation ran out of memory. */
+    VGU_TIMEOUT = -4,           /* < The operation times out. */
+    VGU_INVALID_PARAMETER = -5, /* < One or more parameters are invalid. */
+    VGU_BUSY = -6,              /* < The device is busy. */
+    VGU_NO_CONTEXT = -7,        /* < There is no context specified. */
+} VGUResult;
+
+/* *
+ * @brief Enumerates styles for the endpoints of a stroked line.
+ *
+ */
+typedef enum {
+    VGU_LINECAP_BUTT = 0,   /* < A line with a squared-off end (default value) */
+    VGU_LINECAP_ROUND,      /* < A line with a rounded end */
+    VGU_LINECAP_SQUARE      /* < A line with a squared-off end */
+} VGULineCap;
+
+/* *
+ * @brief Enumerates join types for stroked lines.
+ *
+ */
+typedef enum {
+    VGU_LINE_JOIN_MITER = 0,    /* < A join with a sharp corner (default value) */
+    VGU_LINE_JOIN_ROUND,        /* < A join with a rounded end */
+    VGU_LINE_JOIN_BEVEL,        /* < A join with a squared-off end */
+    VGU_LINE_JOIN_BUTT          /* < Invalid definition */
+} VGUJointType;
+
+/* *
+ * @brief Defines the coordinates of a point.
+ *
+ */
+typedef struct {
+    VGUScalar x;    /* < Horizontal coordinate of the point */
+    VGUScalar y;    /* < Vertical coordinate of the point */
+} VGUPoint;
+
+/* *
+ * @brief Defines a rectangle.
+ *
+ */
+typedef struct {
+    VGUScalar x; /* < Horizontal coordinate of the start point of the rectangle */
+    VGUScalar y; /* < Vertical coordinate of the start point of the rectangle */
+    VGUScalar w; /* < Width of the rectangle */
+    VGUScalar h; /* < Height of the rectangle */
+} VGURect;
+
+/* *
+ * @brief Enumerates filter types for rendering an image.
+ *
+ */
+typedef enum {
+    VGU_FILTER_BILINEAR = 0,    /* < Bilinear interpolation filter (default value) */
+    VGU_FILTER_NEAREST,         /* < No interpolation filter */
+    VGU_FILTER_LINEAR,          /* < Linear interpolation filter */
+    VGU_FILTER_BUTT             /* < Invalid definition */
+} VGUFilter;
+
+/* *
+ * @brief Enumerates fill rules for graphics.
+ *
+ */
+typedef enum {
+    VGU_RULE_WINDING = 0,   /* < Non-zero winding rule (default value) */
+    VGU_RULE_EVEN_ODD,      /* < Even-odd rule */
+    VGU_RULE_BUTT           /* < Invalid definition */
+} VGUFillRule;
+
+/* *
+ * @brief Enumerates fill types of the outside of the gradient area.
+ *
+ */
+typedef enum {
+    VGU_SPREAD_PAD = 0,     /* < The area is filled with the closest gradient stop color. (Default value) */
+    VGU_SPREAD_REFLECT,     /* < The gradient is reflected outside the area. */
+    VGU_SPREAD_REPEAT,      /* < The gradient is repeated outside the area. */
+    VGU_SPREAD_BUTT         /* < Invalid definition */
+} VGUFillSpread;
+
+/* *
+ * @brief Enumerates wrap types of a pattern.
+ *
+ */
+typedef enum {
+    VGU_WRAP_REFLECT = 0,   /* < The pattern is reflected. */
+    VGU_WRAP_REPEAT,        /* < The pattern is repeated. */
+    VGU_WRAP_BUTT           /* < Invalid definition */
+} VGUWrapType;
+
+/* *
+ * @brief Enumerates commands for drawing a path.
+ *
+ */
+typedef enum {
+    VGU_PATH_CMD_CLOSE = 0,     /* < Close the current subpath (coordinates: none). */
+    VGU_PATH_CMD_MOVE,          /* < Move to the specified point (coordinates: x0, y0). */
+    VGU_PATH_CMD_LINE,          /* < Draw a line (coordinates: x0, y0). */
+    VGU_PATH_CMD_HLINE,         /* < Draw a horizontal line (coordinates: x0). */
+    VGU_PATH_CMD_VLINE,         /* < Draw a vertical line (coordinates: y0). */
+    VGU_PATH_CMD_QUAD,          /* < Draw a quadratic Bezier curve (coordinates: x0, y0, x1, y1). */
+    VGU_PATH_CMD_CUBIC,         /* < Draw a cubic Bezier curve (coordinates: x0, y0, x1, y1, x2, y2). */
+    VGU_PATH_CMD_SQUAD,         /* < Draw a smooth quadratic Bezier curve (coordinates: x1, y1). */
+    VGU_PATH_CMD_SCUBIC,        /* < Draw a smooth cubic Bezier curve (coordinates: x1, y1, x2, y2). */
+    VGU_PATH_CMD_BUTT,          /* < Invalid definition */
+} VGUPathCmd;
+
+/* *
+ * @brief Defines a path object, which stores path-related commands and coordinates.
+ *
+ */
+typedef struct {
+    uint8_t *segment;       /* < Pointer to the path command data */
+    int32_t numSegments;    /* < Total number of path commands */
+    uint8_t *data;          /* < Pointer to the coordinates used in the path commands */
+    VGUPathDataType type;   /* < Data type of the path */
+    bool enAlias;           /* < Whether to enable anti-aliasing */
+    VGURect boundBox;       /* < Bounding box of the path */
+} VGUPath;
+
+/* *
+ * @brief Enumerates transform types.
+ *
+ */
+typedef enum {
+    VGU_TRANSFORM_TRANSLATE = (1 << 0),     /* < Translate */
+    VGU_TRANSFORM_SCALE = (1 << 1),         /* < Scale */
+    VGU_TRANSFORM_ROTATE_90 = (1 << 2),     /* < Rotate by 90 degrees */
+    VGU_TRANSFORM_ROTATE_180 = (1 << 3),    /* < Rotate by 180 degrees */
+    VGU_TRANSFORM_ROTATE_270 = (1 << 4),    /* < Rotate by 270 degrees */
+    VGU_TRANSFORM_OTHER = (1 << 16)         /* < Other transform type */
+} VGUTransformType;
+
+/* *
+ * @brief Defines a transformation matrix.
+ *
+ */
+typedef struct {
+    float m[3][3];    /* < 3x3 transformation matrix */
+    uint32_t type;    /* < Transform type, which can be scale, translate, or rotate by 90 x <i>N</i> degrees */
+} VGUMatrix3;
+
+/* *
+ * @brief Stores bitmap information for hardware acceleration.
+ *
+ */
+typedef struct {
+    VGUPixelFormat pixelFormat;  /* < Pixel format */
+    uint32_t width;             /* < Bitmap width */
+    uint32_t height;            /* < Bitmap height */
+    uint32_t stride;            /* < Bitmap stride */
+    void *virAddr;              /* < Virtual address of the requested memory */
+    uint64_t phyAddr;           /* < Physical memory address */
+} VGUBuffer;
+
+/* *
+ * @brief Enumerates clip types of a surface.
+ *
+ */
+typedef enum {
+    VGU_CLIP_RECT = 0,  /* < Rectangle clip (default value) */
+    VGU_CLIP_PATH,      /* < Path clip */
+    VGU_CLIP_BUTT       /* < Invalid definition */
+} VGUClipType;
+
+/* *
+ * @brief Defines a mask layer.
+ *
+ */
+typedef struct {
+    VGUBuffer *buffer;  /* < Pointer to the buffer for the mask */
+    VGURect *rect;      /* < Pointer to the rectangle for the mask */
+} VGUMaskLayer;
+
+/* *
+ * @brief Stores surface information for 2D hardware acceleration.
+ *
+ */
+typedef struct {
+    VGUBuffer *buffer;      /* < Bitmap buffer */
+    union {
+        VGURect *clipRect;  /* < Pointer to the clip rectangle. If it is null, the entire surface will be rendered. */
+        VGUPath *clipPath;  /* < Pointer to the clip path. If it is null, the entire surface will be rendered. */
+    };
+    VGUClipType clipType;   /* < Clip type of the surface */
+    VGUMaskLayer *mask;     /* < Mask layer, which can be null */
+    VGUBlendType blend;     /* < Blend type, specifying how a new image is drawn onto an existing surface */
+    VGUFilter filter;       /* < Filter type */
+} VGUSurface;
+
+/* *
+ * @brief Defines how the colors are distributed along the gradient.
+ *
+ */
+typedef struct {
+    float stop;     /* < Stop position. The value ranges from 0.0 to 1.0. */
+    uint32_t color; /* < Color of the stop */
+} VGUColorStop;
+
+/* *
+ * @brief Defines a linear gradient.
+ *
+ */
+typedef struct {
+    VGUScalar x1; /* < Horizontal coordinate of the start point of the linear gradient */
+    VGUScalar y1; /* < Vertical coordinate of the start point of the linear gradient */
+    VGUScalar x2; /* < Horizontal coordinate of the end point of the linear gradient */
+    VGUScalar y2; /* < Vertical coordinate of the end point of the linear gradient */
+} VGULinear;
+
+/* *
+ * @brief Defines a radial gradient.
+ *
+ */
+typedef struct {
+    VGUScalar x0; /* < Horizontal coordinate of the center of the inner circle */
+    VGUScalar y0; /* < Vertical coordinate of the center of the inner circle */
+    VGUScalar r0; /* < Radius of the inner circle */
+    VGUScalar x1; /* < Horizontal coordinate of the center of the outer circle */
+    VGUScalar y1; /* < Vertical coordinate of the center of the outer circle */
+    VGUScalar r1; /* < Radius of the outer circle */
+} VGURadial;
+
+/* *
+ * @brief Defines a conic gradient.
+ *
+ */
+typedef struct {
+    VGUScalar cx; /* < Horizontal coordinate of the center of the circle */
+    VGUScalar cy; /* < Vertical coordinate of the center of the circle */
+} VGUConic;
+
+/* *
+ * @brief Defines an image.
+ *
+ */
+typedef struct {
+    VGUBuffer *buffer;  /* < Image buffer */
+    VGUMatrix3 *matrix; /* < Pointer to the transformation matrix. If it is null, the identity matrix is used. */
+    VGURect *rect;      /* < Pointer to the rectangle of the image. If it is null, the entire buffer data is used. */
+    uint8_t opacity;    /* < Opacity. The value ranges from 0 to 255. */
+} VGUImage;
+
+/* *
+ * @brief Defines an image pattern.
+ *
+ */
+typedef struct {
+    VGUImage *image;    /* < Pointer to the image object */
+    VGUWrapType wrapx;  /* < Wrap the image horizontally. */
+    VGUWrapType wrapy;  /* < Wrap the image vertically. */
+} VGUPattern;
+
+/* *
+ * @brief Enumerates gradient types.
+ *
+ */
+typedef enum {
+    VGU_GRADIENT_LINEAR = 0,    /* < Linear gradient */
+    VGU_GRADIENT_RADIAL,        /* < Radial gradient */
+    VGU_GRADIENT_CONIC,         /* < Conic gradient */
+    VGU_GRADIENT_BUTT           /* < Invalid definition */
+} VGUGradientType;
+
+/* *
+ * @brief Defines a gradient object.
+ *
+ */
+typedef struct {
+    VGUMatrix3 *matrix;         /* < Pointer to the transformation matrix of the gradient object */
+    VGUColorStop *colorStops;   /* < Pointer to the gradient stop color array */
+    uint16_t stopCount;         /* < Number of stop colors */
+    union {
+        VGULinear linear;       /* < Linear gradient object */
+        VGURadial radial;       /* < Radial gradient object */
+        VGUConic conic;         /* < Conic gradient object */
+    };
+    VGUGradientType type;       /* < Gradient type */
+    VGUFillSpread spread;       /* < Gradient spread mode */
+    uint8_t opacity;            /* < Opacity. The value ranges from 0 to 255. */
+} VGUGradient;
+
+/* *
+ * @brief Defines a solid color.
+ *
+ */
+typedef struct {
+    uint32_t color;     /* < Solid color */
+    uint8_t opacity;    /* < Opacity. The value ranges from 0 to 255. */
+} VGUSolid;
+
+/* *
+ * @brief Enumerates paint types.
+ *
+ */
+typedef enum {
+    VGU_PAINT_SOLID = 0,    /* < Paint a solid color. */
+    VGU_PAINT_GRADIENT,     /* < Paint a gradient object. */
+    VGU_PAINT_PATTERN,      /* < Paint a pattern. */
+    VGU_PAINT_BUTT          /* < Invalid operation */
+} VGUPaintType;
+
+/* *
+ * @brief Defines the paint style when filling or stroking a path.
+ *
+ */
+typedef struct {
+    union {
+        VGUGradient *gradient;  /* < Pointer to the gradient object */
+        VGUPattern *pattern;    /* < Pointer to the pattern object */
+        VGUSolid *solid;        /* < Pointer to the solid color object */
+    };
+    VGUPaintType type;          /* < Paint type */
+} VGUPaintStyle;
+
+/* *
+ * @brief Defines path filling attributes.
+ *
+ */
+typedef struct {
+    VGUFillRule rule; /* < Fill rule */
+} VGUFillAttr;
+
+/* *
+ * @brief Defines path stroking attributes.
+ *
+ */
+typedef struct {
+    VGULineCap cap;     /* < Line cap style */
+    VGUJointType join;  /* < Join type */
+    float miterLimit;   /* < Miter limit */
+    float width;        /* < Line width */
+} VGUStrokeAttr;
+
+/* *
+ * @brief Defines driver functions for 2D hardware acceleration.
+ */
+typedef struct {
+    /* *
+     * @brief Initializes hardware acceleration.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @see DeinitVgu
+     * @since 3.0
+     */
+    VGUResult (*InitVgu)(void);
+
+    /* *
+     * @brief Deinitializes hardware acceleration.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @see InitVgu
+     * @since 3.0
+     */
+    VGUResult (*DeinitVgu)(void);
+
+    /* *
+     * @brief Queries hardware acceleration capabilities.
+     *
+     * @param cap Indicates the capabilities to query, which are defined by <b>VGUCapability</b>.
+     *
+     * @return Returns a value greater than or equal to 0 if the operation is successful; returns an error code defined
+     * in {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    int32_t (*QueryCapability)(uint32_t cap);
+
+    /* *
+     * @brief Fills the given path with a specified paint style.
+     *
+     * @param target Indicates the pointer to the target surface.
+     * @param path Indicates the pointer to the path object.
+     * @param matrix Indicates the pointer to the transformation matrix object. If this parameter is null,
+     * the identity matrix is used by default.
+     * @param attr Indicates the pointer to the path filling attributes.
+     * @param style Indicates the pointer to the paint style to use.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderFill)(VGUSurface *target, const VGUPath *path, const VGUMatrix3 *matrix, const VGUFillAttr *attr,
+        const VGUPaintStyle *style);
+
+    /* *
+     * @brief Strokes the given path with a specified paint style.
+     *
+     * @param target Indicates the pointer to the target surface.
+     * @param path Indicates the pointer to the path object.
+     * @param matrix Indicates the pointer to the transformation matrix object. If this parameter is null,
+     * the identity matrix is used by default.
+     * @param attr Indicates the pointer to the path stroking attributes.
+     * @param style Indicates the pointer to the paint style to use.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderStroke)(VGUSurface *target, const VGUPath *path, const VGUMatrix3 *matrix,
+        const VGUStrokeAttr *attr, const VGUPaintStyle *style);
+
+    /* *
+     * @brief Blurs a specified surface.
+     *
+     * @param target Indicates the pointer to the target surface.
+     * @param blur Indicates the blur radius.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderBlur)(VGUSurface *target, uint16_t blur);
+
+    /* *
+     * @brief Blits an image to the target surface.
+     *
+     * During bit blit, color space conversion (CSC) and transformation can be implemented.
+     *
+     * @param target Indicates the pointer to the target surface.
+     * @param src Indicates the pointer to the source image.
+     * @param color Indicates the color for blending. If this parameter is <b>0</b>, color blending is not performed.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderBlit)(VGUSurface *target, const VGUImage *src, uint32_t color);
+
+    /* *
+     * @brief Blits multiple images to the target surface.
+     *
+     * During bit blit, color space conversion (CSC) and transformation can be implemented. You can use this 
+     * function to combine multiple source images to the target surface.
+     * To query the maximum number of source images allowed, call the <b>QueryCapability<b/> function.
+     *
+     * @param target Indicates the pointer to the target surface.
+     * @param src Indicates the pointer to the array of source images.
+     * @param count Indicates the number of source images.
+     * @param color Indicates the color for blending. If this parameter is <b>0</b>, color blending is not performed.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderBlitN)(VGUSurface *target, const VGUImage *src, uint16_t count, uint32_t color);
+
+    /* *
+     * @brief Clears a rectangle with a given color on the target surface.
+     *
+     * @param target Indicates the pointer to the target surface.
+     * @param rect Indicates the pointer to the rectangle to clear. If this parameter is null, the entire surface
+     * will be cleared.
+     * @param color Indicates the color to fill.
+     * @param opacity Indicates the opacity to set.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderClearRect)(VGUSurface *target, const VGURect *rect, uint32_t color, uint8_t opacity);
+
+    /* *
+     * @brief Disables hardware acceleration for rendering.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderCancel)();
+
+    /* *
+     * @brief Synchronizes hardware acceleration when it is used to draw and blit bitmaps.
+     *
+     * This function blocks the process until hardware acceleration is complete.
+     *
+     * @param timeOut Indicates the timeout duration for hardware acceleration synchronization.
+     * The value <b>0</b> indicates no timeout, so the process keeps waiting until hardware acceleration is complete.
+     *
+     * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+     * {@link VGUResult} otherwise.
+     * @since 3.0
+     */
+    VGUResult (*RenderSync)(int32_t timeOut);
+} VGUFuncs;
+
+/* *
+ * @brief Initializes a path object.
+ *
+ * @param path Indicates the pointer to the path object.
+ * @param type Indicates the data type of the path.
+ * @param segments Indicates the pointer to the path commands.
+ * @param numSegments Indicates the total number of path commands.
+ * @param data Indicates the pointer to the coordinate data used in the path commands.
+ * @param enAlias Specifies whether to enable anti-aliasing.
+ * @param boundBox Indicates the bounding box of the path.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUPathInit(VGUPath *path, VGUPathDataType type, const uint8_t* segments, int numSegments,
+    const uint8_t *data, bool enAlias, VGURect boundBox);
+
+/* *
+ * @brief Adds a subpath to a specified path.
+ *
+ * @param path Indicates the pointer to the path object.
+ * @param subpath Indicates the pointer to the subpath object.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUPathAppend(VGUPath *path, const VGUPath *subpath);
+
+/* *
+ * @brief Clears the memory of a specified path object.
+ *
+ * @param path Indicates the pointer to the path object.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUPathClear(VGUPath *path);
+
+/* *
+ * @brief Loads an identity matrix into a specified matrix object.
+ *
+ * @param matrix Indicates the pointer to the transformation matrix object.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUMatrixIdentity(VGUMatrix3 *matrix);
+
+/* *
+ * @brief Scales a specified transformation matrix.
+ *
+ * @param matrix Indicates the pointer to the transformation matrix object.
+ * @param xScale Indicates how much you want to scale the horizontal coordinate by.
+ * @param yScale Indicates how much you want to scale the vertical coordinate by.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUMatrixScale(VGUMatrix3 *matrix, float xScale, float yScale);
+
+/* *
+ * @brief Rotates a specified transformation matrix.
+ *
+ * @param matrix Indicates the pointer to the transformation matrix object.
+ * @param degree Indicates the number of degrees to rotate.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUMatrixRotate(VGUMatrix3 *matrix, float degree);
+
+/* *
+ * @brief Translates a specified transformation matrix.
+ *
+ * @param matrix Indicates the pointer to the transformation matrix object.
+ * @param x Indicates how much you want to translate the horizontal coordinate by.
+ * @param y Indicates how much you want to translate the vertical coordinate by.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUMatrixTranslate(VGUMatrix3 *matrix, float x, float y);
+
+/* *
+ * @brief Adds color stops to a specified gradient.
+ *
+ * @param gradient Indicates the pointer to the gradient object.
+ * @param colorStop Indicates the pointer to the color stop array.
+ * @param count Indicates the total number of color stops.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUGradientColorStop(VGUGradient *gradient, const VGUColorStop *colorStop, uint32_t count);
+
+/* *
+ * @brief Clears color stops of a specified gradient.
+ *
+ * @param gradient Indicates the pointer to the gradient object.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUGradientClearStop(VGUGradient *gradient);
+
+/* *
+ * @brief Sets a transformation matrix for a specified gradient.
+ *
+ * @param gradient Indicates the pointer to the gradient object.
+ * @param matrix Indicates the pointer to the transformation matrix object to set.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUGradientMatrix(VGUGradient *gradient, const VGUMatrix3 *matrix);
+
+/* *
+ * @brief Creates a linear gradient object.
+ *
+ * @param gradient Indicates the pointer to the gradient object.
+ * @param p1 Indicates the pointer to the coordinates of the start point.
+ * @param p2 Indicates the pointer to the coordinates of the end point.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUGradientLinear(VGUGradient *gradient, const VGUPoint *p1, const VGUPoint *p2);
+
+/* *
+ * @brief Creates a radial gradient object.
+ *
+ * @param gradient Indicates the pointer to the gradient object.
+ * @param p1 Indicates the pointer to the center point coordinates of the inner circle.
+ * @param r1 Indicates the radius of the inner circle.
+ * @param p2 Indicates the pointer to the center point coordinates of the outer circle.
+ * @param r2 Indicates the radius of the outer circle.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUGradientRadial(VGUGradient *gradient, const VGUPoint *p1, VGUScalar r1, const VGUPoint *p2, VGUScalar r2);
+
+/* *
+ * @brief Creates a conic gradient object.
+ *
+ * @param gradient Indicates the pointer to the gradient object.
+ * @param cx Indicates the horizontal coordinate of the center point of the gradient.
+ * @param cy Indicates the vertical coordinate of the center point of the gradient.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUGradientConic(VGUGradient *gradient, VGUScalar cx, VGUScalar cy);
+
+/* *
+ * @brief Initializes the hardware acceleration module to obtain the pointer to functions for
+ * hardware acceleration operations.
+ *
+ * @param funcs Indicates the double pointer to the functions for hardware acceleration operations.
+ * Memory is allocated automatically when you initiate the hardware acceleration module, so you can simply use
+ * the pointer to gain access to the functions.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ *
+ * @since 3.0
+ */
+VGUResult VGUInitialize(VGUFuncs **funcs);
+
+/* *
+ * @brief Deinitializes the hardware acceleration module to release the pointer to functions
+ * for hardware acceleration operations.
+ *
+ * @param funcs Indicates the pointer to the functions for hardware acceleration operations.
+ *
+ * @return Returns <b>VGU_SUCCESS</b> if the operation is successful; returns an error code defined in
+ * {@link VGUResult} otherwise.
+ * @since 3.0
+ */
+VGUResult VGUUninitialize(VGUFuncs *funcs);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/ohos_ndk_aosp/includes/graphic_util/buffer_handle_parcel.h b/ohos_ndk_aosp/includes/graphic_util/buffer_handle_parcel.h
new file mode 100755
index 0000000000..d399bbabe9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/graphic_util/buffer_handle_parcel.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_INCLUDE_BUFFER_HANDLE_PARCEL_H
+#define UTILS_INCLUDE_BUFFER_HANDLE_PARCEL_H
+
+#ifdef __cplusplus
+#include "buffer_handle.h"
+#include "message_parcel.h"
+namespace OHOS {
+/* *
+ * @Description: Write BufferHanedle to MessageParcel
+ * @param parcel which the buffer handle will write to
+ * @param handle Buffer handle which will wtite to parcel
+ * @return  Returns true if the operation is successful; returns <b>false</b> otherwise.
+ */
+bool WriteBufferHandle(MessageParcel &parcel, const BufferHandle &handle);
+
+/* *
+ * @Description: Read BufferHanedle from MessageParcel
+ * @param parcel message parcel which should has a buffer handle
+ * @return  Returns pointer to buffer handle if the operation is successful; returns <b>nullptr</b> otherwise.
+ */
+BufferHandle *ReadBufferHandle(MessageParcel &parcel);
+} // namespace OHO
+#endif // __cplusplus
+
+#endif // UTILS_INCLUDE_BUFFER_HANDLE_PARCEL_H
diff --git a/ohos_ndk_aosp/includes/graphic_util/buffer_handle_utils.h b/ohos_ndk_aosp/includes/graphic_util/buffer_handle_utils.h
new file mode 100644
index 0000000000..0ef9cc94cc
--- /dev/null
+++ b/ohos_ndk_aosp/includes/graphic_util/buffer_handle_utils.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INCLUDE_BUFFER_HANDLE_UTILS_H
+#define INCLUDE_BUFFER_HANDLE_UTILS_H
+
+#include <stdint.h>
+#include <buffer_handle.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+* @Description: Init buffer handle, and must be freeed by FreeBufferHandle to avoid memory leak
+* @param reserveInts The number of reserved integers
+* @param reserveFds The number of reserved fds
+* @return Returns pointer to buffer handle if the operation is successful; returns <b>nullptr</b> otherwise.
+*/
+BufferHandle *AllocateBufferHandle(uint32_t reserveInts, uint32_t reserveFds);
+
+/**
+* @Description: Free buffer handle allocated by AllocateBufferHandle, and close the fd at the same time.
+* @param handle Buffer handle which is to be freed.
+* @return  Returns <b>0</b> if the operation is successful; returns <b>-1</b> if failed
+*/
+int32_t FreeBufferHandle(BufferHandle *handle);
+
+/**
+* @Description: clone a new buffer handle based on given buffer handle
+* @param handle Buffer handle which is to be cloned.
+* @return  Returns pointer to buffer handle if the operation is successful; returns <b>nullptr</b> otherwise.
+*/
+BufferHandle *CloneBufferHandle(const BufferHandle *handle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // INCLUDE_BUFFER_HANDLE_UTILS_H
diff --git a/ohos_ndk_aosp/includes/hilog/log.h b/ohos_ndk_aosp/includes/hilog/log.h
new file mode 100644
index 0000000000..4b0bc93cb3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/hilog/log.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HIVIEWDFX_HILOG_H
+#define HIVIEWDFX_HILOG_H
+
+#include "hilog/log_c.h"
+#include "hilog/log_cpp.h"
+
+#endif  // HIVIEWDFX_HILOG_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/hilog/log_c.h b/ohos_ndk_aosp/includes/hilog/log_c.h
new file mode 100644
index 0000000000..dbbba724e9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/hilog/log_c.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HIVIEWDFX_HILOG_C_H
+#define HIVIEWDFX_HILOG_C_H
+
+#include <stdarg.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Log domain
+#ifndef LOG_DOMAIN
+#define LOG_DOMAIN 0
+#endif
+
+// Log tag
+#ifndef LOG_TAG
+#define LOG_TAG NULL
+#endif
+
+// Log type
+typedef enum {
+    LOG_TYPE_MIN = 0,
+    LOG_APP = 0,
+    LOG_INIT = 1,
+    // Used by core service, framework.
+    LOG_CORE = 3,
+    LOG_KMSG = 4,
+    LOG_TYPE_MAX
+} LogType;
+
+// Log level
+typedef enum {
+    LOG_LEVEL_MIN = 0,
+    LOG_DEBUG = 3,
+    LOG_INFO = 4,
+    LOG_WARN = 5,
+    LOG_ERROR = 6,
+    LOG_FATAL = 7,
+    LOG_LEVEL_MAX,
+} LogLevel;
+
+int HiLogPrint(LogType type, LogLevel level, unsigned int domain, const char *tag, const char *fmt, ...)
+    __attribute__((__format__(os_log, 5, 6)));
+
+#define HILOG_DEBUG(type, ...) ((void)HiLogPrint((type), LOG_DEBUG, LOG_DOMAIN, LOG_TAG, __VA_ARGS__))
+
+#define HILOG_INFO(type, ...) ((void)HiLogPrint((type), LOG_INFO, LOG_DOMAIN, LOG_TAG, __VA_ARGS__))
+
+#define HILOG_WARN(type, ...) ((void)HiLogPrint((type), LOG_WARN, LOG_DOMAIN, LOG_TAG, __VA_ARGS__))
+
+#define HILOG_ERROR(type, ...) ((void)HiLogPrint((type), LOG_ERROR, LOG_DOMAIN, LOG_TAG, __VA_ARGS__))
+
+#define HILOG_FATAL(type, ...) ((void)HiLogPrint((type), LOG_FATAL, LOG_DOMAIN, LOG_TAG, __VA_ARGS__))
+
+bool HiLogIsLoggable(unsigned int domain, const char *tag, LogLevel level);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // HIVIEWDFX_HILOG_C_H
diff --git a/ohos_ndk_aosp/includes/hilog/log_cpp.h b/ohos_ndk_aosp/includes/hilog/log_cpp.h
new file mode 100644
index 0000000000..2f894e7ead
--- /dev/null
+++ b/ohos_ndk_aosp/includes/hilog/log_cpp.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HIVIEWDFX_HILOG_CPP_H
+#define HIVIEWDFX_HILOG_CPP_H
+
+#include "hilog/log_c.h"
+
+#ifdef __cplusplus
+
+namespace OHOS {
+namespace HiviewDFX {
+
+typedef struct HiLogLabel {
+    LogType type;
+    unsigned int domain;
+    const char *tag;
+} HiLogLabel;
+
+class HiLog final {
+public:
+    static int Debug(const HiLogLabel &label, const char *fmt, ...) __attribute__((__format__(os_log, 2, 3)));
+    static int Info(const HiLogLabel &label, const char *fmt, ...) __attribute__((__format__(os_log, 2, 3)));
+    static int Warn(const HiLogLabel &label, const char *fmt, ...) __attribute__((__format__(os_log, 2, 3)));
+    static int Error(const HiLogLabel &label, const char *fmt, ...) __attribute__((__format__(os_log, 2, 3)));
+    static int Fatal(const HiLogLabel &label, const char *fmt, ...) __attribute__((__format__(os_log, 2, 3)));
+};
+
+} // namespace HiviewDFX
+} // namespace OHOS
+
+#endif // __cplusplus
+
+#endif // HIVIEWDFX_HILOG_CPP_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/i_input_method_agent.h b/ohos_ndk_aosp/includes/inputmethod_ability/i_input_method_agent.h
new file mode 100644
index 0000000000..74d7156188
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/i_input_method_agent.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IINPUTMETHODAGENT_H
+#define FM_IMMS_PROJECT_IINPUTMETHODAGENT_H
+
+#include "iremote_broker.h"
+#include "global.h"
+
+/**
+ * brief Definition of interface IInputMethodAgent
+ * It defines the remote calls from input client to input method service
+ */
+namespace OHOS {
+namespace MiscServices {
+    class IInputMethodAgent : public IRemoteBroker {
+    public:
+        enum {
+            DISPATCH_KEY_EVENT = FIRST_CALL_TRANSACTION,
+            ON_CURSOR_UPDATE,
+            ON_SELECTION_CHANGE,
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.IInputMethodAgent");
+
+        virtual bool DispatchKeyEvent(MessageParcel& data) = 0;
+        virtual void OnCursorUpdate(int32_t positionX, int32_t positionY, int height) = 0;
+        virtual void OnSelectionChange(std::u16string text, int32_t oldBegin, int32_t oldEnd,
+                                       int32_t newBegin, int32_t newEnd) = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_IINPUTMETHODAGENT_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/i_input_method_core.h b/ohos_ndk_aosp/includes/inputmethod_ability/i_input_method_core.h
new file mode 100644
index 0000000000..8018dd8a18
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/i_input_method_core.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IINPUTMETHODCORE_H
+#define FM_IMMS_PROJECT_IINPUTMETHODCORE_H
+#include "iremote_broker.h"
+#include "i_input_data_channel.h"
+#include "i_input_control_channel.h"
+#include "ipc_types.h"
+#include "input_attribute.h"
+#include "keyboard_type.h"
+#include "input_channel.h"
+#include "global.h"
+
+/**
+ * brief Definition of interface IInputMethodCore
+ * It defines the remote calls from input method management service to input method service
+ */
+namespace OHOS {
+namespace MiscServices {
+    class IInputMethodCore : public IRemoteBroker {
+    public:
+        enum {
+            INITIALIZE_INPUT = FIRST_CALL_TRANSACTION,
+            SET_CLIENT_STATE,
+            START_INPUT,
+            STOP_INPUT,
+            SHOW_KEYBOARD,
+            STOP_INPUT_SERVICE,
+            HIDE_KEYBOARD,
+            SET_KEYBOARD_TYPE,
+            GET_KEYBOARD_WINDOW_HEIGHT,
+            INIT_INPUT_CONTROL_CHANNEL
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.IInputMethodCore");
+
+        virtual int32_t initializeInput(sptr<IRemoteObject>& startInputToken, int32_t displayId,
+                                        sptr<IInputControlChannel>& inputControlChannel) = 0;
+        virtual bool startInput(const sptr<IInputDataChannel>& startInputToken,
+                                const InputAttribute& editorAttribute,
+                                bool supportPhysicalKbd) = 0;
+        virtual int32_t stopInput() = 0;
+        virtual bool showKeyboard(const sptr<IInputDataChannel>& inputDataChannel) = 0;
+        virtual bool hideKeyboard(int32_t flags) = 0;
+        virtual int32_t setKeyboardType(const KeyboardType& type) = 0;
+        virtual int32_t getKeyboardWindowHeight(int32_t retHeight) = 0;
+        virtual int32_t InitInputControlChannel(sptr<IInputControlChannel> &inputControlChannel) = 0;
+        virtual void SetClientState(bool state) = 0;
+        virtual void StopInputService(std::string imeId) = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_IINPUTMETHODCORE_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/input_method_ability.h b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_ability.h
new file mode 100644
index 0000000000..679a8d80da
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_ability.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTMETHODABILITY_H
+#define FM_IMMS_PROJECT_INPUTMETHODABILITY_H
+
+#include <thread>
+#include "js_input_method_engine_listener.h"
+#include "js_keyboard_delegate_listener.h"
+#include "iremote_object.h"
+#include "i_input_control_channel.h"
+#include "i_input_method_core.h"
+#include "i_input_data_channel.h"
+#include "i_input_method_agent.h"
+#include "input_method_core_stub.h"
+#include "input_control_channel_proxy.h"
+#include "input_attribute.h"
+#include "message_handler.h"
+#include "input_channel.h"
+#include "message.h"
+#include "utils.h"
+#include "input_method_system_ability_proxy.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class JsInputMethodEngineListener;
+    class MessageHandler;
+    class InputMethodAbility : public RefBase {
+    public:
+        InputMethodAbility();
+        ~InputMethodAbility();
+        static sptr<InputMethodAbility> GetInstance();
+        sptr<IInputMethodCore> OnConnect();
+        bool InsertText(const std::string text);
+        void setImeListener(sptr<JsInputMethodEngineListener> &imeListener);
+        void setKdListener(sptr<JsKeyboardDelegateListener> &kdListener);
+        void DeleteForward(int32_t length);
+        void DeleteBackward(int32_t length);
+        void HideKeyboardSelf();
+        std::u16string GetTextBeforeCursor(int32_t number);
+        std::u16string GetTextAfterCursor(int32_t number);
+        void SendFunctionKey(int32_t funcKey);
+        void MoveCursor(int32_t keyCode);
+        bool DispatchKeyEvent(int32_t keyCode, int32_t keyStatus);
+        int32_t GetEnterKeyType();
+        int32_t GetInputPattern();
+        void StopInput();
+
+    private:
+        std::thread workThreadHandler;
+        MessageHandler *msgHandler;
+        bool mSupportPhysicalKbd = false;
+        InputAttribute *editorAttribute;
+        int32_t displyId = 0;
+        sptr<IRemoteObject> startInputToken;
+        InputChannel *writeInputChannel;
+        bool stop_;
+        int32_t KEYBOARD_HIDE = 1;
+        int32_t KEYBOARD_SHOW = 2;
+        bool isBindClient = false;
+
+        // communicating with IMSA
+        sptr<IInputControlChannel> inputControlChannel;
+        void SetCoreAndAgent();
+
+        // communicating with IMC
+        sptr<IInputDataChannel> inputDataChannel;
+        sptr<JsInputMethodEngineListener> imeListener_;
+        sptr<JsKeyboardDelegateListener> kdListener_;
+        static std::mutex instanceLock_;
+        static sptr<InputMethodAbility> instance_;
+        sptr<InputMethodSystemAbilityProxy> mImms;
+        sptr<InputMethodSystemAbilityProxy> GetImsaProxy();
+
+        void Initialize();
+        void WorkThread();
+
+        // the message from IMSA
+        void OnInitialInput(Message *msg);
+        void OnStartInput(Message *msg);
+        void OnStopInput(Message *msg);
+        void OnSetKeyboardType(Message *msg);
+        void OnShowKeyboard(Message *msg);
+        void OnHideKeyboard(Message *msg);
+        void OnInitInputControlChannel(Message *msg);
+
+        // the message from IMC
+        void OnCursorUpdate(Message *msg);
+        void OnSelectionChange(Message *msg);
+
+        // control inputwindow
+        void InitialInputWindow();
+        void ShowInputWindow();
+        void DissmissInputWindow();
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTMETHODABILITY_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/input_method_agent_proxy.h b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_agent_proxy.h
new file mode 100644
index 0000000000..da635de89d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_agent_proxy.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMC_PROJECT_INPUTMETHODAGENTPROXY_H
+#define FM_IMC_PROJECT_INPUTMETHODAGENTPROXY_H
+
+#include "iremote_proxy.h"
+#include "i_input_method_agent.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodAgentProxy : public IRemoteProxy<IInputMethodAgent> {
+    public:
+        explicit InputMethodAgentProxy(const sptr<IRemoteObject> &object);
+        ~InputMethodAgentProxy() = default;
+        DISALLOW_COPY_AND_MOVE(InputMethodAgentProxy);
+
+        bool DispatchKeyEvent(MessageParcel& data) override;
+        void OnCursorUpdate(int32_t positionX, int32_t positionY, int32_t height) override;
+        void OnSelectionChange(std::u16string text, int32_t oldBegin, int32_t oldEnd,
+                               int32_t newBegin, int32_t newEnd) override;
+    private:
+        static inline BrokerDelegator<InputMethodAgentProxy> delegator_;
+    };
+}
+}
+#endif // FM_IMC_PROJECT_INPUTMETHODAGENTPROXY_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/input_method_agent_stub.h b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_agent_stub.h
new file mode 100644
index 0000000000..9a3ccec77a
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_agent_stub.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMC_PROJECT_INPUTMETHODAGENTSTUB_H
+#define FM_IMC_PROJECT_INPUTMETHODAGENTSTUB_H
+
+#include "iremote_stub.h"
+#include "message_parcel.h"
+#include "message_option.h"
+#include "i_input_method_agent.h"
+#include "message_handler.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodAgentStub : public IRemoteStub<IInputMethodAgent> {
+    public:
+        explicit InputMethodAgentStub();
+        virtual ~InputMethodAgentStub();
+        virtual int32_t OnRemoteRequest(uint32_t code,
+                                        MessageParcel &data,
+                                        MessageParcel &reply,
+                                        MessageOption &option) override;
+        virtual bool DispatchKeyEvent(MessageParcel &data) override;
+        virtual void OnCursorUpdate(int32_t positionX, int32_t positionY, int height) override;
+        virtual void OnSelectionChange(std::u16string text, int32_t oldBegin, int32_t oldEnd,
+                                       int32_t newBegin, int32_t newEnd) override;
+        void SetMessageHandler(MessageHandler *msgHandler);
+    private:
+        MessageHandler *msgHandler_;
+    };
+}
+}
+#endif // FM_IMC_PROJECT_INPUTMETHODAGENTSTUB_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/input_method_core_proxy.h b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_core_proxy.h
new file mode 100644
index 0000000000..aa1849ce1e
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_core_proxy.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMC_PROJECT_INPUTMETHODCOREPROXY_H
+#define FM_IMC_PROJECT_INPUTMETHODCOREPROXY_H
+
+#include "iremote_proxy.h"
+#include "iremote_object.h"
+#include "message_parcel.h"
+#include "message_option.h"
+#include "i_input_method_core.h"
+#include "i_input_control_channel.h"
+#include "i_input_data_channel.h"
+#include "input_attribute.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodCoreProxy : public IRemoteProxy<IInputMethodCore> {
+    public:
+        explicit InputMethodCoreProxy(const sptr<IRemoteObject>& object);
+        ~InputMethodCoreProxy();
+
+        DISALLOW_COPY_AND_MOVE(InputMethodCoreProxy);
+
+        virtual int32_t initializeInput(sptr<IRemoteObject>& startInputToken, int32_t displayId,
+            sptr<IInputControlChannel>& inputControlChannel) override;
+        virtual bool startInput(const sptr<IInputDataChannel>& inputDataChannel,
+                                const InputAttribute& editorAttribute,
+                                bool supportPhysicalKbd) override;
+        virtual int32_t stopInput() override;
+        virtual bool showKeyboard(const sptr<IInputDataChannel>& inputDataChannel) override;
+        virtual bool hideKeyboard(int32_t flags) override;
+        virtual int32_t setKeyboardType(const KeyboardType& type) override;
+        virtual int32_t getKeyboardWindowHeight(int32_t retHeight) override;
+        virtual int32_t InitInputControlChannel(sptr<IInputControlChannel> &inputControlChannel) override;
+        virtual void SetClientState(bool state) override;
+        virtual void StopInputService(std::string imeId) override;
+    private:
+        static inline BrokerDelegator<InputMethodCoreProxy> delegator_;
+    };
+}
+}
+#endif // FM_IMC_PROJECT_INPUTMETHODCOREPROXY_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_ability/input_method_core_stub.h b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_core_stub.h
new file mode 100644
index 0000000000..ae6a3c661d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_ability/input_method_core_stub.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTCONTROLCHANNEL_SK_H
+#define FM_IMMS_PROJECT_INPUTCONTROLCHANNEL_SK_H
+
+#include <mutex>
+#include <condition_variable>
+#include <cstdint>
+#include "iremote_broker.h"
+#include "iremote_stub.h"
+#include "i_input_method_agent.h"
+#include "input_channel.h"
+#include "message_parcel.h"
+#include "input_attribute.h"
+#include "i_input_data_channel.h"
+#include "i_input_method_core.h"
+#include "i_input_control_channel.h"
+#include "keyboard_type.h"
+#include "message_handler.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodCoreStub : public IRemoteStub<IInputMethodCore> {
+    public:
+        DISALLOW_COPY_AND_MOVE(InputMethodCoreStub);
+        explicit InputMethodCoreStub(int userId);
+        virtual ~InputMethodCoreStub();
+        virtual int OnRemoteRequest(uint32_t code,
+                                    MessageParcel &data,
+                                    MessageParcel &reply,
+                                    MessageOption &option) override;
+
+        virtual int32_t initializeInput(sptr<IRemoteObject>& startInputToken, int32_t displayId,
+                                        sptr<IInputControlChannel>& inputControlChannel) override;
+        virtual bool startInput(const sptr<IInputDataChannel>& inputDataChannel,
+                                const InputAttribute& editorAttribute,
+                                bool supportPhysicalKbd) override;
+        virtual int32_t stopInput() override;
+        virtual bool showKeyboard(const sptr<IInputDataChannel>& inputDataChannel) override;
+        virtual bool hideKeyboard(int32_t flags)override;
+        virtual int32_t setKeyboardType(const KeyboardType& type) override;
+        virtual int32_t getKeyboardWindowHeight(int32_t retHeight) override;
+        virtual int32_t InitInputControlChannel(sptr<IInputControlChannel> &inputControlChannel) override;
+        virtual void SetClientState(bool state) override;
+        virtual void StopInputService(std::string imeId) override;
+        void SetMessageHandler(MessageHandler *msgHandler);
+
+    private:
+        int userId_;
+        MessageHandler *msgHandler_;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTCONTROLCHANNEL_SK_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/i_input_client.h b/ohos_ndk_aosp/includes/inputmethod_controller/i_input_client.h
new file mode 100644
index 0000000000..9b18ed64ce
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/i_input_client.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IINPUTCLIENT_H
+#define FM_IMMS_PROJECT_IINPUTCLIENT_H
+
+#include "iremote_broker.h"
+#include "i_input_method_agent.h"
+#include "input_channel.h"
+#include "global.h"
+
+/**
+ * brief Definition of interface IInputClient
+ * It defines the remote calls from input method management service to input client.
+ */
+namespace OHOS {
+namespace MiscServices {
+    class IInputClient : public IRemoteBroker {
+    public:
+        enum {
+            ON_INPUT_READY = 0,
+            ON_INPUT_RELEASED,
+            SET_DISPLAY_MODE,
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.InputClient");
+
+        virtual int32_t onInputReady(const sptr<IInputMethodAgent>& agent) = 0;
+        virtual int32_t onInputReleased(int32_t retValue) = 0;
+        virtual int32_t setDisplayMode(int32_t mode) = 0;
+    };
+} 
+}
+#endif // FM_IMMS_PROJECT_IINPUTCLIENT_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/i_input_data_channel.h b/ohos_ndk_aosp/includes/inputmethod_controller/i_input_data_channel.h
new file mode 100644
index 0000000000..4052fc2a98
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/i_input_data_channel.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IINPUTDATACHANNEL_H
+#define FM_IMMS_PROJECT_IINPUTDATACHANNEL_H
+#include <errors.h>
+#include "iremote_broker.h"
+#include "global.h"
+#include "input_method_utils.h"
+
+/**
+ * brief Definition of interface IInputDataChannel
+ * It defines the remote calls from input method service to input client
+ */
+namespace OHOS {
+namespace MiscServices {
+    class IInputDataChannel : public IRemoteBroker {
+    public:
+        enum {
+            INSERT_TEXT = 0,
+            DELETE_FORWARD,
+            DELETE_BACKWARD,
+            CLOSE,
+            GET_TEXT_BEFORE_CURSOR,
+            GET_TEXT_AFTER_CURSOR,
+            GET_ENTER_KEY_TYPE,
+            GET_INPUT_PATTERN,
+            STOP_INPUT,
+            SEND_KEYBOARD_STATUS,
+            SEND_FUNCTION_KEY,
+            MOVE_CURSOR,
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.IInputDataChannel");
+
+        virtual bool InsertText(const std::u16string& text) = 0;
+        virtual bool DeleteForward(int32_t length) = 0;
+        virtual bool DeleteBackward(int32_t length) = 0;
+        virtual void Close() = 0;
+        virtual std::u16string GetTextBeforeCursor(int32_t number) = 0;
+        virtual std::u16string GetTextAfterCursor(int32_t number) = 0;
+        virtual void SendKeyboardStatus(int32_t status) = 0;
+        virtual void SendFunctionKey(int32_t funcKey) = 0;
+        virtual void MoveCursor(int32_t keyCode) = 0;
+        virtual int32_t GetEnterKeyType() = 0;
+        virtual int32_t GetInputPattern() = 0;
+        virtual void StopInput() = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_IINPUTDATACHANNEL_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_client_proxy.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_client_proxy.h
new file mode 100644
index 0000000000..8d4a71ec24
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_client_proxy.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef FM_IMC_PROJECT_INPUTCLIENTPROXY_H
+#define FM_IMC_PROJECT_INPUTCLIENTPROXY_H
+
+#include "iremote_proxy.h"
+#include "i_input_client.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputClientProxy : public IRemoteProxy<IInputClient> {
+    public:
+        explicit InputClientProxy(const sptr<IRemoteObject> &object);
+        ~InputClientProxy() = default;
+        DISALLOW_COPY_AND_MOVE(InputClientProxy);
+
+        int32_t onInputReady(const sptr<IInputMethodAgent>& agent) override;
+        int32_t onInputReleased(int32_t retValue) override;
+        int32_t setDisplayMode(int32_t mode) override;
+
+    private:
+        static inline BrokerDelegator<InputClientProxy> delegator_;
+    };
+}
+}
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_client_stub.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_client_stub.h
new file mode 100644
index 0000000000..a601b92552
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_client_stub.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef FM_IMC_PROJECT_INPUTCLIENTSTUB_H
+#define FM_IMC_PROJECT_INPUTCLIENTSTUB_H
+
+#include "iremote_stub.h"
+#include "i_input_client.h"
+#include "message_handler.h"
+#include "message.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputClientStub : public IRemoteStub<IInputClient> {
+    public:
+        DISALLOW_COPY_AND_MOVE(InputClientStub);
+        int32_t OnRemoteRequest(uint32_t code, MessageParcel &data,
+                                MessageParcel &reply, MessageOption &option) override;
+        InputClientStub();
+        ~InputClientStub();
+        void SetHandler(MessageHandler *handler);
+
+        int32_t onInputReady(const sptr<IInputMethodAgent>& agent) override;
+        int32_t onInputReleased(int32_t retValue) override;
+        int32_t setDisplayMode(int32_t mode) override;
+    private:
+        MessageHandler *msgHandler = nullptr;
+    };
+}
+}
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_data_channel_proxy.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_data_channel_proxy.h
new file mode 100644
index 0000000000..83cefdaa5c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_data_channel_proxy.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMC_PROJECT_INPUTDATACHANNELPROXY_H
+#define FM_IMC_PROJECT_INPUTDATACHANNELPROXY_H
+
+#include "iremote_proxy.h"
+#include "i_input_data_channel.h"
+#include "input_method_utils.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputDataChannelProxy : public IRemoteProxy<IInputDataChannel> {
+    public:
+        explicit InputDataChannelProxy(const sptr<IRemoteObject> &object);
+        ~InputDataChannelProxy() = default;
+        DISALLOW_COPY_AND_MOVE(InputDataChannelProxy);
+
+        bool InsertText(const std::u16string& text) override;
+        bool DeleteForward(int32_t length) override;
+        bool DeleteBackward(int32_t length) override;
+        void Close() override;
+        std::u16string GetTextBeforeCursor(int32_t number) override;
+        std::u16string GetTextAfterCursor(int32_t number) override;
+        void SendKeyboardStatus(int32_t status) override;
+        void SendFunctionKey(int32_t funcKey) override;
+        void MoveCursor(int32_t keyCode) override;
+        int32_t GetEnterKeyType() override;
+        int32_t GetInputPattern() override;
+        void StopInput() override;
+
+    private:
+        static inline BrokerDelegator<InputDataChannelProxy> delegator_;
+    };
+}
+}
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_data_channel_stub.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_data_channel_stub.h
new file mode 100644
index 0000000000..20ff48c7a5
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_data_channel_stub.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef FM_IMC_PROJECT_INPUTDATACHANNELSTUB_H
+#define FM_IMC_PROJECT_INPUTDATACHANNELSTUB_H
+
+#include "i_input_data_channel.h"
+#include "iremote_stub.h"
+#include "message_handler.h"
+#include "input_method_utils.h"
+#include "input_method_controller.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodController;
+
+    class InputDataChannelStub : public IRemoteStub<IInputDataChannel> {
+    public:
+        DISALLOW_COPY_AND_MOVE(InputDataChannelStub);
+        int32_t OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply,
+                                MessageOption &option) override;
+        InputDataChannelStub();
+        ~InputDataChannelStub();
+        void SetHandler(MessageHandler *handler);
+
+        bool InsertText(const std::u16string& text) override;
+        bool DeleteForward(int32_t length) override;
+        bool DeleteBackward(int32_t length) override;
+        void Close() override;
+        std::u16string GetTextBeforeCursor(int32_t number) override;
+        std::u16string GetTextAfterCursor(int32_t number) override;
+        void SendKeyboardStatus(int32_t status) override;
+        void SendFunctionKey(int32_t funcKey) override;
+        void MoveCursor(int32_t keyCode) override;
+        int32_t GetEnterKeyType() override;
+        int32_t GetInputPattern() override;
+        void StopInput() override;
+    private:
+        MessageHandler *msgHandler;
+    };
+}
+}
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_method_controller.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_method_controller.h
new file mode 100644
index 0000000000..354552ddb2
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_method_controller.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef FM_IMC_PROJECT_INPUTMETHODCONTROLLER_H
+#define FM_IMC_PROJECT_INPUTMETHODCONTROLLER_H
+
+#include <mutex>
+#include <thread>
+#include "input_data_channel_stub.h"
+#include "input_client_stub.h"
+#include "input_method_system_ability_proxy.h"
+#include "input_method_agent_proxy.h"
+#include "i_input_method_agent.h"
+#include "message_handler.h"
+#include "iremote_object.h"
+#include "input_method_utils.h"
+#include "key_event.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputDataChannelStub;
+    class InputMethodSystemAbilityProxy;
+    class OnTextChangedListener : public virtual RefBase {
+    public:
+        virtual void InsertText(const std::u16string& text) = 0;
+        virtual void DeleteForward(int32_t length) = 0;
+        virtual void DeleteBackward(int32_t length) = 0;
+        virtual void SendKeyEventFromInputMethod(const KeyEvent& event) = 0;
+        virtual void SendKeyboardInfo(const KeyboardInfo& info) = 0;
+        virtual void SetKeyboardStatus(bool status) = 0;
+        virtual void MoveCursor(const Direction direction) = 0;
+    };
+
+    class ImsaDeathRecipient : public IRemoteObject::DeathRecipient {
+    public:
+        explicit ImsaDeathRecipient();
+        ~ImsaDeathRecipient() = default;
+
+        void OnRemoteDied(const wptr<IRemoteObject> &object) override;
+    };
+
+    class InputMethodController : public RefBase {
+    public:
+        static sptr<InputMethodController> GetInstance();
+        void Attach(sptr<OnTextChangedListener> &listener);
+        std::u16string GetTextBeforeCursor(int32_t number);
+        std::u16string GetTextAfterCursor(int32_t number);
+        void ShowTextInput();
+        void HideTextInput();
+        void Close();
+        void OnRemoteSaDied(const wptr<IRemoteObject> &object);
+        void OnCursorUpdate(CursorInfo cursorInfo);
+        void OnSelectionChange(std::u16string text, int start, int end);
+        void OnConfigurationChange(Configuration info);
+        bool dispatchKeyEvent(std::shared_ptr<MMI::KeyEvent> keyEvent);
+        void DisplayOptionalInputMethod();
+        std::vector<InputMethodProperty*> ListInputMethod();
+        int32_t GetEnterKeyType();
+        int32_t GetInputPattern();
+        void HideCurrentInput();
+    private:
+        InputMethodController();
+        ~InputMethodController();
+
+        bool Initialize();
+        sptr<InputMethodSystemAbilityProxy> GetImsaProxy();
+        void PrepareInput(int32_t displayId, sptr<InputClientStub> &client, sptr<InputDataChannelStub> &channel,
+                          InputAttribute &attribute);
+        void StartInput(sptr<InputClientStub> &client);
+        void StopInput(sptr<InputClientStub> &client);
+        void ReleaseInput(sptr<InputClientStub> &client);
+        void WorkThread();
+
+        sptr<InputDataChannelStub> mInputDataChannel;
+        sptr<InputClientStub> mClient;
+        sptr<InputMethodSystemAbilityProxy> mImms;
+        sptr<ImsaDeathRecipient> deathRecipient_;
+        sptr<InputMethodAgentProxy> mAgent;
+        OnTextChangedListener *textListener;
+        InputAttribute mAttribute;
+        std::u16string mTextString;
+        int mSelectOldBegin = 0;
+        int mSelectOldEnd = 0;
+        int mSelectNewBegin = 0;
+        int mSelectNewEnd = 0;
+        CursorInfo cursorInfo_;
+
+        static std::mutex instanceLock_;
+        static sptr<InputMethodController> instance_;
+        std::thread workThreadHandler;
+        MessageHandler *msgHandler;
+        bool stop_;
+        int32_t enterKeyType_ = 0;
+        int32_t inputPattern_ = 0;
+    };
+}
+}
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_method_system_ability_proxy.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_method_system_ability_proxy.h
new file mode 100644
index 0000000000..5f1ef4704c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_method_system_ability_proxy.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMC_PROJECT_INPUTMETHODSYSTEMABILITYPROXY_H
+#define FM_IMC_PROJECT_INPUTMETHODSYSTEMABILITYPROXY_H
+
+#include <vector>
+#include "iremote_proxy.h"
+#include "i_input_method_system_ability.h"
+#include "message_parcel.h"
+#include "keyboard_type.h"
+#include "input_method_property.h"
+#include "input_client_stub.h"
+#include "input_data_channel_stub.h"
+#include "input_attribute.h"
+#include "global.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputDataChannelStub;
+    class InputMethodSystemAbilityProxy : public IRemoteProxy<IInputMethodSystemAbility> {
+    public:
+        explicit InputMethodSystemAbilityProxy(const sptr<IRemoteObject> &object);
+        ~InputMethodSystemAbilityProxy() = default;
+        DISALLOW_COPY_AND_MOVE(InputMethodSystemAbilityProxy);
+
+        virtual void prepareInput(MessageParcel& data) override;
+        virtual void releaseInput(MessageParcel& data) override;
+        virtual void startInput(MessageParcel& data) override;
+        virtual void stopInput(MessageParcel& data) override;
+        virtual void SetCoreAndAgent(MessageParcel& data) override;
+        virtual void HideCurrentInput(MessageParcel& data) override;
+
+        int32_t Prepare(int32_t displayId, sptr<InputClientStub> &client, sptr<InputDataChannelStub> &channel,
+                        InputAttribute &attribute);
+        int32_t Release(sptr<InputClientStub> &client);
+        int32_t Start(sptr<InputClientStub> &client);
+        int32_t Stop(sptr<InputClientStub> &client);
+
+        virtual void displayOptionalInputMethod(MessageParcel& data) override;
+        virtual int32_t getDisplayMode(int32_t retMode) override;
+        virtual int32_t getKeyboardWindowHeight(int32_t retHeight) override;
+        virtual int32_t getCurrentKeyboardType(KeyboardType *retType) override;
+        virtual int32_t listInputMethodEnabled(std::vector<InputMethodProperty*> *properties) override;
+        virtual int32_t listInputMethod(std::vector<InputMethodProperty*> *properties) override;
+        virtual int32_t listKeyboardType(const std::u16string& imeId, std::vector<KeyboardType*> *types) override;
+
+    private:
+        static inline BrokerDelegator<InputMethodSystemAbilityProxy> delegator_;
+    };
+}
+}
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_controller/input_method_utils.h b/ohos_ndk_aosp/includes/inputmethod_controller/input_method_utils.h
new file mode 100644
index 0000000000..5441014256
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_controller/input_method_utils.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMC_PROJECT_INPUT_METHOD_UTILS_H
+#define FM_IMC_PROJECT_INPUT_METHOD_UTILS_H
+
+#include <stdint.h>
+
+namespace OHOS {
+namespace MiscServices {
+    enum class EnterKeyType {
+        UNSPECIFIED = 0,
+        NONE,
+        GO,
+        SEARCH,
+        SEND,
+        NEXT,
+        DONE,
+        PREVIOUS
+    };
+
+    enum class TextInputType {
+        NONE = -1,
+        TEXT = 0,
+        MULTILINE,
+        NUMBER,
+        PHONE,
+        DATETIME,
+        EMAIL_ADDRESS,
+        URL,
+        VISIBLE_PASSWORD,
+    };
+
+    enum class Direction {
+        NONE = 0,
+        UP = 1,
+        DOWN,
+        LEFT,
+        RIGHT,
+    };
+
+    class Configuration {
+    public:
+        EnterKeyType GetEnterKeyType() const
+        {
+            return enterKeyType;
+        }
+
+        void SetEnterKeyType(EnterKeyType keyType)
+        {
+            enterKeyType = keyType;
+        }
+
+        TextInputType GetTextInputType() const
+        {
+            return textInputType;
+        }
+
+        void SetTextInputType(TextInputType textType)
+        {
+            textInputType = textType;
+        }
+
+    private:
+        EnterKeyType enterKeyType = EnterKeyType::UNSPECIFIED;
+        TextInputType textInputType = TextInputType::TEXT;
+    };
+
+    struct CursorInfo {
+        double left = 0.0;
+        double top = 0.0;
+        double width = 0.0;
+        double height = 0.0;
+    };
+
+    class KeyEvent {
+    };
+
+    enum class KeyboardStatus {
+        NONE = 0,
+        HIDE,
+        SHOW
+    };
+    enum class FunctionKey {
+        NONE = 0,
+        CONFIRM
+    };
+    class KeyboardInfo {
+    public:
+        KeyboardStatus GetKeyboardStatus() const
+        {
+            return keyboardStatus;
+        }
+
+        void SetKeyboardStatus(int32_t status)
+        {
+            keyboardStatus = static_cast<KeyboardStatus>(status);
+        }
+
+        FunctionKey GetFunctionKey() const
+        {
+            return functionKey;
+        }
+
+        void SetFunctionKey(int32_t key)
+        {
+            functionKey = static_cast<FunctionKey>(key);
+        }
+    private:
+        KeyboardStatus keyboardStatus = KeyboardStatus::NONE;
+        FunctionKey functionKey = FunctionKey::NONE;
+    };
+}
+}
+#endif // FM_IMC_PROJECT_INPUT_METHOD_UTILS_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/global.h b/ohos_ndk_aosp/includes/inputmethod_services/global.h
new file mode 100644
index 0000000000..353e550905
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/global.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_GLOBAL_H
+#define FM_IMMS_PROJECT_GLOBAL_H
+
+#include <errno.h>
+#include <time.h>
+#include <sys/time.h>
+#include "iremote_broker.h"
+#include "peer_holder.h"
+#include "ipc_object_stub.h"
+#include "refbase.h"
+#include "hilog/log.h"
+
+namespace OHOS {
+namespace MiscServices {
+#define PLATFORM   OHOS
+
+using BRemoteObject = IPCObjectStub;
+
+#define INPUTMETHOD_DEBUG 0
+
+#define LOG_INFO(fmt, args...) \
+    LogTimeStamp(); printf("I %s:%d  %s - " fmt, basename(__FILE__), __LINE__, __FUNCTION__, ##args)
+
+#define LOG_ERROR(fmt, args...) \
+    LogTimeStamp(); printf("E %s:%d  %s - " fmt, basename(__FILE__), __LINE__, __FUNCTION__, ##args)
+
+#define LOG_WARNING(fmt, args...) \
+    LogTimeStamp(); printf("W %s:%d  %s - " fmt, basename(__FILE__), __LINE__, __FUNCTION__, ##args)
+
+#if DEBUG
+#define LOG_DEBUG(fmt, args...) \
+    LogTimeStamp(); printf("D %s:%d  %s - " fmt, basename(__FILE__), __LINE__, __FUNCTION__, ##args)
+#else
+#define LOG_DEBUG(fmt, args...)
+#endif
+
+void LogTimeStamp();
+
+namespace CommonEvent {
+    // the events handled in input method management system
+    enum {
+        COMMON_EVENT_USER_STARTED = 10001, // a user is started.
+        COMMON_EVENT_USER_STOPPED = 10002, // a user is stopped.
+        COMMON_EVENT_USER_UNLOCKED = 10003, // a user is unlocked.
+        COMMON_EVENT_USER_LOCKED = 10004, // a user is locked.
+        COMMON_EVENT_SETTING_CHANGED = 10005, // input method setting data is changed.
+        COMMON_EVENT_PACKAGE_ADDED = 10006, // a package is installed.
+        COMMON_EVENT_PACKAGE_REMOVED = 10007, // a package is removed
+    };
+};
+
+// User State
+namespace UserState {
+    // The states of a user in the system.
+    enum {
+        USER_STATE_NOT_AVAILABLE = -1,
+        USER_STATE_STARTED = 0, // a user is started.
+        USER_STATE_UNLOCKED, // a user is unlocked.
+    };
+};
+
+// Error Code
+namespace ErrorCode {
+    // Error Code definition in the input method management system
+    enum {
+        ERROR_STATUS_UNKNOWN_ERROR = (-2147483647 - 1), // unknown error
+        ERROR_STATUS_NO_MEMORY = -ENOMEM, // no memory
+        ERROR_STATUS_INVALID_OPERATION = -ENOSYS, // invalid operation
+        ERROR_STATUS_BAD_VALUE = -EINVAL, // bad value
+        ERROR_STATUS_BAD_TYPE = ERROR_STATUS_UNKNOWN_ERROR + 1, // bad type
+        ERROR_STATUS_NAME_NOT_FOUND = -ENOENT, // name not found
+        ERROR_STATUS_PERMISSION_DENIED = -EPERM, // permission denied
+        ERROR_STATUS_NO_INIT = -ENODEV, //  no init
+        ERROR_STATUS_ALREADY_EXISTS = -EEXIST,  //  already exist
+        ERROR_STATUS_DEAD_OBJECT = -EPIPE, // dead object
+        ERROR_STATUS_FAILED_TRANSACTION = ERROR_STATUS_UNKNOWN_ERROR + 2, // failed transaction
+        ERROR_STATUS_BAD_INDEX = -EOVERFLOW, // bad index
+        ERROR_STATUS_NOT_ENOUGH_DATA = -ENODATA, // not enough data
+        ERROR_STATUS_WOULD_BLOCK = -EWOULDBLOCK, // would block
+        ERROR_STATUS_TIMED_OUT = -ETIMEDOUT, // time out
+        ERROR_STATUS_UNKNOWN_TRANSACTION = -EBADMSG, // unknown transaction
+        ERROR_STATUS_FDS_NOT_ALLOWED = ERROR_STATUS_UNKNOWN_ERROR + 7, // fds not allowed
+        ERROR_STATUS_UNEXPECTED_NULL = ERROR_STATUS_UNKNOWN_ERROR + 8, // unexpected null,
+
+        // binder exception error code from Status.h
+        ERROR_EX_ILLEGAL_ARGUMENT = -3, // illegal argument exception
+        ERROR_EX_NULL_POINTER = -4, // null pointer exception
+        ERROR_EX_ILLEGAL_STATE = -5, // illegal state exception
+        ERROR_EX_NETWORK_MAIN_THREAD = -6, // network main thread exception
+        ERROR_EX_UNSUPPORTED_OPERATION = -7, // unsupported operation exception
+        ERROR_EX_SERVICE_SPECIFIC = -8, // service specific exception
+        ERROR_EX_PARCELABLE = -9, // parcelable exception
+        // no error
+        NO_ERROR = 0, // no error
+
+        // system service error
+        ERROR_NULL_POINTER, // null pointer
+        ERROR_BAD_PARAMETERS,  // bad parameters
+        ERROR_SERVICE_START_FAILED, // failed to start service
+        ERROR_USER_NOT_STARTED, // user is not started
+        ERROR_USER_ALREADY_STARTED, // user has already started
+        ERROR_USER_NOT_UNLOCKED, // user is not unlocked
+        ERROR_USER_ALREADY_UNLOCKED, // user has already unlocked
+        ERROR_USER_NOT_LOCKED, // user is not locked
+
+        ERROR_IME_NOT_AVAILABLE, // input method engine is not available
+        ERROR_SECURITY_IME_NOT_AVAILABLE, // security input method engine is not available
+        ERROR_TOKEN_CREATE_FAILED, // failed to create window token
+        ERROR_TOKEN_DESTROY_FAILED, // failed to destroy window token
+        ERROR_IME_BIND_FAILED, // failed to bind IME service
+        ERROR_IME_UNBIND_FAILED, // failed to unbind IME service
+        ERROR_IME_START_FAILED, // failed to start IME service
+        ERROR_IME_STOP_FAILED, // failed to stop IME service
+        ERROR_KBD_SHOW_FAILED, // failed to show keyboard
+        ERROR_KBD_HIDE_FAILED, // failed to hide keyboard
+        ERROR_IME_NOT_STARTED, // input method service is not started
+        ERROR_KBD_IS_OCCUPIED, // keyboard is showing by other client
+        ERROR_KBD_IS_NOT_SHOWING, // keyboard is not showing
+        ERROR_IME_ALREADY_STARTED, // input method service has already started
+        ERROR_NOT_IME_PACKAGE, // not an IME package
+        ERROR_IME_PACKAGE_DUPLICATED, // duplicated IME package
+        ERROR_SETTING_SAME_VALUE, // same setting value
+        ERROR_NO_NEXT_IME, // no next ime is available
+        ERROR_CLIENTWINDOW_NOT_FOCUSED, // the input client window is not focused
+        ERROR_CLIENT_NOT_WINDOW, // the input client is not from a valid window
+        // error from ime
+        ERROR_REMOTE_IME_DIED, // remote input method service died abnormally
+        ERROR_RESTART_IME_FAILED, // failed to restart input method service
+        // error from client
+        ERROR_REMOTE_CLIENT_DIED,  // remote client died abnormally
+        ERROR_CLIENT_DUPLICATED,  // duplicated client
+        ERROR_CLIENT_NOT_FOUND, // client is not found
+    };
+    const char* ToString(int errorCode);
+};
+
+static constexpr HiviewDFX::HiLogLabel g_SMALL_SERVICES_LABEL = {
+    LOG_CORE,
+    0xD001C00,
+    "ImsaKit"
+};
+
+#define IMSA_HILOGD(fmt, ...) (void)OHOS::HiviewDFX::HiLog::Debug(OHOS::MiscServices::g_SMALL_SERVICES_LABEL, \
+    "line: %d, function: %s," fmt, __LINE__, __FUNCTION__, ##__VA_ARGS__)
+#define IMSA_HILOGE(fmt, ...) (void)OHOS::HiviewDFX::HiLog::Error(OHOS::MiscServices::g_SMALL_SERVICES_LABEL, \
+    "line: %d, function: %s," fmt, __LINE__, __FUNCTION__, ##__VA_ARGS__)
+#define IMSA_HILOGF(fmt, ...) (void)OHOS::HiviewDFX::HiLog::Fatal(OHOS::MiscServices::g_SMALL_SERVICES_LABEL, \
+    "line: %d, function: %s," fmt, __LINE__FILE__, __FUNCTION__, ##__VA_ARGS__)
+#define IMSA_HILOGI(fmt, ...) (void)OHOS::HiviewDFX::HiLog::Info(OHOS::MiscServices::g_SMALL_SERVICES_LABEL, \
+    "line: %d, function: %s," fmt, __LINE__, __FUNCTION__, ##__VA_ARGS__)
+#define IMSA_HILOGW(fmt, ...) (void)OHOS::HiviewDFX::HiLog::Warn(OHOS::MiscServices::g_SMALL_SERVICES_LABEL, \
+    "line: %d, function: %s," fmt, __LINE__, __FUNCTION__, ##__VA_ARGS__)
+}
+}
+#endif // FM_IMMS_PROJECT_GLOBAL_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/i_input_control_channel.h b/ohos_ndk_aosp/includes/inputmethod_services/i_input_control_channel.h
new file mode 100644
index 0000000000..7fd71af1b5
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/i_input_control_channel.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IINPUTCONTROLCHANNEL_H
+#define FM_IMMS_PROJECT_IINPUTCONTROLCHANNEL_H
+
+#include "iremote_broker.h"
+#include "input_channel.h"
+#include "i_input_method_agent.h"
+#include "global.h"
+
+namespace OHOS {
+    namespace MiscServices {
+        class IInputControlChannel : public IRemoteBroker {
+        public:
+            enum {
+                HIDE_KEYBOARD_SELF = FIRST_CALL_TRANSACTION,
+                ADVANCE_TO_NEXT,
+                SET_DISPLAY_MODE,
+                ON_KEYBOARD_SHOWED,
+            };
+
+            DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.InputControlChannel");
+
+            virtual void hideKeyboardSelf(int flags) = 0;
+            virtual bool advanceToNext(bool isCurrentIme) = 0;
+            virtual void setDisplayMode(int mode) = 0;
+            virtual void onKeyboardShowed() = 0;
+        };
+    }
+}
+#endif // FM_IMMS_PROJECT_IINPUTCONTROLCHANNEL_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/i_input_method_system_ability.h b/ohos_ndk_aosp/includes/inputmethod_services/i_input_method_system_ability.h
new file mode 100644
index 0000000000..d688d98a9b
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/i_input_method_system_ability.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IINPUTMETHODSYSTEMABILITY_H
+#define FM_IMMS_PROJECT_IINPUTMETHODSYSTEMABILITY_H
+
+#include <vector>
+#include <errors.h>
+#include "iremote_broker.h"
+#include "i_input_client.h"
+#include "i_input_data_channel.h"
+#include "input_attribute.h"
+#include "input_method_property.h"
+#include "keyboard_type.h"
+#include "global.h"
+#include "message_parcel.h"
+#include "i_input_method_core.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class IInputMethodSystemAbility : public IRemoteBroker {
+    public:
+        enum {
+            PREPARE_INPUT = 0,
+            RELEASE_INPUT,
+            START_INPUT,
+            STOP_INPUT,
+            HIDE_CURRENT_INPUT,
+            SET_INPUT_METHOD_CORE,
+            GET_DISPLAY_MODE,
+            GET_KEYBOARD_WINDOW_HEIGHT,
+            GET_CURRENT_KEYBOARD_TYPE,
+            LIST_INPUT_METHOD_ENABLED,
+            LIST_INPUT_METHOD,
+            LIST_KEYBOARD_TYPE,
+            SET_CORE_AND_AGENT,
+            DISPLAY_OPTIONAL_INPUT_METHOD,
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.IInputMethodSystemAbility");
+
+        virtual void prepareInput(MessageParcel& data) = 0;
+        virtual void releaseInput(MessageParcel& data) = 0;
+        virtual void startInput(MessageParcel& data) = 0;
+        virtual void stopInput(MessageParcel& data) = 0;
+        virtual void SetCoreAndAgent(MessageParcel& data) = 0;
+        virtual void HideCurrentInput(MessageParcel& data) = 0;
+
+        virtual void displayOptionalInputMethod(MessageParcel& data) = 0;
+        virtual int32_t getDisplayMode(int32_t retMode) = 0;
+        virtual int32_t getKeyboardWindowHeight(int32_t retHeight) = 0;
+        virtual int32_t getCurrentKeyboardType(KeyboardType *retType) = 0;
+        virtual int32_t listInputMethodEnabled(std::vector<InputMethodProperty*> *properties) = 0;
+        virtual int32_t listInputMethod(std::vector<InputMethodProperty*> *properties) = 0;
+        virtual int32_t listKeyboardType(const std::u16string& imeId, std::vector<KeyboardType*> *types) = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_IINPUTMETHODSYSTEMABILITY_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/i_platform_api.h b/ohos_ndk_aosp/includes/inputmethod_services/i_platform_api.h
new file mode 100644
index 0000000000..006b03955c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/i_platform_api.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IPLATFORMAPI_H
+#define FM_IMMS_PROJECT_IPLATFORMAPI_H
+
+#include <vector>
+#include <string>
+#include "iremote_broker.h"
+#include "ipc_types.h"
+
+#include "i_platform_callback.h"
+#include "input_method_property.h"
+#include "input_method_setting.h"
+#include "i_input_method_core.h"
+#include "global.h"
+
+namespace OHOS {
+    namespace MiscServices {
+    class IPlatformApi : public IRemoteBroker {
+    public:
+        enum {
+            REGISTER_CALLBACK = FIRST_CALL_TRANSACTION,
+            BIND_IMS,
+            UNBIND_IMS,
+            CREATE_WINDOW_TOKEN,
+            DESTROY_WINDOW_TOKEN,
+            LIST_INPUT_METHOD,
+            GET_INPUT_METHOD_PROPERTY,
+            GET_INPUT_METHOD_SETTING,
+            SET_INPUT_METHOD_SETTING,
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.IPlatformApi");
+
+        virtual int32_t registerCallback(const sptr<IPlatformCallback>& cb) = 0;
+        virtual sptr<IInputMethodCore> bindInputMethodService(const std::u16string& packageName,
+                                                              const std::u16string& intention, int userId) = 0;
+        virtual int32_t unbindInputMethodService(int userId, const std::u16string& packageName) = 0;
+        virtual sptr<IRemoteObject> createWindowToken(int userId, int displayId, const std::u16string& packageName) = 0;
+        virtual int32_t destroyWindowToken(int userId, const std::u16string& packageName) = 0;
+        virtual int32_t listInputMethod(int userId, std::vector<InputMethodProperty*> *properties) = 0;
+        virtual int32_t getInputMethodProperty(int userId, const std::u16string& packageName,
+                                                InputMethodProperty *inputMethodProperty) = 0;
+        virtual int32_t getInputMethodSetting(int userId, InputMethodSetting *inputMethodSetting) = 0;
+        virtual int32_t setInputMethodSetting(int userId, const InputMethodSetting& inputMethodSetting) = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_IPLATFORMAPI_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/i_platform_callback.h b/ohos_ndk_aosp/includes/inputmethod_services/i_platform_callback.h
new file mode 100644
index 0000000000..2c94b538b4
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/i_platform_callback.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IPLATFORMCALLBACK_H
+#define FM_IMMS_PROJECT_IPLATFORMCALLBACK_H
+
+#include <vector>
+#include <string>
+#include "iremote_broker.h"
+#include "ipc_types.h"
+#include "global.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class IPlatformCallback : public IRemoteBroker {
+    public:
+        enum {
+            NOTIFY_EVENT = OHOS::FIRST_CALL_TRANSACTION,
+        };
+
+        DECLARE_INTERFACE_DESCRIPTOR(u"ohos.miscservices.inputmethod.IPlatformCallback");
+
+        virtual void notifyEvent(int eventId, int userId, const std::vector<std::u16string>& eventContent) = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_IPLATFORMCALLBACK_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/im_common_event_manager.h b/ohos_ndk_aosp/includes/inputmethod_services/im_common_event_manager.h
new file mode 100644
index 0000000000..4b7e0d6b10
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/im_common_event_manager.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_IMCOMMONEVENTMANAGER_H
+#define FM_IMMS_PROJECT_IMCOMMONEVENTMANAGER_H
+
+#include <mutex>
+#include "common_event_subscriber.h"
+#include "common_event_subscribe_info.h"
+#include "common_event_data.h"
+#include "matching_skills.h"
+
+namespace OHOS {
+namespace MiscServices {
+class ImCommonEventManager : public RefBase {
+public:
+    ImCommonEventManager();
+    ~ImCommonEventManager();
+    static sptr<ImCommonEventManager> GetInstance();
+    bool SubscribeEvent(const std::string &event);
+    bool UnsubscribeEvent();
+
+    class EventSubscriber : public EventFwk::CommonEventSubscriber {
+    public:
+        EventSubscriber(const EventFwk::CommonEventSubscribeInfo &subscribeInfo)
+            : EventFwk::CommonEventSubscriber(subscribeInfo) {}
+        void OnReceiveEvent(const EventFwk::CommonEventData &data);
+        void startUser(int32_t newUserId);
+    };
+
+private:
+    static std::mutex instanceLock_;
+    static sptr<ImCommonEventManager> instance_;
+};
+} // namespace MiscServices
+} // namespace OHOS
+#endif // FM_IMMS_PROJECT_IPLATFORMCALLBACK_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_attribute.h b/ohos_ndk_aosp/includes/inputmethod_services/input_attribute.h
new file mode 100644
index 0000000000..a2912391c8
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_attribute.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTATTRIBUTE_H
+#define FM_IMMS_PROJECT_INPUTATTRIBUTE_H
+#include "parcel.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputAttribute : public Parcelable {
+    public:
+        InputAttribute();
+        InputAttribute(const InputAttribute& attribute);
+        InputAttribute& operator =(const InputAttribute& attribute);
+        ~InputAttribute();
+        virtual bool Marshalling(Parcel &parcel) const override;
+        static InputAttribute *Unmarshalling(Parcel &parcel);
+        void SetInputPattern(int32_t pattern);
+        bool GetSecurityFlag();
+        static const int32_t PATTERN_TEXT = 0x00000001;
+        static const int32_t PATTERN_PASSWORD = 0x00000007;
+    private:
+        int32_t inputPattern;
+        int32_t enterKeyType;
+        int32_t inputOption;
+    };
+}
+}
+
+#endif // FM_IMMS_PROJECT_INPUTATTRIBUTE_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_channel.h b/ohos_ndk_aosp/includes/inputmethod_services/input_channel.h
new file mode 100644
index 0000000000..c22a79de6c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_channel.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT__INPUTCHANNEL_H
+#define FM_IMMS_PROJECT__INPUTCHANNEL_H
+#include <string>
+#include "parcel.h"
+#include "global.h"
+#include "message_parcel.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputChannel : public Parcelable {
+    public:
+        InputChannel();
+        ~InputChannel();
+        virtual bool Marshalling(Parcel &parcel) const override;
+        static InputChannel *Unmarshalling(Parcel &parcel);
+    private:
+        std::u16string name;
+        MessageParcel inputChannelParcel;
+        InputChannel(const InputChannel& channel);
+        InputChannel& operator =(const InputChannel& channel);
+    };
+}
+}
+#endif // INPUTMETHODSYSTEMSERVICE_INPUTCHANNEL_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_control_channel_proxy.h b/ohos_ndk_aosp/includes/inputmethod_services/input_control_channel_proxy.h
new file mode 100644
index 0000000000..fca53776d9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_control_channel_proxy.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTCONTROLCHANNELPROXY_H
+#define FM_IMMS_PROJECT_INPUTCONTROLCHANNELPROXY_H
+
+#include "parcel.h"
+#include "iremote_broker.h"
+#include "message_parcel.h"
+#include "message_handler.h"
+
+#include "global.h"
+#include "iremote_proxy.h"
+#include "i_input_control_channel.h"
+#include "i_input_method_agent.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputControlChannelProxy : public IRemoteProxy<IInputControlChannel> {
+    public:
+        InputControlChannelProxy(const sptr<IRemoteObject> &impl);
+        ~InputControlChannelProxy();
+
+        virtual void hideKeyboardSelf(int flags) override;
+        virtual bool advanceToNext(bool isCurrentIme) override;
+        virtual void setDisplayMode(int mode) override;
+        virtual void onKeyboardShowed() override;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTCONTROLCHANNELPROXY_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_control_channel_stub.h b/ohos_ndk_aosp/includes/inputmethod_services/input_control_channel_stub.h
new file mode 100644
index 0000000000..15ea287bcd
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_control_channel_stub.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTCONTROLCHANNELSTUB_H
+#define FM_IMMS_PROJECT_INPUTCONTROLCHANNELSTUB_H
+
+#include <mutex>
+#include <condition_variable>
+#include "iremote_broker.h"
+#include "iremote_stub.h"
+#include "i_input_method_agent.h"
+#include "input_channel.h"
+#include "message_parcel.h"
+#include "i_input_control_channel.h"
+
+namespace OHOS {
+    namespace MiscServices {
+    class InputControlChannelStub : public IRemoteStub<IInputControlChannel> {
+    public:
+        explicit InputControlChannelStub(int userId);
+        virtual ~InputControlChannelStub();
+        virtual int OnRemoteRequest(uint32_t code,
+                                      MessageParcel &data,
+                                      MessageParcel &reply,
+                                      MessageOption &option) override;
+        virtual void hideKeyboardSelf(int flags) override;
+        virtual bool advanceToNext(bool isCurrentIme) override;
+        virtual void setDisplayMode(int mode) override;
+        virtual void onKeyboardShowed() override;
+
+        void ResetFlag();
+        bool WaitKeyboardReady();
+    private:
+        int userId_;
+
+        std::mutex mtx;
+        std::condition_variable cv;
+        bool agentReadyFlag = false;
+        bool keyboardReadyFlag = false;
+        const int32_t sleepTime = 300;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTCONTROLCHANNELSTUB_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_method_ability_connection_stub.h b/ohos_ndk_aosp/includes/inputmethod_services/input_method_ability_connection_stub.h
new file mode 100644
index 0000000000..bc4426127c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_method_ability_connection_stub.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef SERVICES_INPUTMETHODABILITYCONNECTIONSTUB_H
+#define SERVICES_INPUTMETHODABILITYCONNECTIONSTUB_H
+#include "ability_connect_callback_stub.h"
+#include "want.h"
+#include "element_name.h"
+#include "message_handler.h"
+#include "iremote_object.h"
+#include "global.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodAbilityConnectionStub : public AAFwk::AbilityConnectionStub {
+    public:
+        enum MessageID {
+            MSG_ID_ABILITY_CONNECT_DONE = 1,
+            MSG_ID_ABILITY_DISCONNECT_DONE,
+        };
+
+        InputMethodAbilityConnectionStub(const int index);
+        ~InputMethodAbilityConnectionStub();
+        void OnAbilityConnectDone(const AppExecFwk::ElementName &element,
+                                  const sptr<IRemoteObject> &remoteObject, int resultCode) override;
+        void OnAbilityDisconnectDone(const AppExecFwk::ElementName &element, int resultCode) override;
+        void SetHandler(MessageHandler *handler);
+
+    private:
+        MessageHandler *messageHandler;
+        int mIndex;
+    };
+}
+}
+#endif // SERVICES_INPUTMETHODABILITYCONNECTIONSTUB_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_method_property.h b/ohos_ndk_aosp/includes/inputmethod_services/input_method_property.h
new file mode 100644
index 0000000000..c87be3eb46
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_method_property.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTMETHODPROPERTY_H
+#define FM_IMMS_PROJECT_INPUTMETHODPROPERTY_H
+#include <vector>
+#include <string>
+#include "parcel.h"
+#include "keyboard_type.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodProperty : public Parcelable {
+    public:
+        std::u16string mImeId;
+        std::u16string mPackageName;
+        std::u16string mAbilityName;
+        std::u16string mConfigurationPage;
+        bool isSystemIme;
+        int32_t mDefaultImeId;
+        std::vector<KeyboardType*> mTypes;
+        int32_t labelId;
+        int32_t descriptionId;
+        std::u16string label;
+        std::u16string description;
+
+        InputMethodProperty();
+        ~InputMethodProperty();
+        InputMethodProperty(const InputMethodProperty& property);
+        InputMethodProperty& operator =(const InputMethodProperty& property);
+        virtual bool Marshalling(Parcel &parcel) const override;
+        static InputMethodProperty *Unmarshalling(Parcel &parcel);
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTMETHODPROPERTY_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_method_setting.h b/ohos_ndk_aosp/includes/inputmethod_services/input_method_setting.h
new file mode 100644
index 0000000000..0594a12457
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_method_setting.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTMETHODSETTING_H
+#define FM_IMMS_PROJECT_INPUTMETHODSETTING_H
+#include <map>
+#include <vector>
+#include "string.h"
+#include "global.h"
+#include "parcel.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodSetting : public Parcelable {
+    public:
+
+        const static std::u16string CURRENT_INPUT_METHOD_TAG; // default IME
+        const static std::u16string ENABLED_INPUT_METHODS_TAG; // enabled IME list
+        const static std::u16string CURRENT_KEYBOARD_TYPE_TAG; // default keyboard type
+        const static std::u16string CURRENT_SYS_KEYBOARD_TYPE_TAG; // default keyboard type for security IME
+        const static std::u16string SYSTEM_LOCALE_TAG;  // locale list supported in the system
+
+        InputMethodSetting();
+        ~InputMethodSetting();
+        InputMethodSetting(const InputMethodSetting& inputMethodSetting);
+        InputMethodSetting& operator =(const InputMethodSetting& inputMethodSetting);
+
+        void SetValue(const std::u16string& key, const std::u16string& value);
+        std::u16string GetValue(const std::u16string& key) const;
+
+        std::u16string GetCurrentInputMethod() const;
+        void SetCurrentInputMethod(const std::u16string& imeId);
+
+        std::vector<std::u16string> GetEnabledInputMethodList();
+        bool AddEnabledInputMethod(const std::u16string& imeId, const std::vector<int32_t>& types);
+        bool RemoveEnabledInputMethod(const std::u16string& imdId);
+
+        std::vector<int32_t> GetEnabledKeyboardTypes(const std::u16string& imeId);
+        int32_t GetCurrentKeyboardType();
+        void SetCurrentKeyboardType(int32_t type);
+        int32_t GetCurrentSysKeyboardType();
+        void SetCurrentSysKeyboardType(int32_t type);
+        void ClearData();
+        bool FindKey(const std::u16string& key) const;
+
+        virtual bool Marshalling(Parcel &parcel) const override;
+        static InputMethodSetting *Unmarshalling(Parcel &parcel);
+
+    private:
+        std::map<std::u16string, std::u16string> setting;
+        const char16_t DELIM_IME = ':';
+        const char16_t DELIM_KBD_TYPE = ';';
+        std::vector<std::u16string> Split(const std::u16string& str, char16_t delim);
+        std::u16string BuildString(const std::vector<std::u16string>& vector, char16_t delim);
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTMETHODSETTING_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_method_system_ability.h b/ohos_ndk_aosp/includes/inputmethod_services/input_method_system_ability.h
new file mode 100644
index 0000000000..01beb52adc
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_method_system_ability.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTMETHODSYSTEMABILITY_H
+#define FM_IMMS_PROJECT_INPUTMETHODSYSTEMABILITY_H
+
+#include <thread>
+#include <map>
+#include "system_ability.h"
+#include "input_method_system_ability_stub.h"
+#include "peruser_setting.h"
+#include "peruser_session.h"
+#include "event_handler.h"
+#include "bundle_mgr_proxy.h"
+#include "ability_manager_interface.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputDataChannelStub;
+    enum class ServiceRunningState {
+        STATE_NOT_START,
+        STATE_RUNNING
+    };
+
+    class InputMethodSystemAbility : public SystemAbility, public InputMethodSystemAbilityStub {
+        DECLARE_SYSTEM_ABILITY(InputMethodSystemAbility);
+    public:
+        DISALLOW_COPY_AND_MOVE(InputMethodSystemAbility);
+        InputMethodSystemAbility(int32_t systemAbilityId, bool runOnCreate);
+        InputMethodSystemAbility();
+        ~InputMethodSystemAbility();
+        static sptr<InputMethodSystemAbility> GetInstance();
+        
+        int32_t GetUserState(int32_t userId);
+
+        int32_t OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply,
+                                MessageOption &option) override;
+        virtual int32_t getDisplayMode(int32_t retMode) override;
+        virtual int32_t getKeyboardWindowHeight(int32_t retHeight) override;
+        virtual int32_t getCurrentKeyboardType(KeyboardType *retType) override;
+        virtual int32_t listInputMethodEnabled(std::vector<InputMethodProperty*> *properties) override;
+        virtual int32_t listInputMethod(std::vector<InputMethodProperty*> *properties) override;
+        virtual int32_t listInputMethodByUserId(int32_t userId, std::vector<InputMethodProperty*> *properties) override;
+        virtual int32_t listKeyboardType(const std::u16string& imeId, std::vector<KeyboardType*> *types) override;
+    protected:
+        void OnStart() override;
+        void OnStop() override;
+    private:
+        int32_t Init();
+        void Initialize();
+        
+        std::thread workThreadHandler; /*!< thread handler of the WorkThread */
+
+        std::map<int32_t, PerUserSetting*> userSettings;
+
+        std::map<int32_t, PerUserSession*> userSessions;
+        std::map<int32_t, MessageHandler*> msgHandlers;
+
+        void WorkThread();
+        PerUserSetting *GetUserSetting(int32_t userId);
+        PerUserSession *GetUserSession(int32_t userId);
+        void StartInputService(std::string imeId);
+        void StopInputService(std::string imeId);
+        int32_t OnUserStarted(const Message *msg);
+        int32_t OnUserStopped(const Message *msg);
+        int32_t OnUserUnlocked(const Message *msg);
+        int32_t OnUserLocked(const Message *msg);
+        int32_t OnHandleMessage(Message *msg);
+        int32_t OnRemotePeerDied(const Message *msg);
+        int32_t OnSettingChanged(const Message *msg);
+        int32_t OnPackageRemoved(const Message *msg);
+        int32_t OnPackageAdded(const Message *msg);
+        int32_t OnDisableIms(const Message *msg);
+        int32_t OnAdvanceToNext(const Message *msg);
+        void OnDisplayOptionalInputMethod(int32_t userId);
+        static sptr<AAFwk::IAbilityManager> GetAbilityManagerService();
+        OHOS::sptr<OHOS::AppExecFwk::IBundleMgr> GetBundleMgr();
+        void StartUserIdListener();
+
+        ServiceRunningState state_;
+        void InitServiceHandler();
+        static std::mutex instanceLock_;
+        static sptr<InputMethodSystemAbility> instance_;
+        static std::shared_ptr<AppExecFwk::EventHandler> serviceHandler_;
+        int32_t userId_;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_INPUTMETHODSYSTEMABILITY_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/input_method_system_ability_stub.h b/ohos_ndk_aosp/includes/inputmethod_services/input_method_system_ability_stub.h
new file mode 100644
index 0000000000..df92a0245f
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/input_method_system_ability_stub.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_INPUTMETHODSYSTEMABILITY_SK_H
+#define FM_IMMS_PROJECT_INPUTMETHODSYSTEMABILITY_SK_H
+#include <errors.h>
+#include "refbase.h"
+#include "i_input_method_system_ability.h"
+#include "iremote_stub.h"
+#include "global.h"
+#include "message_parcel.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class InputMethodSystemAbilityStub : public IRemoteStub<IInputMethodSystemAbility> {
+    public:
+        int32_t OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply,
+                                MessageOption &option) override;
+
+        virtual void prepareInput(MessageParcel& data) override;
+        virtual void releaseInput(MessageParcel& data) override;
+        virtual void startInput(MessageParcel& data) override;
+        virtual void stopInput(MessageParcel& data) override;
+        virtual void SetCoreAndAgent(MessageParcel& data) override;
+        virtual void HideCurrentInput(MessageParcel& data) override;
+        virtual void displayOptionalInputMethod(MessageParcel& data) override;
+        virtual int32_t listInputMethodByUserId(int32_t userId, std::vector<InputMethodProperty*> *properties) = 0;
+    protected:
+        int32_t getUserId(int32_t uid);
+        int USER_ID_CHANGE_VALUE = 200000; // user range
+    };
+}
+}
+
+#endif // FM_IMMS_PROJECT_INPUTMETHODSYSTEMABILITY_SK_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/keyboard_type.h b/ohos_ndk_aosp/includes/inputmethod_services/keyboard_type.h
new file mode 100644
index 0000000000..abd5b8e078
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/keyboard_type.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_KEYBOARDTYPE_H
+#define FM_IMMS_PROJECT_KEYBOARDTYPE_H
+
+#include <vector>
+#include <string>
+#include "parcel.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class KeyboardType : public Parcelable {
+    public:
+        KeyboardType();
+        KeyboardType(const KeyboardType& type);
+        ~KeyboardType();
+        KeyboardType& operator =(const KeyboardType& type);
+        virtual bool Marshalling(Parcel &parcel) const override;
+        static KeyboardType *Unmarshalling(Parcel &parcel);
+        void setId(int32_t typeId);
+        void setLabelId(int32_t labelId);
+        void setIconId(int32_t iconId);
+        void setAsciiCapability(bool isAsciiCapable);
+        void setLanguage(std::u16string language);
+        void setInputSource(std::u16string inputSource);
+        void setCustomizedValue(std::u16string customizedValue);
+        int32_t getId() const;
+        int32_t getLabelId() const;
+        int32_t getIconId() const;
+        int32_t getHashCode() const;
+        std::u16string getLanguage() const;
+        std::u16string getInputSource() const;
+        std::u16string getCustomizedValue() const;
+        bool supportsAscii();
+
+    private:
+        int32_t mId;
+        int32_t mHashCode;
+        int32_t mLabelId;
+        int32_t mIconId;
+        bool mIsAsciiCapable;
+        std::u16string mLanguage;
+        std::u16string mInputSource;
+        std::u16string mCustomizedValue;
+
+        const int32_t ID_NONE = 0;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_KEYBOARDTYPE_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/message.h b/ohos_ndk_aosp/includes/inputmethod_services/message.h
new file mode 100644
index 0000000000..9f7cc3a969
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/message.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*! \file MessageHandler.h */
+#ifndef FM_IMMS_PROJECT_MESSAGE_H
+#define FM_IMMS_PROJECT_MESSAGE_H
+
+#include "global.h"
+#include "message_parcel.h"
+namespace OHOS {
+namespace MiscServices {
+    class Message {
+    public:
+        int32_t msgId_; // message id
+        MessageParcel *msgContent_ = nullptr; // message content
+        Message(int32_t msgId, MessageParcel *msgContent);
+        explicit Message(const Message& msg);
+        Message& operator =(const Message& msg);
+        ~Message();
+    private:
+        Message(const Message&&);
+        Message& operator =(const Message&&);
+    };
+}
+}
+
+#endif // FM_IMMS_PROJECT_MESSAGE_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/message_handler.h b/ohos_ndk_aosp/includes/inputmethod_services/message_handler.h
new file mode 100644
index 0000000000..9d05044903
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/message_handler.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*! \file MessageHandler.h */
+#ifndef FM_IMMS_PROJECT_MESSAGEHANDLER_H
+#define FM_IMMS_PROJECT_MESSAGEHANDLER_H
+
+#include <queue>
+#include <mutex>
+#include <condition_variable>
+#include "global.h"
+#include "message_parcel.h"
+#include "message.h"
+
+namespace OHOS {
+namespace MiscServices {
+namespace MessageID {
+    enum {
+        // for system broadcast
+        MSG_ID_SYSTEM_START = 0, // system started
+        MSG_ID_SYSTEM_STOP, // system stopped
+        MSG_ID_USER_START, //  a user started
+        MSG_ID_USER_STOP, // a user stopped
+        MSG_ID_USER_UNLOCK, // a user unlocked
+        MSG_ID_USER_LOCK, // a user locked
+        MSG_ID_PACKAGE_ADDED, // a package is installed
+        MSG_ID_PACKAGE_REMOVED, // a package is removed
+        MSG_ID_SETTING_CHANGED, // input method setting is changed
+
+        // the request from client
+        MSG_ID_PREPARE_INPUT, // prepare input
+        MSG_ID_START_INPUT, // start input
+        MSG_ID_STOP_INPUT, // stop input
+        MSG_ID_RELEASE_INPUT, // release input
+        MSG_ID_SET_CORE_AND_AGENT,
+        MSG_HIDE_CURRENT_INPUT,
+
+        // the request to handle the condition that the remote object died
+        MSG_ID_CLIENT_DIED, // input client died
+        MSG_ID_IMS_DIED, // input method service died
+        MSG_ID_DISABLE_IMS, // disable input method service
+        MSG_ID_RESTART_IMS, // restart input method service
+        MSG_ID_HIDE_KEYBOARD_SELF, // hide the current keyboard
+        MSG_ID_DISPLAY_OPTIONAL_INPUT_METHOD,
+        MSG_ID_ADVANCE_TO_NEXT, // switch to next
+        MSG_ID_SET_DISPLAY_MODE, // set display mode
+
+        MSG_ID_SHELL_COMMAND, // shell command
+        MSG_ID_EXIT_SERVICE, // exit service
+
+        // the request from IMSA to IMC
+        MSG_ID_INSERT_CHAR,
+        MSG_ID_DELETE_FORWARD,
+        MSG_ID_DELETE_BACKWARD,
+        MSG_ID_CLOSE,
+        MSG_ID_ON_INPUT_READY,
+        MSG_ID_SEND_KEYBOARD_STATUS,
+        MSG_ID_SEND_FUNCTION_KEY,
+        MSG_ID_MOVE_CURSOR,
+
+        // the request from IMSA to IMA
+        MSG_ID_SET_CLIENT_STATE,
+        MSG_ID_SHOW_KEYBOARD,
+        MSG_ID_INITIALIZE_INPUT,
+        MSG_ID_HIDE_KEYBOARD,
+        MSG_ID_SET_KEYBOARD_TYPE,
+        MSG_ID_STOP_INPUT_SERVICE,
+        MSG_ID_GET_KEYBOARD_WINDOW_HEIGHT,
+        MSG_ID_INIT_INPUT_CONTROL_CHANNEL,
+
+        // the request from IMC to IMA
+        MSG_ID_ON_CURSOR_UPDATE,
+        MSG_ID_ON_SELECTION_CHANGE,
+    };
+}
+
+    class MessageHandler {
+    public:
+        MessageHandler();
+        ~MessageHandler();
+        void SendMessage(Message *msg);
+        Message *GetMessage();
+        static MessageHandler *Instance();
+
+    private:
+        std::mutex mMutex; // a mutex to guard message queue
+        std::condition_variable mCV; // condition variable to work with mMutex
+        std::queue<Message*> mQueue; // Message queue, guarded by mMutex;
+
+        MessageHandler(const MessageHandler&);
+        MessageHandler& operator =(const MessageHandler&);
+        MessageHandler(const MessageHandler&&);
+        MessageHandler& operator =(const MessageHandler&&);
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_MESSAGEHANDLER_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/peruser_session.h b/ohos_ndk_aosp/includes/inputmethod_services/peruser_session.h
new file mode 100644
index 0000000000..c9e470c0d7
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/peruser_session.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_PERUSERSESSION_H
+#define FM_IMMS_PROJECT_PERUSERSESSION_H
+
+#include <thread>
+#include <mutex>
+#include <map>
+#include <memory>
+
+#include "iremote_object.h"
+#include "i_input_control_channel.h"
+#include "i_input_client.h"
+#include "i_input_method_core.h"
+#include "i_input_data_channel.h"
+#include "i_input_method_agent.h"
+#include "input_attribute.h"
+#include "input_method_property.h"
+#include "input_method_setting.h"
+#include "input_control_channel_stub.h"
+#include "message.h"
+#include "message_handler.h"
+#include "global.h"
+#include "platform.h"
+#include "keyboard_type.h"
+#include "ability_manager_interface.h"
+#include "ability_connect_callback_proxy.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class RemoteObjectDeathRecipient : public IRemoteObject::DeathRecipient {
+    public:
+        RemoteObjectDeathRecipient(int userId, int msgId);
+        ~RemoteObjectDeathRecipient();
+        void OnRemoteDied(const wptr<IRemoteObject>& who) override;
+    private:
+        int userId_; // the id of the user to whom the object is linking
+        int msgId_; // the message id can be  MessageID::MSG_ID_CLIENT_DIED and MessageID::MSG_ID_IMS_DIED
+    };
+
+    /*! \class ClientInfo
+    \brief The class defines the details of an input client.
+    */
+    class ClientInfo {
+    public:
+        int pid; // the process id of the process in which the input client is running
+        int uid; // the uid of the process in which the input client is running
+        int userId; // the user if of the user under which the input client is running
+        int displayId; // the display id on which the input client is showing
+        sptr<IInputClient> client; // the remote object handler for the service to callback to the input client
+        sptr<IInputDataChannel> channel; // the remote object handler for IMSA callback to input client
+        InputAttribute attribute; // the input attribute of the input client
+
+        ClientInfo(int pid, int uid, int userId, int displayId, const sptr<IInputClient>& client,
+                   const sptr<IInputDataChannel>& channel, const InputAttribute& attribute)
+        {
+            this->pid = pid;
+            this->uid = uid;
+            this->userId = userId;
+            this->displayId = displayId;
+            this->client = client;
+            this->channel = channel;
+            this->attribute = attribute;
+        };
+
+        ~ClientInfo()
+        {
+            this->client = nullptr;
+            this->channel = nullptr;
+        };
+    };
+
+    /*! \class PerUserSession
+        \brief The class provides session management in input method management service
+
+        This class manages the sessions between input clients and input method engines for each unlocked user.
+    */
+    class PerUserSession {
+    enum {
+        DEFAULT_IME = 0,  // index for default input method service
+        SECURITY_IME = 1, // index for security input method service
+        MAX_IME = 2, // the maximum count of ims started for a user
+    };
+
+    public:
+        explicit PerUserSession(int userId);
+        ~PerUserSession();
+
+        void SetCurrentIme(InputMethodProperty *ime);
+        void SetSecurityIme(InputMethodProperty *ime);
+        void SetInputMethodSetting(InputMethodSetting *setting);
+        void ResetIme(InputMethodProperty *defaultIme, InputMethodProperty *securityIme);
+        void OnPackageRemoved(const std::u16string& packageName);
+
+        int GetDisplayMode();
+        int GetKeyboardWindowHeight(int retHeight);
+        KeyboardType *GetCurrentKeyboardType();
+
+        int OnSettingChanged(const std::u16string& key, const std::u16string& value);
+        void CreateWorkThread(MessageHandler& handler);
+        void JoinWorkThread();
+        void StopInputService(std::string imeId);
+        static bool StartInputService();
+    private:
+        int userId_; // the id of the user to whom the object is linking
+        int userState; // the state of the user to whom the object is linking
+        int displayId; // the id of the display screen on which the user is
+        int currentIndex;
+        std::map<sptr<IRemoteObject>, ClientInfo*> mapClients;
+        int MIN_IME = 2;
+        int IME_ERROR_CODE = 3;
+        int COMMON_COUNT_THREE_HUNDRED = 300;
+        int SLEEP_TIME = 300000;
+
+        InputMethodProperty *currentIme[MAX_IME]; // 0 - the default ime. 1 - security ime
+
+        InputControlChannelStub *localControlChannel[MAX_IME];
+        sptr<IInputControlChannel> inputControlChannel[MAX_IME];
+        sptr<IInputMethodCore> imsCore[MAX_IME]; // the remote handlers of input method service
+        sptr<IRemoteObject> inputMethodToken[MAX_IME]; // the window token of keyboard
+        int currentKbdIndex[MAX_IME]; // current keyboard index
+        int lastImeIndex; // The last ime which showed keyboard
+        InputMethodSetting *inputMethodSetting; // The pointer referred to the object in PerUserSetting
+        int currentDisplayMode; // the display mode of the current keyboard
+
+        sptr<IInputMethodAgent> imsAgent;
+        InputChannel *imsChannel; // the write channel created by input method service
+        sptr<IInputClient> currentClient; // the current input client
+        sptr<IInputClient> needReshowClient; // the input client for which keyboard need to re-show
+
+        sptr<RemoteObjectDeathRecipient> clientDeathRecipient; // remote object death monitor for input client
+        sptr<RemoteObjectDeathRecipient> imsDeathRecipient;
+        MessageHandler *msgHandler = nullptr; // message handler working with Work Thread
+        std::thread workThreadHandler; // work thread handler
+        std::mutex mtx; // mutex to lock the operations among multi work threads
+        sptr<AAFwk::AbilityConnectionProxy> connCallback;
+
+        PerUserSession(const PerUserSession&);
+        PerUserSession& operator =(const PerUserSession&);
+        PerUserSession(const PerUserSession&&);
+        PerUserSession& operator =(const PerUserSession&&);
+        int IncreaseOrResetImeError(bool resetFlag, int imeIndex);
+        KeyboardType *GetKeyboardType(int imeIndex, int typeIndex);
+        void ResetCurrentKeyboardType(int imeIndex);
+        int OnCurrentKeyboardTypeChanged(int index, const std::u16string& value);
+        void CopyInputMethodService(int imeIndex);
+        ClientInfo *GetClientInfo(const sptr<IInputClient>& inputClient);
+        void WorkThread();
+        void OnPrepareInput(Message *msg);
+        void OnReleaseInput(Message *msg);
+        void OnStartInput(Message *msg);
+        void OnStopInput(Message *msg);
+        void SetCoreAndAgent(Message *msg);
+        void OnClientDied(const wptr<IRemoteObject>& who);
+        void OnImsDied(const wptr<IRemoteObject>& who);
+        void OnHideKeyboardSelf(int flags);
+        void OnAdvanceToNext();
+        void OnSetDisplayMode(int mode);
+        void OnRestartIms(int index, const std::u16string& imeId);
+        void OnUserLocked();
+        int AddClient(int pid, int uid, int displayId, const sptr<IInputClient>& inputClient,
+                  const sptr<IInputDataChannel>& channel,
+                  const InputAttribute& attribute);
+        int RemoveClient(const sptr<IInputClient>& inputClient, int retClientNum);
+        int StartInputMethod(int index);
+        int StopInputMethod(int index);
+        int ShowKeyboard(const sptr<IInputClient>& inputClient);
+        int HideKeyboard(const sptr<IInputClient>& inputClient);
+        void SetDisplayId(int displayId);
+        int GetImeIndex(const sptr<IInputClient>& inputClient);
+        static sptr<AAFwk::IAbilityManager> GetAbilityManagerService();
+        void SendAgentToSingleClient(const sptr<IInputClient>& inputClient);
+        void InitInputControlChannel();
+        void SendAgentToAllClients();
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_PERUSERSESSION_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/peruser_setting.h b/ohos_ndk_aosp/includes/inputmethod_services/peruser_setting.h
new file mode 100644
index 0000000000..28e1a5575d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/peruser_setting.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_PERUSERSETTING_H
+#define FM_IMMS_PROJECT_PERUSERSETTING_H
+
+#include <map>
+#include <string>
+#include <vector>
+#include "input_method_property.h"
+#include "input_method_setting.h"
+#include "global.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class PerUserSetting {
+    public:
+        explicit PerUserSetting(int32_t userId);
+
+        ~PerUserSetting();
+
+        void Initialize();
+        int32_t GetUserState();
+        InputMethodProperty *GetCurrentInputMethod();
+        InputMethodProperty *GetSecurityInputMethod();
+        InputMethodProperty *GetNextInputMethod();
+        InputMethodSetting *GetInputMethodSetting();
+        InputMethodProperty *GetInputMethodProperty(const std::u16string& imeId);
+
+        int32_t OnPackageAdded(std::u16string& packageName, bool isSecurityIme);
+        int32_t OnPackageRemoved(std::u16string& packageName, bool isSecurityIme);
+        int32_t OnSettingChanged(const std::u16string& key, const std::u16string& value);
+        void OnAdvanceToNext();
+        void OnUserLocked();
+        void Dump(int32_t fd);
+
+        int32_t ListInputMethodEnabled(std::vector<InputMethodProperty*> *properties);
+        int32_t ListInputMethod(std::vector<InputMethodProperty*> *properties);
+        int32_t ListKeyboardType(const std::u16string& imeId, std::vector<KeyboardType*> *types);
+
+        static bool CheckIfSecurityIme(const InputMethodProperty& property);
+
+    private:
+        int32_t userId_; // the id of the user to whom the object is linking
+        int32_t userState; // the state of the user to whom the object is linking
+        std::vector<InputMethodProperty*> inputMethodProperties; // a vector to save all IME installed for this user
+        std::u16string currentImeId; // the id of the default input method engine.
+        InputMethodSetting inputMethodSetting; // the object to manage the setting data for this user
+        int COMMON_COUNT_ONE_HUNDRED_THOUSAND = 100000;
+
+        PerUserSetting(const PerUserSetting&);
+        PerUserSetting& operator =(const PerUserSetting&);
+        PerUserSetting(const PerUserSetting&&);
+        PerUserSetting& operator =(const PerUserSetting&&);
+        void InitInputMethodSetting();
+        void ResetCurrentInputMethod();
+        std::u16string GetKeyboardTypeLanguage(const InputMethodProperty *property, int32_t hashCode);
+        std::u16string GetImeId(const std::u16string& packageName);
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_PERUSERSETTING_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/platform.h b/ohos_ndk_aosp/includes/inputmethod_services/platform.h
new file mode 100644
index 0000000000..3088e11393
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/platform.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_PLATFORMAPI_H
+#define FM_IMMS_PROJECT_PLATFORMAPI_H
+
+#include <vector>
+#include <string>
+#include <memory>
+#include "iremote_broker.h"
+#include "iremote_object.h"
+#include "i_platform_api.h"
+#include "i_input_method_core.h"
+#include "input_method_property.h"
+#include "input_method_setting.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class Platform {
+    public:
+        static Platform *Instance();
+        void SetPlatform(const sptr<IPlatformApi>& platformApi);
+        sptr<IInputMethodCore> BindInputMethodService(int userId, const std::u16string& packageName,
+                                                      const std::u16string& intention);
+        int UnbindInputMethodService(int userId, const std::u16string& packageName);
+        sptr<IRemoteObject> CreateWindowToken(int userId, int displayId, const std::u16string& packageName);
+        int DestroyWindowToken(int userId, const std::u16string& packageName);
+        int ListInputMethod(int userId, std::vector<InputMethodProperty*> *properties);
+        int GetInputMethodProperty(int userId, const std::u16string& packageName,
+                                   InputMethodProperty *inputMethodProperty);
+        int GetInputMethodSetting(int userId, InputMethodSetting *inputMethodSetting);
+        int SetInputMethodSetting(int userId, const InputMethodSetting& inputMethodSetting);
+        bool CheckPhysicalKeyboard();
+        bool IsValidWindow(int uid, int pid, int displayId);
+        bool IsWindowFocused(int uid, int pid, int displayId);
+
+        static inline sptr<IRemoteObject> RemoteBrokerToObject(const sptr<IRemoteBroker>& broker)
+        {
+            return broker->AsObject();
+        }
+
+    private:
+        sptr<IPlatformApi> platformApi;
+        Platform();
+        ~Platform();
+        Platform(const Platform&);
+        Platform& operator =(const Platform&);
+        Platform(const Platform&&);
+        Platform& operator =(const Platform&&);
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_PLATFORMAPI_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/platform_callback_stub.h b/ohos_ndk_aosp/includes/inputmethod_services/platform_callback_stub.h
new file mode 100644
index 0000000000..982f0ca95d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/platform_callback_stub.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FM_IMMS_PROJECT_PLATFORMCALLBACK_SK_H
+#define FM_IMMS_PROJECT_PLATFORMCALLBACK_SK_H
+
+#include <string>
+#include "iremote_stub.h"
+#include "message_option.h"
+#include "message_parcel.h"
+#include "i_platform_callback.h"
+
+namespace OHOS {
+namespace MiscServices {
+    class PlatformCallbackStub : public IRemoteStub<IPlatformCallback> {
+    public:
+        PlatformCallbackStub();
+        ~PlatformCallbackStub();
+
+        virtual int  OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply,
+                                     MessageOption &option) override;
+        virtual void notifyEvent(int eventId, int userId, const std::vector<std::u16string>& eventContent) override;
+    };
+}
+}
+#endif // FM_IMMS_PROJECT_PLATFORMCALLBACK_SK_H
diff --git a/ohos_ndk_aosp/includes/inputmethod_services/utils.h b/ohos_ndk_aosp/includes/inputmethod_services/utils.h
new file mode 100644
index 0000000000..087846c523
--- /dev/null
+++ b/ohos_ndk_aosp/includes/inputmethod_services/utils.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*! \file utils.h */
+
+#ifndef FM_IMMS_PROJECT_UTILS_H
+#define FM_IMMS_PROJECT_UTILS_H
+
+#include <string>
+#include <codecvt>
+#include <locale>
+#include <iostream>
+
+namespace OHOS {
+namespace MiscServices {
+    class Utils {
+    public:
+        static std::string to_utf8(std::u16string str16)
+        {
+            return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> {}.to_bytes(str16);
+        }
+        static std::u16string to_utf16(std::string str)
+        {
+            return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> {}.from_bytes(str);
+        }
+    };
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/ipc_core/ipc_file_descriptor.h b/ohos_ndk_aosp/includes/ipc_core/ipc_file_descriptor.h
new file mode 100755
index 0000000000..6f0c242d9a
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/ipc_file_descriptor.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IPC_FILE_DESCRIPTOR_H
+#define OHOS_IPC_IPC_FILE_DESCRIPTOR_H
+
+#include "parcel.h"
+
+namespace OHOS {
+class IPCFileDescriptor : public virtual Parcelable {
+public:
+    IPCFileDescriptor();
+    explicit IPCFileDescriptor(int fd);
+    ~IPCFileDescriptor();
+
+    bool Marshalling(Parcel &parcel) const override;
+    static bool Marshalling(Parcel &parcel, const sptr<IPCFileDescriptor> &object);
+    static IPCFileDescriptor *Unmarshalling(Parcel &parcel);
+    int GetFd() const;
+    void SetFd(int fd);
+
+private:
+    int fd_ = -1;
+};
+} // namespace OHOS
+#endif // OHOS_IPC_IPC_FILE_DESCRIPTOR_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/ipc_object_proxy.h b/ohos_ndk_aosp/includes/ipc_core/ipc_object_proxy.h
new file mode 100755
index 0000000000..67d0a97bc9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/ipc_object_proxy.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IPC_OBJECT_PROXY_H
+#define OHOS_IPC_IPC_OBJECT_PROXY_H
+
+#include <mutex>
+#include <vector>
+
+#include "iremote_object.h"
+
+namespace OHOS {
+class IPCObjectProxy : public IRemoteObject {
+public:
+    explicit IPCObjectProxy(int handle, std::u16string descriptor = std::u16string(),
+        int proto = IRemoteObject::IF_PROT_DEFAULT);
+    ~IPCObjectProxy();
+
+    int SendRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &optionoption) override;
+
+    bool IsProxyObject() const override
+    {
+        return true;
+    };
+
+    bool IsObjectDead() const;
+
+    int32_t GetObjectRefCount() override;
+
+    int Dump(int fd, const std::vector<std::u16string> &args) override;
+
+    void OnFirstStrongRef(const void *objectId) override;
+
+    void OnLastStrongRef(const void *objectId) override;
+
+    bool AddDeathRecipient(const sptr<DeathRecipient> &recipient) override;
+
+    bool RemoveDeathRecipient(const sptr<DeathRecipient> &recipient) override;
+
+    void SendObituary();
+
+    bool IsSubscribeDeathNotice() const
+    {
+        if (recipients_.empty()) {
+            return false;
+        }
+        return true;
+    };
+
+    uint32_t GetHandle() const
+    {
+        return handle_;
+    };
+
+    int InvokeListenThread(MessageParcel &data, MessageParcel &reply);
+    int32_t NoticeServiceDie();
+    std::string GetPidAndUidInfo();
+
+    std::string GetDataBusName();
+    std::string TransDataBusName(uint32_t uid, uint32_t pid);
+    int GetProto() const;
+    void WaitForInit();
+    std::u16string GetInterfaceDescriptor();
+
+private:
+    void MarkObjectDied();
+    int SendLocalRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &optionoption);
+    int SendRequestInner(bool isLocal, uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+
+#ifndef CONFIG_IPC_SINGLE
+    void SetProto(int proto);
+
+    int UpdateProto();
+
+    void ReleaseProto();
+
+    void IncRefToRemote();
+
+    int GetSessionFromDBinderService();
+
+    bool AddDbinderDeathRecipient();
+
+    bool RemoveDbinderDeathRecipient();
+
+    void ReleaseDatabusProto();
+
+    void ReleaseBinderProto();
+
+    bool UpdateDatabusClientSession(int handle, MessageParcel &reply);
+
+    bool CheckHaveSession(uint32_t &type);
+#endif
+
+private:
+    std::mutex initMutex_;
+    std::recursive_mutex mutex_;
+
+    std::vector<sptr<DeathRecipient>> recipients_;
+    const uint32_t handle_;
+    int proto_;
+    bool isFinishInit_;
+    bool isRemoteDead_;
+    std::u16string remoteDescriptor_;
+};
+} // namespace OHOS
+#endif // OHOS_IPC_IPC_OBJECT_PROXY_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/ipc_object_stub.h b/ohos_ndk_aosp/includes/ipc_core/ipc_object_stub.h
new file mode 100755
index 0000000000..8e922a882c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/ipc_object_stub.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IPC_OBJECT_STUB_H
+#define OHOS_IPC_IPC_OBJECT_STUB_H
+
+#include "iremote_object.h"
+#include <list>
+#include "ipc_object_proxy.h"
+
+namespace OHOS {
+struct RefCountNode {
+    int remotePid;
+    std::string deviceId;
+};
+
+class IPCObjectStub : public IRemoteObject {
+public:
+    enum {
+        OBJECT_TYPE_NATIVE,
+        OBJECT_TYPE_JAVA,
+        OBJECT_TYPE_JAVASCRIPT,
+    };
+
+    explicit IPCObjectStub(std::u16string descriptor = nullptr);
+    ~IPCObjectStub();
+
+    bool IsProxyObject() const override
+    {
+        return false;
+    };
+
+    int32_t GetObjectRefCount() override;
+
+    int Dump(int fd, const std::vector<std::u16string> &args) override;
+
+    virtual int OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+
+    int SendRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option) override;
+
+    void OnFirstStrongRef(const void *objectId) override;
+
+    void OnLastStrongRef(const void *objectId) override;
+
+    bool AddDeathRecipient(const sptr<DeathRecipient> &recipient) override;
+
+    bool RemoveDeathRecipient(const sptr<DeathRecipient> &recipient) override;
+
+    int GetCallingPid();
+
+    int GetCallingUid();
+
+    uint32_t GetCallingTokenID();
+
+    uint32_t GetFirstTokenID();
+
+    virtual int OnRemoteDump(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+
+    virtual int32_t ProcessProto(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+
+    virtual int GetObjectType() const;
+
+#ifndef CONFIG_IPC_SINGLE
+    int32_t InvokerThread(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+    int32_t NoticeServiceDie(MessageParcel &data, MessageParcel &reply, MessageOption &option);
+    int32_t InvokerDataBusThread(MessageParcel &data, MessageParcel &reply);
+    int32_t IncStubRefs(MessageParcel &data, MessageParcel &reply);
+    int32_t DecStubRefs(MessageParcel &data, MessageParcel &reply);
+    int32_t AddAuthInfo(MessageParcel &data, MessageParcel &reply, uint32_t code);
+
+private:
+    int32_t GrantDataBusName(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+    int32_t TransDataBusName(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option);
+    std::string CreateDatabusName(int uid, int pid);
+    std::string GetDataBusName();
+#endif
+private:
+    bool IsDeviceIdIllegal(const std::string &deviceID);
+};
+} // namespace OHOS
+#endif // OHOS_IPC_IPC_OBJECT_STUB_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/ipc_skeleton.h b/ohos_ndk_aosp/includes/ipc_core/ipc_skeleton.h
new file mode 100755
index 0000000000..4ea3c1a3bf
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/ipc_skeleton.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IPC_SKELETON_H
+#define OHOS_IPC_IPC_SKELETON_H
+
+#include "iremote_object.h"
+
+namespace OHOS {
+class IPCSkeleton {
+public:
+    IPCSkeleton() = default;
+    ~IPCSkeleton() = default;
+
+    // default max is 4, only if you need a customize value
+    static bool SetMaxWorkThreadNum(int maxThreadNum);
+
+    // join current thread into work loop.
+    static void JoinWorkThread();
+
+    // remove current thread from work loop.
+    static void StopWorkThread();
+
+    static pid_t GetCallingPid();
+
+    static pid_t GetCallingUid();
+
+    static uint32_t GetCallingTokenID();
+
+    static uint32_t GetFirstTokenID();
+
+    static std::string GetLocalDeviceID();
+
+    static std::string GetCallingDeviceID();
+
+    static bool IsLocalCalling();
+
+    static IPCSkeleton &GetInstance();
+
+    static sptr<IRemoteObject> GetContextObject();
+
+    static bool SetContextObject(sptr<IRemoteObject> &object);
+
+    static int FlushCommands(IRemoteObject *object);
+
+    static std::string ResetCallingIdentity();
+
+    static bool SetCallingIdentity(std::string &identity);
+};
+} // namespace OHOS
+#endif // OHOS_IPC_IPC_SKELETON_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/ipc_types.h b/ohos_ndk_aosp/includes/ipc_core/ipc_types.h
new file mode 100755
index 0000000000..66b46ad1b8
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/ipc_types.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IPC_TYPES_H
+#define OHOS_IPC_IPC_TYPES_H
+
+#include <sys/types.h>
+#include <errno.h>
+#include "errors.h"
+
+namespace OHOS {
+#define ZIPC_PACK_CHARS(c1, c2, c3, c4) ((((c1) << 24)) | (((c2) << 16)) | (((c3) << 8)) | (c4))
+
+constexpr int REGISTRY_HANDLE = 0;
+
+enum {
+    FIRST_CALL_TRANSACTION = 0x00000001,
+    LAST_CALL_TRANSACTION = 0x00ffffff,
+    PING_TRANSACTION = ZIPC_PACK_CHARS('_', 'P', 'N', 'G'),
+    DUMP_TRANSACTION = ZIPC_PACK_CHARS('_', 'D', 'M', 'P'),
+    SHELL_COMMAND_TRANSACTION = ZIPC_PACK_CHARS('_', 'C', 'M', 'D'),
+    INTERFACE_TRANSACTION = ZIPC_PACK_CHARS('_', 'N', 'T', 'F'),
+    SYSPROPS_TRANSACTION = ZIPC_PACK_CHARS('_', 'S', 'P', 'R'),
+    SYNCHRONIZE_REFERENCE = ZIPC_PACK_CHARS('_', 'S', 'Y', 'C'),
+    INVOKE_LISTEN_THREAD = ZIPC_PACK_CHARS('_', 'I', 'L', 'T'),
+    GET_PROTO_INFO = ZIPC_PACK_CHARS('_', 'G', 'R', 'I'),
+    GET_UIDPID_INFO = ZIPC_PACK_CHARS('_', 'G', 'U', 'I'),
+    GRANT_DATABUS_NAME = ZIPC_PACK_CHARS('_', 'G', 'D', 'N'),
+    TRANS_DATABUS_NAME = ZIPC_PACK_CHARS('_', 'T', 'D', 'N'),
+    DBINDER_OBITUARY_TRANSACTION = ZIPC_PACK_CHARS('_', 'D', 'O', 'T'),
+    DBINDER_INCREFS_TRANSACTION = ZIPC_PACK_CHARS('_', 'D', 'I', 'T'),
+    DBINDER_DECREFS_TRANSACTION = ZIPC_PACK_CHARS('_', 'D', 'D', 'T'),
+    DBINDER_ADD_COMMAUTH = ZIPC_PACK_CHARS('_', 'D', 'A', 'C'),
+    DBINDER_TRANS_COMMAUTH = ZIPC_PACK_CHARS('_', 'D', 'T', 'C'),
+    TRANS_SYNC = 0,
+    TRANS_ASYNC = 1,
+};
+
+enum {
+    NO_ERROR = 0,
+    TRANSACTION_ERR,
+    FLATTEN_ERR = 3,
+    UNKNOWN_TRANSACTION = 4,
+    INVALID_DATA = 5,
+    OBJECT_NULL = 7,
+    INVALID_OPERATION = 8,
+    DEAD_OBJECT = -EPIPE,
+    UNKNOWN_ERROR,
+};
+
+constexpr int MIN_TRANSACTION_ID = 0x1;
+constexpr int MAX_TRANSACTION_ID = 0x00ffffff;
+constexpr int INVALID_FD = -1;
+
+enum {
+    ERR_NONE = 0,
+    ERR_TRANSACTION_FAILED = 1,
+    ERR_UNKNOWN_OBJECT = 2,
+    ERR_FLATTEN_OBJECT = 3,
+    ERR_UNKNOWN_TRANSACTION = 4,
+    ERR_INVALID_DATA = 5,
+    ERR_NULL_OBJECT = 7,
+    ERR_UNKNOWN_REASON,
+    ERR_INVALID_REPLY,
+    ERR_INVALID_STATE,
+    IPC_SKELETON_ERR = 100,
+    IPC_SKELETON_NULL_OBJECT_ERR,
+    IPC_PROXY_ERR = 200,
+    IPC_PROXY_DEAD_OBJECT_ERR,
+    IPC_PROXY_NULL_INVOKER_ERR,
+    IPC_PROXY_TRANSACTION_ERR,
+    IPC_PROXY_INVALID_CODE_ERR,
+    IPC_STUB_ERR = 300,
+    IPC_STUB_WRITE_PARCEL_ERR,
+    IPC_STUB_INVOKE_THREAD_ERR,
+    IPC_STUB_INVALID_DATA_ERR,
+    IPC_STUB_CURRENT_NULL_ERR,
+    IPC_STUB_UNKNOW_TRANS_ERR,
+    IPC_STUB_CREATE_BUS_SERVER_ERR,
+    IPC_INVOKER_ERR = 400,
+    IPC_INVOKER_WRITE_TRANS_ERR,
+    IPC_INVOKER_TRANSLATE_ERR,
+    IPC_INVOKER_CONNECT_ERR,
+    IPC_INVOKER_ON_TRANSACT_ERR,
+    IPC_INVOKER_INVALID_DATA_ERR,
+    IPC_INVOKER_INVALID_REPLY_ERR,
+    RPC_BASE_INVOKER_ERR = 500,
+    RPC_BASE_INVOKER_INVALID_REPLY_ERR,
+    RPC_BASE_INVOKER_WAIT_REPLY_ERR,
+    RPC_BASE_INVOKER_CURRENT_NULL_ERR,
+    RPC_BASE_INVOKER_INVALID_DATA_ERR,
+    RPC_BASE_INVOKER_WRITE_TRANS_ERR,
+    RPC_BASE_INVOKER_SEND_REPLY_ERR,
+    RPC_DATABUS_INVOKER_ERR = 600,
+    RPC_DATABUS_INVOKER_INVALID_DATA_ERR,
+    RPC_DATABUS_INVOKER_CLOSED_PEER_ERR,
+    RPC_DATABUS_INVOKER_INVALID_STUB_INDEX,
+    DBINDER_SERVICE_ERR = 700,
+    DBINDER_SERVICE_INVALID_DATA_ERR,
+    DBINDER_SERVICE_NOTICE_DIE_ERR,
+    DBINDER_SERVICE_PROCESS_PROTO_ERR,
+    DBINDER_SERVICE_UNKNOW_TRANS_ERR,
+    DBINDER_SERVICE_ADD_DEATH_ERR,
+    DBINDER_SERVICE_REMOVE_DEATH_ERR,
+    DBINDER_SERVICE_WRONG_SESSION,
+    SESSION_WRONG_FD_ERR = 800,
+    SESSION_INVOKER_NULL_ERR,
+    SESSION_UNAUTHENTICATED_ERR,
+    SESSION_UNOPEN_ERR = -1,
+    DBINDER_CALLBACK_ERR = 900,
+    DBINDER_CALLBACK_ADD_DEATH_ERR,
+    DBINDER_CALLBACK_RMV_DEATH_ERR,
+    DBINDER_CALLBACK_READ_OBJECT_ERR,
+    BINDER_CALLBACK_AUTHCOMM_ERR,
+    BINDER_CALLBACK_STUBINDEX_ERR
+};
+} // namespace OHOS
+#endif // OHOS_IPC_IPC_TYPES_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/iremote_broker.h b/ohos_ndk_aosp/includes/ipc_core/iremote_broker.h
new file mode 100755
index 0000000000..4251a993d8
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/iremote_broker.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IREMOTE_BROKER_H
+#define OHOS_IPC_IREMOTE_BROKER_H
+
+#include <unordered_map>
+#include <functional>
+#include "iremote_object.h"
+#include "refbase.h"
+
+namespace OHOS {
+template <typename T> class BrokerCreator {
+public:
+    BrokerCreator() = default;
+    ~BrokerCreator() = default;
+    sptr<IRemoteBroker> operator () (const sptr<IRemoteObject> &object)
+    {
+        return static_cast<IRemoteBroker *>(new T(object));
+    };
+};
+
+class IRemoteBroker : public virtual RefBase {
+public:
+    IRemoteBroker() = default;
+    virtual ~IRemoteBroker() override = default;
+    virtual sptr<IRemoteObject> AsObject() = 0;
+    static inline sptr<IRemoteBroker> AsImplement(const sptr<IRemoteObject> &object)
+    {
+        return nullptr;
+    }
+};
+
+#define DECLARE_INTERFACE_DESCRIPTOR(DESCRIPTOR)                         \
+    static inline const std::u16string metaDescriptor_ = { DESCRIPTOR }; \
+    static inline const std::u16string &GetDescriptor()                  \
+    {                                                                    \
+        return metaDescriptor_;                                          \
+    }
+
+class BrokerRegistration {
+    using Constructor = std::function<sptr<IRemoteBroker>(const sptr<IRemoteObject> &object)>;
+
+public:
+    static BrokerRegistration &Get();
+    bool Register(const std::u16string &descriptor, const Constructor &creator);
+    void Unregister(const std::u16string &descriptor);
+    sptr<IRemoteBroker> NewInstance(const std::u16string &descriptor, const sptr<IRemoteObject> &object);
+
+protected:
+    BrokerRegistration() = default;
+    ~BrokerRegistration();
+
+private:
+    BrokerRegistration(const BrokerRegistration &) = delete;
+    BrokerRegistration(BrokerRegistration &&) = delete;
+    BrokerRegistration &operator = (const BrokerRegistration &) = delete;
+    BrokerRegistration &operator = (BrokerRegistration &&) = delete;
+    std::mutex creatorMutex_;
+    std::unordered_map<std::u16string, Constructor> creators_;
+};
+
+template <typename T> class BrokerDelegator {
+public:
+    BrokerDelegator();
+    ~BrokerDelegator();
+
+private:
+    BrokerDelegator(const BrokerDelegator &) = delete;
+    BrokerDelegator(BrokerDelegator &&) = delete;
+    BrokerDelegator &operator = (const BrokerDelegator &) = delete;
+    BrokerDelegator &operator = (BrokerDelegator &&) = delete;
+};
+
+template <typename T> BrokerDelegator<T>::BrokerDelegator()
+{
+    const std::u16string descriptor = T::GetDescriptor();
+    BrokerRegistration &registration = BrokerRegistration::Get();
+    registration.Register(descriptor, BrokerCreator<T>());
+}
+
+template <typename T> BrokerDelegator<T>::~BrokerDelegator()
+{
+    const std::u16string descriptor = T::GetDescriptor();
+    BrokerRegistration &registration = BrokerRegistration::Get();
+    registration.Unregister(descriptor);
+}
+
+template <typename INTERFACE> inline sptr<INTERFACE> iface_cast(const sptr<IRemoteObject> &object)
+{
+    const std::u16string descriptor = INTERFACE::GetDescriptor();
+    BrokerRegistration &registration = BrokerRegistration::Get();
+    sptr<IRemoteBroker> broker = registration.NewInstance(descriptor, object);
+    return static_cast<INTERFACE *>(broker.GetRefPtr());
+}
+} // namespace OHOS
+#endif // OHOS_IPC_IREMOTE_BROKER_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/iremote_object.h b/ohos_ndk_aosp/includes/ipc_core/iremote_object.h
new file mode 100755
index 0000000000..7c4b8e064d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/iremote_object.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IREMOTE_OBJECT_H
+#define OHOS_IPC_IREMOTE_OBJECT_H
+
+#include <codecvt>
+#include <locale>
+#include <vector>
+#include <string>
+#include "ipc_types.h"
+#include "message_parcel.h"
+#include "message_option.h"
+
+namespace OHOS {
+class IRemoteBroker;
+inline std::u16string to_utf16(const std::string &str)
+{
+    return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> {}.from_bytes(str);
+}
+
+class IRemoteObject : public virtual Parcelable, public virtual RefBase {
+public:
+    enum {
+        IF_PROT_DEFAULT, /* Invoker family. */
+        IF_PROT_BINDER = IF_PROT_DEFAULT,
+        IF_PROT_DATABUS,
+    };
+    enum {
+        DATABUS_TYPE,
+    };
+    class DeathRecipient : public RefBase {
+    public:
+        enum {
+            ADD_DEATH_RECIPIENT,
+            REMOVE_DEATH_RECIPIENT,
+            NOTICE_DEATH_RECIPIENT,
+            TEST_SERVICE_DEATH_RECIPIENT,
+            TEST_DEVICE_DEATH_RECIPIENT,
+        };
+        virtual void OnRemoteDied(const wptr<IRemoteObject> &object) = 0;
+    };
+
+    virtual int32_t GetObjectRefCount() = 0;
+
+    virtual int SendRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option) = 0;
+
+    virtual bool IsProxyObject() const;
+
+    virtual bool CheckObjectLegality() const;
+
+    virtual bool AddDeathRecipient(const sptr<DeathRecipient> &recipient) = 0;
+
+    virtual bool RemoveDeathRecipient(const sptr<DeathRecipient> &recipient) = 0;
+
+    virtual bool Marshalling(Parcel &parcel) const override;
+
+    static IRemoteObject *Unmarshalling(Parcel &parcel);
+
+    static bool Marshalling(Parcel &parcel, const sptr<IRemoteObject> &object);
+
+    virtual sptr<IRemoteBroker> AsInterface();
+
+    virtual int Dump(int fd, const std::vector<std::u16string> &args) = 0;
+
+    const std::u16string descriptor_;
+
+    std::u16string GetObjectDescriptor() const;
+
+protected:
+    explicit IRemoteObject(std::u16string descriptor = nullptr);
+    virtual ~IRemoteObject() = default;
+};
+} // namespace OHOS
+#endif // OHOS_IPC_IREMOTE_OBJECT_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/iremote_proxy.h b/ohos_ndk_aosp/includes/ipc_core/iremote_proxy.h
new file mode 100755
index 0000000000..fff5bc5f21
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/iremote_proxy.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IREMOTE_PROXY_H
+#define OHOS_IPC_IREMOTE_PROXY_H
+
+#include "iremote_broker.h"
+#include "peer_holder.h"
+#include "iremote_object.h"
+
+namespace OHOS {
+template <typename INTERFACE> class IRemoteProxy : public PeerHolder, public INTERFACE {
+public:
+    explicit IRemoteProxy(const sptr<IRemoteObject> &object);
+    ~IRemoteProxy() override = default;
+
+protected:
+    sptr<IRemoteObject> AsObject() override;
+};
+
+template <typename INTERFACE>
+IRemoteProxy<INTERFACE>::IRemoteProxy(const sptr<IRemoteObject> &object) : PeerHolder(object)
+{
+}
+
+template <typename INTERFACE> sptr<IRemoteObject> IRemoteProxy<INTERFACE>::AsObject()
+{
+    return Remote();
+}
+} // namespace OHOS
+#endif // OHOS_IPC_IREMOTE_PROXY_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/iremote_stub.h b/ohos_ndk_aosp/includes/ipc_core/iremote_stub.h
new file mode 100755
index 0000000000..3151a93a4c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/iremote_stub.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_IREMOTE_STUB_H
+#define OHOS_IPC_IREMOTE_STUB_H
+
+#include <string>
+#include "iremote_broker.h"
+#include "ipc_object_stub.h"
+
+namespace OHOS {
+template <typename INTERFACE> class IRemoteStub : public IPCObjectStub, public INTERFACE {
+public:
+    IRemoteStub();
+    virtual ~IRemoteStub() = default;
+    sptr<IRemoteObject> AsObject() override;
+    sptr<IRemoteBroker> AsInterface() override;
+};
+
+template <typename INTERFACE> IRemoteStub<INTERFACE>::IRemoteStub() : IPCObjectStub(INTERFACE::GetDescriptor()) {}
+
+template <typename INTERFACE> sptr<IRemoteBroker> IRemoteStub<INTERFACE>::AsInterface()
+{
+    return this;
+}
+
+template <typename INTERFACE> sptr<IRemoteObject> IRemoteStub<INTERFACE>::AsObject()
+{
+    return this;
+}
+} // namespace OHOS
+#endif // OHOS_IPC_IREMOTE_STUB_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/jni_help.h b/ohos_ndk_aosp/includes/ipc_core/jni_help.h
new file mode 100755
index 0000000000..fb286bfd33
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/jni_help.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_JNI_HELP_H
+#define OHOS_IPC_JNI_HELP_H
+
+#include <jni.h>
+#include <refbase.h>
+#include <iremote_object.h>
+
+namespace OHOS {
+jobject JNIHelperGetJavaRemoteObject(JNIEnv *env, const sptr<IRemoteObject> &target);
+} // namespace OHOS
+#endif // OHOS_IPC_JNI_HELP_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/message_option.h b/ohos_ndk_aosp/includes/ipc_core/message_option.h
new file mode 100755
index 0000000000..7aa96519d9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/message_option.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_MESSAGE_OPTION_H
+#define OHOS_IPC_MESSAGE_OPTION_H
+
+#include <memory>
+namespace OHOS {
+class MessageOption {
+public:
+    enum {
+        TF_SYNC = 0x00,
+        TF_ASYNC = 0x01,
+        TF_STATUS_CODE = 0x08,
+        TF_ACCEPT_FDS = 0x10,
+        TF_WAIT_TIME = 0x4,
+    };
+    MessageOption(int flags = TF_SYNC, int waitTime = TF_WAIT_TIME);
+    ~MessageOption() = default;
+    void SetFlags(int flags);
+    int GetFlags() const;
+    void SetWaitTime(int waitTime);
+    int GetWaitTime() const;
+
+private:
+    uint32_t flags_;
+    int waitTime_;
+};
+using MessageOptionPtr = std::shared_ptr<MessageOption>;
+} // namespace OHOS
+#endif // OHOS_IPC_MESSAGE_OPTION_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/ipc_core/message_parcel.h b/ohos_ndk_aosp/includes/ipc_core/message_parcel.h
new file mode 100755
index 0000000000..af5bfb8964
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/message_parcel.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_MESSAGE_PARCEL_H
+#define OHOS_IPC_MESSAGE_PARCEL_H
+
+#include <string>
+#include "parcel.h"
+#include "refbase.h"
+#include <ashmem.h>
+
+namespace OHOS {
+class IRemoteObject;
+class MessageParcel : public Parcel {
+public:
+    MessageParcel();
+    ~MessageParcel();
+    explicit MessageParcel(Allocator *allocator);
+    bool WriteRemoteObject(const sptr<IRemoteObject> &object);
+    sptr<IRemoteObject> ReadRemoteObject();
+    bool WriteFileDescriptor(int fd);
+    int ReadFileDescriptor();
+    bool ContainFileDescriptors() const;
+    bool WriteInterfaceToken(std::u16string name);
+    std::u16string ReadInterfaceToken();
+    bool WriteRawData(const void *data, size_t size);
+    const void *ReadRawData(size_t size);
+    bool RestoreRawData(std::shared_ptr<char> rawData, size_t size);
+    const void *GetRawData() const;
+    size_t GetRawDataSize() const;
+    size_t GetRawDataCapacity() const;
+    void WriteNoException();
+    int32_t ReadException();
+    bool WriteAshmem(sptr<Ashmem> ashmem);
+    sptr<Ashmem> ReadAshmem();
+    void ClearFileDescriptor();
+    void SetClearFdFlag()
+    {
+        needCloseFd_ = true;
+    };
+
+private:
+#ifndef CONFIG_IPC_SINGLE
+    bool WriteDBinderProxy(const sptr<IRemoteObject> &object, uint32_t handle, uint64_t stubIndex);
+#endif
+    static constexpr size_t MAX_RAWDATA_SIZE = 128 * 1024 * 1024; // 128M
+    static constexpr size_t MIN_RAWDATA_SIZE = 32 * 1024;         // 32k
+    bool needCloseFd_ = false;
+    std::vector<sptr<Parcelable>> holders_;
+    int writeRawDataFd_;
+    int readRawDataFd_;
+    void *kernelMappedWrite_;
+    void *kernelMappedRead_;
+    std::shared_ptr<char> rawData_;
+    size_t rawDataSize_;
+};
+} // namespace OHOS
+#endif // OHOS_IPC_MESSAGE_PARCEL_H
diff --git a/ohos_ndk_aosp/includes/ipc_core/peer_holder.h b/ohos_ndk_aosp/includes/ipc_core/peer_holder.h
new file mode 100755
index 0000000000..9ca9c7bffe
--- /dev/null
+++ b/ohos_ndk_aosp/includes/ipc_core/peer_holder.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_IPC_PEER_HOLDER_H
+#define OHOS_IPC_PEER_HOLDER_H
+
+#include "iremote_object.h"
+
+namespace OHOS {
+class PeerHolder {
+protected:
+    PeerHolder(const sptr<IRemoteObject> &object);
+
+    ~PeerHolder() = default;
+
+    sptr<IRemoteObject> Remote();
+
+private:
+    const sptr<IRemoteObject> remoteObject_;
+};
+} // namespace OHOS
+#endif // OHOS_IPC_PEER_HOLDER_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/dumper.h b/ohos_ndk_aosp/includes/libeventhandler/dumper.h
new file mode 100644
index 0000000000..59d5d476db
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/dumper.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_DUMPER_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_DUMPER_H
+
+namespace OHOS {
+namespace AppExecFwk {
+class Dumper {
+public:
+    /**
+     * Processes the content of a specified string.
+     * @param message the content of a specified string.
+     */
+    virtual void Dump(const std::string &message) = 0;
+
+    /**
+     * Obtains the tag information.
+     * which is a prefix added to each string before the string content is processed.
+     * @return the tag information.
+     */
+    virtual std::string GetTag() = 0;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_DUMPER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/libeventhandler/event_handler.h b/ohos_ndk_aosp/includes/libeventhandler/event_handler.h
new file mode 100644
index 0000000000..aa01f68744
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/event_handler.h
@@ -0,0 +1,927 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_HANDLER_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_HANDLER_H
+
+#include "event_runner.h"
+#include "dumper.h"
+
+namespace OHOS {
+namespace AppExecFwk {
+enum class EventType {
+    SYNC_EVENT = 0,
+    DELAY_EVENT = 1,
+    TIMING_EVENT = 2,
+};
+
+template<typename T>
+class ThreadLocalData;
+
+class EventHandler : public std::enable_shared_from_this<EventHandler> {
+public:
+    using CallbackTimeout = std::function<void()>;
+    using Callback = InnerEvent::Callback;
+    using Priority = EventQueue::Priority;
+
+    /**
+     * Constructor, set 'EventRunner' automatically.
+     *
+     * @param runner The 'EventRunner'.
+     */
+    explicit EventHandler(const std::shared_ptr<EventRunner> &runner = nullptr);
+    virtual ~EventHandler();
+    DISALLOW_COPY_AND_MOVE(EventHandler);
+
+    /**
+     * Get event handler that running on current thread.
+     *
+     * @return Returns shared pointer of the current 'EventHandler'.
+     */
+    static std::shared_ptr<EventHandler> Current();
+
+    /**
+     * Send an event.
+     *
+     * @param event Event which should be handled.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully. If returns false, event should be released manually.
+     */
+    bool SendEvent(InnerEvent::Pointer &event, int64_t delayTime = 0, Priority priority = Priority::LOW);
+
+    /**
+     * Send an event.
+     *
+     * @param event Event which should be handled.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully. If returns false, event should be released manually.
+     */
+    bool SendTimingEvent(InnerEvent::Pointer &event, int64_t taskTime, Priority priority = Priority::LOW);
+
+    /**
+     * Send an event.
+     *
+     * @param event Event which should be handled.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully. If returns false, event should be released manually.
+     */
+    inline bool SendEvent(InnerEvent::Pointer &event, Priority priority)
+    {
+        return SendEvent(event, 0, priority);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param event Event which should be handled.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendEvent(InnerEvent::Pointer &&event, int64_t delayTime = 0, Priority priority = Priority::LOW)
+    {
+        return SendEvent(event, delayTime, priority);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event, default is 0.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendEvent(uint32_t innerEventId, int64_t param, int64_t delayTime)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, param), delayTime);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendEvent(uint32_t innerEventId, int64_t delayTime = 0, Priority priority = Priority::LOW)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, 0), delayTime, priority);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendEvent(uint32_t innerEventId, Priority priority)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, 0), 0, priority);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Shared pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendEvent(uint32_t innerEventId, const std::shared_ptr<T> &object, int64_t delayTime = 0)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Weak pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendEvent(uint32_t innerEventId, const std::weak_ptr<T> &object, int64_t delayTime = 0)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendEvent(uint32_t innerEventId, std::unique_ptr<T, D> &object, int64_t delayTime = 0)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendEvent(uint32_t innerEventId, std::unique_ptr<T, D> &&object, int64_t delayTime = 0)
+    {
+        return SendEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param event Event which should be handled.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendImmediateEvent(InnerEvent::Pointer &event)
+    {
+        return SendEvent(event, 0, Priority::IMMEDIATE);
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param event Event which should be handled.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendImmediateEvent(InnerEvent::Pointer &&event)
+    {
+        return SendImmediateEvent(event);
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event, default is 0.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendImmediateEvent(uint32_t innerEventId, int64_t param = 0)
+    {
+        return SendImmediateEvent(InnerEvent::Get(innerEventId, param));
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Shared pointer of object.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendImmediateEvent(uint32_t innerEventId, const std::shared_ptr<T> &object)
+    {
+        return SendImmediateEvent(InnerEvent::Get(innerEventId, object));
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Weak pointer of object.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendImmediateEvent(uint32_t innerEventId, const std::weak_ptr<T> &object)
+    {
+        return SendImmediateEvent(InnerEvent::Get(innerEventId, object));
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendImmediateEvent(uint32_t innerEventId, std::unique_ptr<T, D> &object)
+    {
+        return SendImmediateEvent(InnerEvent::Get(innerEventId, object));
+    }
+
+    /**
+     * Send an immediate event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendImmediateEvent(uint32_t innerEventId, std::unique_ptr<T, D> &&object)
+    {
+        return SendImmediateEvent(InnerEvent::Get(innerEventId, object));
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param event Event which should be handled.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendHighPriorityEvent(InnerEvent::Pointer &event, int64_t delayTime = 0)
+    {
+        return SendEvent(event, delayTime, Priority::HIGH);
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param event Event which should be handled.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendHighPriorityEvent(InnerEvent::Pointer &&event, int64_t delayTime = 0)
+    {
+        return SendHighPriorityEvent(event, delayTime);
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event, default is 0.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendHighPriorityEvent(uint32_t innerEventId, int64_t param = 0, int64_t delayTime = 0)
+    {
+        return SendHighPriorityEvent(InnerEvent::Get(innerEventId, param), delayTime);
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Shared pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendHighPriorityEvent(uint32_t innerEventId, const std::shared_ptr<T> &object, int64_t delayTime = 0)
+    {
+        return SendHighPriorityEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Weak pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendHighPriorityEvent(uint32_t innerEventId, const std::weak_ptr<T> &object, int64_t delayTime = 0)
+    {
+        return SendHighPriorityEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendHighPriorityEvent(uint32_t innerEventId, std::unique_ptr<T, D> &object, int64_t delayTime = 0)
+    {
+        return SendHighPriorityEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Send an high priority event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendHighPriorityEvent(uint32_t innerEventId, std::unique_ptr<T, D> &&object, int64_t delayTime = 0)
+    {
+        return SendHighPriorityEvent(InnerEvent::Get(innerEventId, object), delayTime);
+    }
+
+    /**
+     * Post a task.
+     *
+     * @param callback Task callback.
+     * @param name Name of the task.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostTask(const Callback &callback, const std::string &name = std::string(), int64_t delayTime = 0,
+        Priority priority = Priority::LOW)
+    {
+        return SendEvent(InnerEvent::Get(callback, name), delayTime, priority);
+    }
+
+    /**
+     * Set delivery time out callback.
+     *
+     * @param callback Delivery Time out callback.
+     */
+    void SetDeliveryTimeoutCallback(const Callback &callback)
+    {
+        deliveryTimeoutCallback_ = callback;
+    }
+
+    /**
+     * Set distribute time out callback.
+     *
+     * @param callback Distribute Time out callback.
+     */
+    void SetDistributeTimeoutCallback(const Callback &callback)
+    {
+        distributeTimeoutCallback_ = callback;
+    }
+
+    /**
+     * Post a task.
+     *
+     * @param callback Task callback.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostTask(const Callback &callback, Priority priority)
+    {
+        return PostTask(callback, std::string(), 0, priority);
+    }
+
+    /**
+     * Post a task.
+     *
+     * @param callback Task callback.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostTask(const Callback &callback, int64_t delayTime, Priority priority = Priority::LOW)
+    {
+        return PostTask(callback, std::string(), delayTime, priority);
+    }
+
+    /**
+     * Post an immediate task.
+     *
+     * @param callback Task callback.
+     * @param name Remove events by name of the task.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostImmediateTask(const Callback &callback, const std::string &name = std::string())
+    {
+        return SendEvent(InnerEvent::Get(callback, name), 0, Priority::IMMEDIATE);
+    }
+
+    /**
+     * Post a high priority task.
+     *
+     * @param callback Task callback.
+     * @param name Name of the task.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostHighPriorityTask(
+        const Callback &callback, const std::string &name = std::string(), int64_t delayTime = 0)
+    {
+        return PostTask(callback, name, delayTime, Priority::HIGH);
+    }
+
+    /**
+     * Post a high priority task.
+     *
+     * @param callback Task callback.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostHighPriorityTask(const Callback &callback, int64_t delayTime)
+    {
+        return PostHighPriorityTask(callback, std::string(), delayTime);
+    }
+
+    /**
+     * Post a idle task.
+     *
+     * @param callback task callback.
+     * @param name Name of the task.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostIdleTask(const Callback &callback, const std::string &name = std::string(), int64_t delayTime = 0)
+    {
+        return PostTask(callback, name, delayTime, Priority::IDLE);
+    }
+
+    /**
+     * Post a idle task.
+     *
+     * @param callback Task callback.
+     * @param delayTime Process the event after 'delayTime' milliseconds.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostIdleTask(const Callback &callback, int64_t delayTime)
+    {
+        return PostIdleTask(callback, std::string(), delayTime);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param event Event which should be handled.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully. If returns false, event should be released manually.
+     */
+    bool SendSyncEvent(InnerEvent::Pointer &event, Priority priority = Priority::LOW);
+
+    /**
+     * Send an event.
+     *
+     * @param event Event which should be handled.
+     * @param priority Priority of the event queue for this event.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendSyncEvent(InnerEvent::Pointer &&event, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(event, priority);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event, default is 0.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendSyncEvent(uint32_t innerEventId, int64_t param = 0, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(InnerEvent::Get(innerEventId, param), priority);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param innerEventId The id of the event.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendSyncEvent(uint32_t innerEventId, Priority priority)
+    {
+        return SendSyncEvent(InnerEvent::Get(innerEventId, 0), priority);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Shared pointer of object.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendSyncEvent(
+        uint32_t innerEventId, const std::shared_ptr<T> &object, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(InnerEvent::Get(innerEventId, object), priority);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Weak pointer of object.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendSyncEvent(uint32_t innerEventId, const std::weak_ptr<T> &object, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(InnerEvent::Get(innerEventId, object), priority);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendSyncEvent(uint32_t innerEventId, std::unique_ptr<T, D> &object, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(InnerEvent::Get(innerEventId, object), priority);
+    }
+
+    /**
+     * Send an event, and wait until this event has been handled.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendSyncEvent(uint32_t innerEventId, std::unique_ptr<T, D> &&object, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(InnerEvent::Get(innerEventId, object), priority);
+    }
+
+    /**
+     * Post a task, and wait until this task has been handled.
+     *
+     * @param callback Task callback.
+     * @param name Name of the task.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostSyncTask(const Callback &callback, const std::string &name, Priority priority = Priority::LOW)
+    {
+        return SendSyncEvent(InnerEvent::Get(callback, name), priority);
+    }
+
+    /**
+     * Post a task, and wait until this task has been handled.
+     *
+     * @param callback Task callback.
+     * @param priority Priority of the event queue for this event, IDLE is not permitted for sync event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostSyncTask(const Callback &callback, Priority priority = Priority::LOW)
+    {
+        return PostSyncTask(callback, std::string(), priority);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param event Event which should be handled.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendTimingEvent(InnerEvent::Pointer &&event, int64_t taskTime, Priority priority)
+    {
+        return SendTimingEvent(event, taskTime, priority);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param event Event which should be handled.
+     * @param taskTime Process the event at taskTime.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendTimingEvent(InnerEvent::Pointer &&event, int64_t taskTime)
+    {
+        return SendTimingEvent(event, taskTime, Priority::LOW);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param taskTime Process the event at taskTime.
+     * @param param Basic parameter of the event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendTimingEvent(uint32_t innerEventId, int64_t taskTime, int64_t param)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, param), taskTime);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendTimingEvent(uint32_t innerEventId, int64_t taskTime, Priority priority)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, 0), taskTime, priority);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if event has been sent successfully.
+     */
+    inline bool SendTimingEvent(uint32_t innerEventId, int64_t taskTime)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, 0), taskTime, Priority::LOW);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Shared pointer of object.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendTimingEvent(
+        uint32_t innerEventId, const std::shared_ptr<T> &object, int64_t taskTime, Priority priority = Priority::LOW)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, object), taskTime, priority);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Weak pointer of object.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T>
+    inline bool SendTimingEvent(
+        uint32_t innerEventId, const std::weak_ptr<T> &object, int64_t taskTime, Priority priority = Priority::LOW)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, object), taskTime, priority);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendTimingEvent(
+        uint32_t innerEventId, std::unique_ptr<T, D> &object, int64_t taskTime, Priority priority = Priority::LOW)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, object), taskTime, priority);
+    }
+
+    /**
+     * Send a timing event.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of object.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event
+     * @return Returns true if event has been sent successfully.
+     */
+    template<typename T, typename D>
+    inline bool SendTimingEvent(
+        uint32_t innerEventId, std::unique_ptr<T, D> &&object, int64_t taskTime, Priority priority = Priority::LOW)
+    {
+        return SendTimingEvent(InnerEvent::Get(innerEventId, object), taskTime, priority);
+    }
+
+    /**
+     * Post a timing task.
+     *
+     * @param callback Task callback.
+     * @param taskTime Process the event at taskTime.
+     * @param name Name of the task.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostTimingTask(const Callback &callback, int64_t taskTime, const std::string &name = std::string(),
+        Priority priority = Priority::LOW)
+    {
+        return SendTimingEvent(InnerEvent::Get(callback, name), taskTime, priority);
+    }
+
+    /**
+     * Post a timing task.
+     *
+     * @param callback Task callback.
+     * @param taskTime Process the event at taskTime.
+     * @param priority Priority of the event queue for this event.
+     * @return Returns true if task has been sent successfully.
+     */
+    inline bool PostTimingTask(const Callback &callback, int64_t taskTime, Priority priority = Priority::LOW)
+    {
+        return PostTimingTask(callback, taskTime, std::string(), priority);
+    }
+
+    /**
+     * Remove all sent events.
+     */
+    void RemoveAllEvents();
+
+    /**
+     * Remove sent events.
+     *
+     * @param innerEventId The id of the event.
+     */
+    void RemoveEvent(uint32_t innerEventId);
+
+    /**
+     * Remove sent events.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event.
+     */
+    void RemoveEvent(uint32_t innerEventId, int64_t param);
+
+    /**
+     * Remove a task.
+     *
+     * @param name Name of the task.
+     */
+    void RemoveTask(const std::string &name);
+
+    /**
+     * Add file descriptor listener for a file descriptor.
+     *
+     * @param fileDescriptor File descriptor.
+     * @param events Events from file descriptor, such as input, output, error
+     * @param listener Listener callback.
+     * @return Return 'ERR_OK' on success.
+     */
+    ErrCode AddFileDescriptorListener(
+        int32_t fileDescriptor, uint32_t events, const std::shared_ptr<FileDescriptorListener> &listener);
+
+    /**
+     * Remove all file descriptor listeners.
+     */
+    void RemoveAllFileDescriptorListeners();
+
+    /**
+     * Remove file descriptor listener for a file descriptor.
+     *
+     * @param fileDescriptor File descriptor.
+     */
+    void RemoveFileDescriptorListener(int32_t fileDescriptor);
+
+    /**
+     * Set the 'EventRunner' to the 'EventHandler'.
+     *
+     * @param runner The 'EventRunner'.
+     */
+    void SetEventRunner(const std::shared_ptr<EventRunner> &runner);
+
+    /**
+     * Get the 'EventRunner' of the 'EventHandler'.
+     *
+     * @return Return the 'EventRunner'.
+     */
+    inline const std::shared_ptr<EventRunner> &GetEventRunner() const
+    {
+        return eventRunner_;
+    }
+
+    /**
+     * Distribute the event.
+     *
+     * @param event The event should be distributed.
+     */
+    void DistributeEvent(const InnerEvent::Pointer &event);
+
+    /**
+     * Distribute time out action.
+     *
+     * @param event The event should be distribute.
+     * @param nowStart Dotting before distribution.
+     */
+    void DistributeTimeAction(const InnerEvent::Pointer &event, InnerEvent::TimePoint nowStart);
+
+    /**
+     * Delivery time out action.
+     *
+     * @param event The event should be distribute.
+     * @param nowStart Dotting before distribution.
+     */
+    void DeliveryTimeAction(const InnerEvent::Pointer &event, InnerEvent::TimePoint nowStart);
+
+    /**
+     * Print out the internal information about an object in the specified format,
+     * helping you diagnose internal errors of the object.
+     *
+     * @param dumpr The Dumper object you have implemented to process the output internal information.
+     */
+    void Dump(Dumper &dumper);
+
+    /**
+     * Check whether an event with the given ID can be found among the events that have been sent but not processed.
+     *
+     * @param innerEventId The id of the event.
+     */
+    bool HasInnerEvent(uint32_t innerEventId);
+
+    /**
+     * Check whether an event carrying the given param can be found among the events that have been sent but not
+     * processed.
+     *
+     * @param param Basic parameter of the event.
+     */
+    bool HasInnerEvent(int64_t param);
+
+    /**
+     * Check whether an event carrying the given param can be found among the events that have been sent but not
+     * processed.
+     *
+     * @param event InnerEvent whose name is to be obtained.
+     * @return Returns the task name if the given event contains a specific task; returns the event ID otherwise.
+     */
+    std::string GetEventName(const InnerEvent::Pointer &event);
+
+    /**
+     * Checks whether the current event handler is idle
+     * @return Returns true if current event handler is idle otherwise return false.
+     */
+    bool IsIdle();
+
+protected:
+    /**
+     * Process the event. Developers should override this method.
+     *
+     * @param event The event should be processed.
+     */
+    virtual void ProcessEvent(const InnerEvent::Pointer &event);
+
+private:
+    std::shared_ptr<EventRunner> eventRunner_;
+    CallbackTimeout deliveryTimeoutCallback_;
+    CallbackTimeout distributeTimeoutCallback_;
+
+    static ThreadLocalData<std::weak_ptr<EventHandler>> currentEventHandler;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // #ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_HANDLER_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/event_handler_errors.h b/ohos_ndk_aosp/includes/libeventhandler/event_handler_errors.h
new file mode 100644
index 0000000000..f8aadc7ac9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/event_handler_errors.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_HANDLER_ERRORS_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_HANDLER_ERRORS_H
+
+#include "errors.h"
+
+namespace OHOS {
+namespace AppExecFwk {
+// Module id of event handler is assigned in "appexecfwk_errors.h"
+const uint32_t APPEXECFWK_MODULE_EVENT_HANDLER = 0x10;
+constexpr ErrCode EVENT_HANDLER_ERR_OFFSET = ErrCodeOffset(SUBSYS_APPEXECFWK, APPEXECFWK_MODULE_EVENT_HANDLER);
+
+enum {
+    // Invalid parameters.
+    EVENT_HANDLER_ERR_INVALID_PARAM = EVENT_HANDLER_ERR_OFFSET,
+    // Have not set event runner yet.
+    EVENT_HANDLER_ERR_NO_EVENT_RUNNER,
+    // Not support to listen file descriptors.
+    EVENT_HANDLER_ERR_FD_NOT_SUPPORT,
+    // File descriptor is already in listening.
+    EVENT_HANDLER_ERR_FD_ALREADY,
+    // Failed to listen file descriptor.
+    EVENT_HANDLER_ERR_FD_FAILED,
+    // No permit to start or stop deposited event runner.
+    EVENT_HANDLER_ERR_RUNNER_NO_PERMIT,
+    // Event runner is already running.
+    EVENT_HANDLER_ERR_RUNNER_ALREADY,
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_HANDLER_ERRORS_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/event_queue.h b/ohos_ndk_aosp/includes/libeventhandler/event_queue.h
new file mode 100644
index 0000000000..a8029e795e
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/event_queue.h
@@ -0,0 +1,261 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_QUEUE_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_QUEUE_H
+
+#include <array>
+#include <list>
+#include <map>
+#include <mutex>
+
+#include "inner_event.h"
+#include "event_handler_errors.h"
+#include "file_descriptor_listener.h"
+#include "dumper.h"
+#include "logger.h"
+
+namespace OHOS {
+namespace AppExecFwk {
+class IoWaiter;
+
+class EventQueue final {
+public:
+    // Priority for the events
+    enum class Priority : uint32_t {
+        // Event that should be distributed at once if possible.
+        IMMEDIATE = 0,
+        // High priority event, sorted by handle time, should be distributed before low priority event.
+        HIGH,
+        // Normal event, sorted by handle time.
+        LOW,
+        // Event that should be distributed only if no other event right now.
+        IDLE,
+    };
+
+    EventQueue();
+    explicit EventQueue(const std::shared_ptr<IoWaiter> &ioWaiter);
+    ~EventQueue() = default;
+    DISALLOW_COPY_AND_MOVE(EventQueue);
+
+    /**
+     * Insert an event into event queue with different priority.
+     * The events will be sorted by handle time.
+     *
+     * @param event Event instance which should be added into event queue.
+     * @param Priority Priority of the event
+     *
+     * @see #Priority
+     */
+    void Insert(InnerEvent::Pointer &event, Priority priority = Priority::LOW);
+
+    /**
+     * Remove events if its owner is invalid.
+     */
+    void RemoveOrphan();
+
+    /**
+     * Remove events with specified requirements.
+     *
+     * @param owner Owner of the event which is point to an instance of 'EventHandler'.
+     */
+    void Remove(const std::shared_ptr<EventHandler> &owner);
+
+    /**
+     * Remove events with specified requirements.
+     *
+     * @param owner Owner of the event which is point to an instance of 'EventHandler'.
+     * @param innerEventId Remove events by event id.
+     */
+    void Remove(const std::shared_ptr<EventHandler> &owner, uint32_t innerEventId);
+
+    /**
+     * Remove events with specified requirements.
+     *
+     * @param owner Owner of the event which is point to an instance of 'EventHandler'.
+     * @param innerEventId Remove events by event id.
+     * @param param Remove events by value of param.
+     */
+    void Remove(const std::shared_ptr<EventHandler> &owner, uint32_t innerEventId, int64_t param);
+
+    /**
+     * Remove events with specified requirements.
+     *
+     * @param owner Owner of the event which is point to an instance of 'EventHandler'.
+     * @param name Remove events by name of the task.
+     */
+    void Remove(const std::shared_ptr<EventHandler> &owner, const std::string &name);
+
+    /**
+     * Add file descriptor listener for a file descriptor.
+     *
+     * @param fileDescriptor File descriptor.
+     * @param events Events from file descriptor, such as input, output, error
+     * @param listener Listener callback.
+     * @return Return 'ERR_OK' on success.
+     */
+    ErrCode AddFileDescriptorListener(
+        int32_t fileDescriptor, uint32_t events, const std::shared_ptr<FileDescriptorListener> &listener);
+
+    /**
+     * Remove all file descriptor listeners for a specified owner.
+     *
+     * @param owner Owner of the event which is point to an instance of 'FileDescriptorListener'.
+     */
+    void RemoveFileDescriptorListener(const std::shared_ptr<EventHandler> &owner);
+
+    /**
+     * Remove file descriptor listener for a file descriptor.
+     *
+     * @param fileDescriptor File descriptor.
+     */
+    void RemoveFileDescriptorListener(int32_t fileDescriptor);
+
+    /**
+     * Prepare event queue, before calling {@link #GetEvent}.
+     * If {@link #Finish} is called, prepare event queue again, before calling {@link #GetEvent}.
+     */
+    void Prepare();
+
+    /**
+     * Exit from blocking in {@link #GetEvent}, and mark the event queue finished.
+     * After calling {@link #Finish}, {@link #GetEvent} never returns any event, until {@link #Prepare} is called.
+     */
+    void Finish();
+
+    /**
+     * Get event from event queue one by one.
+     * Before calling this method, developers should call {@link #Prepare} first.
+     * If none should be handled right now, the thread will be blocked in this method.
+     * Call {@link #Finish} to exit from blocking.
+     *
+     * @return Returns nullptr if event queue is not prepared yet, or {@link #Finish} is called.
+     * Otherwise returns event instance.
+     */
+    InnerEvent::Pointer GetEvent();
+
+    /**
+     * Get expired event from event queue one by one.
+     * Before calling this method, developers should call {@link #Prepare} first.
+     *
+     * @param nextExpiredTime Output the expired time for the next event.
+     * @return Returns nullptr if none in event queue is expired.
+     * Otherwise returns event instance.
+     */
+    InnerEvent::Pointer GetExpiredEvent(InnerEvent::TimePoint &nextExpiredTime);
+
+    /**
+     * Prints out the internal information about an object in the specified format,
+     * helping you diagnose internal errors of the object.
+     *
+     * @param dumpr The Dumper object you have implemented to process the output internal information.
+     */
+    void Dump(Dumper &dumper);
+
+    /**
+     * Print out the internal information about an object in the specified format,
+     * helping you diagnose internal errors of the object.
+     *
+     * @param queueInfo queue Info.
+     */
+    void DumpQueueInfo(std::string& queueInfo);
+
+    /**
+     * Checks whether the current EventHandler is idle.
+     *
+     * @return Returns true if all events have been processed; returns false otherwise.
+     */
+    bool IsIdle();
+
+    /**
+     * Check whether this event queue is empty.
+     *
+     * @return If queue is empty return true otherwise return false.
+     */
+    bool IsQueueEmpty();
+
+    /**
+     * Check whether an event with the given ID can be found among the events that have been sent but not processed.
+     *
+     * @param owner Owner of the event which is point to an instance of 'EventHandler'.
+     * @param innerEventId The id of the event.
+     */
+    bool HasInnerEvent(const std::shared_ptr<EventHandler> &owner, uint32_t innerEventId);
+
+    /**
+     * Check whether an event carrying the given param can be found among the events that have been sent but not
+     * processed.
+     *
+     * @param owner The owner of the event which is point to an instance of 'EventHandler'.
+     * @param param The basic parameter of the event.
+     */
+    bool HasInnerEvent(const std::shared_ptr<EventHandler> &owner, int64_t param);
+
+private:
+    using RemoveFilter = std::function<bool(const InnerEvent::Pointer &)>;
+    using HasFilter = std::function<bool(const InnerEvent::Pointer &)>;
+
+    /*
+     * To avoid starvation of lower priority event queue, give a chance to process lower priority events,
+     * after continuous processing several higher priority events.
+     */
+    static const uint32_t DEFAULT_MAX_HANDLED_EVENT_COUNT = 5;
+
+    // Sub event queues for IMMEDIATE, HIGH and LOW priority. So use value of IDLE as size.
+    static const uint32_t SUB_EVENT_QUEUE_NUM = static_cast<uint32_t>(Priority::IDLE);
+
+    struct SubEventQueue {
+        std::list<InnerEvent::Pointer> queue;
+        uint32_t handledEventsCount{0};
+        uint32_t maxHandledEventsCount{DEFAULT_MAX_HANDLED_EVENT_COUNT};
+    };
+
+    void Remove(const RemoveFilter &filter);
+    bool HasInnerEvent(const HasFilter &filter);
+    InnerEvent::Pointer PickEventLocked(const InnerEvent::TimePoint &now, InnerEvent::TimePoint &nextWakeUpTime);
+    InnerEvent::Pointer GetExpiredEventLocked(InnerEvent::TimePoint &nextExpiredTime);
+    void WaitUntilLocked(const InnerEvent::TimePoint &when, std::unique_lock<std::mutex> &lock);
+    void HandleFileDescriptorEvent(int32_t fileDescriptor, uint32_t events);
+    bool EnsureIoWaiterSupportListerningFileDescriptorLocked();
+
+    std::mutex queueLock_;
+
+    // Sub event queues for different priority.
+    std::array<SubEventQueue, SUB_EVENT_QUEUE_NUM> subEventQueues_;
+
+    // Event queue for IDLE events.
+    std::list<InnerEvent::Pointer> idleEvents_;
+
+    // Next wake up time when block in 'GetEvent'.
+    InnerEvent::TimePoint wakeUpTime_ { InnerEvent::TimePoint::max() };
+
+    // Mark if in idle mode, and record the start time of idle.
+    InnerEvent::TimePoint idleTimeStamp_ { InnerEvent::Clock::now() };
+
+    bool isIdle_{true};
+
+    // Mark if the event queue is finished.
+    bool finished_{true};
+
+    // IO waiter used to block if no events while calling 'GetEvent'.
+    std::shared_ptr<IoWaiter> ioWaiter_;
+
+    // File descriptor listeners to handle IO events.
+    std::map<int32_t, std::shared_ptr<FileDescriptorListener>> listeners_;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // #ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_QUEUE_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/event_runner.h b/ohos_ndk_aosp/includes/libeventhandler/event_runner.h
new file mode 100644
index 0000000000..df408141f9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/event_runner.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_RUNNER_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_RUNNER_H
+
+#include <atomic>
+
+#include "event_queue.h"
+#include "dumper.h"
+#include "logger.h"
+
+namespace OHOS {
+namespace AppExecFwk {
+class EventInnerRunner;
+
+class EventRunner final {
+public:
+    EventRunner() = delete;
+    ~EventRunner();
+    DISALLOW_COPY_AND_MOVE(EventRunner);
+
+    /**
+     * Create new 'EventRunner'.
+     *
+     * @param inNewThread True if create new thread to start the 'EventRunner' automatically.
+     * @return Returns shared pointer of the new 'EventRunner'.
+     */
+    static std::shared_ptr<EventRunner> Create(bool inNewThread = true);
+
+    /**
+     * Create new 'EventRunner' and start to run in a new thread.
+     *
+     * @param threadName Thread name of the new created thread.
+     * @return Returns shared pointer of the new 'EventRunner'.
+     */
+    static std::shared_ptr<EventRunner> Create(const std::string &threadName);
+
+    /**
+     * Create new 'EventRunner' and start to run in a new thread.
+     * Eliminate ambiguity, while calling like 'EventRunner::Create("threadName")'.
+     *
+     * @param threadName Thread name of the new created thread.
+     * @return Returns shared pointer of the new 'EventRunner'.
+     */
+    static inline std::shared_ptr<EventRunner> Create(const char *threadName)
+    {
+        return Create((threadName != nullptr) ? std::string(threadName) : std::string());
+    }
+
+    /**
+     * Get event runner on current thread.
+     *
+     * @return Returns shared pointer of the current 'EventRunner'.
+     */
+    static std::shared_ptr<EventRunner> Current();
+
+    /**
+     * Start to run the 'EventRunner'. Only used for the 'EventRunner' which is not running in new thread.
+     * Only running on single thread.
+     *
+     * @return Returns 'ERR_OK' on success.
+     */
+    ErrCode Run();
+
+    /**
+     * Stop to run the 'EventRunner'. Only used for the 'EventRunner' which is not running in new thread.
+     * It is a good practice to call {@link #Stop} on the same thread that called {@link #Run}.
+     *
+     * @return Returns 'ERR_OK' on success.
+     */
+    ErrCode Stop();
+
+    /**
+     * Get thread name
+     *
+     * @return Returns thread name.
+     */
+    std::string GetRunnerThreadName() const;
+
+    /**
+     * Get event queue from event runner.
+     * This method only called by 'EventHandler'.
+     *
+     * @return Returns event queue.
+     */
+    inline const std::shared_ptr<EventQueue> &GetEventQueue() const
+    {
+        return queue_;
+    }
+
+    /**
+     * Obtain the event queue of the EventRunner associated with the current thread.
+     *
+     * @return Return current event queue.
+     */
+    static std::shared_ptr<EventQueue> GetCurrentEventQueue();
+
+    /**
+     * Print out the internal information about an object in the specified format,
+     * helping you diagnose internal errors of the object.
+     *
+     * @param dumpr The Dumper object you have implemented to process the output internal information.
+     */
+    void Dump(Dumper &dumper);
+
+    /**
+     * Print out the internal information about an object in the specified format,
+     * helping you diagnose internal errors of the object.
+     *
+     * @param runnerInfo runner Info.
+     */
+    void DumpRunnerInfo(std::string& runnerInfo);
+
+    /**
+     * Set the Logger object for logging messages that are processed by this event runner.
+     *
+     * @param logger The Logger object you have implemented for logging messages.
+     */
+    void SetLogger(const std::shared_ptr<Logger> &logger);
+
+    /**
+     * Obtain the ID of the worker thread associated with this EventRunner.
+     *
+     * @return thread id.
+     */
+    uint64_t GetThreadId();
+
+    /**
+     * Check whether the current thread is the worker thread of this EventRunner.
+     *
+     * @return Returns true if the current thread is the worker thread of this EventRunner; returns false otherwise.
+     */
+    bool IsCurrentRunnerThread();
+
+    /**
+     * Set the distribution standard expiration time.
+     *
+     * @param deliveryTimeout the distribution standard expiration time.
+     */
+    void SetDeliveryTimeout(int64_t deliveryTimeout)
+    {
+        deliveryTimeout_ = deliveryTimeout;
+    }
+
+    /**
+     * Get the distribution standard expiration time.
+     *
+     * @return the distribution standard expiration time.
+     */
+    int64_t GetDeliveryTimeout() const
+    {
+        return deliveryTimeout_;
+    }
+
+    /**
+     * Set the execution standard timeout period.
+     *
+     * @param distributeTimeout the distribution standard expiration time.
+     */
+    void SetDistributeTimeout(int64_t distributeTimeout)
+    {
+        distributeTimeout_ = distributeTimeout;
+    }
+
+    /**
+     * Get the execution standard timeout period.
+     *
+     * @return the distribution standard expiration time.
+     */
+    int64_t GetDistributeTimeout() const
+    {
+        return distributeTimeout_;
+    }
+
+    /**
+     * Obtains the EventRunner for the main thread of the application.
+     *
+     * @return Returns the EventRunner for the main thread of the application.
+     */
+    static std::shared_ptr<EventRunner> GetMainEventRunner();
+
+private:
+    explicit EventRunner(bool deposit);
+
+    friend class EventHandler;
+
+    /**
+     * Check whether this event runner is running.
+     *
+     * @return if this event runner is running return true otherwise return false
+     */
+    inline bool IsRunning() const
+    {
+        // If this runner is deposited, it it always running
+        return (deposit_) || (running_.load());
+    }
+
+    int64_t deliveryTimeout_ = 0;
+    int64_t distributeTimeout_ = 0;
+    bool deposit_{true};
+    std::atomic<bool> running_{false};
+    std::shared_ptr<EventQueue> queue_;
+    std::shared_ptr<EventInnerRunner> innerRunner_;
+    static std::shared_ptr<EventRunner> mainRunner_;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // #ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_EVENT_RUNNER_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/file_descriptor_listener.h b/ohos_ndk_aosp/includes/libeventhandler/file_descriptor_listener.h
new file mode 100644
index 0000000000..e299c16033
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/file_descriptor_listener.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_FILE_DESCRIPTOR_LISTENER_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_FILE_DESCRIPTOR_LISTENER_H
+
+#include <cstdint>
+#include <memory>
+
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace AppExecFwk {
+// Listen input or output events
+const uint32_t FILE_DESCRIPTOR_INPUT_EVENT = 1;
+const uint32_t FILE_DESCRIPTOR_OUTPUT_EVENT = 2;
+// Listen shutdown and exception events automatically, so not necessary to set.
+const uint32_t FILE_DESCRIPTOR_SHUTDOWN_EVENT = 4;
+const uint32_t FILE_DESCRIPTOR_EXCEPTION_EVENT = 8;
+const uint32_t FILE_DESCRIPTOR_EVENTS_MASK = (FILE_DESCRIPTOR_INPUT_EVENT | FILE_DESCRIPTOR_OUTPUT_EVENT);
+
+class EventHandler;
+
+class FileDescriptorListener {
+public:
+    DISALLOW_COPY_AND_MOVE(FileDescriptorListener);
+
+    /**
+     * Called while file descriptor is readable.
+     *
+     * @param fileDescriptor File descriptor which is readable.
+     */
+    virtual void OnReadable(int32_t fileDescriptor);
+
+    /**
+     * Called while file descriptor is writable.
+     *
+     * @param fileDescriptor File descriptor which is writable.
+     */
+    virtual void OnWritable(int32_t fileDescriptor);
+
+    /**
+     * Called while shutting down this file descriptor.
+     *
+     * @param fileDescriptor File descriptor which is shutting down.
+     */
+    virtual void OnShutdown(int32_t fileDescriptor);
+
+    /**
+     * Called while error happened on this file descriptor.
+     *
+     * @param fileDescriptor Error happened on this file descriptor.
+     */
+    virtual void OnException(int32_t fileDescriptor);
+
+    /**
+     * Get owner of the event.
+     *
+     * @return Returns owner of the event after it has been sent.
+     */
+    inline std::shared_ptr<EventHandler> GetOwner() const
+    {
+        return owner_.lock();
+    }
+
+    /**
+     * Set owner of the event.
+     *
+     * @param owner Owner for the event.
+     */
+    inline void SetOwner(const std::shared_ptr<EventHandler> &owner)
+    {
+        owner_ = owner;
+    }
+
+protected:
+    FileDescriptorListener() = default;
+    virtual ~FileDescriptorListener() = default;
+
+private:
+    std::weak_ptr<EventHandler> owner_;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // #ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_FILE_DESCRIPTOR_LISTENER_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/inner_event.h b/ohos_ndk_aosp/includes/libeventhandler/inner_event.h
new file mode 100644
index 0000000000..e05a7c0497
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/inner_event.h
@@ -0,0 +1,530 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_INNER_EVENT_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_INNER_EVENT_H
+
+#include <cstdint>
+#include <chrono>
+#include <functional>
+#include <memory>
+#include <string>
+#include <typeinfo>
+
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace HiviewDFX {
+class HiTraceId;
+}
+
+namespace AppExecFwk {
+using HiTraceId = OHOS::HiviewDFX::HiTraceId;
+
+class EventHandler;
+
+const std::string LINE_SEPARATOR = "\n";
+
+class InnerEvent final {
+public:
+    using Clock = std::chrono::steady_clock;
+    using TimePoint = std::chrono::time_point<Clock>;
+    using Callback = std::function<void()>;
+    using Pointer = std::unique_ptr<InnerEvent, void (*)(InnerEvent *)>;
+
+    class Waiter {
+    public:
+        Waiter() = default;
+        virtual ~Waiter() = default;
+        DISALLOW_COPY_AND_MOVE(Waiter);
+
+        virtual void Wait() = 0;
+        virtual void Notify() = 0;
+    };
+
+    DISALLOW_COPY_AND_MOVE(InnerEvent);
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event, default is 0.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    static Pointer Get(uint32_t innerEventId, int64_t param = 0);
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Shared pointer of the object.
+     * @param param Basic parameter of the event, default is 0.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T>
+    static inline Pointer Get(uint32_t innerEventId, const std::shared_ptr<T> &object, int64_t param = 0)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveSharedPtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Weak pointer of the object.
+     * @param param Basic parameter of the event, default is 0.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T>
+    static inline Pointer Get(uint32_t innerEventId, const std::weak_ptr<T> &object, int64_t param = 0)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveSharedPtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of the object.
+     * @param param Basic parameter of the event, default is 0.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T, typename D>
+    static inline Pointer Get(uint32_t innerEventId, std::unique_ptr<T, D> &&object, int64_t param = 0)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveUniquePtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param object Unique pointer of the object.
+     * @param param Basic parameter of the event, default is 0.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T, typename D>
+    static inline Pointer Get(uint32_t innerEventId, std::unique_ptr<T, D> &object, int64_t param = 0)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveUniquePtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event.
+     * @param object Shared pointer of the object.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T>
+    static inline Pointer Get(uint32_t innerEventId, int64_t param, const std::shared_ptr<T> &object)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveSharedPtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event.
+     * @param object Weak pointer of the object.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T>
+    static inline Pointer Get(uint32_t innerEventId, int64_t param, const std::weak_ptr<T> &object)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveSharedPtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event.
+     * @param object Unique pointer of the object.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T, typename D>
+    static inline Pointer Get(uint32_t innerEventId, int64_t param, std::unique_ptr<T, D> &&object)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveUniquePtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param innerEventId The id of the event.
+     * @param param Basic parameter of the event.
+     * @param object Unique pointer of the object.
+     * @return Returns the pointer of InnerEvent instance.
+     */
+    template<typename T, typename D>
+    static inline Pointer Get(uint32_t innerEventId, int64_t param, std::unique_ptr<T, D> &object)
+    {
+        auto event = Get(innerEventId, param);
+        event->SaveUniquePtr(object);
+        return event;
+    }
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @param callback Callback for task.
+     * @param name Name of task.
+     * @return Returns the pointer of InnerEvent instance, if callback is invalid, returns nullptr object.
+     */
+    static Pointer Get(const Callback &callback, const std::string &name = std::string());
+
+    /**
+     * Get InnerEvent instance from pool.
+     *
+     * @return Returns the pointer of InnerEvent instance
+     */
+    static Pointer Get();
+
+    /**
+     * Get owner of the event.
+     *
+     * @return Returns owner of the event after it has been sent.
+     */
+    inline std::shared_ptr<EventHandler> GetOwner() const
+    {
+        return owner_.lock();
+    }
+
+    /**
+     * Set owner of the event.
+     *
+     * @param owner Owner for the event.
+     */
+    inline void SetOwner(const std::shared_ptr<EventHandler> &owner)
+    {
+        owner_ = owner;
+    }
+
+    /**
+     * Get handle time of the event.
+     *
+     * @return Returns handle time of the event after it has been sent.
+     */
+    inline const TimePoint &GetHandleTime() const
+    {
+        return handleTime_;
+    }
+
+    /**
+     * Set handle time of the event.
+     *
+     * @param handleTime Handle time of the event.
+     */
+    inline void SetHandleTime(const TimePoint &handleTime)
+    {
+        handleTime_ = handleTime;
+    }
+
+    /**
+     * Get send time of the event.
+     *
+     * @return Returns send time of the event after it has been sent.
+     */
+    inline const TimePoint &GetSendTime() const
+    {
+        return sendTime_;
+    }
+
+    /**
+     * Set send time of the event.
+     *
+     * @param sendTime Send time of the event.
+     */
+    inline void SetSendTime(const TimePoint &sendTime)
+    {
+        sendTime_ = sendTime;
+    }
+
+    /**
+     * Get id of the event.
+     * Make sure {@link #hasTask} returns false.
+     *
+     * @return Returns id of the event after it has been sent.
+     */
+    inline uint32_t GetInnerEventId() const
+    {
+        return innerEventId_;
+    }
+
+    /**
+     * Get basic param of the event.
+     * Make sure {@link #hasTask} returns false.
+     *
+     * @return Returns basic param of the event after it has been sent.
+     */
+    inline int64_t GetParam() const
+    {
+        return param_;
+    }
+
+    /**
+     * Get saved object.
+     *
+     * @return Returns shared pointer of saved object.
+     */
+    template<typename T>
+    std::shared_ptr<T> GetSharedObject() const
+    {
+        const std::shared_ptr<T> &sharedObject = *reinterpret_cast<const std::shared_ptr<T> *>(smartPtr_);
+        if (CalculateSmartPtrTypeId(sharedObject) == smartPtrTypeId_) {
+            return sharedObject;
+        }
+
+        const std::weak_ptr<T> &weakObject = *reinterpret_cast<const std::weak_ptr<T> *>(smartPtr_);
+        if (CalculateSmartPtrTypeId(weakObject) == smartPtrTypeId_) {
+            return weakObject.lock();
+        }
+
+        WarnSmartPtrCastMismatch();
+        return nullptr;
+    }
+
+    /**
+     * Get saved object.
+     *
+     * @return Returns unique pointer of saved object.
+     */
+    template<typename T>
+    std::unique_ptr<T> GetUniqueObject() const
+    {
+        std::unique_ptr<T> &object = *reinterpret_cast<std::unique_ptr<T> *>(smartPtr_);
+        if (CalculateSmartPtrTypeId(object) == smartPtrTypeId_) {
+            return std::move(object);
+        }
+
+        WarnSmartPtrCastMismatch();
+        return nullptr;
+    }
+
+    /**
+     * Get saved object.
+     *
+     * @return Returns unique pointer of saved object.
+     */
+    template<typename T, typename D>
+    std::unique_ptr<T, D> GetUniqueObject() const
+    {
+        std::unique_ptr<T, D> &object = *reinterpret_cast<std::unique_ptr<T, D> *>(smartPtr_);
+        if (CalculateSmartPtrTypeId(object) == smartPtrTypeId_) {
+            return std::move(object);
+        }
+
+        WarnSmartPtrCastMismatch();
+        return std::unique_ptr<T, D>(nullptr, nullptr);
+    }
+
+    /**
+     * Get task name.
+     * Make sure {@link #hasTask} returns true.
+     *
+     * @return Returns the task name.
+     */
+    inline const std::string &GetTaskName() const
+    {
+        return taskName_;
+    }
+
+    /**
+     * Get task callback.
+     * Make sure {@link #hasTask} returns true.
+     *
+     * @return Returns the callback of the task.
+     */
+    inline const Callback &GetTaskCallback() const
+    {
+        return taskCallback_;
+    }
+
+    /**
+     * Obtains the Runnable task that will be executed when this InnerEvent is handled.
+     *
+     * @return Returns the callback of the task.
+     */
+    inline const Callback &GetTask() const
+    {
+        return GetTaskCallback();
+    }
+
+    /**
+     * Check whether it takes a task callback in event.
+     *
+     * @return Returns true if it takes a task callback.
+     */
+    inline bool HasTask() const
+    {
+        return static_cast<bool>(taskCallback_);
+    }
+
+    /**
+     * Prints out the internal information about an object in the specified format,
+     * helping you diagnose internal errors of the object.
+     *
+     * @param return The content of the event.
+     */
+    std::string Dump();
+
+private:
+    using SmartPtrDestructor = void (*)(void *);
+
+    InnerEvent() = default;
+    ~InnerEvent() = default;
+
+    void ClearEvent();
+
+    static void WarnSmartPtrCastMismatch();
+
+    template<typename T>
+    static void ReleaseSmartPtr(void *smartPtr)
+    {
+        if (smartPtr != nullptr) {
+            delete reinterpret_cast<T *>(smartPtr);
+        }
+    }
+
+    template<typename T>
+    inline void SaveSharedPtr(const T &object)
+    {
+        smartPtr_ = new T(object);
+        smartPtrDtor_ = ReleaseSmartPtr<T>;
+        smartPtrTypeId_ = CalculateSmartPtrTypeId(object);
+    }
+
+    template<typename T>
+    inline void SaveUniquePtr(T &object)
+    {
+        smartPtr_ = new T(std::move(object));
+        smartPtrDtor_ = ReleaseSmartPtr<T>;
+        smartPtrTypeId_ = CalculateSmartPtrTypeId(object);
+    }
+
+    /**
+     * if event has trace id ,return trace id, else create span id,
+     * store it in event and return.
+     *
+     * @return return hiTrace Id.
+     */
+    const std::shared_ptr<HiTraceId> GetOrCreateTraceId();
+
+    /**
+     * return trace id.
+     *
+     * @return return hiTrace Id.
+     */
+    const std::shared_ptr<HiTraceId> GetTraceId();
+
+    /*
+     * Calculate the type id for different smart pointers.
+     */
+#ifdef __GXX_RTTI
+    // If RTTI(Run-Time Type Info) is enabled, use hash code of type info.
+    template<typename T>
+    static inline size_t CalculateSmartPtrTypeId(const T &)
+    {
+        return typeid(T).hash_code();
+    }
+#else   // #ifdef __GXX_RTTI
+    // Otherwise, generate type id using smart pointer type and the size of the elements they contain.
+    static const size_t SHARED_PTR_TYPE = 0x10000000;
+    static const size_t WEAK_PTR_TYPE = 0x20000000;
+    static const size_t UNIQUE_PTR_TYPE = 0x30000000;
+    static const size_t UNIQUE_PTR_ARRAY_TYPE = 0x40000000;
+
+    template<typename T>
+    static inline size_t CalculateSmartPtrTypeId(const std::shared_ptr<T> &)
+    {
+        return (sizeof(T) | SHARED_PTR_TYPE);
+    }
+
+    template<typename T>
+    static inline size_t CalculateSmartPtrTypeId(const std::weak_ptr<T> &)
+    {
+        return (sizeof(T) | WEAK_PTR_TYPE);
+    }
+
+    template<typename T, typename D>
+    static inline size_t CalculateSmartPtrTypeId(const std::unique_ptr<T, D> &)
+    {
+        return (sizeof(T) | (sizeof(D) - 1) | UNIQUE_PTR_TYPE);
+    }
+
+    template<typename T, typename D>
+    static inline size_t CalculateSmartPtrTypeId(const std::unique_ptr<T[], D> &)
+    {
+        return (sizeof(T) | (sizeof(D) - 1) | UNIQUE_PTR_ARRAY_TYPE);
+    }
+#endif  // #ifdef __GXX_RTTI
+
+    // Used by event handler to create waiter.
+    const std::shared_ptr<Waiter> &CreateWaiter();
+
+    // Used by event handler to tell whether event has waiter.
+    bool HasWaiter() const;
+
+    // Let event pool to create instance of events.
+    friend class InnerEventPool;
+    // Let event handler to access private interface.
+    friend class EventHandler;
+
+    std::weak_ptr<EventHandler> owner_;
+    TimePoint handleTime_;
+    TimePoint sendTime_;
+
+    // Event id of the event, if it is not a task object
+    uint32_t innerEventId_{0};
+
+    // Simple parameter for the event.
+    int64_t param_{0};
+
+    // Using to save smart pointer
+    size_t smartPtrTypeId_{0};
+    void *smartPtr_{nullptr};
+    SmartPtrDestructor smartPtrDtor_{nullptr};
+
+    // Task callback and its name.
+    Callback taskCallback_;
+    std::string taskName_;
+
+    // Used for synchronized event.
+    std::shared_ptr<Waiter> waiter_;
+
+    // use to store hitrace Id
+    std::shared_ptr<HiTraceId> hiTraceId_;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // #ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_INNER_EVENT_H
diff --git a/ohos_ndk_aosp/includes/libeventhandler/logger.h b/ohos_ndk_aosp/includes/libeventhandler/logger.h
new file mode 100644
index 0000000000..e5b10bf64f
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/logger.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_LOGGER_H
+#define FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_LOGGER_H
+
+namespace OHOS {
+namespace AppExecFwk {
+class Logger {
+public:
+    /**
+     * Processes the content of a specified string.
+     * @param message the content of a specified string.
+     */
+    virtual void Log(const std::string &line) = 0;
+};
+}  // namespace AppExecFwk
+}  // namespace OHOS
+
+#endif  // FOUNDATION_APPEXECFWK_INTERFACES_INNERKITS_LIBEVENTHANDLER_INCLUDE_LOGGER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/libeventhandler/native_implement_eventhandler.h b/ohos_ndk_aosp/includes/libeventhandler/native_implement_eventhandler.h
new file mode 100644
index 0000000000..f100447077
--- /dev/null
+++ b/ohos_ndk_aosp/includes/libeventhandler/native_implement_eventhandler.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AAFWK_APPEXECFWK_NATIVE_IMPLEMENT_EVENTHANDLER_H
+#define AAFWK_APPEXECFWK_NATIVE_IMPLEMENT_EVENTHANDLER_H
+
+#include "event_runner.h"
+
+using OHOS::ErrCode;
+using OHOS::AppExecFwk::EventHandler;
+using OHOS::AppExecFwk::EventRunner;
+
+typedef void (*FileFDCallback)(int32_t filedescriptor);
+
+struct FileDescriptorCallbacks;
+struct EventRunnerNativeImplement {
+public:
+    EventRunnerNativeImplement(bool current);
+    ~EventRunnerNativeImplement();
+
+    /**
+     * Get current thread 'EventRunnerNativeImplement'.
+     *
+     * @return Returns pointer of the new 'EventRunnerNativeImplement'.
+     */
+    static const EventRunnerNativeImplement *GetEventRunnerNativeObj();
+
+    /**
+     * Create new 'EventRunnerNativeImplement'.
+     *
+     * @return Returns pointer of the new 'EventRunnerNativeImplement'.
+     */
+    static const EventRunnerNativeImplement *CreateEventRunnerNativeObj();
+
+    /**
+     * Start to run the 'EventRunnerNativeImplement'. Only running on single thread.
+     *
+     * @return Returns 'ERR_OK' on success.
+     */
+    ErrCode RunEventRunnerNativeObj() const;
+
+    /**
+     * Stop to run the 'EventRunnerNativeImplement'.
+     *
+     * @return Returns 'ERR_OK' on success.
+     */
+    ErrCode StopEventRunnerNativeObj() const;
+
+    /**
+     * Add file descriptor listener for a file descriptor.
+     *
+     * @param fileDescriptor File descriptor.
+     * @param events Events from file descriptor, such as input, output, error
+     * @param onReadableCallback Called while file descriptor is readable.
+     * @param onWritableCallback Called while file descriptor is writable.
+     * @param onShutdownCallback Called while shutting down this file descriptor.
+     * @param onExceptionCallback Called while error happened on this file descriptor.
+     * @return Return 'ERR_OK' on success.
+     */
+    ErrCode AddFileDescriptorListener(
+        int32_t fileDescriptor, uint32_t events, const FileDescriptorCallbacks *fdCallbacks) const;
+
+    /**
+     * Remove file descriptor listener for a file descriptor.
+     *
+     * @param fileDescriptor File descriptor.
+     */
+    void RemoveFileDescriptorListener(int32_t fileDescriptor) const;
+
+private:
+    std::shared_ptr<EventRunner> eventRunner_ = nullptr;
+};
+
+#endif  // AAFWK_APPEXECFWK_NATIVE_IMPLEMENT_EVENTHANDLER_H
diff --git a/ohos_ndk_aosp/includes/media/av_common.h b/ohos_ndk_aosp/includes/media/av_common.h
new file mode 100644
index 0000000000..ea366fe7d3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/av_common.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef AV_COMMOM_H
+#define AV_COMMOM_H
+
+#include <vector>
+#include <string>
+#include "format.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Media type
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum MediaType : int32_t {
+    /**
+     * track is audio.
+     */
+    MEDIA_TYPE_AUD = 0,
+    /**
+     * track is video.
+     */
+    MEDIA_TYPE_VID = 1,
+    /**
+     * track is subtitle.
+     */
+    MEDIA_TYPE_SUBTITLE = 2,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum VideoPixelFormat {
+    /**
+     * yuv 420 planar.
+     */
+    YUVI420 = 1,
+    /**
+     *  NV12. yuv 420 semiplanar.
+     */
+    NV12 = 2,
+    /**
+     *  NV21. yvu 420 semiplanar.
+     */
+    NV21 = 3,
+    /**
+     * format from surface.
+     */
+    SURFACE_FORMAT = 4,
+};
+
+/**
+ * @brief the struct of geolocation
+ *
+ * @param latitude float: latitude in degrees. Its value must be in the range [-90, 90].
+ * @param longitude float: longitude in degrees. Its value must be in the range [-180, 180].
+ * @since  3.1
+ * @version 3.1
+ */
+struct Location {
+    float latitude = 0;
+    float longitude = 0;
+};
+
+/**
+ * @brief Enumerates the seek mode.
+ */
+enum AVSeekMode : uint8_t {
+    /**
+     * @brief this mode is used to seek to a key frame that is located right or before at
+     * the given timestamp.
+     */
+    AV_SEEK_PREV_SYNC = 0,
+    /**
+     * @brief this mode is used to seek to a key frame that is located right or after at
+     * the given timestamp.
+     */
+    AV_SEEK_NEXT_SYNC = 1,
+    /**
+     * @brief this mode is used to seek to a key frame that is located right or closest at
+     * the given timestamp.
+     */
+    AV_SEEK_CLOSEST_SYNC = 2,
+    /**
+     * @brief this mode is used to seek to a frame that is located right or closest at
+     * the given timestamp.
+     */
+    AV_SEEK_CLOSEST = 3,
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AV_COMMOM_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avcodec_audio_decoder.h b/ohos_ndk_aosp/includes/media/avcodec_audio_decoder.h
new file mode 100644
index 0000000000..906dd5b6a6
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_audio_decoder.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCODEC_AUDIO_DECODER_H
+#define AVCODEC_AUDIO_DECODER_H
+
+#include "avcodec_common.h"
+#include "avcodec_info.h"
+#include "avsharedmemory.h"
+#include "format.h"
+
+namespace OHOS {
+namespace Media {
+class AudioDecoder {
+public:
+    virtual ~AudioDecoder() = default;
+
+    /**
+     * @brief Configure the decoder.
+     *
+     * @param format The format of the input data and the desired format of the output data.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Configure(const Format &format) = 0;
+
+    /**
+     * @brief Prepare for decoding.
+     *
+     * This function must be called after {@link Configure} and before {@link Start}
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Prepare() = 0;
+
+    /**
+     * @brief Start decoding.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Start() = 0;
+
+    /**
+     * @brief Stop decoding.
+     *
+     * This function must be called during running
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Stop() = 0;
+
+    /**
+     * @brief Flush both input and output buffers of the decoder.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Flush() = 0;
+
+    /**
+     * @brief Restores the decoder to the initial state.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Reset() = 0;
+
+    /**
+     * @brief Releases decoder resources. All methods are unavailable after calling this.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Release() = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a input buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetInputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Submits input buffer to decoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @param info The info of the input buffer. For details, see {@link AVCodecBufferInfo}
+     * @param flag The flag of the input buffer. For details, see {@link AVCodecBufferFlag}
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t QueueInputBuffer(uint32_t index, AVCodecBufferInfo info, AVCodecBufferFlag flag) = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a output buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Gets the format of the output data.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t GetOutputFormat(Format &format) = 0;
+
+    /**
+     * @brief Gets the audio decoder capability.
+     *
+     * @return Returns {@link AudioCaps}.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AudioCaps> GetAudioDecoderCaps() = 0;
+
+    /**
+     * @brief Returns the output buffer to the decoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t ReleaseOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Sets the parameters to the decoder.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format The parameters.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetParameter(const Format &format) = 0;
+
+    /**
+     * @brief Registers a decoder listener.
+     *
+     * This function must be called before {@link Configure}
+     *
+     * @param callback Indicates the decoder listener to register. For details, see {@link AVCodecCallback}.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetCallback(const std::shared_ptr<AVCodecCallback> &callback) = 0;
+};
+
+class __attribute__((visibility("default"))) AudioDecoderFactory {
+public:
+    /**
+     * @brief Instantiate the preferred decoder of the given mime type.
+     *
+     * @param mime The mime type.
+     * @return Returns the preferred decoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<AudioDecoder> CreateByMime(const std::string &mime);
+
+    /**
+     * @brief Instantiates the designated decoder.
+     *
+     * @param name The decoder's name.
+     * @return Returns the designated decoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<AudioDecoder> CreateByName(const std::string &name);
+private:
+    AudioDecoderFactory() = default;
+    ~AudioDecoderFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_AUDIO_DECODER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avcodec_audio_encoder.h b/ohos_ndk_aosp/includes/media/avcodec_audio_encoder.h
new file mode 100644
index 0000000000..3b66b572a5
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_audio_encoder.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCODEC_AUDIO_ENCODER_H
+#define AVCODEC_AUDIO_ENCODER_H
+
+#include "avcodec_common.h"
+#include "avcodec_info.h"
+#include "avsharedmemory.h"
+#include "format.h"
+
+namespace OHOS {
+namespace Media {
+class AudioEncoder {
+public:
+    virtual ~AudioEncoder() = default;
+
+    /**
+     * @brief Configure the encoder.
+     *
+     * @param format The format of the input data and the desired format of the output data.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Configure(const Format &format) = 0;
+
+    /**
+     * @brief Prepare for decoding.
+     *
+     * This function must be called after {@link Configure} and before {@link Start}
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Prepare() = 0;
+
+    /**
+     * @brief Start decoding.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Start() = 0;
+
+    /**
+     * @brief Stop decoding.
+     *
+     * This function must be called during running
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Stop() = 0;
+
+    /**
+     * @brief Flush both input and output buffers of the encoder.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Flush() = 0;
+
+    /**
+     * @brief Restores the encoder to the initial state.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Reset() = 0;
+
+    /**
+     * @brief Releases encoder resources. All methods are unavailable after calling this.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Release() = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a input buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetInputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Submits input buffer to encoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @param info The info of the input buffer. For details, see {@link AVCodecBufferInfo}
+     * @param flag The flag of the input buffer. For details, see {@link AVCodecBufferFlag}
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t QueueInputBuffer(uint32_t index, AVCodecBufferInfo info, AVCodecBufferFlag flag) = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a output buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Gets the format of the output data.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t GetOutputFormat(Format &format) = 0;
+
+    /**
+     * @brief Gets the audio encoder capability.
+     *
+     * @return Returns {@link AudioCaps}.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AudioCaps> GetAudioEncoderCaps() = 0;
+
+    /**
+     * @brief Returns the output buffer to the encoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t ReleaseOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Sets the parameters to the encoder.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format The parameters.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetParameter(const Format &format) = 0;
+
+    /**
+     * @brief Registers a encoder listener.
+     *
+     * This function must be called before {@link Configure}
+     *
+     * @param callback Indicates the encoder listener to register. For details, see {@link AVCodecCallback}.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetCallback(const std::shared_ptr<AVCodecCallback> &callback) = 0;
+};
+
+class __attribute__((visibility("default"))) AudioEncoderFactory {
+public:
+    /**
+     * @brief Instantiate the preferred encoder of the given mime type.
+     *
+     * @param mime The mime type.
+     * @return Returns the preferred encoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<AudioEncoder> CreateByMime(const std::string &mime);
+
+    /**
+     * @brief Instantiates the designated encoder.
+     *
+     * @param name The encoder's name.
+     * @return Returns the designated encoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<AudioEncoder> CreateByName(const std::string &name);
+private:
+    AudioEncoderFactory() = default;
+    ~AudioEncoderFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_AUDIO_ENCODER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avcodec_common.h b/ohos_ndk_aosp/includes/media/avcodec_common.h
new file mode 100644
index 0000000000..9907aa23fb
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_common.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef AVCODEC_COMMOM_H
+#define AVCODEC_COMMOM_H
+
+#include <string>
+#include "av_common.h"
+#include "format.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Error type of AVCodec
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AVCodecErrorType : int32_t {
+    /* internal errors, error code passed by the errorCode, and definition see "MediaServiceErrCode" */
+    AVCODEC_ERROR_INTERNAL,
+    /* extend error start. The extension error code agreed upon by the plug-in and
+       the application will be transparently transmitted by the service. */
+    AVCODEC_ERROR_EXTEND_START = 0X10000,
+};
+
+enum AVCodecBufferFlag : uint32_t {
+    AVCODEC_BUFFER_FLAG_NONE = 0,
+    /* This signals the end of stream */
+    AVCODEC_BUFFER_FLAG_EOS = 1 << 0,
+    /* This indicates that the buffer contains the data for a sync frame */
+    AVCODEC_BUFFER_FLAG_SYNC_FRAME = 1 << 1,
+    /* This indicates that the buffer only contains part of a frame */
+    AVCODEC_BUFFER_FLAG_PARTIAL_FRAME = 1 << 2,
+    /* This indicated that the buffer contains codec specific data */
+    AVCODEC_BUFFER_FLAG_CODEC_DATA = 1 << 3,
+};
+
+struct AVCodecBufferInfo {
+    /* The presentation timestamp in microseconds for the buffer */
+    int64_t presentationTimeUs = 0;
+    /* The amount of data (in bytes) in the buffer */
+    int32_t size = 0;
+    /* The start-offset of the data in the buffer */
+    int32_t offset = 0;
+};
+
+class AVCodecCallback {
+public:
+    virtual ~AVCodecCallback() = default;
+    /**
+     * Called when an error occurred.
+     *
+     * @param errorType Error type. For details, see {@link AVCodecErrorType}.
+     * @param errorCode Error code.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual void OnError(AVCodecErrorType errorType, int32_t errorCode) = 0;
+
+    /**
+     * Called when the output format has changed.
+     *
+     * @param format The new output format.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual void OnOutputFormatChanged(const Format &format) = 0;
+
+    /**
+     * Called when an input buffer becomes available.
+     *
+     * @param index The index of the available input buffer.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual void OnInputBufferAvailable(uint32_t index) = 0;
+
+    /**
+     * Called when an output buffer becomes available.
+     *
+     * @param index The index of the available output buffer.
+     * @param info The info of the available output buffer. For details, see {@link AVCodecBufferInfo}
+     * @param flag The flag of the available output buffer. For details, see {@link AVCodecBufferFlag}
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual void OnOutputBufferAvailable(uint32_t index, AVCodecBufferInfo info, AVCodecBufferFlag flag) = 0;
+};
+
+__attribute__((visibility("default"))) std::string AVCodecErrorTypeToString(AVCodecErrorType type);
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_COMMOM_H
diff --git a/ohos_ndk_aosp/includes/media/avcodec_info.h b/ohos_ndk_aosp/includes/media/avcodec_info.h
new file mode 100644
index 0000000000..2e5bc3ec22
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_info.h
@@ -0,0 +1,795 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCODEC_INFO_H
+#define AVCODEC_INFO_H
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "av_common.h"
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief AVCodec Type
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AVCodecType : int32_t {
+    AVCODEC_TYPE_NONE = -1,
+    AVCODEC_TYPE_VIDEO_ENCODER = 0,
+    AVCODEC_TYPE_VIDEO_DECODER,
+    AVCODEC_TYPE_AUDIO_ENCODER,
+    AVCODEC_TYPE_AUDIO_DECODER,
+};
+
+/**
+ * @brief Range contain min and max value
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+struct Range {
+    int32_t minVal;
+    int32_t maxVal;
+    Range() : minVal(0), maxVal(0) {}
+    Range(const int32_t &min, const int32_t &max)
+    {
+        if (min <= max) {
+            this->minVal = min;
+            this->maxVal = max;
+        } else {
+            this->minVal = 0;
+            this->maxVal = 0;
+        }
+    }
+
+    Range Create(const int32_t &min, const int32_t &max)
+    {
+        return Range(min, max);
+    }
+
+    Range Intersect(const int32_t &min, const int32_t &max)
+    {
+        int32_t minCmp = this->minVal > min ? this->minVal : min;
+        int32_t maxCmp = this->maxVal < max ? this->maxVal : max;
+        return this->Create(minCmp, maxCmp);
+    }
+
+    Range Intersect(const Range &range)
+    {
+        int32_t minCmp = this->minVal > range.minVal ? this->minVal : range.minVal;
+        int32_t maxCmp = this->maxVal < range.maxVal ? this->maxVal : range.maxVal;
+        return this->Create(minCmp, maxCmp);
+    }
+};
+
+/**
+ * @brief ImgSize contain width and height
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+struct ImgSize {
+    int32_t width;
+    int32_t height;
+
+    ImgSize() : width(0), height(0) {}
+
+    ImgSize(const int32_t &width, const int32_t &height)
+    {
+        this->width = width;
+        this->height = height;
+    }
+
+    bool operator<(const ImgSize &p) const
+    {
+        return (width < p.width) || (width == p.width && height < p.height);
+    }
+};
+
+/**
+ * @brief Capability Data struct of Codec, parser from config file
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+struct CapabilityData {
+    std::string codecName = "";
+    int32_t codecType = AVCODEC_TYPE_NONE;
+    std::string mimeType = "";
+    bool isVendor = false;
+    Range bitrate;
+    Range channels;
+    Range complexity;
+    Range alignment;
+    Range width;
+    Range height;
+    Range frameRate;
+    Range encodeQuality;
+    Range quality;
+    Range blockPerFrame;
+    Range blockPerSecond;
+    ImgSize blockSize;
+    std::vector<int32_t> sampleRate;
+    std::vector<int32_t> format;
+    std::vector<int32_t> profiles;
+    std::vector<int32_t> bitrateMode;
+    std::vector<int32_t> levels;
+    std::map<int32_t, std::vector<int32_t>> profileLevelsMap;
+    std::map<ImgSize, Range> measuredFrameRate;
+};
+
+struct LevelParams {
+    int32_t maxBlockPerFrame = 0;
+    int32_t maxBlockPerSecond = 0;
+    int32_t maxFrameRate = 0;
+    int32_t maxWidth = 0;
+    int32_t maxHeight = 0;
+    LevelParams(const int32_t &blockPerFrame, const int32_t &blockPerSecond,
+                const int32_t &frameRate, const int32_t &width, const int32_t height)
+    {
+        this->maxBlockPerFrame = blockPerFrame;
+        this->maxBlockPerSecond = blockPerSecond;
+        this->maxFrameRate = frameRate;
+        this->maxWidth = width;
+        this->maxHeight = height;
+    }
+    LevelParams(const int32_t &blockPerFrame, const int32_t &blockPerSecond)
+    {
+        this->maxBlockPerFrame = blockPerFrame;
+        this->maxBlockPerSecond = blockPerSecond;
+    }
+};
+
+class __attribute__((visibility("default"))) AVCodecInfo {
+public:
+    explicit AVCodecInfo(CapabilityData &capabilityData);
+    ~AVCodecInfo();
+
+    /**
+     * @brief Get name of this codec, used to create the codec instance.
+     * @return Returns codec name.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::string GetName();
+
+    /**
+     * @brief Get type of this codec
+     * @return Returns codec type, see {@link AVCodecType}
+     * @since 3.1
+     * @version 3.1
+     */
+    AVCodecType GetType();
+
+    /**
+     * @brief Get mime type of this codec
+     * @return Returns codec mime type, see {@link CodecMimeType}
+     * @since 3.1
+     * @version 3.1
+     */
+    std::string GetMimeType();
+
+    /**
+     * @brief Check whether the codec is accelerated by hardware.
+     * @return Returns true if the codec is hardware accelerated; false otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    bool IsHardwareAccelerated();
+
+    /**
+     * @brief Check whether the codec is software implemented only.
+     * @return Returns true if the codec is software implemented only; false otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    bool IsSoftwareOnly();
+
+    /**
+     * @brief Check whether the codec is provided by vendor.
+     * @return Returns true if the codec is provided by vendor; false otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    bool IsVendor();
+
+private:
+    CapabilityData data_;
+};
+
+class __attribute__((visibility("default"))) VideoCaps {
+public:
+    explicit VideoCaps(CapabilityData &capabilityData);
+    ~VideoCaps();
+
+    /**
+     * @brief Get codec information,  such as the codec name, codec type,
+     * whether hardware acceleration is supported, whether only software is supported,
+     * and whether the codec is provided by the vendor.
+     * @return Returns the pointer of {@link AVCodecInfo}.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::shared_ptr<AVCodecInfo> GetCodecInfo();
+
+    /**
+     * @brief Get supported bitrate range.
+     * @return Returns the range of supported bitrates.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedBitrate();
+
+    /**
+     * @brief Get supported video raw formats.
+     * @return Returns an array of supported formats. For Details, see {@link VideoPixelFormat}.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedFormats();
+
+    /**
+     * @brief Get supported alignment of video height, only used for video codecs.
+     * @return Returns the supported alignment of video height (in pixels).
+     * @since 3.1
+     * @version 3.1
+     */
+    int32_t GetSupportedHeightAlignment();
+
+    /**
+     * @brief Get supported alignment of video width, only used for video codecs.
+     * @return Returns the supported alignment of video width (in pixels).
+     * @since 3.1
+     * @version 3.1
+     */
+    int32_t GetSupportedWidthAlignment();
+
+    /**
+     * @brief Get supported width range of video.
+     * @return Returns the supported width range of video.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedWidth();
+
+    /**
+     * @brief Get supported height range of video.
+     * @return Returns the supported height range of video.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedHeight();
+
+    /**
+     * @brief Get supported profiles of this codec.
+     * @return Returns an array of supported profiles:
+     * returns {@link H263Profile} array if codec is h263,
+     * returns {@link AVCProfile} array if codec is h264,
+     * returns {@link HEVCProfile} array if codec is h265,
+     * returns {@link MPEG2Profile} array if codec is mpeg2,
+     * returns {@link MPEG4Profile} array if codec is mpeg4,
+     * returns {@link VP8Profile} array if codec is vp8.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedProfiles();
+
+    /**
+     * @brief Get supported codec level array.
+     * @return Returns an array of supported codec level number.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedLevels();
+
+    /**
+     * @brief Get supported video encode quality Range.
+     * @return Returns an array of supported video encode quality Range.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedEncodeQuality();
+
+    /**
+     * @brief Check whether the width and height is supported.
+     * @param width Indicates the specified video width (in pixels).
+     * @param height Indicates the specified video height (in pixels).
+     * @return Returns true if the codec supports {@link width} * {@link height} size video, false otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    bool IsSizeSupported(int32_t width, int32_t height);
+
+    /**
+     * @brief Get supported frameRate.
+     * @return Returns the supported frameRate range of video.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedFrameRate();
+
+    /**
+     * @brief Get supported frameRate range for the specified width and height.
+     * @param width Indicates the specified video width (in pixels).
+     * @param height Indicates the specified video height (in pixels).
+     * @return Returns the supported frameRate range for the specified width and height.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedFrameRatesFor(int32_t width, int32_t height);
+
+    /**
+     * @brief Check whether the size and frameRate is supported.
+     * @param width Indicates the specified video width (in pixels).
+     * @param height Indicates the specified video height (in pixels).
+     * @param frameRate Indicates the specified video frameRate.
+     * @return Returns true if the codec supports the specified size and frameRate; false otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    bool IsSizeAndRateSupported(int32_t width, int32_t height, double frameRate);
+
+    /**
+     * @brief Get preferred frameRate range for the specified width and height,
+     * these framerates can be reach the performance.
+     * @param width Indicates the specified video width (in pixels).
+     * @param height Indicates the specified video height (in pixels).
+     * @return Returns preferred frameRate range for the specified width and height.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetPreferredFrameRate(int32_t width, int32_t height);
+
+    /**
+     * @brief Get supported encode bitrate mode.
+     * @return Returns an array of supported encode bitrate mode. For details, see {@link VideoEncodeBitrateMode}.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedBitrateMode();
+
+    /**
+     * @brief Get supported encode qualit range.
+     * @return Returns supported encode qualit range.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedQuality();
+
+    /**
+     * @brief Get supported encode complexity range.
+     * @return Returns supported encode complexity range.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedComplexity();
+
+    /**
+     * @brief Check video encoder wether support request key frame dynamicly.
+     * @return Returns true if support, false not support.
+     * @since 3.1
+     * @version 3.1
+     */
+    bool IsSupportDynamicIframe();
+
+private:
+    CapabilityData data_;
+    int32_t blockWidth_;
+    int32_t blockHeight_;
+    Range horizontalBlockRange_;
+    Range verticalBlockRange_;
+    Range blockPerFrameRange_;
+    Range blockPerSecondRange_;
+    Range widthRange_;
+    Range heightRange_;
+    Range frameRateRange_;
+    void InitParams();
+    void UpdateParams();
+    void LoadLevelParams();
+    void LoadAVCLevelParams();
+    void LoadMPEG2LevelParams();
+    void LoadMPEG4LevelParams();
+    ImgSize MatchClosestSize(const ImgSize &imgSize);
+    int32_t DivCeil(const int32_t &dividend, const int32_t &divisor);
+    Range DivRange(const Range &range, const int32_t &divisor);
+    void UpdateBlockParams(const int32_t &blockWidth, const int32_t &blockHeight,
+                           Range &blockPerFrameRange, Range &blockPerSecondRange);
+};
+
+class __attribute__((visibility("default"))) AudioCaps {
+public:
+    explicit AudioCaps(CapabilityData &capabilityData);
+    ~AudioCaps();
+
+    /**
+     * @brief Get codec information,  such as the codec name, codec type,
+     * whether hardware acceleration is supported, whether only software is supported,
+     * and whether the codec is provided by the vendor.
+     * @return Returns the pointer of {@link AVCodecInfo}
+     * @since 3.1
+     * @version 3.1
+     */
+    std::shared_ptr<AVCodecInfo> GetCodecInfo();
+
+    /**
+     * @brief Get supported bitrate range.
+     * @return Returns the range of supported bitrates.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedBitrate();
+
+    /**
+     * @brief Get supported channel range.
+     * @return Returns the range of supported channel.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedChannel();
+
+    /**
+     * @brief Get supported audio raw format range.
+     * @return Returns the range of supported audio raw format. For details, see {@link AudioRawFormat}.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedFormats();
+
+    /**
+     * @brief Get supported audio samplerates.
+     * @return Returns an array of supported samplerates.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedSampleRates();
+
+    /**
+     * @brief Get supported codec profile number.
+     * @return Returns an array of supported codec profile number. For details, see {@link AACProfile}.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedProfiles();
+
+    /**
+     * @brief Get supported codec level array.
+     * @return Returns an array of supported codec level number.
+     * @since 3.1
+     * @version 3.1
+     */
+    std::vector<int32_t> GetSupportedLevels();
+
+    /**
+     * @brief Get supported encode complexity range.
+     * @return Returns supported encode complexity range.
+     * @since 3.1
+     * @version 3.1
+     */
+    Range GetSupportedComplexity();
+
+private:
+    CapabilityData data_;
+};
+
+/**
+ * @brief Enumerates the codec mime type.
+ */
+class CodecMimeType {
+public:
+    static constexpr std::string_view VIDEO_H263 = "video/h263";
+    static constexpr std::string_view VIDEO_AVC = "video/avc";
+    static constexpr std::string_view VIDEO_MPEG2 = "video/mpeg2";
+    static constexpr std::string_view VIDEO_HEVC = "video/hevc";
+    static constexpr std::string_view VIDEO_MPEG4 = "video/mp4v-es";
+    static constexpr std::string_view VIDEO_VP8 = "video/x-vnd.on2.vp8";
+    static constexpr std::string_view VIDEO_VP9 = "video/x-vnd.on2.vp9";
+    static constexpr std::string_view AUDIO_AMR_NB = "audio/3gpp";
+    static constexpr std::string_view AUDIO_AMR_WB = "audio/amr-wb";
+    static constexpr std::string_view AUDIO_MPEG = "audio/mpeg";
+    static constexpr std::string_view AUDIO_AAC = "audio/mp4a-latm";
+    static constexpr std::string_view AUDIO_VORBIS = "audio/vorbis";
+    static constexpr std::string_view AUDIO_OPUS = "audio/opus";
+    static constexpr std::string_view AUDIO_FLAC = "audio/flac";
+    static constexpr std::string_view AUDIO_RAW = "audio/raw";
+};
+
+/**
+ * @brief AVC Profile
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AVCProfile {
+    AVC_PROFILE_BASELINE = 0,
+    AVC_PROFILE_CONSTRAINED_BASELINE = 1,
+    AVC_PROFILE_CONSTRAINED_HIGH = 2,
+    AVC_PROFILE_EXTENDED = 3,
+    AVC_PROFILE_HIGH = 4,
+    AVC_PROFILE_HIGH_10 = 5,
+    AVC_PROFILE_HIGH_422 = 6,
+    AVC_PROFILE_HIGH_444 = 7,
+    AVC_PROFILE_MAIN = 8,
+};
+
+/**
+ * @brief HEVC Profile
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum HEVCProfile {
+    HEVC_PROFILE_MAIN = 0,
+    HEVC_PROFILE_MAIN_10 = 1,
+    HEVC_PROFILE_MAIN_STILL = 3,
+};
+
+/**
+ * @brief MPEG2 Profile
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum MPEG2Profile {
+    MPEG2_PROFILE_422 = 0,
+    MPEG2_PROFILE_HIGH = 1,
+    MPEG2_PROFILE_MAIN = 2,
+    MPEG2_PROFILE_SNR = 3,
+    MPEG2_PROFILE_SIMPLE = 4,
+    MPEG2_PROFILE_SPATIAL = 5,
+};
+
+/**
+ * @brief MPEG4 Profile
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum MPEG4Profile {
+    MPEG4_PROFILE_ADVANCED_CODING = 0,
+    MPEG4_PROFILE_ADVANCED_CORE = 1,
+    MPEG4_PROFILE_ADVANCED_REAL_TIME = 2,
+    MPEG4_PROFILE_ADVANCED_SCALABLE = 3,
+    MPEG4_PROFILE_ADVANCED_SIMPLE = 4,
+    MPEG4_PROFILE_BASIC_ANIMATED = 5,
+    MPEG4_PROFILE_CORE = 6,
+    MPEG4_PROFILE_CORE_SCALABLE = 7,
+    MPEG4_PROFILE_HYBRID = 8,
+    MPEG4_PROFILE_MAIN = 9,
+    MPEG4_PROFILE_NBIT = 10,
+    MPEG4_PROFILE_SCALABLE_TEXTURE = 11,
+    MPEG4_PROFILE_SIMPLE = 12,
+    MPEG4_PROFILE_SIMPLE_FBA = 13,
+    MPEG4_PROFILE_SIMPLE_FACE = 14,
+    MPEG4_PROFILE_SIMPLE_SCALABLE = 15,
+};
+
+/**
+ * @brief H263 Profile
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum H263Profile {
+    H263_PROFILE_BACKWARD_COMPATIBLE = 0,
+    H263_PROFILE_BASELINE = 1,
+    H263_PROFILE_H320_CODING = 2,
+    H263_PROFILE_HIGH_COMPRESSION = 3,
+    H263_PROFILE_HIGH_LATENCY = 4,
+    H263_PROFILE_ISW_V2 = 5,
+    H263_PROFILE_ISW_V3 = 6,
+    H263_PROFILE_INTERLACE = 7,
+    H263_PROFILE_INTERNET = 8,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum VP8Profile {
+    VP8_PROFILE_MAIN = 0,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AACProfile {
+    AAC_PROFILE_LC = 0,
+    AAC_PROFILE_ELD = 1,
+    AAC_PROFILE_ERLC = 2,
+    AAC_PROFILE_HE = 3,
+    AAC_PROFILE_HE_V2 = 4,
+    AAC_PROFILE_LD = 5,
+    AAC_PROFILE_MAIN = 6,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AVCLevel {
+    AVC_LEVEL_1 = 0,
+    AVC_LEVEL_1b = 1,
+    AVC_LEVEL_11 = 2,
+    AVC_LEVEL_12 = 3,
+    AVC_LEVEL_13 = 4,
+    AVC_LEVEL_2 = 5,
+    AVC_LEVEL_21 = 6,
+    AVC_LEVEL_22 = 7,
+    AVC_LEVEL_3 = 8,
+    AVC_LEVEL_31 = 9,
+    AVC_LEVEL_32 = 10,
+    AVC_LEVEL_4 = 11,
+    AVC_LEVEL_41 = 12,
+    AVC_LEVEL_42 = 13,
+    AVC_LEVEL_5 = 14,
+    AVC_LEVEL_51 = 15,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum HEVCLevel {
+    HEVC_LEVEL_1 = 0,
+    HEVC_LEVEL_2 = 1,
+    HEVC_LEVEL_21 = 2,
+    HEVC_LEVEL_3 = 3,
+    HEVC_LEVEL_31 = 4,
+    HEVC_LEVEL_4 = 5,
+    HEVC_LEVEL_41 = 6,
+    HEVC_LEVEL_5 = 7,
+    HEVC_LEVEL_51 = 8,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum MPEG2Level {
+    MPEG2_LEVEL_LL = 0,
+    MPEG2_LEVEL_ML = 1,
+    MPEG2_LEVEL_H14 = 2,
+    MPEG2_LEVEL_HL = 3,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum MPEG4Level {
+    MPEG4_LEVEL_0 = 0,
+    MPEG4_LEVEL_0B = 1,
+    MPEG4_LEVEL_1 = 2,
+    MPEG4_LEVEL_2 = 3,
+    MPEG4_LEVEL_3 = 4,
+    MPEG4_LEVEL_4 = 5,
+    MPEG4_LEVEL_4A = 6,
+    MPEG4_LEVEL_5 = 7,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AudioRawFormat {
+    /**
+     * signed 8 bits.
+     */
+    AUDIO_PCM_S8 = 1,
+    /**
+     * unsigned 8 bits.
+     */
+    AUDIO_PCM_8 = 2,
+    /**
+     * signed 16 bits in big endian.
+     */
+    AUDIO_PCM_S16_BE = 3,
+    /**
+     * signed 16 bits in little endian.
+     */
+    AUDIO_PCM_S16_LE = 4,
+    /**
+     * unsigned 16 bits in big endian.
+     */
+    AUDIO_PCM_16_BE = 5,
+    /**
+     * unsigned 16 bits in little endian.
+     */
+    AUDIO_PCM_16_LE = 6,
+    /**
+     * signed 24 bits in big endian.
+     */
+    AUDIO_PCM_S24_BE = 7,
+    /**
+     * signed 24 bits in little endian.
+     */
+    AUDIO_PCM_S24_LE = 8,
+    /**
+     * unsigned 24 bits in big endian.
+     */
+    AUDIO_PCM_24_BE = 9,
+    /**
+     * unsigned 24 bits in little endian.
+     */
+    AUDIO_PCM_24_LE = 10,
+    /**
+     * signed 32 bits in big endian.
+     */
+    AUDIO_PCM_S32_BE = 11,
+    /**
+     * signed 32 bits in little endian.
+     */
+    AUDIO_PCM_S32_LE = 12,
+    /**
+     * unsigned 32 bits in big endian.
+     */
+    AUDIO_PCM_32_BE = 13,
+    /**
+     * unsigned 32 bits in little endian.
+     */
+    AUDIO_PCM_32_LE = 14,
+    /**
+     * float 32 bits in big endian.
+     */
+    AUDIO_PCM_F32_BE = 15,
+    /**
+     * float 32 bits in little endian.
+     */
+    AUDIO_PCM_F32_LE = 16,
+};
+
+/**
+ * @brief
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum VideoEncodeBitrateMode {
+    /**
+     * constant bit rate mode.
+    */
+    CBR = 0,
+    /**
+     * variable bit rate mode.
+    */
+    VBR = 1,
+    /**
+     * constant quality mode.
+    */
+    CQ = 2,
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_INFO_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avcodec_list.h b/ohos_ndk_aosp/includes/media/avcodec_list.h
new file mode 100644
index 0000000000..7122dd2dd6
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_list.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCODEC_LIST_H
+#define AVCODEC_LIST_H
+
+#include <cstdint>
+#include <memory>
+#include "avcodec_info.h"
+
+namespace OHOS {
+namespace Media {
+class AVCodecList {
+public:
+    virtual ~AVCodecList() = default;
+
+    /**
+     * @brief Find the supported video decoder name by format(usually contains video decoder MIME).
+     * @param format Indicates a media description which contains required video decoder capability.
+     * @return  Returns video decoder name, if not find, return empty string.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::string FindVideoDecoder(const Format &format) = 0;
+
+    /**
+     * @brief Find the supported video encoder name by format(usually contains video encoder MIME).
+     * @param format Indicates a media description which contains required video encoder capability.
+     * @return  Returns video encoder name, if not find, return empty string.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::string FindVideoEncoder(const Format &format) = 0;
+
+    /**
+     * @brief Find the supported audio decoder name by format(usually contains audio decoder MIME).
+     * @param format Indicates a media description which contains required audio decoder capability.
+     * @return  Returns audio decoder name, if not find, return empty string.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::string FindAudioDecoder(const Format &format) = 0;
+
+    /**
+     * @brief Find the supported audio encoder name by format(usually contains audio encoder MIME).
+     * @param format Indicates a media description which contains required audio encoder capability.
+     * @return  Returns audio encoder name, if not find, return empty string.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::string FindAudioEncoder(const Format &format) = 0;
+
+    /**
+     * @brief Get the supported video decoder capabilities.
+     * @return Returns an array of supported video decoder capability.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::vector<std::shared_ptr<VideoCaps>> GetVideoDecoderCaps() = 0;
+
+    /**
+     * @brief Get the supported video encoder capabilities.
+     * @return Returns an array of supported video encoder capability.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::vector<std::shared_ptr<VideoCaps>> GetVideoEncoderCaps() = 0;
+
+    /**
+     * @brief Get the supported audio decoder capabilities.
+     * @return Returns an array of supported audio decoder capability.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::vector<std::shared_ptr<AudioCaps>> GetAudioDecoderCaps() = 0;
+
+    /**
+     * @brief Get the supported audio encoder capabilities.
+     * @return Returns an array of supported audio encoder capability.
+     * @since 1.0
+     * @version 3.1
+     */
+    virtual std::vector<std::shared_ptr<AudioCaps>> GetAudioEncoderCaps() = 0;
+};
+
+class __attribute__((visibility("default"))) AVCodecListFactory {
+public:
+
+    static std::shared_ptr<AVCodecList> CreateAVCodecList();
+private:
+    AVCodecListFactory() = default;
+    ~AVCodecListFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_LIST_H
diff --git a/ohos_ndk_aosp/includes/media/avcodec_video_decoder.h b/ohos_ndk_aosp/includes/media/avcodec_video_decoder.h
new file mode 100644
index 0000000000..602e6869f3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_video_decoder.h
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCODEC_VIDEO_DECODER_H
+#define AVCODEC_VIDEO_DECODER_H
+
+#include "avcodec_common.h"
+#include "avcodec_info.h"
+#include "avsharedmemory.h"
+#include "format.h"
+#include "surface.h"
+
+namespace OHOS {
+namespace Media {
+class VideoDecoder {
+public:
+    virtual ~VideoDecoder() = default;
+
+    /**
+     * @brief Configure the decoder.
+     *
+     * @param format The format of the input data and the desired format of the output data.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Configure(const Format &format) = 0;
+
+    /**
+     * @brief Prepare for decoding.
+     *
+     * This function must be called after {@link Configure} and before {@link Start}
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Prepare() = 0;
+
+    /**
+     * @brief Start decoding.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Start() = 0;
+
+    /**
+     * @brief Stop decoding.
+     *
+     * This function must be called during running
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Stop() = 0;
+
+    /**
+     * @brief Flush both input and output buffers of the decoder.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Flush() = 0;
+
+    /**
+     * @brief Restores the decoder to the initial state.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Reset() = 0;
+
+    /**
+     * @brief Releases decoder resources. All methods are unavailable after calling this.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Release() = 0;
+
+    /**
+     * @brief Sets the surface on which to render the output of this decoder.
+     *
+     * This function must be called before {@link Prepare}
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetOutputSurface(sptr<Surface> surface) = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a input buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetInputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Submits input buffer to decoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @param info The info of the input buffer. For details, see {@link AVCodecBufferInfo}
+     * @param flag The flag of the input buffer. For details, see {@link AVCodecBufferFlag}
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t QueueInputBuffer(uint32_t index, AVCodecBufferInfo info, AVCodecBufferFlag flag) = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a output buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Gets the format of the output data.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t GetOutputFormat(Format &format) = 0;
+
+    /**
+     * @brief Gets the video decoder capability.
+     *
+     * @return Returns {@link VideoCaps}.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<VideoCaps> GetVideoDecoderCaps() = 0;
+
+    /**
+     * @brief Returns the output buffer to the decoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t ReleaseOutputBuffer(uint32_t index, bool render) = 0;
+
+    /**
+     * @brief Sets the parameters to the decoder.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format The parameters.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetParameter(const Format &format) = 0;
+
+    /**
+     * @brief Registers a decoder listener.
+     *
+     * This function must be called before {@link Configure}
+     *
+     * @param callback Indicates the decoder listener to register. For details, see {@link AVCodecCallback}.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetCallback(const std::shared_ptr<AVCodecCallback> &callback) = 0;
+};
+
+class __attribute__((visibility("default"))) VideoDecoderFactory {
+public:
+    /**
+     * @brief Instantiate the preferred decoder of the given mime type.
+     *
+     * @param mime The mime type.
+     * @return Returns the preferred decoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<VideoDecoder> CreateByMime(const std::string &mime);
+
+    /**
+     * @brief Instantiates the designated decoder.
+     *
+     * @param name The decoder's name.
+     * @return Returns the designated decoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<VideoDecoder> CreateByName(const std::string &name);
+private:
+    VideoDecoderFactory() = default;
+    ~VideoDecoderFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_VIDEO_DECODER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avcodec_video_encoder.h b/ohos_ndk_aosp/includes/media/avcodec_video_encoder.h
new file mode 100644
index 0000000000..2158093314
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcodec_video_encoder.h
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCODEC_VIDEO_ENCODER_H
+#define AVCODEC_VIDEO_ENCODER_H
+
+#include "avcodec_common.h"
+#include "avcodec_info.h"
+#include "avsharedmemory.h"
+#include "format.h"
+#include "surface.h"
+
+namespace OHOS {
+namespace Media {
+class VideoEncoder {
+public:
+    virtual ~VideoEncoder() = default;
+
+    /**
+     * @brief Configure the encoder.
+     *
+     * @param format The format of the input data and the desired format of the output data.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Configure(const Format &format) = 0;
+
+    /**
+     * @brief Prepare for decoding.
+     *
+     * This function must be called after {@link Configure} and before {@link Start}
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Prepare() = 0;
+
+    /**
+     * @brief Start decoding.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Start() = 0;
+
+    /**
+     * @brief Stop decoding.
+     *
+     * This function must be called during running
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Stop() = 0;
+
+    /**
+     * @brief Flush both input and output buffers of the encoder.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Flush() = 0;
+
+    /**
+     * @brief Restores the encoder to the initial state.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Reset() = 0;
+
+    /**
+     * @brief Releases encoder resources. All methods are unavailable after calling this.
+     *
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t Release() = 0;
+
+    /**
+     * @brief Obtains the surface from encoder.
+     *
+     * This function can only be called after {@link Configure} and before {@link Prepare}
+     *
+     * @return Returns the pointer to the surface.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual sptr<Surface> CreateInputSurface() = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a input buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetInputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Submits input buffer to encoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the input buffer.
+     * @param info The info of the input buffer. For details, see {@link AVCodecBufferInfo}
+     * @param flag The flag of the input buffer. For details, see {@link AVCodecBufferFlag}
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t QueueInputBuffer(uint32_t index, AVCodecBufferInfo info, AVCodecBufferFlag flag) = 0;
+
+    /**
+     * @brief Returns a {@link AVSharedMemory} object for a output buffer index that contains the data.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link AVSharedMemory} if success; returns nullptr otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<AVSharedMemory> GetOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Gets the format of the output data.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t GetOutputFormat(Format &format) = 0;
+
+    /**
+     * @brief Gets the video encoder capability.
+     *
+     * @return Returns {@link VideoCaps}.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual std::shared_ptr<VideoCaps> GetVideoEncoderCaps() = 0;
+
+    /**
+     * @brief Returns the output buffer to the encoder.
+     *
+     * This function must be called during running
+     *
+     * @param index The index of the output buffer.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t ReleaseOutputBuffer(uint32_t index) = 0;
+
+    /**
+     * @brief Sets the parameters to the encoder.
+     *
+     * This function must be called after {@link Configure}
+     *
+     * @param format The parameters.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetParameter(const Format &format) = 0;
+
+    /**
+     * @brief Registers a encoder listener.
+     *
+     * This function must be called before {@link Configure}
+     *
+     * @param callback Indicates the encoder listener to register. For details, see {@link AVCodecCallback}.
+     * @return Returns {@link MSERR_OK} if success; returns an error code otherwise.
+     * @since 3.1
+     * @version 3.1
+     */
+    virtual int32_t SetCallback(const std::shared_ptr<AVCodecCallback> &callback) = 0;
+};
+
+class __attribute__((visibility("default"))) VideoEncoderFactory {
+public:
+    /**
+     * @brief Instantiate the preferred encoder of the given mime type.
+     *
+     * @param mime The mime type.
+     * @return Returns the preferred encoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<VideoEncoder> CreateByMime(const std::string &mime);
+
+    /**
+     * @brief Instantiates the designated encoder.
+     *
+     * @param name The encoder's name.
+     * @return Returns the designated encoder.
+     * @since 3.1
+     * @version 3.1
+     */
+    static std::shared_ptr<VideoEncoder> CreateByName(const std::string &name);
+private:
+    VideoEncoderFactory() = default;
+    ~VideoEncoderFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCODEC_VIDEO_ENCODER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avcontainer_types.h b/ohos_ndk_aosp/includes/media/avcontainer_types.h
new file mode 100644
index 0000000000..3ed5c2e1c5
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avcontainer_types.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVCONTAINER_TYPES_H
+#define AVCONTAINER_TYPES_H
+
+#include <string_view>
+#include "av_common.h"
+#include "avcodec_common.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Enumerates the container format types.
+ */
+class ContainerFormatType {
+public:
+    static constexpr std::string_view CFT_MPEG_4A = "m4a";
+    static constexpr std::string_view CFT_MPEG_4 = "mp4";
+};
+
+/**
+ * @brief Description information of a sample associated a media track.
+ */
+struct TrackSampleInfo {
+    /**
+     * @brief the id of track that this sample belongs to.
+     */
+    uint32_t trackIdx;
+    /**
+     * @brief the presentation timestamp in microseconds.
+     */
+    int64_t timeUs;
+    /**
+     * @brief the size in bytes.
+     */
+    uint32_t size;
+    /**
+     * @brief the flags associated with the sample, this
+     * maybe be a combination of multiple {@link AVCodecBufferFlag}.
+     */
+    AVCodecBufferFlag flags;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVCONTAINER_TYPES_H
diff --git a/ohos_ndk_aosp/includes/media/avmemory.h b/ohos_ndk_aosp/includes/media/avmemory.h
new file mode 100644
index 0000000000..a4142a25b9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avmemory.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVMEMORY_H
+#define AVMEMORY_H
+
+#include <cstdint>
+#include <cstring>
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Provides a wrap for raw byte buffer.
+ */
+class __attribute__((visibility("default"))) AVMemory {
+public:
+    /**
+     * @brief Construct a new AVMemory object with specified capacity, the raw buffer will be allocated.
+     */
+    explicit AVMemory(size_t capacity);
+
+    /**
+     * @brief Construct a new AVMemory object with specified raw buffer address and capacity.
+     */
+    AVMemory(uint8_t *base, size_t capacity);
+
+    ~AVMemory();
+
+    uint8_t *Base() const
+    {
+        return base_;
+    }
+
+    uint8_t *Data() const
+    {
+        return base_ + offset_;
+    }
+
+    size_t Capacity() const
+    {
+        return capacity_;
+    }
+
+    size_t Size() const
+    {
+        return size_;
+    }
+
+    size_t Offset() const
+    {
+        return offset_;
+    }
+
+    void SetRange(size_t offset, size_t size)
+    {
+        offset_ = offset;
+        size_ = size;
+    }
+
+    DISALLOW_COPY_AND_MOVE(AVMemory);
+
+private:
+    uint8_t *base_ = nullptr;
+    size_t offset_ = 0;
+    size_t size_ = 0;
+    size_t capacity_ = 0;
+    bool ownership = false;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVMEMORY_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avmetadatahelper.h b/ohos_ndk_aosp/includes/media/avmetadatahelper.h
new file mode 100644
index 0000000000..e300085a24
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avmetadatahelper.h
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVMETADATAHELPER_H
+#define AVMETADATAHELPER_H
+
+#include <string>
+#include <unordered_map>
+#include <memory>
+#include "pixel_map.h"
+#include "nocopyable.h"
+#include "avsharedmemory.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Enumerates avmetadata usage.
+ */
+enum AVMetadataUsage : int32_t {
+    /**
+     * Indicates that the avmetadahelper's instance will only be used for resolving the
+     * metadata from the given media resource.
+     */
+    AV_META_USAGE_META_ONLY,
+    /**
+     * Indicates that the avmetadahelper's instance will be used for fetching the video frame
+     * and resolving metadata from the given media resource.
+     */
+    AV_META_USAGE_PIXEL_MAP,
+};
+
+/**
+ * @brief Enumerates avmetadata's metadata key.
+ */
+enum AVMetadataCode : int32_t {
+    /**
+     * The metadata key to retrieve the information about the album title
+     * of the media source.
+     */
+    AV_KEY_ALBUM = 0,
+    /**
+     * The metadata key to retrieve the information about the performers or
+     * artist associated with the media source.
+     */
+    AV_KEY_ALBUM_ARTIST = 1,
+    /**
+     * The metadata key to retrieve the information about the artist of
+     * the media source.
+     */
+    AV_KEY_ARTIST = 2,
+    /**
+     * The metadata key to retrieve the information about the author of
+     * the media source.
+     */
+    AV_KEY_AUTHOR = 3,
+    /**
+     * The metadata key to retrieve the information about the composer of
+     * the media source.
+     */
+    AV_KEY_COMPOSER = 12,
+    /**
+     * The metadata key to retrieve the playback duration of the media source.
+     */
+    AV_KEY_DURATION = 15,
+    /**
+     * The metadata key to retrieve the content type or genre of the data
+     * source.
+     */
+    AV_KEY_GENRE = 18,
+    /**
+     * If this key exists the media contains audio content.
+     */
+    AV_KEY_HAS_AUDIO = 19,
+    /**
+     * If this key exists the media contains video content.
+     */
+    AV_KEY_HAS_VIDEO = 21,
+    /**
+     * The metadata key to retrieve the mime type of the media source. Some
+     * example mime types include: "video/mp4", "audio/mp4", "audio/amr-wb",
+     * etc.
+     */
+    AV_KEY_MIME_TYPE = 29,
+    /**
+     * The metadata key to retrieve the number of tracks, such as audio, video,
+     * text, in the media source, such as a mp4 or 3gpp file.
+     */
+    AV_KEY_NUM_TRACKS = 30,
+    /**
+     * This key retrieves the sample rate, if available.
+     */
+    AV_KEY_SAMPLE_RATE = 31,
+    /**
+     * The metadata key to retrieve the media source title.
+     */
+    AV_KEY_TITLE = 33,
+    /**
+     * If the media contains video, this key retrieves its height.
+     */
+    AV_KEY_VIDEO_HEIGHT = 35,
+    /**
+     * If the media contains video, this key retrieves its width.
+     */
+    AV_KEY_VIDEO_WIDTH = 37,
+};
+
+/**
+ * @brief Enumerates avmetadata's query option.
+ */
+enum AVMetadataQueryOption : int32_t {
+    /**
+     * This option is used to fetch a key frame from the given media
+     * resource that is located right after or at the given time.
+     */
+    AV_META_QUERY_NEXT_SYNC,
+    /**
+     * This option is used to fetch a key frame from the given media
+     * resource that is located right before or at the given time.
+     */
+    AV_META_QUERY_PREVIOUS_SYNC,
+    /**
+     * This option is used to fetch a key frame from the given media
+     * resource that is located closest to or at the given time.
+     */
+    AV_META_QUERY_CLOSEST_SYNC,
+    /**
+     * This option is used to fetch a frame (maybe not keyframe) from
+     * the given media resource that is located closest to or at the given time.
+     */
+    AV_META_QUERY_CLOSEST,
+};
+
+/**
+ * @brief Provides the definition of the returned pixelmap's configuration
+ */
+struct PixelMapParams {
+    /**
+     * Expected pixelmap's width, -1 means to keep consistent with the
+     * original dimensions of the given video resource.
+     */
+    int32_t dstWidth = -1;
+    /**
+     * Expected pixelmap's width, -1 means to keep consistent with the
+     * original dimensions of the given video resource.
+     */
+    int32_t dstHeight = -1;
+    /**
+     * Expected pixelmap's color format, see {@link PixelFormat}. Currently,
+     * RGB_565, RGB_888, RGBA_8888 are supported.
+     */
+    PixelFormat colorFormat = PixelFormat::RGB_565;
+};
+
+/**
+ * @brief Provides the interfaces to resolve metadata or fetch frame
+ * from a given media resource.
+ */
+class AVMetadataHelper {
+public:
+    virtual ~AVMetadataHelper() = default;
+
+    /**
+     * Set the media source uri to use. Calling this method before the reset
+     * of the methods in this class. This method maybe time consuming.
+     * @param uri the URI of input media source.
+     * @param usage indicates which scene the avmedatahelper's instance will
+     * be used to, see {@link AVMetadataUsage}. If the usage need to be changed,
+     * this method must be called again.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns
+     * an error code otherwise.
+     */
+    virtual int32_t SetSource(const std::string &uri, int32_t usage = AVMetadataUsage::AV_META_USAGE_PIXEL_MAP) = 0;
+
+    /**
+     * Retrieve the meta data associated with the specified key. This method must be
+     * called after the SetSource.
+     * @param key One of the constants listed above at the definition of {@link AVMetadataCode}.
+     * @return Returns the meta data value associate with the given key code on
+     * success; empty string on failure.
+     */
+    virtual std::string ResolveMetadata(int32_t key) = 0;
+
+    /**
+     * Retrieve all meta data within the listed above at the definition of {@link AVMetadataCode}.
+     * This method must be called after the SetSource.
+     * @return Returns the meta data values on success; empty hash map on failure.
+     */
+    virtual std::unordered_map<int32_t, std::string> ResolveMetadata() = 0;
+
+    /**
+     * Fetch the album art picture associated with the data source. If there are
+     * more than one pictures, the cover image will be returned preferably.
+     * @return Returns the a chunk of shared memory containing a picture, which can be
+     * null, if such a picture can not be fetched.
+     */
+    virtual std::shared_ptr<AVSharedMemory> FetchArtPicture() = 0;
+
+    /**
+     * Fetch a representative video frame near a given timestamp by considering the given
+     * option if possible, and return a pixelmap with given parameters. This method must be
+     * called after the SetSource.
+     * @param timeUs The time position in microseconds where the frame will be fetched.
+     * When fetching the frame at the given time position, there is no guarantee that
+     * the video source has a frame located at the position. When this happens, a frame
+     * nearby will be returned. If timeUs is negative, time position and option will ignored,
+     * and any frame that the implementation considers as representative may be returned.
+     * @param option the hint about how to fetch a frame, see {@link AVMetadataQueryOption}
+     * @param param the desired configuration of returned pixelmap, see {@link PixelMapParams}.
+     * @return Returns a pixelmap containing a scaled video frame, which can be null, if such a
+     * frame cannot be fetched.
+     */
+    virtual std::shared_ptr<PixelMap> FetchFrameAtTime(int64_t timeUs, int32_t option, const PixelMapParams &param) = 0;
+
+    /**
+     * Release the internel resource. After this method called, the avmetadatahelper instance
+     * can not be used again.
+     */
+    virtual void Release() = 0;
+};
+
+class __attribute__((visibility("default"))) AVMetadataHelperFactory {
+public:
+    static std::shared_ptr<AVMetadataHelper> CreateAVMetadataHelper();
+
+private:
+    AVMetadataHelperFactory() = default;
+    ~AVMetadataHelperFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVMETADATAHELPER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avmuxer.h b/ohos_ndk_aosp/includes/media/avmuxer.h
new file mode 100644
index 0000000000..c916340651
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avmuxer.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVMUXER_H
+#define AVMUXER_H
+
+#include <string>
+#include <memory>
+#include <vector>
+#include "avmemory.h"
+#include "media_types.h"
+#include "media_description.h"
+
+namespace OHOS {
+namespace Media {
+class AVMuxer {
+public:
+    virtual ~AVMuxer() = default;
+
+    virtual std::vector<std::string> GetAVMuxerFormatList() = 0;
+    virtual int32_t SetOutput(const std::string &path, const std::string &format) = 0;
+    virtual int32_t SetLocation(float latitude, float longtitude) = 0;
+    virtual int32_t SetOrientationHint(int degrees) = 0;
+    virtual int32_t AddTrack(const MediaDescription &trackDesc, int32_t &trackIdx) = 0;
+    virtual int32_t Start() = 0;
+    virtual int32_t WriteTrackSample(std::shared_ptr<AVMemory> sampleData, const TrackSampleInfo &info) = 0;
+    virtual int32_t Stop() = 0;
+    virtual void Release() = 0;
+};
+
+class __attribute__((visibility("default"))) AVMuxerFactory {
+public:
+    static std::shared_ptr<AVMuxer> CreateAVMuxer();
+private:
+    AVMuxerFactory() = default;
+    ~AVMuxerFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVMUXER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avsharedmemory.h b/ohos_ndk_aosp/includes/media/avsharedmemory.h
new file mode 100644
index 0000000000..adc462e0cf
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avsharedmemory.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVSHAREDMEMORY_H
+#define AVSHAREDMEMORY_H
+
+#include <cstdint>
+#include <memory>
+#include <string>
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Provides a unified interface to implement convenient memory sharing
+ * mechanism. For those platforms that do not support multi-process, it may
+ * simply encapsulate ordinary memory blocks, not really multi-process shareable memory.
+ */
+class __attribute__((visibility("default"))) AVSharedMemory {
+public:
+    virtual ~AVSharedMemory() = default;
+
+    /**
+     * @brief Enumerates the flag bits used to create a new shared memory.
+     */
+    enum Flags : uint32_t {
+        /**
+         * This flag bit indicates that the remote process is allowed to read and write
+         * the shared memory. If no flags are specified, this is the default memory
+         * sharing policy. If the FLAGS_READ_ONLY bit is set, this flag bit is ignored.
+         */
+        FLAGS_READ_WRITE = 0x1,
+        /**
+         * For platforms that support multiple processes, this flag bit indicates that the
+         * remote process can only read data in the shared memory. If this flag is not set,
+         * the remote process has both read and write permissions by default. Adding this
+         * flag does not affect the process that creates the memory, which always has the
+         * read and write permission on the shared memory. For platforms that do not support
+         * multi-processes, the memory read and write permission control capability may
+         * not be available. In this case, this flag is invalid.
+         */
+        FLAGS_READ_ONLY = 0x2,
+    };
+
+    /**
+     * @brief Get the memory's virtual address
+     * @return the memory's virtual address if the memory is valid, otherwise nullptr.
+     */
+    virtual uint8_t *GetBase() const = 0;
+
+    /**
+     * @brief Get the memory's size
+     * @return the memory's size if the memory is valid, otherwise -1.
+     */
+    virtual int32_t GetSize() const = 0;
+
+    /**
+     * @brief Get the memory's flags set by the creator, refer to {@Flags}
+     * @return the memory's flags if the memory is valid, otherwise 0.
+     */
+    virtual uint32_t GetFlags() const = 0;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVSHAREDMEMORY_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/avspliter.h b/ohos_ndk_aosp/includes/media/avspliter.h
new file mode 100644
index 0000000000..8d25be4cc9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/avspliter.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVSPLITER_H
+#define AVSPLITER_H
+
+#include <string>
+#include "avmemory.h"
+#include "avcontainer_types.h"
+#include "media_data_source.h"
+#include "media_description.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Enumerates the track select mode.
+ */
+enum TrackSelectMode : uint8_t {
+    /**
+     * @brief this mode indicates that all track will be processed synchronized. When
+     * selecting a track, this track's starting position to read will be forced to keep
+     * sync with the other already selected tracks. If it is the first track selected,
+     * this track will be read from zero timestamp.
+     */
+    TRACK_TIME_SYNC,
+    /**
+     * @brief this mode indicates that all track will be processed independent. When
+     * selecting a track, this track's starting position to read will be restored to
+     * last unselected position. If it it selected for the first time, this track will
+     * be read from zero timestamp.
+     */
+    TRACK_TIME_INDEPENDENT,
+};
+
+/**
+ * @brief Provides the track spliter for media files to get sample data of each track.
+ */
+class AVSpliter {
+public:
+    virtual ~AVSpliter() = default;
+
+    /**
+     * @brief Set the uri source for avspliter. Calling this method before the reset
+     * of the methods in this class. This method maybe time consuming.
+     *
+     * @param uri the URI of input media source.
+     * @param mode the mode indicates how to set the track's sample read position
+     * when select a new track, see {@link TrackSelectMode}.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns
+     * an error code otherwise.
+     */
+    virtual int32_t SetSource(const std::string &uri, TrackSelectMode mode) = 0;
+
+    /**
+     * @brief Set the data source for avspliter. Calling this method before the reset
+     * of the methods in this class. This method maybe time consuming.
+     *
+     * @param dataSource the media data source to be split
+     * @param mode the mode indicates how to set the track's sample read position
+     * when select a new track, see {@link TrackSelectMode}.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns
+     * an error code otherwise.
+     */
+    virtual int32_t SetSource(std::shared_ptr<IMediaDataSource> dataSource, TrackSelectMode mode) = 0;
+
+    /**
+     * @brief Get the container description.
+     *
+     * @param desc the output result will be filled into this parameter, and
+     * all container informations will be represented by key-value pairs. For
+     * keys, see {@link media_description.h}
+     * @return Returns {@link MSERR_OK} if resolving the container informations
+     * is successful; returns an error code otherwise.
+     */
+    virtual int32_t GetContainerDescription(MediaDescription &desc) = 0;
+
+    /**
+     * @brief Get the track description for specified track index.
+     *
+     * @param trackIdx the specified track index, for all track count in the
+     * container, refer to the {@link GetContainerDescription}'s result.
+     * @param desc the output result will be filled into this parameter, and
+     * the specified track's all informations will be represented by key-value pairs.
+     * For keys, see {@link media_description.h}
+     * @return Returns {@link MSERR_OK} if resolving the track informations
+     * is successful; returns an error code otherwise.
+     */
+    virtual int32_t GetTrackDescription(uint32_t trackIdx, MediaDescription &desc) = 0;
+
+    /**
+     * @brief Selecting a specified track to read track sample. Selecting the same track
+     * multiple times has no effect. This function has different behavior when set the
+     * input source with different mode, see {@link TrackSelectMode}.
+     *
+     * @param trackIdx the specified track index.
+     * @return Returns {@link MSERR_OK} if the selecting is success, returns an error code
+     * otherwise.
+     */
+    virtual int32_t SelectTrack(uint32_t trackIdx) = 0;
+
+    /**
+     * @brief Unselecting a specified track. After this function called, the {@link ReadTrackSample}
+     * will not output sample of the specified track. Unselecting the same track multiple
+     * times has no effect.
+     *
+     * @param trackIdx the specified track index.
+     * @return Returns {@link MSERR_OK} if the unselecting is success, returns an error code
+     * otherwise.
+     */
+    virtual int32_t UnSelectTrack(uint32_t trackIdx) = 0;
+
+    /**
+     * @brief Read a encoded sample from all selected track sample, and store it in the
+     * buffer starting at the given offset. All sample will be read in sequence based on
+     * timestamps. If no track selected, the default track for supported media type will
+     * be read. If the Codec Specific Data exists, it will be output before any frame data.
+     * Such data would be marked using the flag {@link AVCodecBufferFlag::AVCODEC_BUFFER_FLAG_CODEC_DATA}.
+     *
+     * @param buffer the destination output buffer, see{@link AVMemory}.
+     * @param info the sample's description information, see {@link TrackSampleInfo}.
+     * @return Returns {@link MSERR_OK} if the reading is success, returns an error code
+     * otherwise.
+     */
+    virtual int32_t ReadTrackSample(std::shared_ptr<AVMemory> buffer, TrackSampleInfo &info) = 0;
+
+    /**
+     * @brief Seek all track to specified time position according the given seek mode.
+     *
+     * @param timeUs the time position in microseconds where the sample will be read.
+     * @param mode the hint about how to seek to the specified time position.
+     * @return Returns {@link MSERR_OK} if the seek is success, returns an error code
+     * otherwise.
+     */
+    virtual int32_t Seek(int64_t timeUs, AVSeekMode mode) = 0;
+
+    /**
+     * @brief Get the an current estimate of how much data is cached in memory, and
+     * the information about whether the cached data has reached the end of stream.
+     * This API is only valid for network streams.
+     *
+     * @param durationUs cached duration in microseconds.
+     * @param endOfStream true if the cached data has reached the end of stream.
+     * @return Returns {@link MSERR_OK} if the query is success, returns an error code
+     * otherwise.
+     */
+    virtual int32_t GetCacheState(int64_t &durationUs, bool &endOfStream) = 0;
+
+    /**
+     * @brief Release the internel resource. After this method called, the avspliter
+     * instance can not be used again.
+     */
+    virtual void Release() = 0;
+};
+
+class __attribute__((visibility("default"))) AVSpliterFactory {
+public:
+    static std::shared_ptr<AVSpliter> CreateAVSpliter();
+private:
+    AVSpliterFactory() = default;
+    ~AVSpliterFactory() = default;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // AVSPLITER_H
diff --git a/ohos_ndk_aosp/includes/media/format.h b/ohos_ndk_aosp/includes/media/format.h
new file mode 100644
index 0000000000..bee434bbd0
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/format.h
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FORMAT_H
+#define FORMAT_H
+
+#include <string>
+#include <map>
+#include <vector>
+
+namespace OHOS {
+namespace Media {
+enum FormatDataType : uint32_t {
+    /* None */
+    FORMAT_TYPE_NONE,
+    /* Int32 */
+    FORMAT_TYPE_INT32,
+    /* Int64 */
+    FORMAT_TYPE_INT64,
+    /* Float */
+    FORMAT_TYPE_FLOAT,
+    /* Double */
+    FORMAT_TYPE_DOUBLE,
+    /* String */
+    FORMAT_TYPE_STRING,
+    /* Addr */
+    FORMAT_TYPE_ADDR,
+};
+
+struct FormatData {
+    FormatDataType type = FORMAT_TYPE_NONE;
+    union Val {
+        int32_t int32Val;
+        int64_t int64Val;
+        float floatVal;
+        double doubleVal;
+    } val = {0};
+    std::string stringVal = "";
+    uint8_t *addr = nullptr;
+    size_t size = 0;
+};
+
+class __attribute__((visibility("default"))) Format {
+public:
+    Format() = default;
+    ~Format();
+
+    Format(const Format &rhs);
+    Format(Format &&rhs) noexcept;
+    Format &operator=(const Format &rhs);
+    Format &operator=(Format &&rhs) noexcept;
+
+    /**
+     * @brief Sets metadata of the integer type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value, which is a 32-bit integer.
+     * @return Returns <b>true</b> if the setting is successful; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool PutIntValue(const std::string_view &key, int32_t value);
+
+    /**
+     * @brief Sets metadata of the long integer type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value, which is a 64-bit integer.
+     * @return Returns <b>true</b> if the setting is successful; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool PutLongValue(const std::string_view &key, int64_t value);
+
+    /**
+     * @brief Sets metadata of the single-precision floating-point type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value, which is a single-precision floating-point number.
+     * @return Returns <b>true</b> if the metadata is successfully set; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool PutFloatValue(const std::string_view &key, float value);
+
+    /**
+     * @brief Sets metadata of the double-precision floating-point type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value, which is a double-precision floating-point number.
+     * @return Returns <b>true</b> if the setting is successful; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool PutDoubleValue(const std::string_view &key, double value);
+
+    /**
+     * @brief Sets metadata of the string type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value, which is a string.
+     * @return Returns <b>true</b> if the metadata is successfully set; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool PutStringValue(const std::string_view &key, const std::string_view &value);
+
+    /**
+     * @brief Sets metadata of the string type.
+     *
+     * @param key Indicates the metadata key.
+     * @param addr Indicates the metadata addr, which is a uint8_t *.
+     * @param size Indicates the metadata addr size, which is a size_t.
+     * @return Returns <b>true</b> if the metadata is successfully set; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool PutBuffer(const std::string_view &key, const uint8_t *addr, size_t size);
+
+    /**
+     * @brief Obtains the metadata value of the integer type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value to obtain, which is a 32-bit integer.
+     * @return Returns <b>true</b> if the integer is successfully obtained; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool GetIntValue(const std::string_view &key, int32_t &value) const;
+
+    /**
+     * @brief Obtains the metadata value of the long integer type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value to obtain, which is a 64-bit long integer.
+     * @return Returns <b>true</b> if the integer is successfully obtained; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool GetLongValue(const std::string_view &key, int64_t &value) const;
+
+    /**
+     * @brief Obtains the metadata value of the single-precision floating-point type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value to obtain, which is a single-precision floating-point number.
+     * @return Returns <b>true</b> if the single-precision number is successfully obtained; returns
+     * <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool GetFloatValue(const std::string_view &key, float &value) const;
+
+    /**
+     * @brief Obtains the metadata value of the double-precision floating-point type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value to obtain, which is a double-precision floating-point number.
+     * @return Returns <b>true</b> if the double-precision number is successfully obtained; returns
+     * <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool GetDoubleValue(const std::string_view &key, double &value) const;
+
+    /**
+     * @brief Obtains the metadata value of the string type.
+     *
+     * @param key Indicates the metadata key.
+     * @param value Indicates the metadata value to obtain, which is a string.
+     * @return Returns <b>true</b> if the string is successfully obtained; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool GetStringValue(const std::string_view &key, std::string &value) const;
+
+    /**
+     * @brief Obtains the metadata value of the string type.
+     *
+     * @param key Indicates the metadata key.
+     * @param addr Indicates the metadata addr to obtain, which is a uint8_t **.
+     * @param size Indicates the metadata addr size to obtain, which is a size_t.
+     * @return Returns <b>true</b> if the string is successfully obtained; returns <b>false</b> otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    bool GetBuffer(const std::string_view &key, uint8_t **addr, size_t &size) const;
+
+    /**
+     * @brief Query whether the key exists in this Format.
+     *
+     * @param key Indicates the metadata key.
+     * @return true
+     * @return false
+     */
+    bool ContainKey(const std::string_view &key) const;
+
+    /**
+     * @brief Get the value type for the key if the key exists in this Format.
+     *
+     * @param key Indicates the metadata key.
+     * @return FormatDataType. If the key does not exists, return FORMAT_TYPE_NONE.
+     */
+    FormatDataType GetValueType(const std::string_view &key) const;
+
+    /**
+     * @brief Remove the key from the Format
+     *
+     * @param keys the key will be removed.
+     */
+    void RemoveKey(const std::string_view &key);
+
+    /**
+     * @brief A trick to enable the comparision between the std::string and std::string_view for
+     * std::map, the trick called Transparent Comparator.
+     *
+     */
+    using FormatDataMap = std::map<std::string, FormatData, std::less<>>;
+
+    /**
+     * @brief Obtains the metadata map.
+     *
+     * @return Returns the map object.
+     * @since 1.0
+     * @version 1.0
+     */
+    const FormatDataMap &GetFormatMap() const;
+
+private:
+    FormatDataMap formatMap_;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // FORMAT_H
diff --git a/ohos_ndk_aosp/includes/media/media_data_source.h b/ohos_ndk_aosp/includes/media/media_data_source.h
new file mode 100644
index 0000000000..0bd8396c15
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/media_data_source.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_DATA_SOURCE_H_
+#define MEDIA_DATA_SOURCE_H_
+
+#include "avsharedmemory.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Use with IMediaDataSource::ReadAt.
+ */
+enum MediaDataSourceError : int32_t {
+    /**
+     * use with ReadAt.the resource is cut off and player will end.
+     * And the player will complete buffers and return an error.
+     */
+    SOURCE_ERROR_IO = -2,
+    /* use with ReadAt.the resource is eos and player will complete. */
+    SOURCE_ERROR_EOF = -1,
+};
+
+/**
+ * @brief the mediaDataSource instance need set to player.
+ *
+ */
+class IMediaDataSource {
+public:
+    virtual ~IMediaDataSource() = default;
+
+    /**
+     * @brief If the size of the datasource is greater than 0, provide the implementation of this interface.
+     * Player use ReadAt to tell the position and length of mem want get.(length is number of Bytes)
+     * Then usr filled the mem, and return the actual length of mem.
+     * @param pos The stream pos player want get start.
+     * @param length Stream length player want to get.
+     * @param mem Stream mem need to fill. see avsharedmemory.h.
+     * The memory length is greater than or equal to the length.
+     * The length of the filled memory must match the actual length returned.
+     * @return The actual length of stream mem filled, if failed or no mem return MediaDataSourceError.
+     */
+    virtual int32_t ReadAt(int64_t pos, uint32_t length, const std::shared_ptr<AVSharedMemory> &mem) = 0;
+
+    /**
+     * @brief One-to-one use with getMem.
+     * If the size of the datasource is -1, provide the implementation of this interface.
+     * Player use ReadAt to tell the length of mem want get.(length is number of Bytes)
+     * Then usr filled the mem, and return the actual length of mem.
+     * @param length Stream length player want to get.
+     * @param mem Stream mem need to fill.see avsharedmemory.h.
+     * The memory length is greater than or equal to the length.
+     * The length of the filled memory must match the actual length returned.
+     * @return The actual length of stream mem filled, if failed or no mem return MediaDataSourceError.
+     */
+    virtual int32_t ReadAt(uint32_t length, const std::shared_ptr<AVSharedMemory> &mem) = 0;
+
+    /**
+     * @brief Get the total size of the stream.
+     * If the stream does not have the length, return -1. With -1, player will use the datasource not seekable.
+     * @param size Total size of the stream. If no size set -1.
+     * @return MSERR_OK if ok; others if failed. see media_errors.h
+     */
+    virtual int32_t GetSize(int64_t &size) = 0;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // MEDIA_DATA_SOURCE_H_
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/media_description.h b/ohos_ndk_aosp/includes/media/media_description.h
new file mode 100644
index 0000000000..44aa7fd146
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/media_description.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_DESCRIPTION_H
+#define MEDIA_DESCRIPTION_H
+
+#include <string_view>
+#include "format.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Provides the uniform container for storing the media description.
+ */
+using MediaDescription = Format;
+
+/**
+ * @brief Provides the key's definition for MediaDescription.
+ */
+class MediaDescriptionKey {
+public:
+    /**
+     * Key for track index, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_TRACK_INDEX = "track_index";
+
+    /**
+     * Key for track type, value type is uint8_t, see {link @MediaTrackType}
+     */
+    static constexpr std::string_view MD_KEY_TRACK_TYPE = "track_type";
+
+    /**
+     * Key for codec mime type, value type is string
+     */
+    static constexpr std::string_view MD_KEY_CODEC_MIME = "codec_mime";
+
+    /**
+     * Key for duration, value type is int64_t
+     */
+    static constexpr std::string_view MD_KEY_DURATION = "duration";
+
+    /**
+     * Key for bitrate, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_BITRATE = "bitrate";
+
+    /**
+     * Key for max input size, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_MAX_INPUT_SIZE = "max_input_size";
+
+    /**
+     * Key for video width, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_WIDTH = "width";
+
+    /**
+     * Key for video height, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_HEIGHT = "height";
+
+    /**
+     * Key for video pixelformat, value type is int32_t, see {link @MediaPixelFormat}
+     */
+    static constexpr std::string_view MD_KEY_PIXEL_FORMAT = "pixel_format";
+
+    /**
+     * Key for video frame rate, value type is double.
+     */
+    static constexpr std::string_view MD_KEY_FRAME_RATE = "frame_rate";
+
+    /**
+     * Key for video capture rate, value type is double
+     */
+    static constexpr std::string_view MD_KEY_CAPTURE_RATE = "capture_rate";
+
+    /**
+     * Key for the interval of key frame. value type is int32_t, the unit is milliseconds.
+     * A negative value means no key frames are requested after the first frame. A zero
+     * value means a stream containing all key frames is requested.
+     */
+    static constexpr std::string_view MD_KEY_I_FRAME_INTERVAL = "i_frame_interval";
+
+    /**
+     * Key for the request a I-Frame immediately. value type is boolean
+     */
+    static constexpr std::string_view MD_KEY_REQUEST_I_FRAME = "req_i_frame";
+
+    /**
+     * Key for audio channel count, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_CHANNEL_COUNT = "channel_count";
+
+    /**
+     * Key for audio sample rate, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_SAMPLE_RATE = "sample_rate";
+
+    /**
+     * Key for track count in the container, value type is uint32_t
+     */
+    static constexpr std::string_view MD_KEY_TRACK_COUNT = "track_count";
+
+    /**
+     * Key for container format type, value type is string
+     */
+    static constexpr std::string_view MD_KEY_CONTAINER_FORMAT = "container_format";
+
+    /**
+     * custom key prefix, media service will pass through to HAL.
+     */
+    static constexpr std::string_view MD_KEY_CUSTOM_PREFIX = "vendor.custom";
+
+private:
+    MediaDescriptionKey() = delete;
+    ~MediaDescriptionKey() = delete;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // MEDIA_DESCRIPTION_H
diff --git a/ohos_ndk_aosp/includes/media/media_errors.h b/ohos_ndk_aosp/includes/media/media_errors.h
new file mode 100644
index 0000000000..cadfbf26c9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/media_errors.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef MEDIA_ERRORS_H
+#define MEDIA_ERRORS_H
+
+#include <map>
+#include <string>
+#include "errors.h"
+
+namespace OHOS {
+namespace Media {
+using MSErrCode = ErrCode;
+
+// bit 28~21 is subsys, bit 20~16 is Module. bit 15~0 is code
+constexpr MSErrCode MS_MODULE = 0X01000;
+constexpr MSErrCode MS_ERR_OFFSET = ErrCodeOffset(SUBSYS_MULTIMEDIA, MS_MODULE);
+enum MediaServiceErrCode : ErrCode {
+    MSERR_OK                = ERR_OK,
+    MSERR_NO_MEMORY         = MS_ERR_OFFSET + ENOMEM, // no memory
+    MSERR_INVALID_OPERATION = MS_ERR_OFFSET + ENOSYS, // opertation not be permitted
+    MSERR_INVALID_VAL       = MS_ERR_OFFSET + EINVAL, // invalid argument
+    MSERR_UNKNOWN           = MS_ERR_OFFSET + 0x200,  // unkown error.
+    MSERR_SERVICE_DIED,                               // media service died
+    MSERR_CREATE_REC_ENGINE_FAILED,                   // create recorder engine failed.
+    MSERR_CREATE_PLAYER_ENGINE_FAILED,                // create player engine failed.
+    MSERR_CREATE_AVMETADATAHELPER_ENGINE_FAILED,      // create avmetadatahelper engine failed.
+    MSERR_CREATE_AVCODEC_ENGINE_FAILED,               // create avcodec engine failed.
+    MSERR_INVALID_STATE,                              // the state is not support this operation.
+    MSERR_UNSUPPORT,                                  // unsupport interface.
+    MSERR_UNSUPPORT_AUD_SRC_TYPE,                     // unsupport audio source type.
+    MSERR_UNSUPPORT_AUD_SAMPLE_RATE,                  // unsupport audio sample rate.
+    MSERR_UNSUPPORT_AUD_CHANNEL_NUM,                  // unsupport audio channel.
+    MSERR_UNSUPPORT_AUD_ENC_TYPE,                     // unsupport audio encoder type.
+    MSERR_UNSUPPORT_AUD_PARAMS,                       // unsupport audio params(other params).
+    MSERR_UNSUPPORT_VID_SRC_TYPE,                     // unsupport video source type.
+    MSERR_UNSUPPORT_VID_ENC_TYPE,                     // unsupport video encoder type.
+    MSERR_UNSUPPORT_VID_PARAMS,                       // unsupport video params(other params).
+    MSERR_UNSUPPORT_CONTAINER_TYPE,                   // unsupport container format type.
+    MSERR_UNSUPPORT_PROTOCOL_TYPE,                    // unsupport protocol type.
+    MSERR_UNSUPPORT_VID_DEC_TYPE,                     // unsupport video decoder type.
+    MSERR_UNSUPPORT_AUD_DEC_TYPE,                     // unsupport audio decoder type.
+    MSERR_AUD_ENC_FAILED,                             // audio encode failed.
+    MSERR_VID_ENC_FAILED,                             // video encode failed.
+    MSERR_AUD_DEC_FAILED,                             // audio decode failed.
+    MSERR_VID_DEC_FAILED,                             // video decode failed.
+    MSERR_MUXER_FAILED,                               // stream muxer failed.
+    MSERR_DEMUXER_FAILED,                             // stream demuxer or parser failed.
+    MSERR_OPEN_FILE_FAILED,                           // open file failed.
+    MSERR_FILE_ACCESS_FAILED,                         // read or write file failed.
+    MSERR_START_FAILED,                               // audio/video start failed.
+    MSERR_PAUSE_FAILED,                               // audio/video pause failed.
+    MSERR_STOP_FAILED,                                // audio/video stop failed.
+    MSERR_SEEK_FAILED,                                // audio/video seek failed.
+    MSERR_NETWORK_TIMEOUT,                            // network timeout.
+    MSERR_NOT_FIND_CONTAINER,                         // not find a demuxer.
+    MSERR_DATA_SOURCE_IO_ERROR,                       // media data source IO failed.
+    MSERR_DATA_SOURCE_OBTAIN_MEM_ERROR,               // media data source get mem failed.
+    MSERR_DATA_SOURCE_ERROR_UNKNOWN,                  // media data source error unknow.
+    MSERR_EXTEND_START      = MS_ERR_OFFSET + 0xF000, // extend err start.
+};
+
+// media api error code
+enum MediaServiceExtErrCode : ErrCode {
+    MSERR_EXT_OK = 0,
+    MSERR_EXT_NO_MEMORY = 1,           // no memory.
+    MSERR_EXT_OPERATE_NOT_PERMIT = 2,  // opertation not be permitted.
+    MSERR_EXT_INVALID_VAL = 3,         // invalid argument.
+    MSERR_EXT_IO = 4,                  // IO error.
+    MSERR_EXT_TIMEOUT = 5,             // network timeout.
+    MSERR_EXT_UNKNOWN = 6,             // unknown error.
+    MSERR_EXT_SERVICE_DIED = 7,        // media service died.
+    MSERR_EXT_INVALID_STATE = 8,       // the state is not support this operation.
+    MSERR_EXT_UNSUPPORT = 9,           // unsupport interface.
+    MSERR_EXT_EXTEND_START = 100,      // extend err start.
+};
+
+__attribute__((visibility("default"))) std::string MSErrorToString(MediaServiceErrCode code);
+__attribute__((visibility("default"))) std::string MSExtErrorToString(MediaServiceExtErrCode code);
+__attribute__((visibility("default"))) std::string MSErrorToExtErrorString(MediaServiceErrCode code);
+__attribute__((visibility("default"))) MediaServiceExtErrCode MSErrorToExtError(MediaServiceErrCode code);
+} // namespace Media
+} // namespace OHOS
+#endif // MEDIA_ERRORS_H
diff --git a/ohos_ndk_aosp/includes/media/media_surface.h b/ohos_ndk_aosp/includes/media/media_surface.h
new file mode 100644
index 0000000000..9fc3558424
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/media_surface.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_SURFACE_H
+#define MEDIA_SURFACE_H
+
+#include "surface.h"
+
+namespace OHOS {
+namespace Media {
+class MediaSurface {
+public:
+    virtual ~MediaSurface() = default;
+    virtual std::string GetSurfaceId(const sptr<Surface> &surface) = 0;
+    virtual sptr<Surface> GetSurface() = 0;
+    virtual sptr<Surface> GetSurface(const std::string &id) = 0;
+    virtual void Release() = 0;
+};
+
+class __attribute__((visibility("default"))) MediaSurfaceFactory {
+public:
+    static std::shared_ptr<MediaSurface> CreateMediaSurface();
+    MediaSurfaceFactory() = delete;
+    ~MediaSurfaceFactory() = delete;
+};
+} // namespace Media
+} // namespace OHOS
+#endif // MEDIA_SURFACE_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/media/player.h b/ohos_ndk_aosp/includes/media/player.h
new file mode 100644
index 0000000000..a88c0cca3d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/player.h
@@ -0,0 +1,478 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PLAYER_H
+#define PLAYER_H
+
+#include <cstdint>
+#include "surface.h"
+#include "format.h"
+#include "media_data_source.h"
+
+namespace OHOS {
+namespace Media {
+class PlayerKeys {
+public:
+    static constexpr std::string_view PLAYER_TRACK_INDEX = "track_index";
+    static constexpr std::string_view PLAYER_TRACK_TYPE = "track_type";
+    static constexpr std::string_view PLAYER_WIDTH = "width";
+    static constexpr std::string_view PLAYER_HEIGHT = "height";
+    static constexpr std::string_view PLAYER_MIME = "codec_mime";
+    static constexpr std::string_view PLAYER_BITRATE = "bitrate";
+    static constexpr std::string_view PLAYER_FRAMERATE = "frame_rate";
+    static constexpr std::string_view PLAYER_LANGUGAE = "language_code";
+    static constexpr std::string_view PLAYER_SAMPLE_RATE = "sample_rate";
+    static constexpr std::string_view PLAYER_CHANNELS = "channel_count";
+    static constexpr std::string_view PLAYER_BUFFERING_START = "buffering_start";
+    static constexpr std::string_view PLAYER_BUFFERING_END = "buffering_end";
+    static constexpr std::string_view PLAYER_BUFFERING_PERCENT = "buffering_percent";
+    static constexpr std::string_view PLAYER_CACHED_DURATION = "cached_duration";
+    static constexpr std::string_view CONTENT_TYPE = "content_type";
+    static constexpr std::string_view STREAM_USAGE = "stream_usage";
+};
+
+enum BufferingInfoType : int32_t {
+    /* begin to b buffering */
+    BUFFERING_START = 1,
+    /* end to buffering */
+    BUFFERING_END = 2,
+    /* buffering percent */
+    BUFFERING_PERCENT = 3,
+    /* cached duration in milliseconds */
+    CACHED_DURATION = 4,
+};
+
+enum PlayerErrorType : int32_t {
+    /* Valid error, error code reference defined in media_errors.h */
+    PLAYER_ERROR,
+    /* Unknown error */
+    PLAYER_ERROR_UNKNOWN,
+     /** extend error type start,The extension error type agreed upon by the plug-in and
+         the application will be transparently transmitted by the service. */
+    PLAYER_ERROR_EXTEND_START = 0X10000,
+};
+
+enum PlayerMessageType : int32_t {
+    /* unknown info */
+    PLAYER_INFO_UNKNOWN = 0,
+    /* first video frame start to render. */
+    PLAYER_INFO_VIDEO_RENDERING_START,
+    /* network bandwidth, uint is KB and passed by "extra"(arg 2). */
+    PLAYER_INFO_NETWORK_BANDWIDTH,
+    /* not fatal errors accured, errorcode see "media_errors.h" and passed by "extra"(arg 2). */
+    PLAYER_INFO_WARNING,
+    /* system new info type should be added here.
+       extend start. App and plugins or PlayerEngine extended info type start. */
+    PLAYER_INFO_EXTEND_START = 0X1000,
+};
+
+enum PlayerOnInfoType : int32_t {
+    /* return the message when seeking done. */
+    INFO_TYPE_SEEKDONE = 1,
+    /* return the message when speeding done. */
+    INFO_TYPE_SPEEDDONE,
+    /* return the message when playback is end of steam.  */
+    INFO_TYPE_EOS,
+    /* return the message when PlayerStates changed.  */
+    INFO_TYPE_STATE_CHANGE,
+    /* return the current posion of playback automatically.  */
+    INFO_TYPE_POSITION_UPDATE,
+    /* return the playback message.  */
+    INFO_TYPE_MESSAGE,
+    /* return the message when volume changed.  */
+    INFO_TYPE_VOLUME_CHANGE,
+    /* return the message when video size is first known or updated. */
+    INFO_TYPE_RESOLUTION_CHANGE,
+    /* return multiqueue buffering time. */
+    INFO_TYPE_BUFFERING_UPDATE,
+    /* return the message with extra information in format. */
+    INFO_TYPE_EXTRA_FORMAT
+};
+
+enum PlayerStates : int32_t {
+    /* error states */
+    PLAYER_STATE_ERROR = 0,
+    /* idle states */
+    PLAYER_IDLE = 1,
+    /* initialized states(Internal states) */
+    PLAYER_INITIALIZED = 2,
+    /* preparing states(Internal states) */
+    PLAYER_PREPARING = 3,
+    /* prepared states */
+    PLAYER_PREPARED = 4,
+    /* started states */
+    PLAYER_STARTED = 5,
+    /* paused states */
+    PLAYER_PAUSED = 6,
+    /* stopped states */
+    PLAYER_STOPPED = 7,
+    /* Play to the end states */
+    PLAYER_PLAYBACK_COMPLETE = 8,
+};
+
+enum PlayerSeekMode : int32_t {
+    /* sync to keyframes after the time point. */
+    SEEK_NEXT_SYNC = 0,
+    /* sync to keyframes before the time point. */
+    SEEK_PREVIOUS_SYNC,
+    /* sync to closest keyframes. */
+    SEEK_CLOSEST_SYNC,
+    /* seek to frames closest the time point. */
+    SEEK_CLOSEST,
+};
+
+enum PlaybackRateMode : int32_t {
+    /* Video playback at 0.75x normal speed */
+    SPEED_FORWARD_0_75_X,
+    /* Video playback at normal speed */
+    SPEED_FORWARD_1_00_X,
+    /* Video playback at 1.25x normal speed */
+    SPEED_FORWARD_1_25_X,
+    /* Video playback at 1.75x normal speed */
+    SPEED_FORWARD_1_75_X,
+    /* Video playback at 2.0x normal speed */
+    SPEED_FORWARD_2_00_X,
+};
+
+class PlayerCallback {
+public:
+    virtual ~PlayerCallback() = default;
+    /**
+     * Called when an error occurred.
+     *
+     * @param errorType Error type. For details, see {@link PlayerErrorType}.
+     * @param errorCode Error code.
+     */
+    virtual void OnError(PlayerErrorType errorType, int32_t errorCode) = 0;
+
+    /**
+     * Called when a player message or alarm is received.
+     *
+     * @param type Indicates the information type. For details, see {@link PlayerOnInfoType}.
+     * @param extra Indicates other information, for example, the start time position of a playing file.
+     * @param infoBody According to the info type, the information carrier passed.Is an optional parameter.
+     */
+    virtual void OnInfo(PlayerOnInfoType type, int32_t extra, const Format &infoBody) = 0;
+};
+
+class Player {
+public:
+    virtual ~Player() = default;
+
+    /**
+     * @brief Sets the playback source for the player. The corresponding source can be http url
+     *
+     * @param url Indicates the playback source.
+     * @return Returns {@link MSERR_OK} if the url is set successfully; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetSource(const std::string &url) = 0;
+
+    /**
+     * @brief Sets the playback media data source for the player.
+     *
+     * @param dataSrc Indicates the media data source. in {@link media_data_source.h}
+     * @return Returns {@link MSERR_OK} if the mediadatasource is set successfully; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetSource(const std::shared_ptr<IMediaDataSource> &dataSrc) = 0;
+
+    /**
+     * @brief Sets the playback media file descriptor source for the player.
+     *
+     * @param fd Indicates the file descriptor of media source.
+     * @param offset Indicates the offset of media source in file descriptor.
+     * @param size Indicates the size of media source.
+     * @return Returns {@link MSERR_OK} if the fd source is set successfully; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetSource(int32_t fd, int64_t offset = 0, int64_t size = 0) = 0;
+
+    /**
+     * @brief Start playback.
+     *
+     * This function must be called after {@link Prepare}. If the player state is <b>Prepared</b>,
+     * this function is called to start playback.
+     *
+     * @return Returns {@link MSERR_OK} if the playback is started; otherwise returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Play() = 0;
+
+    /**
+     * @brief Prepares the playback environment and buffers media data.
+     *
+     * This function must be called after {@link SetSource}.
+     *
+     * @return Returns {@link MSERR_OK} if the playback is prepared; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Prepare() = 0;
+
+    /**
+     * @brief Prepare the playback environment and buffers media data asynchronous.
+     *
+     * This function must be called after {@link SetSource}.
+     *
+     * @return Returns {@link MSERR_OK} if the playback is preparing; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t PrepareAsync() = 0;
+
+    /**
+     * @brief Pauses playback.
+     *
+     * @return Returns {@link MSERR_OK} if the playback is paused; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Pause() = 0;
+
+    /**
+     * @brief Stop playback.
+     *
+     * @return Returns {@link MSERR_OK} if the playback is stopped; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Stop() = 0;
+
+    /**
+     * @brief Restores the player to the initial state.
+     *
+     * After the function is called, add a playback source by calling {@link SetSource},
+     * call {@link Play} to start playback again after {@link Prepare} is called.
+     *
+     * @return Returns {@link MSERR_OK} if the playback is reset; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Reset() = 0;
+
+    /**
+     * @brief Releases player resources
+     *
+     * @return Returns {@link MSERR_OK} if the playback is released; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Release() = 0;
+
+    /**
+     * @brief Sets the volume of the player.
+     *
+     * This function can be used during playback or pause. The value <b>0</b> indicates no sound,
+     * and <b>1</b> indicates the original volume. If no audio device is started or no audio
+     * stream exists, the value <b>-1</b> is returned.
+     *
+     * @param leftVolume Indicates the target volume of the left audio channel to set,
+     *        ranging from 0 to 1. each step is 0.01.
+     * @param rightVolume Indicates the target volume of the right audio channel to set,
+     *        ranging from 0 to 1. each step is 0.01.
+     * @return Returns {@link MSERR_OK} if the volume is set; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVolume(float leftVolume, float rightVolume) = 0;
+
+    /**
+     * @brief Changes the playback position.
+     *
+     * This function can be used during play or pause.
+     *
+     * @param mSeconds Indicates the target playback position, accurate to milliseconds.
+     * @param mode Indicates the player seek mode. For details, see {@link PlayerSeekMode}.
+     * @return Returns {@link MSERR_OK} if the seek is done; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+    */
+    virtual int32_t Seek(int32_t mSeconds, PlayerSeekMode mode) = 0;
+
+    /**
+     * @brief Obtains the playback position, accurate to millisecond.
+     *
+     * @param currentTime Indicates the playback position.
+     * @return Returns {@link MSERR_OK} if the current position is get; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetCurrentTime(int32_t &currentTime) = 0;
+
+    /**
+     * @brief Obtains the video track info, contains mimeType, bitRate, width, height, frameRata.
+     *
+     * @param video track info vec.
+     * @return Returns {@link MSERR_OK} if the track info is get; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetVideoTrackInfo(std::vector<Format> &videoTrack) = 0;
+
+    /**
+     * @brief Obtains the audio track info, contains mimeType, bitRate, sampleRate, channels, language.
+     *
+     * @param audio track info vec.
+     * @return Returns {@link MSERR_OK} if the track info is get; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetAudioTrackInfo(std::vector<Format> &audioTrack) = 0;
+
+    /**
+     * @brief get the video width.
+     *
+     * @return Returns width if success; else returns 0
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetVideoWidth() = 0;
+
+    /**
+     * @brief get the video height.
+     *
+     * @return Returns height if success; else returns 0
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetVideoHeight() = 0;
+
+    /**
+     * @brief Obtains the total duration of media files, accurate to milliseconds.
+     *
+     * @param duration Indicates the total duration of media files.
+     * @return Returns {@link MSERR_OK} if the current duration is get; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetDuration(int32_t &duration) = 0;
+
+    /**
+     * @brief set the player playback rate
+     *
+     * @param mode the rate mode {@link PlaybackRateMode} which can set.
+     * @return Returns {@link MSERR_OK} if the playback rate is set successful; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetPlaybackSpeed(PlaybackRateMode mode) = 0;
+
+    /**
+     * @brief get the current player playback rate
+     *
+     * @param mode the rate mode {@link PlaybackRateMode} which can get.
+     * @return Returns {@link MSERR_OK} if the current player playback rate is get; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t GetPlaybackSpeed(PlaybackRateMode &mode) = 0;
+
+    /**
+     * @brief Method to set the surface.
+     *
+     * @param surface pointer of the surface.
+     * @return Returns {@link MSERR_OK} if the surface is set; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVideoSurface(sptr<Surface> surface) = 0;
+
+    /**
+     * @brief Checks whether the player is playing.
+     *
+     * @return Returns true if the playback is playing; false otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual bool IsPlaying() = 0;
+
+    /**
+     * @brief Returns the value whether single looping is enabled or not .
+     *
+     * @return Returns true if the playback is single looping; false otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual bool IsLooping() = 0;
+
+    /**
+     * @brief Enables single looping of the media playback.
+     *
+     * @return Returns {@link MSERR_OK} if the single looping is set; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetLooping(bool loop) = 0;
+
+    /**
+     * @brief Method to set player callback.
+     *
+     * @param callback object pointer.
+     * @return Returns {@link MSERR_OK} if the playercallback is set; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetPlayerCallback(const std::shared_ptr<PlayerCallback> &callback) = 0;
+
+    /**
+     * @brief Sets an extended parameter for player
+     *
+     * @param format Indicates the string key and value. For details, see {@link Format}
+     * @return Returns {@link MSERR_OK} if the parameters are set; returns an error code defined
+     * in {@link media_errors.h} otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetParameter(const Format &param) = 0;
+};
+
+class __attribute__((visibility("default"))) PlayerFactory {
+public:
+    static std::shared_ptr<Player> CreatePlayer();
+
+private:
+    PlayerFactory() = default;
+    ~PlayerFactory() = default;
+};
+__attribute__((visibility("default"))) std::string PlayerErrorTypeToString(PlayerErrorType type);
+} // namespace Media
+} // namespace OHOS
+#endif // PLAYER_H
diff --git a/ohos_ndk_aosp/includes/media/recorder.h b/ohos_ndk_aosp/includes/media/recorder.h
new file mode 100644
index 0000000000..dbe3967cf4
--- /dev/null
+++ b/ohos_ndk_aosp/includes/media/recorder.h
@@ -0,0 +1,662 @@
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDER_H
+#define RECORDER_H
+
+#include <cstdint>
+#include <string>
+#include "format.h"
+#include "surface.h"
+#include "av_common.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Enumerates video source types.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+enum VideoSourceType : int32_t {
+    /** Unsupported App Usage. */
+    /** YUV video data provided through {@link Surface} */
+    VIDEO_SOURCE_SURFACE_YUV = 0,
+    /** Raw encoded data provided through {@link Surface} */
+    VIDEO_SOURCE_SURFACE_ES,
+    /** Invalid value */
+    VIDEO_SOURCE_BUTT
+};
+
+/**
+ * @brief Enumerates audio source types.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+enum AudioSourceType : int32_t {
+    /** Invalid audio source */
+    AUDIO_SOURCE_INVALID = -1,
+    /** Default audio source */
+    AUDIO_SOURCE_DEFAULT = 0,
+    /** Microphone */
+    AUDIO_MIC = 1,
+};
+
+/**
+ * Unsupported app usage.
+ * @brief Enumerates data source types.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+enum DataSourceType : int32_t {
+    /** meta data source */
+    METADATA = 0
+};
+
+/**
+ * @brief Enumerates output format types.
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum OutputFormatType : int32_t {
+    /** Default format */
+    FORMAT_DEFAULT = 0,
+    /** MPEG4 format */
+    FORMAT_MPEG_4 = 2,
+    /** M4A format */
+    FORMAT_M4A = 6,
+    /** BUTT */
+    FORMAT_BUTT,
+};
+
+/**
+ * @brief Enumerates video codec formats.
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum VideoCodecFormat : int32_t {
+    /** Default format */
+    VIDEO_DEFAULT = 0,
+    /** H.264 */
+    H264 = 2,
+    /** MPEG4 */
+    MPEG4 = 6,
+    VIDEO_CODEC_FORMAT_BUTT,
+};
+
+/**
+ * @brief Enumerates audio codec formats.
+ *
+ * @since 3.1
+ * @version 3.1
+ */
+enum AudioCodecFormat : int32_t {
+    /** Default format */
+    AUDIO_DEFAULT = 0,
+    /** Advanced Audio Coding Low Complexity (AAC-LC) */
+    AAC_LC      =   3,
+    /** Invalid value */
+    AUDIO_CODEC_FORMAT_BUTT,
+};
+
+/**
+ * Unsupported App Usage.
+ * @brief Enumerates file split types.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+enum FileSplitType : int32_t {
+    /** Delayed/Backward split */
+    FILE_SPLIT_POST = 0,
+    /** Advanced/Forward split */
+    FILE_SPLIT_PRE,
+    /** Normal split */
+    FILE_SPLIT_NORMAL,
+    /** Invalid value */
+    FILE_SPLIT_BUTT,
+};
+
+/**
+ * @brief Enumerates recording information types.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+enum RecorderInfoType : int32_t {
+    /**
+     * The recording duration is reaching the threshold specified by {@link SetMaxDuration}. This type of
+     * information is reported when only one second or 10% is left to reach the allowed duration.
+     */
+    RECORDER_INFO_MAX_DURATION_APPROACHING = 0,
+    /**
+     * The recorded file size is reaching the threshold specified by {@link SetMaxFileSize}. This type of
+     * information is reported when only 100 KB or 10% is left to reach the allowed size.
+     */
+    RECORDER_INFO_MAX_FILESIZE_APPROACHING,
+    /**
+     * The threshold specified by {@link SetMaxDuration} is reached, and the recording ends.
+     * Before calling {@link SetNextOutputFile}, you must close the file.
+     */
+    RECORDER_INFO_MAX_DURATION_REACHED,
+    /**
+     * The threshold specified by {@link SetMaxFileSize} is reached, and the recording ends.
+     * Before calling {@link SetNextOutputFile}, you must close the file.
+     */
+    RECORDER_INFO_MAX_FILESIZE_REACHED,
+    /** Recording started for the next output file. */
+    RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED,
+    /** Manual file split completed. */
+    RECORDER_INFO_FILE_SPLIT_FINISHED,
+    /** The start time position of the recording file is not supported. */
+    RECORDER_INFO_FILE_START_TIME_MS,
+    /** Next file fd is needed but not set. */
+    RECORDER_INFO_NEXT_FILE_FD_NOT_SET,
+
+    /** warnings, and the err code passed by the 'extra' argument, the code see "MediaServiceErrCode". */
+    RECORDER_INFO_INTERNEL_WARNING,
+
+     /** extend info start,The extension information code agreed upon by the plug-in and
+         the application will be transparently transmitted by the service. */
+    RECORDER_INFO_EXTEND_START = 0X10000,
+};
+
+/**
+ * @brief Enumerates recording error types.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+enum RecorderErrorType : int32_t {
+    /* internal errors, error code passed by the errorCode, and definition see "MediaServiceErrCode" */
+    RECORDER_ERROR_INTERNAL,
+
+     /** extend error start,The extension error code agreed upon by the plug-in and
+         the application will be transparently transmitted by the service. */
+    RECORDER_ERROR_EXTEND_START = 0X10000,
+};
+
+/**
+ * @brief Provides listeners for recording errors and information events.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+class RecorderCallback {
+public:
+    virtual ~RecorderCallback() = default;
+
+    /**
+     * @brief Called when an error occurs during recording. This callback is used to report recording errors.
+     *
+     * @param errorType Indicates the error type. For details, see {@link RecorderErrorType}.
+     * @param errorCode Indicates the error code.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual void OnError(RecorderErrorType errorType, int32_t errorCode) = 0;
+
+    /**
+     * @brief Called when an information event occurs during recording. This callback is used to report recording
+     * information.
+     *
+     * @param type Indicates the information type. For details, see {@link RecorderInfoType}.
+     * @param extra Indicates other information, for example, the start time position of a recording file.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual void OnInfo(int32_t type, int32_t extra) = 0;
+};
+
+/**
+ * @brief Provides functions for audio and video recording.
+ *
+ * @since 1.0
+ * @version 1.0
+ */
+class Recorder {
+public:
+    virtual ~Recorder() = default;
+
+    /**
+     * @brief Sets a video source for recording.
+     *
+     * If this function is not called, the output file does not contain the video track.
+     *
+     * @param source Indicates the video source type. For details, see {@link VideoSourceType}.
+     * @param sourceId Indicates the video source ID. The value <b>-1</b> indicates an invalid ID and the setting fails.
+     *
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVideoSource(VideoSourceType source, int32_t &sourceId) = 0;
+
+    /**
+     * @brief Sets the audio source for recording.
+     *
+     * If this function is not called, the output file does not contain the audio track.
+     *
+     * @param source Indicates the audio source type. For details, see {@link AudioSourceType}.
+     * @param sourceId Indicates the audio source ID. The value <b>-1</b> indicates an invalid ID and the setting fails.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetAudioSource(AudioSourceType source, int32_t &sourceId) = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Sets a data source for recording.
+     *
+     * If this function is not called, the output file does not contain the data track.
+     *
+     * @param sourceId Indicates the data source ID. The value <b>-1</b> indicates an invalid ID and the setting fails.
+     *
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetDataSource(DataSourceType dataType, int32_t &sourceId) = 0;
+
+    /**
+     * @brief Sets the output file format.
+     *
+     * This function must be called before {@link Prepare} and after after all required sources have been set. After
+     * this function called, no more source settings allowed.
+     *
+     * @param format Indicates the output file format. For details, see {@link OutputFormatType}.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetOutputFormat(OutputFormatType format) = 0;
+
+    /**
+     * @brief Sets a video encoder for recording.
+     *
+     * If this function is not called, the output file does not contain the video track.
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the video source ID, which can be obtained from {@link SetVideoSource}.
+     * @param encoder Indicates the video encoder to set. For details, see {@link VideoCodecFormat}.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVideoEncoder(int32_t sourceId, VideoCodecFormat encoder) = 0;
+
+    /**
+     * @brief Sets the width and height of the video to record.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the video source ID, which can be obtained from {@link SetVideoSource}.
+     * @param width Indicates the video width to set.
+     * @param height Indicates the video height to set.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVideoSize(int32_t sourceId, int32_t width, int32_t height) = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Sets the frame rate of the video to record.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the video source ID, which can be obtained from {@link SetVideoSource}.
+     * @param frameRate Indicates the frame rate to set.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVideoFrameRate(int32_t sourceId, int32_t frameRate) = 0;
+
+    /**
+     * @brief Sets the encoding bit rate of the video to record.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the video source ID, which can be obtained from {@link SetVideoSource}.
+     * @param rate Indicates the encoding bit rate to set.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetVideoEncodingBitRate(int32_t sourceId, int32_t rate) = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Sets the video capture rate.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}. It is valid when the
+     * video source is YUV or RGB.
+     *
+     * @param sourceId Indicates the video source ID, which can be obtained from {@link SetVideoSource}.
+     * @param fps Indicates the rate at which frames are captured per second.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetCaptureRate(int32_t sourceId, double fps) = 0;
+
+    /**
+     * @brief Obtains the surface of the video source. This function can only be called after {@link Prepare} and
+     * before {@link Stop}.
+     *
+     * @param sourceId Indicates the video source ID, which can be obtained from {@link SetVideoSource}.
+     * @return Returns the pointer to the surface.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual sptr<OHOS::Surface> GetSurface(int32_t sourceId) = 0;
+
+    /**
+     * @brief Sets an audio encoder for recording.
+     *
+     * If this function is not called, the output file does not contain the audio track.
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the audio source ID, which can be obtained from {@link SetAudioSource}.
+     * @param encoder Indicates the audio encoder to set.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetAudioEncoder(int32_t sourceId, AudioCodecFormat encoder) = 0;
+
+    /**
+     * @brief Sets the audio sampling rate for recording.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the audio source ID, which can be obtained from {@link SetAudioSource}.
+     * @param rate Indicates the sampling rate of the audio per second.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetAudioSampleRate(int32_t sourceId, int32_t rate) = 0;
+
+    /**
+     * @brief Sets the number of audio channels to record.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the audio source ID, which can be obtained from {@link SetAudioSource}.
+     * @param num Indicates the number of audio channels to set.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetAudioChannels(int32_t sourceId, int32_t num) = 0;
+
+    /**
+     * @brief Sets the encoding bit rate of the audio to record.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}.
+     *
+     * @param sourceId Indicates the audio source ID, which can be obtained from {@link SetAudioSource}.
+     * @param bitRate Indicates the audio encoding bit rate, in bit/s.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetAudioEncodingBitRate(int32_t sourceId, int32_t bitRate) = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Sets the maximum duration of a recorded file, in seconds.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}. If the setting is valid,
+     * {@link RECORDER_INFO_MAX_DURATION_APPROACHING} is reported through {@link OnInfo} in the {@link RecorderCallback}
+     * class when only one second or 10% is left to reach the allowed duration.
+     * If the recording output file is set by calling {@link SetOutputFile}, call {@link SetNextOutputFile} to set the
+     * next output file. Otherwise, the current file will be overwritten when the allowed duration is reached.
+     *
+     * @param duration Indicates the maximum recording duration to set. If the value is <b>0</b> or a negative number,
+     * a failure message is returned. The default duration is 60s.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetMaxDuration(int32_t duration) = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Sets the maximum size of a recorded file, in bytes.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}. If the setting is valid,
+     * {@link RECORDER_INFO_MAX_DURATION_APPROACHING} is reported through {@link OnInfo} in the {@link RecorderCallback}
+     * class when only 100 KB or 10% is left to reach the allowed size.
+     * If the recording output file is set by calling {@link SetOutputFile}, call {@link SetNextOutputFile} to set the
+     * next output file. Otherwise, when the allowed size is reached, the current file will be overwritten. If
+     * <b>MaxDuration</b> is also set by calling {@link SetMaxDuration}, <b>MaxDuration</b> or <b>MaxFileSize</b>
+     * prevails depending on which of them is first satisfied.
+     *
+     * @param size Indicates the maximum file size to set. If the value is <b>0</b> or a negative number, a failure
+     * message is returned.
+     * By default, the maximum size of a single file supported by the current file system is used as the limit.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetMaxFileSize(int64_t size) = 0;
+
+    /**
+     * @brief Sets the output file path.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare} and One of them
+     * {@link SetOutputFile} must be set.
+     *
+     * @param path Indicates the output file path.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetOutputPath(const std::string &path) = 0;
+
+    /**
+     * @brief Sets the file descriptor (FD) of the output file.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare} and One of them
+     * {@link SetOutputPath} must be set.
+     *
+     * @param fd Indicates the FD of the file.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetOutputFile(int32_t fd) = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Sets the FD of the next output file.
+     *
+     * If {@link SetOutputFile} is successful, call this function to set the FD of the next output file after
+     * {@link RECORDER_INFO_MAX_DURATION_APPROACHING} or {@link RECORDER_INFO_MAX_FILESIZE_APPROACHING} is received.
+     *
+     * @param fd Indicates the FD of the next output file.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetNextOutputFile(int32_t fd) = 0;
+
+    /**
+     * @brief Set and store the geodata (latitude and longitude) in the output file.
+     * This method should be called before prepare(). The geodata is stored in udta box if
+     * the output format is OutputFormat.THREE_GPP or OutputFormat.MPEG_4,
+     * and is ignored for other output formats.
+     *
+     * @param latitude float: latitude in degrees. Its value must be in the range [-90, 90].
+     * @param longitude float: longitude in degrees. Its value must be in the range [-180, 180].
+     * @since openharmony 3.1
+     * @version 1.0
+     */
+    virtual void SetLocation(float latitude, float longitude) = 0;
+
+    /**
+     * @brief set the orientation hint in output file, and for the file to playback. mp4 support.
+     * the range of orientation should be {0, 90, 180, 270}, default is 0.
+     *
+     * @param rotation int32_t: should be {0, 90, 180, 270}, default is 0.
+     * @since openharmony 3.1
+     * @version 1.0
+     */
+    virtual void SetOrientationHint(int32_t rotation) = 0;
+
+    /**
+     * @brief Registers a recording listener.
+     *
+     * This function must be called after {@link SetOutputFormat} but before {@link Prepare}
+     *
+     * @param callback Indicates the recording listener to register. For details, see {@link RecorderCallback}.
+     * @return Returns {@link MSERR_OK} if the setting is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetRecorderCallback(const std::shared_ptr<RecorderCallback> &callback) = 0;
+
+    /**
+     * @brief Prepares for recording.
+     *
+     * This function must be called before {@link Start}.
+     *
+     * @return Returns {@link MSERR_OK} if the preparation is successful; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Prepare() = 0;
+
+    /**
+     * @brief Starts recording.
+     *
+     * This function must be called after {@link Prepare}.
+     *
+     * @return Returns {@link MSERR_OK} if the recording is started; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Start() = 0;
+
+    /**
+     * @brief Pauses recording.
+     *
+     * After {@link Start} is called, you can call this function to pause recording.
+     *
+     * @return Returns {@link MSERR_OK} if the recording is paused; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Pause() = 0;
+
+    /**
+    * @brief Resumes recording.
+    *
+    * You can call this function to resume recording after {@link Pause} is called.
+     *
+     * @return Returns {@link MSERR_OK} if the recording is resumed; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Resume() = 0;
+
+    /**
+     * @brief Stops recording.
+     *
+     * @param block Indicates the stop mode. The value <b>true</b> indicates that the processing stops after all caches
+     * are processed, and <b>false</b> indicates that the processing stops immediately and all caches are discarded.
+     * After the recording stopped, all sources and parameters must be set again to restore recording. The function is
+     * like to {@link Reset}, except that the block parameter is allowed to be specified.
+     * @return Returns {@link MSERR_OK} if the recording is stopped; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Stop(bool block) = 0;
+
+    /**
+     * @brief Resets the recording.
+     *
+     * After the function is called, add a recording source by calling {@link SetVideoSource} or {@link SetAudioSource},
+     * set related parameters, and call {@link Start} to start recording again after {@link Prepare} is called.
+     *
+     * @return Returns {@link MSERR_OK} if the recording is stopped; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Reset() = 0;
+
+    /**
+     * @brief Releases recording resources. After this function called, none of interfaces of {@link Recorder}
+     * can be used.
+     *
+     * @return Returns {@link MSERR_OK} if the recording is stopped; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t Release() = 0;
+
+    /**
+     * Unsupported App Usage.
+     * @brief Manually splits a video.
+     *
+     * This function must be called after {@link Start}. After this function is called, the file is split based on the
+     * manual split type. After the manual split is complete, the initial split type is used. This function can be
+     * called again only after {@link RECORDER_INFO_FILE_SPLIT_FINISHED} is reported.
+     *
+     * @param type Indicates the file split type. For details, see {@link FileSplitType}.
+     * @param timestamp Indicates the file split timestamp. This parameter is not supported currently and can be set to
+     * <b>-1</b>. The recording module splits a file based on the call time.
+     * @param duration Indicates the duration for splitting the file.
+     * @return Returns {@link MSERR_OK} if the recording is stopped; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetFileSplitDuration(FileSplitType type, int64_t timestamp, uint32_t duration) = 0;
+
+    /**
+     * @brief Sets an extended parameter for recording, for example, {@link RECORDER_PRE_CACHE_DURATION}.
+     *
+     * This function must be called after {@link Prepare}.
+     *
+     * @param sourceId Indicates the data source ID. The value <b>-1</b> indicates all sources.
+     * @param format Indicates the string key and value. For details, see {@link Format} and
+     * {@link RECORDER_PRE_CACHE_DURATION}.
+     * @return Returns {@link MSERR_OK} if the recording is stopped; returns an error code otherwise.
+     * @since 1.0
+     * @version 1.0
+     */
+    virtual int32_t SetParameter(int32_t sourceId, const Format &format) = 0;
+};
+
+class __attribute__((visibility("default"))) RecorderFactory {
+public:
+    static std::shared_ptr<Recorder> CreateRecorder();
+private:
+    RecorderFactory() = default;
+    ~RecorderFactory() = default;
+};
+
+__attribute__((visibility("default"))) std::string RecorderErrorTypeToString(RecorderErrorType type);
+} // namespace Media
+} // namespace OHOS
+#endif // RECORDER_H
diff --git a/ohos_ndk_aosp/includes/multimodalinput/axis_event.h b/ohos_ndk_aosp/includes/multimodalinput/axis_event.h
new file mode 100755
index 0000000000..bb6bd655b5
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/axis_event.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AXIS_EVENT_H
+#define AXIS_EVENT_H
+
+#include "input_event.h"
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace MMI {
+class AxisEvent : public InputEvent {
+public:
+    static constexpr int32_t AXIS_ACTION_UNKNOWN = 0;
+    static constexpr int32_t AXIS_ACTION_CANCEL = 1;
+
+    static constexpr int32_t AXIS_ACTION_START = 2;
+    static constexpr int32_t AXIS_ACTION_UPDATE = 3;
+    static constexpr int32_t AXIS_ACTION_END = 4;
+
+    static constexpr int32_t AXIS_TYPE_UNKNOWN = 0;
+
+public:
+    static std::shared_ptr<AxisEvent> from(std::shared_ptr<InputEvent> inputEvent);
+    static std::shared_ptr<AxisEvent> Create();
+
+public:
+    DISALLOW_COPY_AND_MOVE(AxisEvent);
+    virtual ~AxisEvent();
+
+    int32_t GetAxisAction();
+    void SetAxisAction(int32_t axisAction);
+
+    int32_t GetAxisType() const;
+    void SetAxisType(int32_t axisType);
+
+    int32_t GetAxisValue() const;
+    void SetAxisValue(int32_t axisValue);
+
+protected:
+    explicit AxisEvent(int32_t eventType);
+};
+} // namespace MMI
+} // namespace OHOS
+#endif // AXIS_EVENT_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/i_input_event_consumer.h b/ohos_ndk_aosp/includes/multimodalinput/i_input_event_consumer.h
new file mode 100755
index 0000000000..61c4cc5f14
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/i_input_event_consumer.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef I_INPUT_EVENT_CONSUMER_H
+#define I_INPUT_EVENT_CONSUMER_H
+
+#include <memory>
+
+#include "key_event.h"
+#include "pointer_event.h"
+#include "axis_event.h"
+
+namespace OHOS {
+namespace MMI {
+struct IInputEventConsumer {
+public:
+    IInputEventConsumer() = default;
+    virtual ~IInputEventConsumer() = default;
+
+    virtual void OnInputEvent(std::shared_ptr<KeyEvent> keyEvent) const;
+    virtual void OnInputEvent(std::shared_ptr<PointerEvent> pointerEvent) const;
+    virtual void OnInputEvent(std::shared_ptr<AxisEvent> axisEvent) const;
+};
+} // namespace MMI
+} // namespace OHOS
+
+#endif // I_INPUT_EVENT_CONSUMER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/i_input_event_handler.h b/ohos_ndk_aosp/includes/multimodalinput/i_input_event_handler.h
new file mode 100755
index 0000000000..12829453b0
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/i_input_event_handler.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef I_INPUT_EVENT_HANDLER_H
+#define I_INPUT_EVENT_HANDLER_H
+
+#include <mutex>
+#include "key_event.h"
+#include "pointer_event.h"
+#include "uds_session.h"
+
+namespace OHOS {
+namespace MMI {
+struct IInputEventHandler {
+    static constexpr int32_t DEFAULT_INTERCEPTOR = 10;
+    static constexpr int32_t DEFAULT_MONITOR = 20;
+    virtual int32_t GetPriority() const = 0;
+    virtual bool HandleEvent(std::shared_ptr<KeyEvent> KeyEvent) = 0;
+    virtual bool HandleEvent(std::shared_ptr<PointerEvent> PointerEvent) = 0;
+};
+} // namespace MMI
+} // namespace OHOS
+#endif // I_INPUT_EVENT_HANDLER_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/if_mmi_client.h b/ohos_ndk_aosp/includes/multimodalinput/if_mmi_client.h
new file mode 100755
index 0000000000..eea97feb7d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/if_mmi_client.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef IF_MMI_CLIENT_H
+#define IF_MMI_CLIENT_H
+#include <memory>
+#include <functional>
+#include "if_client_msg_handler.h"
+
+namespace OHOS {
+namespace MMI {
+class NetPacket;
+class IfMMIClient;
+typedef std::function<void(const IfMMIClient&)> ConnectCallback;
+class IfMMIClient {
+public:
+    virtual bool GetCurrentConnectedStatus() const = 0;
+    virtual bool Start(IClientMsgHandlerPtr msgHdl, bool detachMode) = 0;
+    virtual bool SendMessage(const NetPacket& pkt) const = 0;
+    virtual void RegisterConnectedFunction(ConnectCallback fun) = 0;
+    virtual void RegisterDisconnectedFunction(ConnectCallback fun) = 0;
+};
+using MMIClientPtr = std::shared_ptr<IfMMIClient>;
+} // namespace MMI
+} // namespace OHOS
+#endif // IF_MMI_CLIENT_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/input_event.h b/ohos_ndk_aosp/includes/multimodalinput/input_event.h
new file mode 100755
index 0000000000..e9c15e12f3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/input_event.h
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INPUT_EVENT_H
+#define INPUT_EVENT_H
+
+#include <functional>
+#include <memory>
+#include <mutex>
+#include "nocopyable.h"
+#include "parcel.h"
+
+namespace OHOS {
+namespace MMI {
+class InputEvent {
+public:
+    // Unknown action. Usually used to indicate the initial value of the input event action
+    static constexpr int32_t ACTION_UNKNOWN = 0;
+    // Cancel the action. Used to indicate that a continuous input event is cancelled
+    static constexpr int32_t ACTION_CANCEL = 1;
+
+    // The actual type of the current input event is the basic type (InputEvent type)
+    static constexpr int32_t EVENT_TYPE_BASE = 0X00000000;
+    // The actual type of the current input event is the KeyEvent type or its derived class
+    static constexpr int32_t EVENT_TYPE_KEY = 0X00010000;
+    // The actual type of the current input event is the PointerEvent type or its derived class
+    static constexpr int32_t EVENT_TYPE_POINTER = 0X00020000;
+    // The actual type of the current input event is the AxisEvent type or its derived class
+    static constexpr int32_t EVENT_TYPE_AXIS = 0X00030000;
+
+    static constexpr uint32_t EVENT_FLAG_NONE = 0x00000000;
+    static constexpr uint32_t EVENT_FLAG_NO_INTERCEPT = 0x00000001;
+    static constexpr uint32_t EVENT_FLAG_NO_MONITOR = 0x00000002;
+
+    static constexpr int32_t DEFALUTID = -1;
+
+public:
+    InputEvent(const InputEvent& other);
+    virtual ~InputEvent();
+    virtual InputEvent& operator=(const InputEvent& other) = delete;
+    DISALLOW_MOVE(InputEvent);
+    static std::shared_ptr<InputEvent> Create();
+
+    void Reset();
+    /*
+     * Get or set the unique identifier of the input event,
+     * which is globally unique after being processed by the input service
+     * Under normal circumstances, do not need to set
+     */
+    int32_t GetId() const;
+    void SetId(int32_t id);
+
+    /* *
+     * Get or set the time when the current action occurred.
+     * The default value is the object creation time
+     * Under normal circumstances, do not need to set
+     */
+    int64_t GetActionTime() const;
+    void SetActionTime(int64_t actionTime);
+
+    /*
+     * Get or set the current action
+     */
+    int32_t GetAction() const;
+    void SetAction(int32_t action);
+
+    /*
+     * Action start time.
+     * For instantaneous actions, it is consistent with the time when the action occurred.
+     * For continuous actions, it indicates the start time of the continuous action
+     */
+    int64_t GetActionStartTime() const;
+    void SetActionStartTime(int64_t time);
+
+    /*
+     * Get or set the unique identifier of the input device that reports the input event
+     * The default value is 0, which means that the non-real device reports
+     */
+    int32_t GetDeviceId() const;
+    void SetDeviceId(int32_t deviceId);
+
+    /*
+     * Gets or sets the target display ID of the input event.
+     * The default is -1, which means that it is dynamically determined by the input service
+     */
+    int32_t GetTargetDisplayId() const;
+    void SetTargetDisplayId(int32_t displayId);
+
+    /*
+     * Gets or sets the description window id of the input event.
+     * The default value is -1, and the target window is determined by the input service.
+     */
+    int32_t GetTargetWindowId() const;
+    void SetTargetWindowId(int32_t windowId);
+
+    /*
+     * Gets or sets the id of the input event agent window.
+     * The input event originally sent to the target window will be sent to the proxy window.
+     * The default value is -1. Indicates determined by the input service. External users should not set this value.
+     */
+    int32_t GetAgentWindowId() const;
+    void SetAgentWindowId(int32_t windowId);
+
+    /*
+     * The actual type of the current input event.
+     * Valid values are EVENT_TYPE_BASE, EVENT_TYPE_KEY, EVENT_TYPE_POINTER, EVENT_TYPE_AXIS
+     */
+    int32_t GetEventType() const;
+    const char* DumpEventType() const;
+
+    uint32_t GetFlag() const;
+
+    bool HasFlag(uint32_t flag);
+
+    void AddFlag(uint32_t flag);
+
+    void ClearFlag();
+
+    void UpdateId();
+
+    /*
+     * Mark input event processing completed.
+     * This method can only be called once.
+     */
+    void MarkProcessed();
+
+    /*
+     * Set the callback function when the input event is processed.
+     * External users should not call this interface
+     */
+    void SetProcessedCallback(std::function<void(int32_t)> callback);
+
+public:
+    bool WriteToParcel(Parcel &out) const;
+    bool ReadFromParcel(Parcel &in);
+
+protected:
+    explicit InputEvent(int32_t eventType);
+
+protected:
+    int32_t eventType_;
+    int32_t id_;
+    int64_t actionTime_;
+    int32_t action_;
+    int64_t actionStartTime_;
+    int32_t deviceId_;
+    int32_t targetDisplayId_;
+    int32_t targetWindowId_;
+    int32_t agentWindowId_;
+    uint32_t bitwise_;
+    std::function<void(int32_t)> processedCallback_;
+};
+} // namespace MMI
+} // namespace OHOS
+#endif // INPUT_EVENT_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/input_handler_type.h b/ohos_ndk_aosp/includes/multimodalinput/input_handler_type.h
new file mode 100755
index 0000000000..75fccc2e66
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/input_handler_type.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INPUT_HANDLER_TYPE_H
+#define INPUT_HANDLER_TYPE_H
+#include <limits>
+
+namespace OHOS {
+namespace MMI {
+namespace {
+    constexpr size_t    MAX_N_INPUT_HANDLERS { 16 };
+    constexpr size_t    MAX_N_INPUT_MONITORS { MAX_N_INPUT_HANDLERS };
+    constexpr size_t    MAX_N_INPUT_INTERCEPTORS { MAX_N_INPUT_HANDLERS };
+    constexpr int32_t   MIN_HANDLER_ID { 1 };
+    constexpr int32_t   INVALID_HANDLER_ID { -1 };
+}
+
+enum InputHandlerType : int32_t {
+    NONE,
+    INTERCEPTOR,
+    MONITOR,
+};
+
+inline bool IsValidHandlerType(InputHandlerType handlerType)
+{
+    return ((handlerType == InputHandlerType::INTERCEPTOR) ||
+        (handlerType == InputHandlerType::MONITOR));
+}
+
+inline bool IsValidHandlerId(int32_t handlerId)
+{
+    return ((handlerId >= MIN_HANDLER_ID) && (handlerId < std::numeric_limits<int32_t>::max()));
+}
+} // namespace MMI
+} // namespace OHOS
+#endif // INPUT_HANDLER_TYPE_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/key_event.h b/ohos_ndk_aosp/includes/multimodalinput/key_event.h
new file mode 100755
index 0000000000..ff70c81a2d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/key_event.h
@@ -0,0 +1,1518 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef KEY_EVENT_H
+#define KEY_EVENT_H
+#include <memory>
+#include <vector>
+#include "nocopyable.h"
+#include "parcel.h"
+#include "input_event.h"
+
+namespace OHOS {
+namespace MMI {
+class KeyEvent : public InputEvent {
+public:
+    // KEYCODE
+    static const int32_t KEYCODE_FN;
+    /* *
+     * Keycode constant: unknown keycode
+     * <p>The keycode is unknown.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_UNKNOWN;
+
+    /* *
+     * Keycode constant: Home key
+     * <p>This key is processed by the framework and will never be sent to the application.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_HOME;
+
+    /* *
+     * Keycode constant: Back key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BACK;
+
+    /* *
+     * Keycode constant: Call key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CALL;
+
+    /* *
+     * Keycode constant: End Call key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_ENDCALL;
+
+    /* *
+     * Keycode constant: Clear key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CLEAR;
+
+    /* *
+     * Keycode constant: Headset Hook key
+     * <p>The key is used to end a call and stop media.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_HEADSETHOOK;
+
+    /* *
+     * Keycode constant: Camera Focus key
+     * <p>This key is used to enable focus for the camera.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_FOCUS;
+
+    /* *
+     * Keycode constant: Notification key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NOTIFICATION;
+
+    /* *
+     * Keycode constant: Search key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SEARCH;
+
+    /* *
+     * Keycode constant: Play/Pause media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_PLAY_PAUSE;
+
+    /* *
+     * Keycode constant: Stop media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_STOP;
+
+    /* *
+     * Keycode constant: Play Next media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_NEXT;
+
+    /* *
+     * Keycode constant: Play Previous media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_PREVIOUS;
+
+    /* *
+     * Keycode constant: Rewind media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_REWIND;
+
+    /* *
+     * Keycode constant: Fast Forward media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_FAST_FORWARD;
+
+    /* *
+     * Turns up the volume.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_VOLUME_UP;
+
+    /* *
+     * Turns down the volume.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_VOLUME_DOWN;
+
+    /* *
+     * Presses the power button.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_POWER;
+
+    /* *
+     * Presses the camera key.
+     * <p>It is used to start the camera or take photos.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CAMERA;
+
+    /* *
+     * Voice Assistant key
+     * <p>This key is used to wake up the voice assistant.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_VOICE_ASSISTANT;
+
+    /* *
+     * Custom key 1
+     * <p>The actions mapping to the custom keys are user-defined. Key values 521-529 are reserved for custom keys.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CUSTOM1;
+
+    static const int32_t KEYCODE_VOLUME_MUTE;
+    static const int32_t KEYCODE_MUTE;
+
+    /* *
+     * Brightness UP key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BRIGHTNESS_UP;
+
+    /* *
+     * Brightness Down key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BRIGHTNESS_DOWN;
+
+    /* *
+     * Indicates general-purpose key 1 on the wearables
+     *
+     * @since 3
+     */
+    static const int32_t KEYCODE_WEAR_1;
+
+    /* *
+     * Keycode constant: '0' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_0;
+
+    /* *
+     * Keycode constant: '1' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_1;
+
+    /* *
+     * Keycode constant: '2' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_2;
+
+    /* *
+     * Keycode constant: '3' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_3;
+
+    /* *
+     * Keycode constant: '4' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_4;
+
+    /* *
+     * Keycode constant: '5' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_5;
+
+    /* *
+     * Keycode constant: '6' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_6;
+
+    /* *
+     * Keycode constant: '7' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_7;
+
+    /* *
+     * Keycode constant: '8' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_8;
+
+    /* *
+     * Keycode constant: '9' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_9;
+
+    /* *
+     * Keycode constant: '*' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_STAR;
+
+    /* *
+     * Keycode constant: '#' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_POUND;
+
+    /* *
+     * Keycode constant: Directional Pad Up key
+     * <p>The key may also be synthesized from trackball motions.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_DPAD_UP;
+
+    /* *
+     * Keycode constant: Directional Pad Down key
+     * <p>The key may also be synthesized from trackball motions.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_DPAD_DOWN;
+
+    /* *
+     * Keycode constant: Directional Pad Left key
+     * <p>The key may also be synthesized from trackball motions.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_DPAD_LEFT;
+
+    /* *
+     * Keycode constant: Directional Pad Right key
+     * <p>The key may also be synthesized from trackball motions.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_DPAD_RIGHT;
+
+    /* *
+     * Keycode constant: Directional Pad Center key
+     * <p>The key may also be synthesized from trackball motions.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_DPAD_CENTER;
+
+    /* *
+     * Keycode constant: 'A' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_A;
+
+    /* *
+     * Keycode constant: 'B' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_B;
+
+    /* *
+     * Keycode constant: 'C' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_C;
+
+    /* *
+     * Keycode constant: 'D' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_D;
+
+    /* *
+     * Keycode constant: 'E' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_E;
+
+    /* *
+     * Keycode constant: 'F' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F;
+
+    /* *
+     * Keycode constant: 'G' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_G;
+
+    /* *
+     * Keycode constant: 'H' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_H;
+
+    /* *
+     * Keycode constant: 'I' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_I;
+
+    /* *
+     * Keycode constant: 'J' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_J;
+
+    /* *
+     * Keycode constant: 'K' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_K;
+
+    /* *
+     * Keycode constant: 'L' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_L;
+
+    /* *
+     * Keycode constant: 'M' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_M;
+
+    /* *
+     * Keycode constant: 'N' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_N;
+
+    /* *
+     * Keycode constant: 'O' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_O;
+
+    /* *
+     * Keycode constant: 'P' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_P;
+
+    /* *
+     * Keycode constant: 'Q' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_Q;
+
+    /* *
+     * Keycode constant: 'R' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_R;
+
+    /* *
+     * Keycode constant: 'S' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_S;
+
+    /* *
+     * Keycode constant: 'T' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_T;
+
+    /* *
+     * Keycode constant: 'U' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_U;
+
+    /* *
+     * Keycode constant: 'V' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_V;
+
+    /* *
+     * Keycode constant: 'W' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_W;
+
+    /* *
+     * Keycode constant: 'X' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_X;
+
+    /* *
+     * Keycode constant: 'Y' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_Y;
+
+    /* *
+     * Keycode constant: 'Z' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_Z;
+
+    /* *
+     * Keycode constant: ';' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_COMMA;
+
+    /* *
+     * Keycode constant: '.' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_PERIOD;
+
+    /* *
+     * Keycode constant: Left Alt modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_ALT_LEFT;
+
+    /* *
+     * Keycode constant: Right Alt modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_ALT_RIGHT;
+
+    /* *
+     * Keycode constant: Left Shift modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SHIFT_LEFT;
+
+    /* *
+     * Keycode constant: Right Shift modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SHIFT_RIGHT;
+
+    /* *
+     * Keycode constant: Tab key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_TAB;
+
+    /* *
+     * Keycode constant: Space key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SPACE;
+
+    /* *
+     * Keycode constant: Symbol modifier key
+     * <p>The key is used to input alternate symbols.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SYM;
+
+    /* *
+     * Keycode constant: Explorer function key
+     * <p>This key is used to launch a browser application.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_EXPLORER;
+
+    /* *
+     * Keycode constant: Email function key
+     * <p>This key is used to launch an email application.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_ENVELOPE;
+
+    /* *
+     * Keycode constant: Enter key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_ENTER;
+
+    /* *
+     * Keycode constant: Backspace key
+     * <p>Unlike {@link #static const int32_t KEYCODE_FORWARD_DEL}; this key is used to delete characters before the
+     * insertion point.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_DEL;
+
+    /* *
+     * Keycode constant: '`' key (backtick key)
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_GRAVE;
+
+    /* *
+     * Keycode constant: '-' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MINUS;
+
+    /* *
+     * Keycode constant: '=' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_EQUALS;
+
+    /* *
+     * Keycode constant: '[' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_LEFT_BRACKET;
+
+    /* *
+     * Keycode constant: ']' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_RIGHT_BRACKET;
+
+    /* *
+     * Keycode constant: '\' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BACKSLASH;
+
+    /* *
+     * Keycode constant: ';' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SEMICOLON;
+
+    /* *
+     * Keycode constant: ''' key (apostrophe key)
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_APOSTROPHE;
+
+    /* *
+     * Keycode constant: '/' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SLASH;
+
+    /* *
+     * Keycode constant: '{@literal @}' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_AT;
+
+    /* *
+     * Keycode constant: '+' key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_PLUS;
+
+    /* *
+     * Keycode constant: Menu key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MENU;
+
+    /* *
+     * Keycode constant: Page Up key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_PAGE_UP;
+
+    /* *
+     * Keycode constant: Page Down key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_PAGE_DOWN;
+
+    /* *
+     * Keycode constant: Escape key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_ESCAPE;
+
+    /* *
+     * Keycode constant: Forward Delete key
+     * <p>Unlike {@link #static const int32_t KEYCODE_DEL}; this key is used to delete characters ahead of the insertion
+     * point.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_FORWARD_DEL;
+
+    /* *
+     * Keycode constant: Left Control modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CTRL_LEFT;
+
+    /* *
+     * Keycode constant: Right Control modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CTRL_RIGHT;
+
+    /* *
+     * Keycode constant: Caps Lock key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_CAPS_LOCK;
+
+    /* *
+     * Keycode constant: Scroll Lock key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SCROLL_LOCK;
+
+    /* *
+     * Keycode constant: Left Meta modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_META_LEFT;
+
+    /* *
+     * Keycode constant: Right Meta modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_META_RIGHT;
+
+    /* *
+     * Keycode constant: Function modifier key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_FUNCTION;
+
+    /* *
+     * Keycode constant: System Request/Print Screen key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_SYSRQ;
+
+    /* *
+     * Keycode constant: Break/Pause key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BREAK;
+
+    /* *
+     * Keycode constant: Home Movement key
+     * <p>This key is used to scroll or move the cursor around to the start of a line or to the
+     * top of a list.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MOVE_HOME;
+
+    /* *
+     * Keycode constant: End Movement key
+     * <p>This key is used to scroll or move the cursor around to the end of a line or to the
+     * bottom of a list.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MOVE_END;
+
+    /* *
+     * Keycode constant: Insert key
+     * <p>This key is used to toggle the insert or overwrite edit mode.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_INSERT;
+
+    /* *
+     * Keycode constant: Forward key
+     * <p>This key is used to navigate forward in the history stack. It is a complement of
+     * {@link #static const int32_t KEYCODE_BACK}.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_FORWARD;
+
+    /* *
+     * Keycode constant: Play media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_PLAY;
+
+    /* *
+     * Keycode constant: Pause media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_PAUSE;
+
+    /* *
+     * Keycode constant: Close media key
+     * <p>This key can be used to close a CD tray; for example.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_CLOSE;
+
+    /* *
+     * Keycode constant: Eject media key
+     * <p>This key can be used to eject a CD tray; for example.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_EJECT;
+
+    /* *
+     * Keycode constant: Record media key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_MEDIA_RECORD;
+
+    /* *
+     * Keycode constant: F1 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F1;
+
+    /* *
+     * Keycode constant: F2 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F2;
+
+    /* *
+     * Keycode constant: F3 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F3;
+
+    /* *
+     * Keycode constant: F4 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F4;
+
+    /* *
+     * Keycode constant: F5 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F5;
+
+    /* *
+     * Keycode constant: F6 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F6;
+
+    /* *
+     * Keycode constant: F7 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F7;
+
+    /* *
+     * Keycode constant: F8 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F8;
+
+    /* *
+     * Keycode constant: F9 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F9;
+
+    /* *
+     * Keycode constant: F10 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F10;
+
+    /* *
+     * Keycode constant: F11 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F11;
+
+    /* *
+     * Keycode constant: F12 key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_F12;
+
+    /* *
+     * Keycode constant: Num Lock key
+     * <p>This key is used to alter the behavior of other keys on the numeric keypad.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUM_LOCK;
+
+    /* *
+     * Keycode constant: '0' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_0;
+
+    /* *
+     * Keycode constant: '1' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_1;
+
+    /* *
+     * Keycode constant: '2' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_2;
+
+    /* *
+     * Keycode constant: '3' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_3;
+
+    /* *
+     * Keycode constant: '4' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_4;
+
+    /* *
+     * Keycode constant: '5' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_5;
+
+    /* *
+     * Keycode constant: '6' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_6;
+
+    /* *
+     * Keycode constant: '7' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_7;
+
+    /* *
+     * Keycode constant: '8' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_8;
+
+    /* *
+     * Keycode constant: '9' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_9;
+
+    /* *
+     * Keycode constant: '/' key (for division) on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_DIVIDE;
+
+    /* *
+     * Keycode constant: '*' key (for multiplication) on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_MULTIPLY;
+
+    /* *
+     * Keycode constant: '-' key (for subtraction) on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_SUBTRACT;
+
+    /* *
+     * Keycode constant: '+' key (for addition) on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_ADD;
+
+    /* *
+     * Key code constant: '.' key (for decimals or digit grouping) on the
+     * numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_DOT;
+
+    /* *
+     * Key code constant: ';' key (for decimals or digit grouping) on the
+     * numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_COMMA;
+
+    /* *
+     * Keycode constant: Enter key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_ENTER;
+
+    /* *
+     * Keycode constant: '=' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_EQUALS;
+
+    /* *
+     * Keycode constant: '(' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_LEFT_PAREN;
+
+    /* *
+     * Keycode constant: ')' key on the numeric keypad
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_NUMPAD_RIGHT_PAREN;
+
+    /* *
+     * Key code:  The virtual multitask key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_VIRTUAL_MULTITASK;
+
+    /* *
+     * Key code:  The handle button key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BUTTON_A;
+    static const int32_t KEYCODE_BUTTON_B;
+    static const int32_t KEYCODE_BUTTON_C;
+    static const int32_t KEYCODE_BUTTON_X;
+    static const int32_t KEYCODE_BUTTON_Y;
+    static const int32_t KEYCODE_BUTTON_Z;
+    static const int32_t KEYCODE_BUTTON_L1;
+    static const int32_t KEYCODE_BUTTON_R1;
+    static const int32_t KEYCODE_BUTTON_L2;
+    static const int32_t KEYCODE_BUTTON_R2;
+    static const int32_t KEYCODE_BUTTON_SELECT;
+    static const int32_t KEYCODE_BUTTON_START;
+    static const int32_t KEYCODE_BUTTON_MODE;
+    static const int32_t KEYCODE_BUTTON_THUMBL;
+    static const int32_t KEYCODE_BUTTON_THUMBR;
+
+    /* *
+     * Key code:  The joystick button key
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_BUTTON_TRIGGER;
+    static const int32_t KEYCODE_BUTTON_THUMB;
+    static const int32_t KEYCODE_BUTTON_THUMB2;
+    static const int32_t KEYCODE_BUTTON_TOP;
+    static const int32_t KEYCODE_BUTTON_TOP2;
+    static const int32_t KEYCODE_BUTTON_PINKIE;
+    static const int32_t KEYCODE_BUTTON_BASE1;
+    static const int32_t KEYCODE_BUTTON_BASE2;
+    static const int32_t KEYCODE_BUTTON_BASE3;
+    static const int32_t KEYCODE_BUTTON_BASE4;
+    static const int32_t KEYCODE_BUTTON_BASE5;
+    static const int32_t KEYCODE_BUTTON_BASE6;
+    static const int32_t KEYCODE_BUTTON_BASE7;
+    static const int32_t KEYCODE_BUTTON_BASE8;
+    static const int32_t KEYCODE_BUTTON_BASE9;
+    static const int32_t KEYCODE_BUTTON_DEAD;
+
+    static const int32_t KEYCODE_SLEEP;
+    static const int32_t KEYCODE_ZENKAKU_HANKAKU;
+    static const int32_t KEYCODE_102ND;
+    static const int32_t KEYCODE_RO;
+    static const int32_t KEYCODE_KATAKANA;
+    static const int32_t KEYCODE_HIRAGANA;
+    static const int32_t KEYCODE_HENKAN;
+    static const int32_t KEYCODE_KATAKANA_HIRAGANA;
+    static const int32_t KEYCODE_MUHENKAN;
+    static const int32_t KEYCODE_LINEFEED;
+    static const int32_t KEYCODE_MACRO;
+    static const int32_t KEYCODE_NUMPAD_PLUSMINUS;
+    static const int32_t KEYCODE_SCALE;
+    static const int32_t KEYCODE_HANGUEL;
+    static const int32_t KEYCODE_HANJA;
+    static const int32_t KEYCODE_YEN;
+    static const int32_t KEYCODE_STOP;
+    static const int32_t KEYCODE_AGAIN;
+    static const int32_t KEYCODE_PROPS;
+    static const int32_t KEYCODE_UNDO;
+    static const int32_t KEYCODE_COPY;
+    static const int32_t KEYCODE_OPEN;
+    static const int32_t KEYCODE_PASTE;
+    static const int32_t KEYCODE_FIND;
+    static const int32_t KEYCODE_CUT;
+    static const int32_t KEYCODE_HELP;
+    static const int32_t KEYCODE_CALC;
+    static const int32_t KEYCODE_FILE;
+    static const int32_t KEYCODE_BOOKMARKS;
+    static const int32_t KEYCODE_NEXT;
+    static const int32_t KEYCODE_PLAYPAUSE;
+    static const int32_t KEYCODE_PREVIOUS;
+    static const int32_t KEYCODE_STOPCD;
+    static const int32_t KEYCODE_CONFIG;
+    static const int32_t KEYCODE_REFRESH;
+    static const int32_t KEYCODE_EXIT;
+    static const int32_t KEYCODE_EDIT;
+    static const int32_t KEYCODE_SCROLLUP;
+    static const int32_t KEYCODE_SCROLLDOWN;
+    static const int32_t KEYCODE_NEW;
+    static const int32_t KEYCODE_REDO;
+    static const int32_t KEYCODE_CLOSE;
+    static const int32_t KEYCODE_PLAY;
+    static const int32_t KEYCODE_BASSBOOST;
+    static const int32_t KEYCODE_PRINT;
+    static const int32_t KEYCODE_CHAT;
+    static const int32_t KEYCODE_FINANCE;
+    static const int32_t KEYCODE_CANCEL;
+    static const int32_t KEYCODE_KBDILLUM_TOGGLE;
+    static const int32_t KEYCODE_KBDILLUM_DOWN;
+    static const int32_t KEYCODE_KBDILLUM_UP;
+    static const int32_t KEYCODE_SEND;
+    static const int32_t KEYCODE_REPLY;
+    static const int32_t KEYCODE_FORWARDMAIL;
+    static const int32_t KEYCODE_SAVE;
+    static const int32_t KEYCODE_DOCUMENTS;
+    static const int32_t KEYCODE_VIDEO_NEXT;
+    static const int32_t KEYCODE_VIDEO_PREV;
+    static const int32_t KEYCODE_BRIGHTNESS_CYCLE;
+    static const int32_t KEYCODE_BRIGHTNESS_ZERO;
+    static const int32_t KEYCODE_DISPLAY_OFF;
+    static const int32_t KEYCODE_BTN_MISC;
+    static const int32_t KEYCODE_GOTO;
+    static const int32_t KEYCODE_INFO;
+    static const int32_t KEYCODE_PROGRAM;
+    static const int32_t KEYCODE_PVR;
+    static const int32_t KEYCODE_SUBTITLE;
+    static const int32_t KEYCODE_FULL_SCREEN;
+    static const int32_t KEYCODE_KEYBOARD;
+    static const int32_t KEYCODE_ASPECT_RATIO;
+    static const int32_t KEYCODE_PC;
+    static const int32_t KEYCODE_TV;
+    static const int32_t KEYCODE_TV2;
+    static const int32_t KEYCODE_VCR;
+    static const int32_t KEYCODE_VCR2;
+    static const int32_t KEYCODE_SAT;
+    static const int32_t KEYCODE_CD;
+    static const int32_t KEYCODE_TAPE;
+    static const int32_t KEYCODE_TUNER;
+    static const int32_t KEYCODE_PLAYER;
+    static const int32_t KEYCODE_DVD;
+    static const int32_t KEYCODE_AUDIO;
+    static const int32_t KEYCODE_VIDEO;
+    static const int32_t KEYCODE_MEMO;
+    static const int32_t KEYCODE_CALENDAR;
+    static const int32_t KEYCODE_RED;
+    static const int32_t KEYCODE_GREEN;
+    static const int32_t KEYCODE_YELLOW;
+    static const int32_t KEYCODE_BLUE;
+    static const int32_t KEYCODE_CHANNELUP;
+    static const int32_t KEYCODE_CHANNELDOWN;
+    static const int32_t KEYCODE_LAST;
+    static const int32_t KEYCODE_RESTART;
+    static const int32_t KEYCODE_SLOW;
+    static const int32_t KEYCODE_SHUFFLE;
+    static const int32_t KEYCODE_VIDEOPHONE;
+    static const int32_t KEYCODE_GAMES;
+    static const int32_t KEYCODE_ZOOMIN;
+    static const int32_t KEYCODE_ZOOMOUT;
+    static const int32_t KEYCODE_ZOOMRESET;
+    static const int32_t KEYCODE_WORDPROCESSOR;
+    static const int32_t KEYCODE_EDITOR;
+    static const int32_t KEYCODE_SPREADSHEET;
+    static const int32_t KEYCODE_GRAPHICSEDITOR;
+    static const int32_t KEYCODE_PRESENTATION;
+    static const int32_t KEYCODE_DATABASE;
+    static const int32_t KEYCODE_NEWS;
+    static const int32_t KEYCODE_VOICEMAIL;
+    static const int32_t KEYCODE_ADDRESSBOOK;
+    static const int32_t KEYCODE_MESSENGER;
+    static const int32_t KEYCODE_BRIGHTNESS_TOGGLE;
+    static const int32_t KEYCODE_SPELLCHECK;
+    static const int32_t KEYCODE_COFFEE;
+    static const int32_t KEYCODE_MEDIA_REPEAT;
+    static const int32_t KEYCODE_IMAGES;
+    static const int32_t KEYCODE_BUTTONCONFIG;
+    static const int32_t KEYCODE_TASKMANAGER;
+    static const int32_t KEYCODE_JOURNAL;
+    static const int32_t KEYCODE_CONTROLPANEL;
+    static const int32_t KEYCODE_APPSELECT;
+    static const int32_t KEYCODE_SCREENSAVER;
+    static const int32_t KEYCODE_ASSISTANT;
+    static const int32_t KEYCODE_KBD_LAYOUT_NEXT;
+    static const int32_t KEYCODE_BRIGHTNESS_MIN;
+    static const int32_t KEYCODE_BRIGHTNESS_MAX;
+    static const int32_t KEYCODE_KBDINPUTASSIST_PREV;
+    static const int32_t KEYCODE_KBDINPUTASSIST_NEXT;
+    static const int32_t KEYCODE_KBDINPUTASSIST_PREVGROUP;
+    static const int32_t KEYCODE_KBDINPUTASSIST_NEXTGROUP;
+    static const int32_t KEYCODE_KBDINPUTASSIST_ACCEPT;
+    static const int32_t KEYCODE_KBDINPUTASSIST_CANCEL;
+
+    static const int32_t KEYCODE_FRONT;
+    static const int32_t KEYCODE_SETUP;
+    static const int32_t KEYCODE_WAKEUP;
+    static const int32_t KEYCODE_SENDFILE;
+    static const int32_t KEYCODE_DELETEFILE;
+    static const int32_t KEYCODE_XFER;
+    static const int32_t KEYCODE_PROG1;
+    static const int32_t KEYCODE_PROG2;
+    static const int32_t KEYCODE_MSDOS;
+    static const int32_t KEYCODE_SCREENLOCK;
+    static const int32_t KEYCODE_DIRECTION_ROTATE_DISPLAY;
+    static const int32_t KEYCODE_CYCLEWINDOWS;
+    static const int32_t KEYCODE_COMPUTER;
+    static const int32_t KEYCODE_EJECTCLOSECD;
+    static const int32_t KEYCODE_ISO;
+    static const int32_t KEYCODE_MOVE;
+    static const int32_t KEYCODE_F13;
+    static const int32_t KEYCODE_F14;
+    static const int32_t KEYCODE_F15;
+    static const int32_t KEYCODE_F16;
+    static const int32_t KEYCODE_F17;
+    static const int32_t KEYCODE_F18;
+    static const int32_t KEYCODE_F19;
+    static const int32_t KEYCODE_F20;
+    static const int32_t KEYCODE_F21;
+    static const int32_t KEYCODE_F22;
+    static const int32_t KEYCODE_F23;
+    static const int32_t KEYCODE_F24;
+    static const int32_t KEYCODE_PROG3;
+    static const int32_t KEYCODE_PROG4;
+    static const int32_t KEYCODE_DASHBOARD;
+    static const int32_t KEYCODE_SUSPEND;
+    static const int32_t KEYCODE_HP;
+    static const int32_t KEYCODE_SOUND;
+    static const int32_t KEYCODE_QUESTION;
+    static const int32_t KEYCODE_CONNECT;
+    static const int32_t KEYCODE_SPORT;
+    static const int32_t KEYCODE_SHOP;
+    static const int32_t KEYCODE_ALTERASE;
+    static const int32_t KEYCODE_SWITCHVIDEOMODE;
+    static const int32_t KEYCODE_BATTERY;
+    static const int32_t KEYCODE_BLUETOOTH;
+    static const int32_t KEYCODE_WLAN;
+    static const int32_t KEYCODE_UWB;
+    static const int32_t KEYCODE_WWAN_WIMAX;
+    static const int32_t KEYCODE_RFKILL;
+
+    static const int32_t KEYCODE_CHANNEL;
+    static const int32_t KEYCODE_BTN_0;
+    static const int32_t KEYCODE_BTN_1;
+    static const int32_t KEYCODE_BTN_2;
+    static const int32_t KEYCODE_BTN_3;
+    static const int32_t KEYCODE_BTN_4;
+    static const int32_t KEYCODE_BTN_5;
+    static const int32_t KEYCODE_BTN_6;
+    static const int32_t KEYCODE_BTN_7;
+    static const int32_t KEYCODE_BTN_8;
+    static const int32_t KEYCODE_BTN_9;
+
+    static const int32_t KEYCODE_BRL_DOT1;
+    static const int32_t KEYCODE_BRL_DOT2;
+    static const int32_t KEYCODE_BRL_DOT3;
+    static const int32_t KEYCODE_BRL_DOT4;
+    static const int32_t KEYCODE_BRL_DOT5;
+    static const int32_t KEYCODE_BRL_DOT6;
+    static const int32_t KEYCODE_BRL_DOT7;
+    static const int32_t KEYCODE_BRL_DOT8;
+    static const int32_t KEYCODE_BRL_DOT9;
+    static const int32_t KEYCODE_BRL_DOT10;
+
+    /* *
+     * Left Knob roll-up
+     * <p>In contrast to {@link #static const int32_t KEYCODE_LEFT_KNOB_ROLL_DOWN}; it means rolling
+     * the left knob upwards. The knob functionis scenario-specific; for example;
+     * increasing the volume or air conditioner temperature.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_LEFT_KNOB_ROLL_UP;
+    /* *
+     * Left Knob roll-down
+     * <p>In contrast to {@link #static const int32_t KEYCODE_LEFT_KNOB_ROLL_UP};
+     * it means rolling the left knob downwards. The knob function is
+     * scenario-specific; for example; reducing the volume or air
+     * conditioner temperature.
+     * @since 1
+     */
+    static const int32_t KEYCODE_LEFT_KNOB_ROLL_DOWN;
+
+    /* *
+     * Left Knob
+     * <p>Pressing the knob will activate its adjustment function.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_LEFT_KNOB;
+    /* *
+     * Right Knob roll-up
+     * <p>In contrast to {@link #static const int32_t KEYCODE_RIGHT_KNOB_ROLL_DOWN}; it means rolling
+     * the right knob upwards. The knobfunction is scenario-specific; for example;
+     * increasing the volume or air conditioner temperature.
+     *
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_RIGHT_KNOB_ROLL_UP;
+    /* *
+     * Right Knob roll-down
+     * <p>In contrast to {@link #static const int32_t KEYCODE_RIGHT_KNOB_ROLL_UP}; it means rolling
+     * the right knob downwards. The knobfunction is scenario-specific;
+     * for example; reducing the volume or air conditioner temperature.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_RIGHT_KNOB_ROLL_DOWN;
+    /* *
+     * Right Knob
+     * <p>Pressing the knob will activate its adjustment function.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_RIGHT_KNOB;
+    /* *
+     * Audio Source Switch button
+     * <p>Pressing this button will enable the audio source. Depending on the
+     * actual scenario; it may also indicate that the Bluetooth call control
+     * button is pressed.
+     * @since 1
+     */
+    static const int32_t KEYCODE_VOICE_SOURCE_SWITCH;
+    /* *
+     * Menu key
+     * <p>Pressing this key will display the launcher page.
+     *
+     * @since 1
+     */
+    static const int32_t KEYCODE_LAUNCHER_MENU;
+
+    // Unknown key action. Usually used to indicate the initial invalid value
+    static const int32_t KEY_ACTION_UNKNOWN;
+    // Indicates cancel action.
+    // When the button is pressed, and the lifting action cannot be reported normally, report the key event of this
+    // action
+    static const int32_t KEY_ACTION_CANCEL;
+
+    // Indicates key press action
+    static const int32_t KEY_ACTION_DOWN;
+    // Indicates key release action
+    static const int32_t KEY_ACTION_UP;
+
+public:
+    class KeyItem {
+    public:
+        KeyItem();
+        virtual ~KeyItem();
+
+        // Get or set the key code.
+        // The key code is the number that identifies the key
+        int32_t GetKeyCode() const;
+        void SetKeyCode(int32_t keyCode);
+
+        // Get or set the key press time
+        int64_t GetDownTime() const;
+        void SetDownTime(int64_t downTime);
+
+        // Get or set the unique identifier of the device reporting this button. i
+        // The default value is 0, which means that the non-real device reports.
+        int32_t GetDeviceId() const;
+        void SetDeviceId(int32_t deviceId);
+
+        // Gets or sets whether the key is currently pressed.
+        // The default value is true, which means it is in a pressed state.
+        bool IsPressed() const;
+        void SetPressed(bool pressed);
+    public:
+        bool WriteToParcel(Parcel &out) const;
+        bool ReadFromParcel(Parcel &in);
+
+    private:
+        bool pressed_ = false;
+        int32_t deviceId_ = DEFALUTID;
+        int32_t keyCode_ = -1;
+        int64_t downTime_ = 0;
+    };
+
+public:
+    // Try to convert the InputEvent object into a KeyEvent object.
+    // Returning an empty smart pointer object indicates that the conversion failed
+    static std::shared_ptr<KeyEvent> from(std::shared_ptr<InputEvent> inputEvent);
+
+    static const char* ActionToString(int32_t action);
+    static const char* KeyCodeToString(int32_t keyCode);
+    static std::shared_ptr<KeyEvent> Clone(std::shared_ptr<KeyEvent> keyEvent);
+
+public:
+    KeyEvent(const KeyEvent& other);
+    KeyEvent& operator=(const KeyEvent& other) = delete;
+    DISALLOW_MOVE(KeyEvent);
+    virtual ~KeyEvent();
+
+    static std::shared_ptr<KeyEvent> Create();
+    // Get or change the key code of the device.
+    // Only one key will change in an event report
+    int32_t GetKeyCode() const;
+    void SetKeyCode(int32_t keyCode);
+
+    // Get or set the key action. The default value is the state of the current key code.
+    int32_t GetKeyAction() const;
+    void SetKeyAction(int32_t keyAction);
+
+    // Get the list of keys currently in the pressed state
+    std::vector<int32_t> GetPressedKeys() const;
+    void AddKeyItem(const KeyItem& keyItem);
+    std::vector<KeyEvent::KeyItem> GetKeyItems();
+    void AddPressedKeyItems(const KeyItem& keyItem);
+    void RemoveReleasedKeyItems(const KeyItem& keyItem);
+
+    const KeyItem* GetKeyItem() const;
+    const KeyItem* GetKeyItem(int32_t keyCode) const;
+    bool IsValid() const;
+public:
+    bool WriteToParcel(Parcel &out) const;
+    bool ReadFromParcel(Parcel &in);
+
+protected:
+    explicit KeyEvent(int32_t eventType);
+
+private:
+    bool IsValidKeyItem() const;
+
+private:
+    int32_t keyCode_ = -1;
+    std::vector<KeyItem> keys_;
+    int32_t keyAction_ = 0;
+};
+} // namespace MMI
+} // namespace OHOS
+#endif // KEY_EVENT_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/key_option.h b/ohos_ndk_aosp/includes/multimodalinput/key_option.h
new file mode 100755
index 0000000000..6363ef9794
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/key_option.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef KEY_OPTION_H
+#define KEY_OPTION_H
+
+#include <set>
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace MMI {
+class KeyOption {
+public:
+    KeyOption() = default;
+    DISALLOW_COPY_AND_MOVE(KeyOption);
+
+public:
+    std::set<int32_t> GetPreKeys() const;
+    void SetPreKeys(const std::set<int32_t>& preKeys);
+    int32_t GetFinalKey() const;
+    void SetFinalKey(int32_t finalKey);
+
+    bool IsFinalKeyDown() const;
+    void SetFinalKeyDown(bool pressed);
+
+    int32_t GetFinalKeyDownDuration() const;
+    void SetFinalKeyDownDuration(int32_t duration);
+
+private:
+    std::set<int32_t> preKeys_ {};
+    int32_t finalKey_ { -1 };
+    bool isFinalKeyDown_ { false };
+    int32_t finalKeyDownDuration_ { 0 };
+};
+} // namespace MMI
+} // namespace OHOS
+
+#endif // KEY_OPTION_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/pointer_event.h b/ohos_ndk_aosp/includes/multimodalinput/pointer_event.h
new file mode 100755
index 0000000000..b6e0235205
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/pointer_event.h
@@ -0,0 +1,676 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef POINTER_EVENT_H
+#define POINTER_EVENT_H
+
+#include <array>
+#include <list>
+#include <vector>
+#include <memory>
+#include <map>
+#include <set>
+#include "parcel.h"
+#include "input_event.h"
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace MMI {
+class PointerEvent : public InputEvent {
+public:
+    /**
+     * Indicates an unknown pointer action. It is usually used as initial value.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_UNKNOWN = 0;
+
+    /**
+     * Indicates a pointer action that has been canceled.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_CANCEL = 1;
+
+    /**
+     * Indicates a pointer action representing that a funger is pressed on a touchscreen or touchpad.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_DOWN = 2;
+
+    /**
+     * Indicates a pointer action representing that a funger moves on a touchscreen or touchpad or a mouse pointer moves.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_MOVE = 3;
+
+    /**
+     * Indicates a pointer action representing that a funger leaves  the touchscreen or touchpad.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_UP = 4;
+
+    /**
+     * Indicates the start action of the axis event related to the pointer.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_AXIS_BEGIN = 5;
+
+    /**
+     * Indicates the update action of the axis event related to the pointer.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_AXIS_UPDATE = 6;
+
+    /**
+     * Indicates the end action of the axis event related to the pointer.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_AXIS_END = 7;
+
+    /**
+     * Indicates a pointer action representing that a button is pressed.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_BUTTON_DOWN = 8;
+
+    /**
+     * Indicates a pointer action representing that a button is released.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t POINTER_ACTION_BUTTON_UP = 9;
+
+    enum AxisType {
+        /**
+         * Indicates an unknown axis type. It is generally used as the initial value.
+         * 
+         * @since 8
+         */
+        AXIS_TYPE_UNKNOWN,
+
+        /**
+         * Indicates the vertical scroll axis. When you scrall the mouse wheel or make certain gestures on the touchpad, the status of the vertical scroll axis changes.
+         * 
+         * @since 8
+         */
+        AXIS_TYPE_SCROLL_VERTICAL,
+
+        /**
+         * Indicates the horizontal scroll axis. When you scrall the mouse wheel or make certain gestures on the touchpad, the status of the horizontal scroll axis changes.
+         * 
+         * @since 8
+         */
+        AXIS_TYPE_SCROLL_HORIZONTAL,
+
+        /**
+         * Indicates the pinch axis, which is used to describe a pinch gesture on the touchscreen or touchpad.
+         * 
+         * @since 8
+         */
+        AXIS_TYPE_PINCH,
+
+        /**
+         * Indicates the maximum number of defined axis types.
+         * 
+         * @since 8
+         */
+        AXIS_TYPE_MAX
+    };
+
+    /**
+     * Indicates an unknown input source type. It is usually used as the initial value.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t SOURCE_TYPE_UNKNOWN = 0;
+
+    /**
+     * Indicates that the input source generates events similar to mouse cursor movement, button press and release, and wheel scrolling.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t SOURCE_TYPE_MOUSE = 1;
+
+    /**
+     * Indicates that the input source generates a touchscreen multi-touch event.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t SOURCE_TYPE_TOUCHSCREEN = 2;
+
+    /**
+     * Indicates that the input source generates a touchpad multi-touch event.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t SOURCE_TYPE_TOUCHPAD = 3;
+
+    /**
+     * Indicates an invalid button ID.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t BUTTON_NONE = -1;
+
+    /**
+     * Indicates the left button on a mouse.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t MOUSE_BUTTON_LEFT = 0;
+
+    /**
+     * Indicates the right button on a mouse.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t MOUSE_BUTTON_RIGHT = 1;
+
+    /**
+     * Indicates the middle button on a mouse.
+     * 
+     * @since 8
+     */
+    static constexpr int32_t MOUSE_BUTTON_MIDDLE = 2;
+
+public:
+    static std::shared_ptr<PointerEvent> from(std::shared_ptr<InputEvent> inputEvent);
+
+public:
+    class PointerItem {
+    public:
+        PointerItem();
+        ~PointerItem();
+
+    public:
+        /**
+         * @brief Obtains the ID of the pointer in this event.
+         * @return Returns the pointer ID.
+         * @since 8
+         */
+        int32_t GetPointerId() const;
+
+        /**
+         * @brief Sets the ID of the pointer in this event.
+         * @param pointerId Indicates the pointer ID to set.
+         * @return void
+         * @since 8
+         */
+        void SetPointerId(int32_t pointerId);
+
+        /**
+         * @brief Obtains the time when the pointer is pressed.
+         * @return Returns the time.
+         * @since 8
+         */
+        int64_t GetDownTime() const;
+
+        /**
+         * @brief Sets the time when the pointer is pressed.
+         * @param downTime Indicates the time to set.
+         * @return void
+         * @since 8
+         */
+        void SetDownTime(int64_t downTime);
+
+        /**
+         * @brief Checks whether the pointer is pressed.
+         * @return Returns <b>true</b> if the pointer is pressed; returns <b>false</b> otherwise.
+         * @since 8
+         */
+        bool IsPressed() const;
+
+        /**
+         * @brief Sets whether to enable the pressed state for the pointer.
+         * @param pressed Specifies whether to set the pressed state for the pointer. The value <b>true</b> means to set the pressed state for the pointer, and the <b>false</b> means the opposite.
+         * @return void
+         * @since 8
+         */
+        void SetPressed(bool pressed);
+
+        /**
+         * @brief Obtains the x coordinate relative to the upper left corner of the screen.
+         * For a touchpad input event, the value is the absolute x coordinate on the touchpad. For other pointer input events, the value is the x coordinate on the target screen.
+         * @return Returns the x coordinate.
+         * @since 8
+         */
+        int32_t GetGlobalX() const;
+
+        /**
+         * @brief Sets the x coordinate relative to the upper left corner of the screen.
+         * @param globalX Indicates the x coordinate to set.
+         * @return void
+         * @since 8
+         */
+        void SetGlobalX(int32_t globalX);
+
+        /**
+         * @brief Obtains the y coordinate relative to the upper left corner of the screen.
+         * For a touchpad input event, the value is the absolute y coordinate on the touchpad. For other pointer input events, the value is the y coordinate on the target screen.
+         * @return Returns the y coordinate.
+         * @since 8
+         */
+        int32_t GetGlobalY() const;
+
+        /**
+         * @brief Sets the y coordinate relative to the upper left corner of the screen.
+         * @param globalY Indicates the y coordinate to set.
+         * @return void
+         * @since 8
+         */
+        void SetGlobalY(int32_t globalY);
+
+        /**
+         * @brief Obtains the x coordinate of the active window.
+         * @return Returns the x coordinate.
+         * @since 8
+         */
+        int32_t GetLocalX() const;
+
+        /**
+         * @brief Sets the x coordinate of the active window.
+         * @param x Indicates the x coordinate to set.
+         * @return void
+         * @since 8
+         */
+        void SetLocalX(int32_t x);
+
+        /**
+         * @brief Obtains the y coordinate of the active window.
+         * @return Returns the y coordinate.
+         * @since 8
+         */
+        int32_t GetLocalY() const;
+
+        /**
+         * @brief Sets the y coordinate of the active window.
+         * @param y Indicates the y coordinate to set.
+         * @return void
+         * @since 8
+         */
+        void SetLocalY(int32_t y);
+
+        /**
+         * @brief Obtains the width of the pressed area.
+         * @return Returns the width.
+         * @since 8
+         */
+        int32_t GetWidth() const;
+
+        /**
+         * @brief Sets the width of the pressed area.
+         * @param width Indicates the width to set.
+         * @return void
+         * @since 8
+         */
+        void SetWidth(int32_t width);
+
+        /**
+         * @brief Obtains the height of the pressed area.
+         * @return Returns the height.
+         * @since 8
+         */
+        int32_t GetHeight() const;
+
+        /**
+         * @brief Sets the height of the pressed area.
+         * @param height Indicates the height to set.
+         * @return void
+         * @since 8
+         */
+        void SetHeight(int32_t height);
+
+        /**
+         * @brief Obtains the pressure in this event.
+         * @return Returns the pressure.
+         * @since 8
+         */
+        int32_t GetPressure() const;
+
+        /**
+         * @brief Sets the pressure for this event.
+         * @param pressure Indicates the pressure to set.
+         * @return void
+         * @since 8
+         */
+        void SetPressure(int32_t pressure);
+
+        /**
+         * @brief Obtains the ID of the current device.
+         * @return Returns the device ID.
+         * @since 8
+         */
+        int32_t GetDeviceId() const;
+
+        /**
+         * @brief Sets the ID for the current device.
+         * @param deviceId Indicates the device ID to set.
+         * @return void
+         * @since 8
+         */
+        void SetDeviceId(int32_t deviceId);
+    public:
+        /**
+         * @brief Writes data to a <b>Parcel</b> obejct.
+         * @param out Indicates the object into which data will be written.
+         * @return Returns <b>true</b> if the data is successfully written; returns <b>false</b> otherwise.
+         * @since 8
+         */
+        bool WriteToParcel(Parcel &out) const;
+
+        /**
+         * @brief Reads data from a <b>Parcel</b> obejct.
+         * @param in Indicates the object from which data will be read.
+         * @return Returns <b>true</b> if the data is successfully read; returns <b>false</b> otherwise.
+         * @since 8
+         */
+        bool ReadFromParcel(Parcel &in);
+
+    private:
+        int32_t pointerId_ { 0 };
+        bool pressed_ { false };
+        int32_t globalX_ { 0 };
+        int32_t globalY_ { 0 };
+        int32_t localX_ { 0 };
+        int32_t localY_ { 0 };
+        int32_t width_ { 0 };
+        int32_t height_ { 0 };
+        int32_t pressure_ { 0 };
+        int32_t deviceId_ { 0 };
+        int64_t downTime_ { 0 };
+    };
+
+public:
+    PointerEvent(const PointerEvent& other);
+    virtual ~PointerEvent();
+    PointerEvent& operator=(const PointerEvent& other) = delete;
+    DISALLOW_MOVE(PointerEvent);
+
+    static std::shared_ptr<PointerEvent> Create();
+
+    /**
+     * @brief Obtains the pointer action in this event.
+     * @return Returns the pointer action.
+     * @since 8
+     */
+    int32_t GetPointerAction() const;
+
+    /**
+     * @brief Sets a pointer action for this event.
+     * @param pointerAction Indicates the pointer action to set.
+     * @return void
+     * @since 8
+     */
+    void SetPointerAction(int32_t pointerAction);
+
+    /**
+     * @brief Dumps the action of this pointer input event as a string.
+     * @return Returns the pointer to the string.
+     * @since 8
+     */
+    const char* DumpPointerAction() const;
+
+    /**
+     * @brief Obtains the pointer ID in this event.
+     * @return Returns the pointer ID.
+     * @since 8
+     */
+    int32_t GetPointerId() const;
+
+    /**
+     * @brief Sets an ID for the pointer in this event.
+     * @param pointerId Indicates the pointer ID to set.
+     * @return void
+     * @since 8
+     */
+    void SetPointerId(int32_t pointerId);
+
+    /**
+     * @brief Obtains the pointer item of a specified pointer ID.
+     * @param pointerId Indicates the pointer ID.
+     * @param pointerItem Indicates the item used to receive the data of the pointer.
+     * @return Returns <b>true</b> if the data of the pointer with the specified ID exists; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    bool GetPointerItem(int32_t pointerId, PointerItem &pointerItem);
+
+    /**
+     * @brief Adds a pointer item.
+     * @param pointerItem Indicates the pointer item to add.
+     * @return void
+     * @since 8
+     */
+    void AddPointerItem(PointerItem &pointerItem);
+
+    /**
+     * @brief Removes a pointer item based on the pointer ID.
+     * @param pointerId Indicates the ID of the pointer from which the pointer item is to be removed.
+     * @return void
+     * @since 8
+     */
+    void RemovePointerItem(int32_t pointerId);
+
+    /**
+     * @brief Updates a pointer item based on the pointer ID.
+     * @param pointerId Indicates the ID of the pointer from which the pointer item is to be updated.
+     * @param pointerItem Indicates the pointer item to update.
+     * @return void
+     * @since 8
+     */
+    void UpdatePointerItem(int32_t pointerId, PointerItem &pointerItem);
+
+    /**
+     * @brief Obtains the set of pressed buttons.
+     * @return Returns the pressed buttons.
+     * @since 8
+     */
+    std::set<int32_t> GetPressedButtons() const;
+
+    /**
+     * @brief Checks whether a specified button is being pressed.
+     * @param buttonId Indicates the button ID.
+     * @return Returns <b>true</b> if the button is being pressed; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    bool IsButtonPressed(int32_t buttonId) const;
+
+    /**
+     * @brief Sets the pressed state for a button.
+     * @param buttonId Indicates the button ID of the button to be set in the pressed state.
+     * @return void
+     * @since 8
+     */
+    void SetButtonPressed(int32_t buttonId);
+
+    /**
+     * @brief Deletes a released button.
+     * @param buttonId Indicates the button ID of the button.
+     * @return void
+     * @since 8
+     */
+    void DeleteReleaseButton(int32_t buttonId);
+
+    /**
+     * @brief Clears the button in the pressed state.
+     * @return void
+     * @since 8
+     */
+    void ClearButtonPressed();
+
+    /**
+     * @brief Obtains all pointers in this event.
+     * @return Returns all the pointer IDs.
+     * @since 8
+     */
+    std::vector<int32_t> GetPointersIdList() const;
+
+    /**
+     * @brief Obtains the source type of this event.
+     * @return Returns the source type.
+     * @since 8
+     */
+    int32_t GetSourceType() const;
+
+    /**
+     * @brief Sets the source type for this event.
+     * @param sourceType Indicates the source type to set.
+     * @return void
+     * @since 8
+     */
+    void SetSourceType(int32_t sourceType);
+
+    /**
+     * @brief Dumps the source type of this pointer input event as a string.
+     * @return Returns the pointer to the string.
+     * @since 8
+     */
+    const char* DumpSourceType() const;
+
+    /**
+     * @brief Obtains the button ID in this event.
+     * @return Returns the button ID.
+     * @since 8
+     */
+    int32_t GetButtonId() const;
+
+    /**
+     * @brief Sets the button ID for this event.
+     * @param buttonId Indicates the button ID to set.
+     * @return void
+     * @since 8
+     */
+    void SetButtonId(int32_t buttonId);
+
+    /**
+     * @brief Obtains the axis value.
+     * @param axis Indicates the axis type.
+     * @return Returns the axis value.
+     * @since 8
+     */
+    double GetAxisValue(AxisType axis) const;
+
+    /**
+     * @brief Sets the axis value.
+     * @param axis Indicates the axis type.
+     * @param axisValue Indicates the axis value to set.
+     * @return void
+     * @since 8
+     */
+    void SetAxisValue(AxisType axis, double axisValue);
+
+    /**
+     * @brief Checks whether this event contains a specified axis type.
+     * @param axis Indicates the axis type.
+     * @return Returns <b>true</b> if the event contains the specified axis type; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    bool HasAxis(AxisType axis) const;
+
+    /**
+     * @brief Obtains all axis of this event.
+     * @return Returns all the axis, Each bit indicates an axis.
+     * @since 8
+     */
+    int32_t GetAxes() const;
+
+    /**
+     * @brief Set the front keys in the key combination.
+     * @param pressedKeys Indicates the front keys to set.
+     * @return void.
+     * @since 8
+     */
+    void SetPressedKeys(const std::vector<int32_t> pressedKeys);
+
+    /**
+     * @brief Obtains the set of pressed keys.
+     * @return Returns the pressed keys.
+     * @since 8
+     */
+    std::vector<int32_t> GetPressedKeys() const;
+
+    /**
+     * @brief Checks whether this input event is valid.
+     * @return Returns <b>true</b> if the input event is valid; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    bool IsValid() const;
+public:
+    /**
+     * @brief Checks whether the axes set represented by <b>axes</b> contains a specified type of axis.
+     * @param axes Indicates the set of axes. Each bit indicates an axis.
+     * @param axis Indicates the type of the axis to check.
+     * @return Returns <b>true</b> if the axes set contains the specified axis type; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    static bool HasAxis(int32_t axes, AxisType axis);
+
+public:
+    /**
+     * @brief Writes data to a <b>Parcel</b> obejct.
+     * @param out Indicates the object into which data will be written.
+     * @return Returns <b>true</b> if the data is successfully written; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    bool WriteToParcel(Parcel &out) const;
+
+    /**
+     * @brief Reads data from a <b>Parcel</b> obejct.
+     * @param in Indicates the object from which data will be read.
+     * @return Returns <b>true</b> if the data is successfully read; returns <b>false</b> otherwise.
+     * @since 8
+     */
+    bool ReadFromParcel(Parcel &in);
+
+protected:
+    explicit PointerEvent(int32_t eventType);
+
+private:
+    bool IsValidCheckMouseFunc() const;
+    bool IsValidCheckMouse() const;
+    bool IsValidCheckTouchFunc() const;
+    bool IsValidCheckTouch() const;
+
+private:
+    int32_t pointerId_ { 0 };
+    std::list<PointerItem> pointers_;
+    std::set<int32_t> pressedButtons_;
+    int32_t sourceType_ { 0 };
+    int32_t pointerAction_ { 0 };
+    int32_t buttonId_ { -1 };
+    uint32_t axes_ { 0 };
+    std::array<double, AXIS_TYPE_MAX>   axisValues_ { };
+    std::vector<int32_t> pressedKeys_;
+};
+
+inline bool PointerEvent::HasAxis(AxisType axis) const
+{
+    return HasAxis(axes_, axis);
+}
+
+inline int32_t PointerEvent::GetAxes() const
+{
+    return axes_;
+}
+} // namespace MMI
+} // namespace OHOS
+#endif // POINTER_EVENT_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/multimodalinput/standardized_event_manager.h b/ohos_ndk_aosp/includes/multimodalinput/standardized_event_manager.h
new file mode 100755
index 0000000000..8667dcecbc
--- /dev/null
+++ b/ohos_ndk_aosp/includes/multimodalinput/standardized_event_manager.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef STANDARDIZED_EVENT_MANAGER_H
+#define STANDARDIZED_EVENT_MANAGER_H
+
+#include <set>
+#include "if_mmi_client.h"
+#include "iremote_object.h"
+#include "key_event_input_subscribe_manager.h"
+#include "nocopyable.h"
+#include "pointer_event.h"
+#include "singleton.h"
+
+namespace OHOS {
+namespace MMI {
+class NetPacket;
+class StandardizedEventManager {
+public:
+    StandardizedEventManager();
+    ~StandardizedEventManager();
+    DISALLOW_COPY_AND_MOVE(StandardizedEventManager);
+
+    void SetClientHandle(MMIClientPtr client);
+    const std::set<std::string> *GetRegisterEvent();
+    int32_t InjectionVirtual(bool isPressed, int32_t keyCode, int64_t keyDownDuration, int32_t maxKeyCode);
+    int32_t InjectEvent(const std::shared_ptr<OHOS::MMI::KeyEvent> keyEventPtr);
+    int32_t InjectPointerEvent(std::shared_ptr<PointerEvent> pointerEvent);
+    int32_t GetDevice(int32_t userData, int32_t deviceId);
+    int32_t GetDeviceIds(int32_t userData);
+    int32_t SubscribeKeyEvent(const KeyEventInputSubscribeManager::SubscribeKeyEventInfo& subscribeInfo);
+    int32_t UnSubscribeKeyEvent(int32_t subscribeId);
+protected:
+    bool SendMsg(NetPacket& pkt) const;
+
+protected:
+    MMIClientPtr client_ = nullptr;
+};
+} // namespace MMI
+} // namespace OHOS
+#define EventManager OHOS::Singleton<OHOS::MMI::StandardizedEventManager>::GetInstance()
+#endif // STANDARDIZED_EVENT_MANAGER_H
diff --git a/ohos_ndk_aosp/includes/peripheral/BUILD.gn b/ohos_ndk_aosp/includes/peripheral/BUILD.gn
new file mode 100644
index 0000000000..fc840b4a75
--- /dev/null
+++ b/ohos_ndk_aosp/includes/peripheral/BUILD.gn
@@ -0,0 +1,22 @@
+# Copyright (c) 2021 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/ohos.gni")
+
+ohos_prebuilt_etc("hdf_peripheral.rc") {
+  source = "hdf_peripheral.cfg"
+  relative_install_dir = "init"
+  install_images = [ chipset_base_dir ]
+  subsystem_name = "hdf"
+  part_name = "device_driver_framework"
+}
diff --git a/ohos_ndk_aosp/includes/peripheral/buffer_handle.h b/ohos_ndk_aosp/includes/peripheral/buffer_handle.h
new file mode 100644
index 0000000000..6b352819a5
--- /dev/null
+++ b/ohos_ndk_aosp/includes/peripheral/buffer_handle.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INCLUDE_BUFFER_HANDLE_H
+#define INCLUDE_BUFFER_HANDLE_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    int32_t fd;           /**< buffer fd, -1 if not supported */
+    int32_t width;        /**< the width of memory */
+    int32_t stride;       /**< the stride of memory */
+    int32_t height;       /**< the heigh of memory */
+    int32_t size;         /* < size of memory */
+    int32_t format;       /**< the format of memory */
+    uint64_t usage;        /**< the usage of memory */
+    void *virAddr;        /**< Virtual address of memory  */
+    uint64_t phyAddr;     /**< Physical address */
+    int32_t key;          /**< Shared memory key */
+    uint32_t reserveFds;  /**< the number of reserved fd value */
+    uint32_t reserveInts; /**< the number of reserved integer value */
+    int32_t reserve[0];   /**< the data */
+} BufferHandle;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // INCLUDE_BUFFER_HANDLE_H
diff --git a/ohos_ndk_aosp/includes/peripheral/hdf_peripheral.cfg b/ohos_ndk_aosp/includes/peripheral/hdf_peripheral.cfg
new file mode 100644
index 0000000000..9fb35c1878
--- /dev/null
+++ b/ohos_ndk_aosp/includes/peripheral/hdf_peripheral.cfg
@@ -0,0 +1,25 @@
+{
+    "jobs" : [{
+            "name" : "post-fs-data",
+            "cmds" : [
+                "chown system system /dev/dev_mgr",
+                "chown system system /dev/hdf_disp",
+                "chown system system /dev/hdf_input_host",
+                "chown system system /dev/hdf_input_event1",
+                "chown system system /dev/hdf_input_event2",
+                "chown system system /dev/hdf_input_event3",
+                "chown system system /dev/hdf_input_event4",
+                "chown system system /dev/hdf_input_event5",
+                "chown system system /dev/hdf_input_event6",
+                "chown system system /dev/hdf_sensor_manager_ap",
+                "chown system system /dev/hdf_misc_vibrator",
+                "chown system system /dev/hdf_audio_render",
+                "chown system system /dev/hdf_audio_capture",
+                "chown system system /dev/hdf_audio_control",
+                "chown system system /dev/hdf_audio_codec_dev0",
+                "chown system system /dev/hdf_audio_smartpa_dev0",
+                "chown system system /dev/hdf_dsoftbus"
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/peripheral/hdf_peripheral.rc b/ohos_ndk_aosp/includes/peripheral/hdf_peripheral.rc
new file mode 100644
index 0000000000..bf94724b17
--- /dev/null
+++ b/ohos_ndk_aosp/includes/peripheral/hdf_peripheral.rc
@@ -0,0 +1,30 @@
+# Copyright (c) 2021 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+on post-fs-data
+   chown system system /dev/hdf_disp
+   chown system system /dev/hdf_input_host
+   chown system system /dev/hdf_input_event1
+   chown system system /dev/hdf_input_event2
+   chown system system /dev/hdf_input_event3
+   chown system system /dev/hdf_input_event4
+   chown system system /dev/hdf_input_event5
+   chown system system /dev/hdf_input_event6
+   chown system system /dev/hdf_audio_render
+   chown system system /dev/hdf_audio_capture
+   chown system system /dev/hdf_audio_control
+   chown system system /dev/hdf_audio_codec_dev0
+   chown system system /dev/hdf_audio_smartpa_dev0
+   chown system system /dev/hdf_sensor_manager_ap
+   chown system system /dev/hdf_misc_vibrator
+   chown system system /dev/dev_mgr
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/surface/buffer_extra_data.h b/ohos_ndk_aosp/includes/surface/buffer_extra_data.h
new file mode 100644
index 0000000000..799df0cc65
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/buffer_extra_data.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_BUFFER_EXTRA_DATA_H
+#define INTERFACES_INNERKITS_SURFACE_BUFFER_EXTRA_DATA_H
+
+#include <string>
+
+#include "surface_type.h"
+
+namespace OHOS {
+class MessageParcel;
+class BufferExtraData {
+public:
+    virtual GSError ReadFromParcel(MessageParcel &parcel) = 0;
+    virtual GSError WriteToParcel(MessageParcel &parcel) = 0;
+    virtual GSError ExtraGet(std::string &key, int32_t &value) const = 0;
+    virtual GSError ExtraGet(std::string &key, int64_t &value) const = 0;
+    virtual GSError ExtraGet(std::string &key, double &value) const = 0;
+    virtual GSError ExtraGet(std::string &key, std::string &value) const = 0;
+    virtual GSError ExtraSet(std::string &key, int32_t value) = 0;
+    virtual GSError ExtraSet(std::string &key, int64_t value) = 0;
+    virtual GSError ExtraSet(std::string &key, double value) = 0;
+    virtual GSError ExtraSet(std::string &key, std::string value) = 0;
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_BUFFER_EXTRA_DATA_H
diff --git a/ohos_ndk_aosp/includes/surface/egl_data.h b/ohos_ndk_aosp/includes/surface/egl_data.h
new file mode 100644
index 0000000000..a5290e79f0
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/egl_data.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_EGL_DATA_H
+#define INTERFACES_INNERKITS_SURFACE_EGL_DATA_H
+
+#include <refbase.h>
+
+namespace OHOS {
+class EglData : public RefBase {
+public:
+    virtual ~EglData() = default;
+
+    virtual uint32_t GetFrameBufferObj() const = 0;
+    virtual uint32_t GetTexture() const = 0;
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_EGL_DATA_H
diff --git a/ohos_ndk_aosp/includes/surface/egl_surface.h b/ohos_ndk_aosp/includes/surface/egl_surface.h
new file mode 100644
index 0000000000..4bd8f9a18a
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/egl_surface.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_EGL_RENDER_SURFACE_H
+#define INTERFACES_INNERKITS_SURFACE_EGL_RENDER_SURFACE_H
+
+#include <refbase.h>
+
+#include <EGL/egl.h>
+#include <GLES2/gl2.h>
+#include "ibuffer_producer.h"
+#include "surface_type.h"
+
+namespace OHOS {
+class EglSurface : public RefBase {
+public:
+    static sptr<EglSurface> CreateEglSurfaceAsProducer(sptr<IBufferProducer>& producer);
+    virtual ~EglSurface() = default;
+
+    virtual GSError InitContext(EGLContext context = EGL_NO_CONTEXT) = 0;
+    virtual EGLDisplay GetEglDisplay() const = 0;
+    virtual EGLContext GetEglContext() const = 0;
+    virtual EGLSurface GetEglSurface() const = 0;
+    virtual GLuint GetEglFbo() const = 0;
+    virtual GSError SwapBuffers() = 0;
+    virtual GSError SetWidthAndHeight(int32_t width, int32_t height) = 0;
+
+protected:
+    EglSurface() = default;
+};
+typedef EglSurface EglRenderSurface;
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_EGL_RENDER_SURFACE_H
diff --git a/ohos_ndk_aosp/includes/surface/external_window.h b/ohos_ndk_aosp/includes/surface/external_window.h
new file mode 100644
index 0000000000..82839cd153
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/external_window.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NDK_INCLUDE_EXTERNAL_NATIVE_WINDOW_H_
+#define NDK_INCLUDE_EXTERNAL_NATIVE_WINDOW_H_
+
+/**
+ * @addtogroup NativeWindow
+ * @{
+ *
+ * @brief Provides NativeWindow functions
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @since 8
+ * @version 1.0
+ */
+
+/**
+ * @file external_window.h
+ *
+ * @brief API for accessing a native window
+ *
+ * @since 8
+ * @version 1.0
+ */
+
+#include "window.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Create a NativeWindow from producer surface, Each call will generates a new NativeWindow
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param pSurface Indicates producer surface
+ * @return NativeWindow
+ * @since 8
+ * @version 1.0
+ */
+struct NativeWindow* OH_NativeWindow_CreateNativeWindowFromSurface(void* pSurface);
+
+/**
+ * @brief Unreference NativeWindow object, When the reference count == 0, destroy the NativeWindow
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param window Indicates NativeWindow
+ * @since 8
+ * @version 1.0
+ */
+void OH_NativeWindow_DestroyNativeWindow(struct NativeWindow* window);
+
+/**
+ * @brief Create a NativeWindowBuffer from producer surface buffer
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param pSurfaceBuffer Indicates producer surface buffer
+ * @return NativeWindowBuffer
+ * @since 8
+ * @version 1.0
+ */
+struct NativeWindowBuffer* OH_NativeWindow_CreateNativeWindowBufferFromSurfaceBuffer(void* pSurfaceBuffer);
+
+/**
+ * @brief Unreference NativeWindowBuffer object, when the reference count == 0, destroy a NativeWindow buffer
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param buffer Indicates NativeWindow buffer
+ * @since 8
+ * @version 1.0
+ */
+void OH_NativeWindow_DestroyNativeWindowBuffer(struct NativeWindowBuffer* buffer);
+
+/**
+ * @brief Dequeue a buffer from NativeWindow
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param window Indicates NativeWindow
+ * @param buffer Indicates [out] get NativeWindowBuffer
+ * @param fenceFd Indicates [out] get release fence
+ * @return GSError
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_NativeWindowRequestBuffer(struct NativeWindow *window,
+    struct NativeWindowBuffer **buffer, int *fenceFd);
+
+/**
+ * @brief Queue a buffer to NativeWindow
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param window Indicates NativeWindow
+ * @param buffer Indicates NativeWindowBuffer
+ * @param fenceFd Indicates acquire fence
+ * @param region Indicates the Buffer dirty size
+ * @return GSError
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_NativeWindowFlushBuffer(struct NativeWindow *window, struct NativeWindowBuffer *buffer,
+    int fenceFd, Region region);
+
+/**
+ * @brief Cancel the NativeWindowBuffer to be queued
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param window Indicates NativeWindow
+ * @param buffer Indicates NativeWindowBuffer
+ * @return GSError
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_NativeWindowCancelBuffer(struct NativeWindow *window, struct NativeWindowBuffer *buffer);
+
+/**
+ * @brief Handle the NativeWindowOperation of the NativeWindow
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param window Indicates NativeWindow
+ * @param code Indicates NativeWindowOperation
+ * @return GSError
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_NativeWindowHandleOpt(struct NativeWindow *window, int code, ...);
+
+/**
+ * @brief Get the BufferHandle from the NativeWindowBuffer
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param buffer Indicates NativeWindowBuffer
+ * @return BufferHandle
+ * @since 8
+ * @version 1.0
+ */
+BufferHandle *OH_NativeWindow_GetBufferHandleFromNative(struct NativeWindowBuffer *buffer);
+
+/**
+ * @brief Increase the reference count of the NativeObject
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param obj Indicates NativeWindow or NativeWindowBuffer
+ * @return GSError
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_NativeObjectReference(void *obj);
+
+/**
+ * @brief decrease the reference count of the NativeObject
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param obj Indicates NativeWindow or NativeWindowBuffer
+ * @return GSError
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_NativeObjectUnreference(void *obj);
+
+/**
+ * @brief Get the MagicId of the NativeObject
+ *
+ * @syscap SystemCapability.Graphic.Graphic2D.NativeWindow
+ * @param obj Indicates NativeWindow or NativeWindowBuffer
+ * @return MagicId
+ * @since 8
+ * @version 1.0
+ */
+int32_t OH_NativeWindow_GetNativeObjectMagic(void *obj);
+
+#ifdef __cplusplus
+}
+#endif
+
+/** @} */
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/surface/ibuffer_consumer_listener.h b/ohos_ndk_aosp/includes/surface/ibuffer_consumer_listener.h
new file mode 100644
index 0000000000..18bb04f6b9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/ibuffer_consumer_listener.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_IBUFFER_CONSUMER_LISTENER_H
+#define INTERFACES_INNERKITS_SURFACE_IBUFFER_CONSUMER_LISTENER_H
+
+#include <refbase.h>
+#include "surface_type.h"
+
+namespace OHOS {
+class IBufferConsumerListener : public RefBase {
+public:
+    virtual ~IBufferConsumerListener() = default;
+    virtual void OnBufferAvailable() = 0;
+};
+
+class IBufferConsumerListenerClazz {
+public:
+    virtual ~IBufferConsumerListenerClazz() = default;
+    virtual void OnBufferAvailable() = 0;
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_IBUFFER_CONSUMER_LISTENER_H
diff --git a/ohos_ndk_aosp/includes/surface/ibuffer_producer.h b/ohos_ndk_aosp/includes/surface/ibuffer_producer.h
new file mode 100644
index 0000000000..72a0b40538
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/ibuffer_producer.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_IBUFFER_PRODUCER_H
+#define INTERFACES_INNERKITS_SURFACE_IBUFFER_PRODUCER_H
+
+#include <string>
+#include <vector>
+
+#include <iremote_broker.h>
+
+#include "buffer_extra_data.h"
+#include "surface_buffer.h"
+#include "surface_type.h"
+
+namespace OHOS {
+class IBufferProducer : public IRemoteBroker {
+public:
+    struct RequestBufferReturnValue {
+        int32_t sequence;
+        sptr<SurfaceBuffer> buffer;
+        int32_t fence;
+        std::vector<int32_t> deletingBuffers;
+    };
+    virtual GSError RequestBuffer(const BufferRequestConfig &config, BufferExtraData &bedata,
+                                       RequestBufferReturnValue &retval) = 0;
+
+    virtual GSError CancelBuffer(int32_t sequence, BufferExtraData &bedata) = 0;
+
+    virtual GSError FlushBuffer(int32_t sequence, BufferExtraData &bedata,
+                                     int32_t fence, BufferFlushConfig &config) = 0;
+
+    virtual GSError AttachBuffer(sptr<SurfaceBuffer>& buffer) = 0;
+    virtual GSError DetachBuffer(sptr<SurfaceBuffer>& buffer) = 0;
+
+    virtual uint32_t GetQueueSize() = 0;
+    virtual GSError SetQueueSize(uint32_t queueSize) = 0;
+
+    virtual GSError GetName(std::string &name) = 0;
+
+    virtual int32_t GetDefaultWidth() = 0;
+    virtual int32_t GetDefaultHeight() = 0;
+    virtual uint32_t GetDefaultUsage() = 0;
+
+    virtual uint64_t GetUniqueId() = 0;
+    virtual GSError CleanCache() = 0;
+
+    virtual GSError RegisterReleaseListener(OnReleaseFunc func) = 0;
+
+    DECLARE_INTERFACE_DESCRIPTOR(u"surf.IBufferProducer");
+
+protected:
+    enum {
+        BUFFER_PRODUCER_REQUEST_BUFFER = 0,
+        BUFFER_PRODUCER_CANCEL_BUFFER = 1,
+        BUFFER_PRODUCER_FLUSH_BUFFER = 2,
+        BUFFER_PRODUCER_GET_QUEUE_SIZE = 3,
+        BUFFER_PRODUCER_SET_QUEUE_SIZE = 4,
+        BUFFER_PRODUCER_GET_NAME = 5,
+        BUFFER_PRODUCER_GET_DEFAULT_WIDTH = 6,
+        BUFFER_PRODUCER_GET_DEFAULT_HEIGHT = 7,
+        BUFFER_PRODUCER_GET_DEFAULT_USAGE = 8,
+        BUFFER_PRODUCER_CLEAN_CACHE = 9,
+        BUFFER_PRODUCER_ATTACH_BUFFER = 10,
+        BUFFER_PRODUCER_DETACH_BUFFER = 11,
+        BUFFER_PRODUCER_REGISTER_RELEASE_LISTENER = 12,
+        BUFFER_PRODUCER_GET_UNIQUE_ID = 13,
+    };
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_IBUFFER_PRODUCER_H
diff --git a/ohos_ndk_aosp/includes/surface/surface.h b/ohos_ndk_aosp/includes/surface/surface.h
new file mode 100644
index 0000000000..e8858bf036
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/surface.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_SURFACE_H
+#define INTERFACES_INNERKITS_SURFACE_SURFACE_H
+
+#include <refbase.h>
+
+#include "ibuffer_consumer_listener.h"
+#include "ibuffer_producer.h"
+#include "surface_buffer.h"
+#include "surface_type.h"
+
+namespace OHOS {
+class Surface : public RefBase {
+public:
+    static sptr<Surface> CreateSurfaceAsConsumer(std::string name = "noname", bool isShared = false);
+    static sptr<Surface> CreateSurfaceAsProducer(sptr<IBufferProducer>& producer);
+    static sptr<Surface> CreateEglSurfaceAsConsumer(std::string name = "noname", bool isShared = false);
+
+    virtual ~Surface() = default;
+
+    virtual bool IsConsumer() const = 0;
+    virtual sptr<IBufferProducer> GetProducer() const = 0;
+
+    virtual GSError RequestBuffer(sptr<SurfaceBuffer>& buffer,
+                                       int32_t &fence, BufferRequestConfig &config) = 0;
+
+    virtual GSError CancelBuffer(sptr<SurfaceBuffer>& buffer) = 0;
+
+    virtual GSError FlushBuffer(sptr<SurfaceBuffer>& buffer,
+                                     int32_t fence, BufferFlushConfig &config) = 0;
+
+    virtual GSError AcquireBuffer(sptr<SurfaceBuffer>& buffer, int32_t &fence,
+                                       int64_t &timestamp, Rect &damage) = 0;
+    virtual GSError ReleaseBuffer(sptr<SurfaceBuffer>& buffer, int32_t fence) = 0;
+
+    virtual GSError AttachBuffer(sptr<SurfaceBuffer>& buffer) = 0;
+
+    virtual GSError DetachBuffer(sptr<SurfaceBuffer>& buffer) = 0;
+
+    virtual uint32_t GetQueueSize() = 0;
+    virtual GSError SetQueueSize(uint32_t queueSize) = 0;
+
+    virtual GSError SetDefaultWidthAndHeight(int32_t width, int32_t height) = 0;
+    virtual int32_t GetDefaultWidth() = 0;
+    virtual int32_t GetDefaultHeight() = 0;
+
+    virtual GSError SetDefaultUsage(uint32_t usage) = 0;
+    virtual uint32_t GetDefaultUsage() = 0;
+
+    virtual GSError SetUserData(const std::string &key, const std::string &val) = 0;
+    virtual std::string GetUserData(const std::string &key) = 0;
+
+    virtual GSError GetName(std::string &name) = 0;
+
+    virtual GSError RegisterConsumerListener(sptr<IBufferConsumerListener>& listener) = 0;
+    virtual GSError RegisterConsumerListener(IBufferConsumerListenerClazz *listener) = 0;
+    virtual GSError RegisterReleaseListener(OnReleaseFunc func) = 0;
+    virtual GSError UnregisterConsumerListener() = 0;
+
+    virtual uint64_t GetUniqueId() const = 0;
+
+    virtual void Dump(std::string &result) const = 0;
+
+    virtual GSError CleanCache() = 0;
+protected:
+    Surface() = default;
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_SURFACE_H
diff --git a/ohos_ndk_aosp/includes/surface/surface_buffer.h b/ohos_ndk_aosp/includes/surface/surface_buffer.h
new file mode 100644
index 0000000000..c29965a9c1
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/surface_buffer.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_SURFACE_BUFFER_H
+#define INTERFACES_INNERKITS_SURFACE_SURFACE_BUFFER_H
+
+#include <functional>
+
+#include <refbase.h>
+
+#include "buffer_handle_utils.h"
+#include "surface_type.h"
+#include "egl_data.h"
+
+namespace OHOS {
+class SurfaceBuffer : public RefBase {
+public:
+    virtual BufferHandle *GetBufferHandle() const = 0;
+    virtual int32_t GetWidth() const = 0;
+    virtual int32_t GetHeight() const = 0;
+    virtual int32_t GetStride() const = 0;
+    virtual int32_t GetSurfaceBufferWidth() const = 0;
+    virtual int32_t GetSurfaceBufferHeight() const = 0;
+    virtual SurfaceColorGamut GetSurfaceBufferColorGamut() const = 0;
+    virtual GSError SetSurfaceBufferWidth(int32_t width) = 0;
+    virtual GSError SetSurfaceBufferHeight(int32_t height) = 0;
+    virtual GSError SetSurfaceBufferColorGamut(SurfaceColorGamut colorGamut) = 0;
+    virtual int32_t GetFormat() const = 0;
+    virtual int64_t GetUsage() const = 0;
+    virtual uint64_t GetPhyAddr() const = 0;
+    virtual int32_t GetKey() const = 0;
+    virtual void *GetVirAddr() const = 0;
+    virtual int GetFileDescriptor() const = 0;
+    virtual uint32_t GetSize() const = 0;
+    virtual GSError SetInt32(uint32_t key, int32_t value) = 0;
+    virtual GSError GetInt32(uint32_t key, int32_t &value) = 0;
+    virtual GSError SetInt64(uint32_t key, int64_t value) = 0;
+    virtual GSError GetInt64(uint32_t key, int64_t &value) = 0;
+    virtual sptr<EglData> GetEglData() const = 0;
+
+    // support ipc data
+    virtual GSError ExtraGet(std::string key, int32_t &value) const = 0;
+    virtual GSError ExtraGet(std::string key, int64_t &value) const = 0;
+    virtual GSError ExtraGet(std::string key, double &value) const = 0;
+    virtual GSError ExtraGet(std::string key, std::string &value) const = 0;
+    virtual GSError ExtraSet(std::string key, int32_t value) = 0;
+    virtual GSError ExtraSet(std::string key, int64_t value) = 0;
+    virtual GSError ExtraSet(std::string key, double value) = 0;
+    virtual GSError ExtraSet(std::string key, std::string value) = 0;
+
+protected:
+    SurfaceBuffer(){}
+    virtual ~SurfaceBuffer(){}
+};
+
+using OnReleaseFunc = std::function<GSError(sptr<SurfaceBuffer> &)>;
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_SURFACE_BUFFER_H
diff --git a/ohos_ndk_aosp/includes/surface/surface_type.h b/ohos_ndk_aosp/includes/surface/surface_type.h
new file mode 100644
index 0000000000..f7a4a05c6f
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/surface_type.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_SURFACE_TYPE_H
+#define INTERFACES_INNERKITS_SURFACE_SURFACE_TYPE_H
+
+#include <cstdint>
+#include <string>
+
+#include <graphic_common.h>
+
+namespace OHOS {
+#define SURFACE_MAX_USER_DATA_COUNT 1000
+#define SURFACE_MAX_QUEUE_SIZE 10
+#define SURFACE_DEFAULT_QUEUE_SIZE 3
+#define SURFACE_MAX_STRIDE_ALIGNMENT 32
+#define SURFACE_MIN_STRIDE_ALIGNMENT 4
+#define SURFACE_DEFAULT_STRIDE_ALIGNMENT 4
+#define SURFACE_MAX_SIZE 58982400 // 8K * 8K
+
+using Rect = struct Rect {
+    int32_t x;
+    int32_t y;
+    int32_t w;
+    int32_t h;
+};
+
+typedef enum {
+    COLOR_GAMUT_INVALID = -1,
+    COLOR_GAMUT_NATIVE = 0,
+    COLOR_GAMUT_SATNDARD_BT601 = 1,
+    COLOR_GAMUT_STANDARD_BT709 = 2,
+    COLOR_GAMUT_DCI_P3 = 3,
+    COLOR_GAMUT_SRGB = 4,
+    COLOR_GAMUT_ADOBE_RGB = 5,
+    COLOR_GAMUT_DISPLAY_P3 = 6,
+    COLOR_GAMUT_BT2020 = 7,
+    COLOR_GAMUT_BT2100_PQ = 8,
+    COLOR_GAMUT_BT2100_HLG = 9,
+    COLOR_GAMUT_DISPLAY_BT2020 = 10,
+} SurfaceColorGamut;
+
+using BufferRequestConfig = struct BufferRequestConfig {
+    int32_t width;
+    int32_t height;
+    int32_t strideAlignment;
+    int32_t format; // PixelFormat
+    int32_t usage;
+    int32_t timeout;
+    SurfaceColorGamut colorGamut = SurfaceColorGamut::COLOR_GAMUT_SRGB;
+    bool operator ==(const struct BufferRequestConfig &config) const
+    {
+        return width == config.width &&
+               height == config.height &&
+               strideAlignment == config.strideAlignment &&
+               format == config.format &&
+               usage == config.usage &&
+               colorGamut == config.colorGamut;
+    }
+    bool operator != (const struct BufferRequestConfig &config) const
+    {
+        return !(*this == config);
+    }
+};
+
+using BufferFlushConfig = struct BufferFlushConfig {
+    Rect damage;
+    int64_t timestamp;
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_SURFACE_TYPE_H
diff --git a/ohos_ndk_aosp/includes/surface/surface_utils.h b/ohos_ndk_aosp/includes/surface/surface_utils.h
new file mode 100644
index 0000000000..f33a4c3ee1
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/surface_utils.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SURFACE_SURFACE_UTILS_H
+#define INTERFACES_INNERKITS_SURFACE_SURFACE_UTILS_H
+
+#include <unordered_map>
+#include <mutex>
+#include "surface.h"
+
+namespace OHOS {
+class SurfaceUtils {
+public:
+    static SurfaceUtils* GetInstance();
+
+    // get surface by uniqueId.
+    sptr<Surface> GetSurface(uint64_t uniqueId);
+    // maintenance map with uniqueId and surface.
+    SurfaceError Add(uint64_t uniqueId, const sptr<Surface> &surface);
+    // remove surface by uniqueId.
+    SurfaceError Remove(uint64_t uniqueId);
+
+private:
+    SurfaceUtils() = default;
+    virtual ~SurfaceUtils();
+
+    std::unordered_map<uint64_t, sptr<Surface>> surfaceCache_;
+    std::mutex mutex_;
+};
+} // namespace OHOS
+
+#endif // INTERFACES_INNERKITS_SURFACE_SURFACE_UTILS_H
diff --git a/ohos_ndk_aosp/includes/surface/window.h b/ohos_ndk_aosp/includes/surface/window.h
new file mode 100644
index 0000000000..97910e4913
--- /dev/null
+++ b/ohos_ndk_aosp/includes/surface/window.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NDK_INCLUDE_NATIVE_WINDOW_H_
+#define NDK_INCLUDE_NATIVE_WINDOW_H_
+
+#include <stdint.h>
+#include <buffer_handle.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct NativeWindow;
+struct NativeWindowBuffer;
+
+#define MKMAGIC(a, b, c, d) (((a) << 24) + ((b) << 16) + ((c) << 8) + ((d) << 0))
+
+enum NativeObjectMagic {
+    NATIVE_OBJECT_MAGIC_WINDOW = MKMAGIC('W', 'I', 'N', 'D'),
+    NATIVE_OBJECT_MAGIC_WINDOW_BUFFER = MKMAGIC('W', 'B', 'U', 'F'),
+};
+
+enum NativeObjectType {
+    NATIVE_OBJECT_WINDOW,
+    NATIVE_OBJECT_WINDOW_BUFFER,
+};
+
+struct Region {
+    struct Rect {
+        int32_t x;
+        int32_t y;
+        uint32_t w;
+        uint32_t h;
+    } *rects;           // if nullptr,  fill the Buffer dirty size by defualt
+    int32_t rectNumber; // if rectNumber is 0, fill the Buffer dirty size by defualt
+};
+
+enum NativeWindowOperation {
+    SET_BUFFER_GEOMETRY,    // ([in] int32_t height, [in] int32_t width)
+    GET_BUFFER_GEOMETRY,    // ([out] int32_t *height, [out] int32_t *width)
+    GET_FORMAT,             // ([out] int32_t *format)
+    SET_FORMAT,             // ([in] int32_t format)
+    GET_USAGE,              // ([out] int32_t *usage)
+    SET_USAGE,              // ([in] int32_t usage)
+    SET_STRIDE,             // ([in] int32_t stride)
+    GET_STRIDE,             // ([out] int32_t *stride)
+    SET_SWAP_INTERVAL,      // ([in] int32_t interval)
+    GET_SWAP_INTERVAL,
+    SET_COLOR_GAMUT,        // ([in] int32_t colorGamut)
+    GET_COLOR_GAMUT,        // ([out int32_t *colorGamut])
+};
+
+// pSurface type is OHOS::sptr<OHOS::Surface>*
+struct NativeWindow* CreateNativeWindowFromSurface(void* pSurface);
+void DestoryNativeWindow(struct NativeWindow* window);
+
+// pSurfaceBuffer type is OHOS::sptr<OHOS::SurfaceBuffer>*
+struct NativeWindowBuffer* CreateNativeWindowBufferFromSurfaceBuffer(void* pSurfaceBuffer);
+void DestoryNativeWindowBuffer(struct NativeWindowBuffer* buffer);
+
+int32_t NativeWindowRequestBuffer(struct NativeWindow *window, /* [out] */ struct NativeWindowBuffer **buffer,
+    /* [out] get release fence */ int *fenceFd);
+int32_t NativeWindowFlushBuffer(struct NativeWindow *window, struct NativeWindowBuffer *buffer,
+    int fenceFd, Region region);
+int32_t NativeWindowCancelBuffer(struct NativeWindow *window, struct NativeWindowBuffer *buffer);
+
+// The meaning and quantity of parameters vary according to the code type.
+// For details, see the NativeWindowOperation comment.
+int32_t NativeWindowHandleOpt(struct NativeWindow *window, int code, ...);
+BufferHandle *GetBufferHandleFromNative(struct NativeWindowBuffer *buffer);
+
+// NativeObject: NativeWindow, NativeWindowBuffer
+int32_t NativeObjectReference(void *obj);
+int32_t NativeObjectUnreference(void *obj);
+int32_t GetNativeObjectMagic(void *obj);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/system_ability/if_system_ability_manager.h b/ohos_ndk_aosp/includes/system_ability/if_system_ability_manager.h
new file mode 100644
index 0000000000..827b992f96
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/if_system_ability_manager.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INTERFACES_INNERKITS_SAMGR_INCLUDE_IF_SYSTEM_ABILITY_MANAGER_H_
+#define INTERFACES_INNERKITS_SAMGR_INCLUDE_IF_SYSTEM_ABILITY_MANAGER_H_
+
+#include <string>
+#include <list>
+
+#include "iremote_broker.h"
+#include "iremote_object.h"
+#include "iremote_proxy.h"
+#include "isystem_ability_load_callback.h"
+#include "isystem_ability_status_change.h"
+
+namespace OHOS {
+class ISystemAbilityManager : public IRemoteBroker {
+public:
+    // Return list of all existing abilities.
+    virtual std::vector<std::u16string> ListSystemAbilities(unsigned int dumpFlags = DUMP_FLAG_PRIORITY_ALL) = 0;
+
+    enum {
+        SHEEFT_CRITICAL = 0,
+        SHEEFT_HIGH,
+        SHEEFT_NORMAL,
+        SHEEFT_DEFAULT,
+        SHEEFT_PROTO,
+    };
+
+    static const unsigned int DUMP_FLAG_PRIORITY_CRITICAL = 1 << SHEEFT_CRITICAL;
+    static const unsigned int DUMP_FLAG_PRIORITY_HIGH = 1 << SHEEFT_HIGH;
+    static const unsigned int DUMP_FLAG_PRIORITY_NORMAL = 1 << SHEEFT_NORMAL;
+
+    static const unsigned int DUMP_FLAG_PRIORITY_DEFAULT = 1 << SHEEFT_DEFAULT;
+    static const unsigned int DUMP_FLAG_PRIORITY_ALL = DUMP_FLAG_PRIORITY_CRITICAL |
+        DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PRIORITY_DEFAULT;
+    static const unsigned int DUMP_FLAG_PROTO = 1 << SHEEFT_PROTO;
+
+    enum {
+        GET_SYSTEM_ABILITY_TRANSACTION = 1,
+        CHECK_SYSTEM_ABILITY_TRANSACTION = 2,
+        ADD_SYSTEM_ABILITY_TRANSACTION = 3,
+        REMOVE_SYSTEM_ABILITY_TRANSACTION = 4,
+        LIST_SYSTEM_ABILITY_TRANSACTION = 5,
+        SUBSCRIBE_SYSTEM_ABILITY_TRANSACTION = 6,
+        LOAD_SYSTEM_ABILITY_TRANSACTION = 7,
+        CHECK_REMOTE_SYSTEM_ABILITY_TRANSACTION = 9,
+        ADD_ONDEMAND_SYSTEM_ABILITY_TRANSACTION = 10,
+        CHECK_SYSTEM_ABILITY_IMMEDIATELY_TRANSACTION = 12,
+        CHECK_ONDEMAND_SYSTEM_ABILITY_TRANSACTION = 15,
+        GET_SYSTEM_ABILITYINFOLIST_TRANSACTION = 17,
+        UNSUBSCRIBE_SYSTEM_ABILITY_TRANSACTION = 18,
+        ADD_SYSTEM_PROCESS_TRANSACTION = 20
+    };
+
+    // Retrieve an existing ability, blocking for a few seconds if it doesn't ye exist.
+    virtual sptr<IRemoteObject> GetSystemAbility(int32_t systemAbilityId) = 0;
+
+    // Retrieve an existing ability, no-blocking.
+    virtual sptr<IRemoteObject> CheckSystemAbility(int32_t systemAbilityId) = 0;
+
+    // Remove an ability.
+    virtual int32_t RemoveSystemAbility(int32_t systemAbilityId) = 0;
+
+    virtual int32_t SubscribeSystemAbility(int32_t systemAbilityId,
+        const sptr<ISystemAbilityStatusChange>& listener) = 0;
+    virtual int32_t UnSubscribeSystemAbility(int32_t systemAbilityId,
+        const sptr<ISystemAbilityStatusChange>& listener) = 0;
+
+    // Retrieve an existing ability, blocking for a few seconds if it doesn't ye exist.
+    virtual sptr<IRemoteObject> GetSystemAbility(int32_t systemAbilityId, const std::string& deviceId) = 0;
+
+    // Retrieve an existing ability, no-blocking
+    virtual sptr<IRemoteObject> CheckSystemAbility(int32_t systemAbilityId, const std::string& deviceId) = 0;
+
+    // Add ondemand ability info.
+    virtual int32_t AddOnDemandSystemAbilityInfo(int32_t systemAbilityId,
+        const std::u16string& localAbilityManagerName) = 0;
+
+    // Retrieve an ability, no-blocking.
+    virtual sptr<IRemoteObject> CheckSystemAbility(int32_t systemAbilityId, bool& isExist) = 0;
+
+    struct SAExtraProp {
+        SAExtraProp() = default;
+        SAExtraProp(bool isDistributed, unsigned int dumpFlags, const std::u16string& capability,
+            const std::u16string& permission)
+        {
+            this->isDistributed = isDistributed;
+            this->dumpFlags = dumpFlags;
+            this->capability = capability;
+            this->permission = permission;
+        }
+
+        bool isDistributed = false;
+        unsigned int dumpFlags = DUMP_FLAG_PRIORITY_DEFAULT;
+        std::u16string capability;
+        std::u16string permission;
+    };
+    virtual int32_t AddSystemAbility(int32_t systemAbilityId, const sptr<IRemoteObject>& ability,
+        const SAExtraProp& extraProp = SAExtraProp(false, DUMP_FLAG_PRIORITY_DEFAULT, u"", u"")) = 0;
+
+    virtual int32_t AddSystemProcess(const std::u16string& procName, const sptr<IRemoteObject>& procObject) = 0;
+    virtual int32_t LoadSystemAbility(int32_t systemAbilityId, const sptr<ISystemAbilityLoadCallback>& callback) = 0;
+public:
+    DECLARE_INTERFACE_DESCRIPTOR(u"OHOS.ISystemAbilityManager");
+protected:
+    static constexpr int32_t FIRST_SYS_ABILITY_ID = 0x00000001;
+    static constexpr int32_t LAST_SYS_ABILITY_ID = 0x00ffffff;
+    bool CheckInputSysAbilityId(int32_t sysAbilityId) const
+    {
+        if (sysAbilityId >= FIRST_SYS_ABILITY_ID && sysAbilityId <= LAST_SYS_ABILITY_ID) {
+            return true;
+        }
+        return false;
+    }
+    static inline const std::u16string SAMANAGER_INTERFACE_TOKEN = u"ohos.samgr.accessToken";
+};
+} // namespace OHOS
+
+#endif // !defined(INTERFACES_INNERKITS_SAMGR_INCLUDE_IF_SYSTEM_ABILITY_MANAGER_H_ )
diff --git a/ohos_ndk_aosp/includes/system_ability/iservice_registry.h b/ohos_ndk_aosp/includes/system_ability/iservice_registry.h
new file mode 100755
index 0000000000..a5c3f1ddea
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/iservice_registry.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SERVICE_REGISTRY_INCLUDE_H
+#define SERVICE_REGISTRY_INCLUDE_H
+
+#include "ipc_types.h"
+#include <iremote_broker.h>
+#include "ipc_object_stub.h"
+#include "iremote_proxy.h"
+#include "if_system_ability_manager.h"
+
+namespace OHOS {
+class IServiceRegistry : public IRemoteBroker {
+public:
+    /**
+     * Retrieve an existing service, blocking for a few seconds
+     * if it doesn't yet exist.
+     */
+    virtual sptr<IRemoteObject> GetService(const std::u16string& name) = 0;
+
+    /**
+     * Retrieve an existing service, non-blocking.
+     */
+    virtual sptr<IRemoteObject> CheckService(const std::u16string& name) = 0;
+
+    /**
+     * Register a service.
+     */
+    virtual int AddService(const std::u16string& name, const sptr<IRemoteObject> &service,
+        bool allowIsolated = false, int dumpsysFlags = 0) = 0;
+
+    enum {
+        GET_SERVICE_TRANSACTION = FIRST_CALL_TRANSACTION,
+        CHECK_SERVICE_TRANSACTION,
+        ADD_SERVICE_TRANSACTION,
+    };
+public:
+    DECLARE_INTERFACE_DESCRIPTOR(u"");
+};
+
+class ServiceRegistry {
+public:
+    /**
+     * get Service registry instance.
+     */
+    static sptr<IServiceRegistry> GetInstance();
+
+private:
+    static std::mutex serviceRegistryLock_;
+};
+
+class SystemAbilityManagerClient {
+public:
+    static SystemAbilityManagerClient& GetInstance();
+
+    /**
+     * get system ability manager.
+     */
+    sptr<ISystemAbilityManager> GetSystemAbilityManager();
+
+    /**
+     * get remote object of samgr.
+     */
+    sptr<IRemoteObject> GetRegistryRemoteObject();
+
+    /**
+     * destroy remote object of samgr.
+     */
+    void DestroySystemAbilityManagerObject();
+
+private:
+    SystemAbilityManagerClient() = default;
+    ~SystemAbilityManagerClient() = default;
+
+    sptr<ISystemAbilityManager> systemAbilityManager_;
+    std::mutex systemAbilityManagerLock_;
+};
+} // namespace OHOS
+
+#endif // ZIPC_SERVICE_REGISTRY_INCLUDE_H
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/system_ability/isystem_ability_load_callback.h b/ohos_ndk_aosp/includes/system_ability/isystem_ability_load_callback.h
new file mode 100755
index 0000000000..01d55cacf6
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/isystem_ability_load_callback.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_ISYSTEM_ABILITY_LOAD_CALLBACK_H
+#define SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_ISYSTEM_ABILITY_LOAD_CALLBACK_H
+
+#include "iremote_broker.h"
+#include "iremote_object.h"
+#include "iremote_proxy.h"
+
+namespace OHOS {
+class ISystemAbilityLoadCallback : public IRemoteBroker {
+public:
+    virtual ~ISystemAbilityLoadCallback() = default;
+    virtual void OnLoadSystemAbilitySuccess(int32_t systemAbilityId, const sptr<IRemoteObject>& remoteObject) = 0;
+    virtual void OnLoadSystemAbilityFail(int32_t systemAbilityId) = 0;
+    DECLARE_INTERFACE_DESCRIPTOR(u"OHOS.ISystemAbilityLoadCallback");
+protected:
+    enum {
+        ON_LOAD_SYSTEM_ABILITY_SUCCESS = 1,
+        ON_LOAD_SYSTEM_ABILITY_FAIL = 2,
+    };
+};
+}
+#endif /* SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_ISYSTEM_ABILITY_LOAD_CALLBACK_H */
diff --git a/ohos_ndk_aosp/includes/system_ability/isystem_ability_status_change.h b/ohos_ndk_aosp/includes/system_ability/isystem_ability_status_change.h
new file mode 100755
index 0000000000..ace87cb10c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/isystem_ability_status_change.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_IF_SYSTEM_ABILITY_STATUS_CHANGE_H
+#define SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_IF_SYSTEM_ABILITY_STATUS_CHANGE_H
+
+#include "iremote_broker.h"
+#include "iremote_object.h"
+#include "iremote_proxy.h"
+
+namespace OHOS {
+class ISystemAbilityStatusChange : public IRemoteBroker {
+public:
+    virtual ~ISystemAbilityStatusChange() = default;
+    virtual void OnAddSystemAbility(int32_t systemAbilityId, const std::string& deviceId) = 0;
+    virtual void OnRemoveSystemAbility(int32_t systemAbilityId, const std::string& deviceId) = 0;
+    DECLARE_INTERFACE_DESCRIPTOR(u"OHOS.ISystemAbilityStatusChange");
+    enum {
+        ON_ADD_SYSTEM_ABILITY = 1,
+        ON_REMOVE_SYSTEM_ABILITY = 2,
+    };
+};
+}
+#endif /* SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_IF_SYSTEM_ABILITY_STATUS_CHANGE_H */
diff --git a/ohos_ndk_aosp/includes/system_ability/sam_log.h b/ohos_ndk_aosp/includes/system_ability/sam_log.h
new file mode 100644
index 0000000000..f8b202ac14
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/sam_log.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SERVICES_SAMGR_NATIVE_INCLUDE_SAM_LOG_H_
+#define SERVICES_SAMGR_NATIVE_INCLUDE_SAM_LOG_H_
+
+#include "hilog/log.h"
+
+namespace OHOS {
+static constexpr OHOS::HiviewDFX::HiLogLabel SYSTEM_ABLILITY_MGR_LABEL = {
+    LOG_CORE,
+    0xD001800,
+    "SAMGR"
+};
+
+#ifdef HILOGF
+#undef HILOGF
+#endif
+
+#ifdef HILOGE
+#undef HILOGE
+#endif
+
+#ifdef HILOGW
+#undef HILOGW
+#endif
+
+#ifdef HILOGI
+#undef HILOGI
+#endif
+
+#ifdef HILOGD
+#undef HILOGD
+#endif
+
+#define HILOGF(...) (void)OHOS::HiviewDFX::HiLog::Fatal(SYSTEM_ABLILITY_MGR_LABEL, __VA_ARGS__)
+#define HILOGE(...) (void)OHOS::HiviewDFX::HiLog::Error(SYSTEM_ABLILITY_MGR_LABEL, __VA_ARGS__)
+#define HILOGW(...) (void)OHOS::HiviewDFX::HiLog::Warn(SYSTEM_ABLILITY_MGR_LABEL, __VA_ARGS__)
+#define HILOGI(...) (void)OHOS::HiviewDFX::HiLog::Info(SYSTEM_ABLILITY_MGR_LABEL, __VA_ARGS__)
+#define HILOGD(...) (void)OHOS::HiviewDFX::HiLog::Debug(SYSTEM_ABLILITY_MGR_LABEL, __VA_ARGS__)
+} // namespace OHOS
+
+#endif // #ifndef SERVICES_SAMGR_NATIVE_INCLUDE_SAM_LOG_H_
diff --git a/ohos_ndk_aosp/includes/system_ability/system_ability_definition.h b/ohos_ndk_aosp/includes/system_ability/system_ability_definition.h
new file mode 100755
index 0000000000..93e2c2b9b9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/system_ability_definition.h
@@ -0,0 +1,295 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_SYSTEM_ABILITY_DEFINITION_H
+#define UTILS_SYSTEM_ABILITY_DEFINITION_H
+
+#include<map>
+#include<string>
+
+namespace OHOS {
+// system ability definition should be a number between FIRST_SYS_ABILITY_ID and LAST_SYS_ABILITY_ID
+enum {
+    FIRST_SYS_ABILITY_ID                             = 0x00000001,
+    SUBSYS_COMMON_SYS_ABILITY_ID_BEGIN               = 1,
+    RENDER_SERVICE                                   = 10,
+    SUBSYS_AAFWK_SYS_ABILITY_ID_BEGIN                = 100,
+    ABILITY_TOOLS_SERVICE_ID                         = 116,
+    ABILITY_TEST_SERVICE_ID                          = 179,
+    ABILITY_MGR_SERVICE_ID                           = 180,
+    ABILITY_MST_SERVICE_ID                           = 181,
+    DATAOBS_MGR_SERVICE_SA_ID                        = 182,
+    URI_PERMISSION_MGR_SERVICE_ID                    = 183,
+    SUBSYS_AAFWK_SYS_ABILITY_ID_END                  = 199,
+    SUBSYS_ACCOUNT_SYS_ABILITY_ID_BEGIN              = 200,
+    SUBSYS_AI_SYS_ABILITY_ID_BEGIN                   = 300,
+    SUBSYS_AI_DS_SYS_ABILITY_ID                      = 310,
+    SUBSYS_APPEXECFWK_SYS_ABILITY_ID_BEGIN           = 400,
+    BUNDLE_MGR_SERVICE_SYS_ABILITY_ID                = 401,
+    DISTRIBUTED_BUNDLE_MGR_SERVICE_SYS_ABILITY_ID    = 402,
+    FORM_MGR_SERVICE_ID                              = 403,
+    SUBSYS_APPLICATIONS_SYS_ABILITY_ID_BEGIN         = 500,
+    APP_MGR_SERVICE_ID                               = 501,
+    INSTALLD_SERVICE_ID                              = 511,
+    SUBSYS_ARVR_SYS_ABILITY_ID_BEGIN                 = 600,
+    SUBSYS_ARVRHARDWARE_SYS_ABILITY_ID_BEGIN         = 700,
+    SUBSYS_BARRIERFREE_SYS_ABILITY_ID_BEGIN          = 800,
+    ACCESSIBILITY_MANAGER_SERVICE_ID                 = 801,
+    SUBSYS_BARRIERFREE_SYS_ABILITY_ID_END            = 899,
+    SUBSYS_USERIAM_SYS_ABILITY_ID_BEGIN              = 900,
+    SUBSYS_USERIAM_SYS_ABILITY_USERIDM               = 901,
+    SUBSYS_USERIAM_SYS_ABILITY_USERAUTH              = 921,
+    SUBSYS_USERIAM_SYS_ABILITY_AUTHEXECUTORMGR       = 931,
+    SUBSYS_USERIAM_SYS_ABILITY_PINAUTH               = 941,
+    SUBSYS_USERIAM_SYS_ABILITY_FACEAUTH              = 942,
+    SUBSYS_CCRUNTIME_SYS_ABILITY_ID_BEGIN            = 1000,
+    SUBSYS_COMMUNICATION_SYS_ABILITY_ID_BEGIN        = 1100,
+    RPC_UNREGISTERED_TEST_SERVICE                    = 1108,
+    RPC_TEST_SERVICE                                 = 1109,
+    RPC_TEST_SERVICE2                                = 1110,
+    IPC_MSG_SEV                                      = 1114,
+    IPC_MSG_UNREGISTERED_SERVER                      = 1115,
+    IPC_MSG_REPEAT_SERVER                            = 1116,
+    IPC_MSG_SERVER                                   = 1117,
+    IPC_TEST_SERVICE                                 = 1118,
+    IPC_EXTRA_TEST_SERVICE                           = 1119,
+    WIFI_DEVICE_SYS_ABILITY_ID                       = 1120,
+    WIFI_HOTSPOT_SYS_ABILITY_ID                      = 1121,
+    WIFI_ENHANCER_SYS_ABILITY_ID                     = 1122,
+    WIFI_P2P_SYS_ABILITY_ID                          = 1123,
+    BLUETOOTH_HOST_SYS_ABILITY_ID                    = 1130,
+    NFC_MANAGER_SYS_ABILITY_ID                       = 1140,
+    DISCOVER_SYS_ABILITY_ID                          = 1160,
+    DNET_SYS_ABILITY_ID                              = 1170,
+    NET_MANAGER_SYS_ABILITY_ID                       = 1150,
+    COMM_NET_CONN_MANAGER_SYS_ABILITY_ID             = 1151,
+    COMM_NET_POLICY_MANAGER_SYS_ABILITY_ID           = 1152,
+    COMM_NET_STATS_MANAGER_SYS_ABILITY_ID            = 1153,
+    COMM_NET_TETHERING_MANAGER_SYS_ABILITY_ID        = 1154,
+    COMM_VPN_MANAGER_SYS_ABILITY_ID                  = 1155,
+    COMM_DNS_MANAGER_SYS_ABILITY_ID                  = 1156,
+    COMM_ETHERNET_MANAGER_SYS_ABILITY_ID             = 1157,
+    COMM_NETSYS_NATIVE_SYS_ABILITY_ID                  = 1158,
+    SMART_COMM_SYS_ABILITY_ID                        = 1180,
+    SUBSYS_DFX_SYS_ABILITY_ID_BEGIN                  = 1200,
+    DFX_SYS_HIVIEW_ABILITY_ID                        = 1201,
+    DFX_SYS_EVENT_SERVICE_ABILITY_ID                 = 1203,
+    SUBSYS_DISTRIBUTEDDATAMNG_SYS_ABILITY_ID_BEGIN   = 1300,
+    DISTRIBUTED_KV_DATA_SERVICE_ABILITY_ID           = 1301,
+    DISTRIBUTED_FS_DAEMON_SERVICE_ID                 = 1302,
+    DISTRIBUTED_FS_META_SERVICE_ID                   = 1303,
+    DISTRIBUTED_FS_STORAGE_SERVICE_ID                = 1304,
+    SUBSYS_DISTRIBUTEDSCHEDULE_SYS_ABILITY_ID_BEGIN  = 1400,
+    DISTRIBUTED_SCHED_SA_ID                          = 1401,
+    DISTRIBUTED_SCHED_ADAPTER_SA_ID                  = 1402,
+    DISTRIBUTED_SCENARIO_MGR_SA_ID                   = 1403,
+    DISTRIBUTED_SCHED_TEST_SO_ID                     = 1490,
+    DISTRIBUTED_SCHED_TEST_OS_ID                     = 1491,
+    DISTRIBUTED_SCHED_TEST_OOS_ID                    = 1492,
+    DISTRIBUTED_SCHED_TEST_TT_ID                     = 1493,
+    DISTRIBUTED_SCHED_TEST_LISTEN_ID                 = 1494,
+    DISTRIBUTED_SCHED_TEST_CONNECTION_ID             = 1495,
+    DISTRIBUTED_SCHED_TEST_INCOMPLETE_ID             = 1496,
+    DISTRIBUTED_SCHED_TEST_ONDEMAND_ID               = 1497,
+    DISTRIBUTED_SCHED_TEST_AUDIO_ID                  = 1498,
+    DISTRIBUTED_SCHED_TEST_MEDIA_ID                  = 1499,
+    SUBSYS_DRIVERS_SYS_ABILITY_ID_BEGIN              = 1500,
+    SUBSYS_GLOBAL_SYS_ABILITY_ID_BEGIN               = 1600,
+    ENTERPRISE_DEVICE_MANAGER_SA_ID                  = 1601,
+    SUBSYS_GRAPHIC_SYS_ABILITY_ID_BEGIN              = 1700,
+    SUBSYS_HBS_SYS_ABILITY_ID_BEGIN                  = 1800,
+    SUBSYS_IAWARE_SYS_ABILITY_ID_BEGIN               = 1900,
+    RES_SCHED_SYS_ABILITY_ID                         = 1901,
+    RESSCHEDD_SA_ID                                  = 1902,
+    BACKGROUND_TASK_MANAGER_SERVICE_ID               = 1903,
+    WORK_SCHEDULE_SERVICE_ID                         = 1904,
+    SOC_PERF_SERVICE_SA_ID                           = 1906,
+    DEVICE_USAGE_STATISTICS_SYS_ABILITY_ID           = 1907,
+    MEMORY_MANAGER_SA_ID                             = 1909,
+    SUBSYS_IDE_SYS_ABILITY_ID_BEGIN                  = 2000,
+    SUBSYS_INTELLIACCESSORIES_SYS_ABILITY_ID_BEGIN   = 2100,
+    SUBSYS_INTELLISPEAKER_SYS_ABILITY_ID_BEGIN       = 2200,
+    SUBSYS_INTELLITV_SYS_ABILITY_ID_BEGIN            = 2300,
+    SUBSYS_IOT_SYS_ABILITY_ID_BEGIN                  = 2400,
+    SUBSYS_IOTHARDWARE_SYS_ABILITY_ID_BEGIN          = 2500,
+    SUBSYS_IVIHARDWARE_SYS_ABILITY_ID_BEGIN          = 2600,
+    IVIHARDWARE_MANAGER_SA_ID                        = 2601,
+    IVIHARDWARE_ADAS_SA_ID                           = 2602,
+    IVIHARDWARE_TBOX_SA_ID                           = 2603,
+    IVIHARDWARE_CLUSTER_SA_ID                        = 2604,
+    SUBSYS_KERNEL_SYS_ABILITY_ID_BEGIN               = 2700,
+    SUBSYS_LOCATION_SYS_ABILITY_ID_BEGIN             = 2800,
+    LOCATION_GEO_CONVERT_SA_ID                       = 2801,
+    LOCATION_LOCATOR_SA_ID                           = 2802,
+    LOCATION_GNSS_SA_ID                              = 2803,
+    LOCATION_NETWORK_LOCATING_SA_ID                  = 2804,
+    LOCATION_NOPOWER_LOCATING_SA_ID                  = 2805,
+    LOCATION_NOTIFICATION_SA_ID                      = 2806,
+    SUBSYS_MSDP_SYS_ABILITY_ID_BEGIN                 = 2900,
+    MSDP_MOTION_SERVICE_ID                           = 2901,
+    MSDP_DEVICESTATUS_SERVICE_ID                     = 2902,
+    MSDP_MOVEMENT_SERVICE_ID                         = 2903,
+    MSDP_SPATIAL_AWARENESS_SERVICE_ID                = 2904,
+    MSDP_GEOFENCE_SERVICE_ID                         = 2905,
+    MSDP_TIMELINE_SERVICE_ID                         = 2906,
+    SUBSYS_MULTIMEDIA_SYS_ABILITY_ID_BEGIN           = 3000,
+    AUDIO_DISTRIBUTED_SERVICE_ID                     = 3001,
+    PLAYER_DISTRIBUTED_SERVICE_ID                    = 3002,
+    RADIO_IVI_SERVICE_ID                             = 3003,
+    AUDIO_SWIFT_SERVICE_ID                           = 3004,
+    UPDATE_DISTRIBUTED_SERVICE_ID                    = 3006,
+    MEDIA_LIBRARY_SERVICE_ID                         = 3007,
+    CAMERA_SERVICE_ID                                = 3008,
+    AUDIO_POLICY_SERVICE_ID                          = 3009,
+    SUBSYS_MULTIMODAINPUT_SYS_ABILITY_ID_BEGIN       = 3100,
+    MULTIMODAL_INPUT_SERVICE_ID                      = 3101,
+    MULTIMODAL_CHANNEL_SERVICE_ID                    = 3102,
+    SUBSYS_NOTIFICATION_SYS_ABILITY_ID_BEGIN         = 3200,
+    EVENT_MANAGER_SERVICE_ID                         = 3201,
+    COMMON_EVENT_SERVICE_ABILITY_ID                  = 3202,
+    ADVANCED_NOTIFICATION_SERVICE_ABILITY_ID         = 3203,
+    COMMON_EVENT_SERVICE_ID                          = 3299,
+    SUBSYS_POWERMNG_SYS_ABILITY_ID_BEGIN             = 3300,
+    POWER_MANAGER_SERVICE_ID                         = 3301,
+    POWER_MANAGER_BATT_SERVICE_ID                    = 3302,
+    POWER_MANAGER_THERMAL_SERVICE_ID                 = 3303,
+    POWER_MANAGER_BATT_STATS_SERVICE_ID              = 3304,
+    DISPLAY_MANAGER_SERVICE_ID                       = 3308,
+    IVIPOWER_ENHANCED_SERVICE_ID                     = 3309,
+    SUBSYS_ROUTER_SYS_ABILITY_ID_BEGIN               = 3400,
+    SUBSYS_SECURITY_SYS_ABILITY_ID_BEGIN             = 3500,
+    DEVICE_SECURITY_LEVEL_MANAGER_SA_ID              = 3511,
+    SUBSYS_SENSORS_SYS_ABILITY_ID_BEGIN              = 3600,
+    SENSOR_SERVICE_ABILITY_ID                        = 3601,
+    MISCDEVICE_SERVICE_ABILITY_ID                    = 3602,
+    EXTSHB_SERVICE_ABILITY_ID                        = 3603,
+    SUBSYS_SMALLSERVICES_SYS_ABILITY_ID_BEGIN        = 3700,
+    PASTEBOARD_SERVICE_ID                            = 3701,
+    TIME_SERVICE_ID                                  = 3702,
+    INPUT_METHOD_SYSTEM_ABILITY_ID                   = 3703,
+    SCREENLOCK_SERVICE_ID                            = 3704,
+    WALLPAPER_MANAGER_SERVICE_ID                     = 3705,
+    DOWNLOAD_SERVICE_ID                              = 3706,
+    SUBSYS_SOURCECODETRANSFORMER_SYS_ABILITY_ID_BEGIN = 3800,
+    SUBSYS_STARTUP_SYS_ABILITY_ID_BEGIN              = 3900,
+    PARAM_WATCHER_DISTRIBUTED_SERVICE_ID             = 3901,
+    SYSPARAM_DEVICE_SERVICE_ID                       = 3902,
+    SUBSYS_TELEPONY_SYS_ABILITY_ID_BEGIN             = 4000,
+    TELEPHONY_SYS_ABILITY_ID                         = 4001,
+    DCALL_SYS_ABILITY_ID                             = 4002,
+    TELEPHONY_CALL_MANAGER_SYS_ABILITY_ID            = 4005,
+    TELEPHONY_CELLULAR_CALL_SYS_ABILITY_ID           = 4006,
+    TELEPHONY_CELLULAR_DATA_SYS_ABILITY_ID           = 4007,
+    TELEPHONY_SMS_MMS_SYS_ABILITY_ID                 = 4008,
+    TELEPHONY_STATE_REGISTRY_SYS_ABILITY_ID          = 4009,
+    TELEPHONY_CORE_SERVICE_SYS_ABILITY_ID            = 4010,
+    TELEPHONY_DATA_STORAGE_SYS_ABILITY_ID            = 4012,
+    SUBSYS_UPDATE_SYS_ABILITY_ID_BEGIN               = 4100,
+    SUBSYS_USB_SYS_ABILITY_ID_BEGIN                  = 4200,
+    USB_SYSTEM_ABILITY_ID                            = 4201,
+    SUBSYS_WEARABLE_SYS_ABILITY_ID_BEGIN             = 4300,
+    SUBSYS_WEARABLEHARDWARE_SYS_ABILITY_ID_BEGIN     = 4400,
+    SUBSYS_IVI_SYS_ABILITY_ID_BEGIN                  = 4500,
+    IVI_DRIVINGSAFETY_SA_ID                          = 4501,
+    IVI_CONFIGMANAGER_SA_ID                          = 4502,
+    IVI_COCKPITMONITOR_SA_ID                         = 4503,
+    WINDOW_MANAGER_ID                                = 4600,
+    VSYNC_MANAGER_ID                                 = 4601,
+    VSYNC_MANAGER_TEST_ID                            = 4602,
+    GRAPHIC_DUMPER_SERVICE_SA_ID                     = 4603,
+    GRAPHIC_DUMPER_COMMAND_SA_ID                     = 4604,
+    ANIMATION_SERVER_SA_ID                           = 4605,
+    WINDOW_MANAGER_SERVICE_ID                        = 4606,
+    DISPLAY_MANAGER_SERVICE_SA_ID                    = 4607,
+    SOFTBUS_SERVER_SA_ID                             = 4700,
+    DEVICE_AUTH_SERVICE_ID                           = 4701,
+    SUBSYS_DISTRIBUTED_HARDWARE_SYS_ABILITY_ID_BEGIN = 4800,
+    DISTRIBUTED_HARDWARE_SA_ID                       = 4801,
+    DISTRIBUTED_HARDWARE_DEVICEMANAGER_SA_ID         = 4802,
+    DISTRIBUTED_HARDWARE_CAMERA_SOURCE_SA_ID         = 4803,
+    DISTRIBUTED_HARDWARE_CAMERA_SINK_SA_ID           = 4804,
+    SUBSYS_STORAGE_SYS_ABILITY_ID_BEGIN              = 4900,
+    STORAGE_DISTRIBUTED_FILE_DAEMON_SA_ID            = 4901,
+    STORAGE_DISTRIBUTED_FILE_SERVICE_SA_ID           = 4902,
+    DEVICE_STORAGE_MANAGER_SERVICE_ID                = 5000,
+    STORAGE_SERVICE_ID                               = 5001,
+    STORAGE_MANAGER_DAEMON_ID                        = 5002,
+    STORAGE_MANAGER_MANAGER_ID                       = 5003,
+    FILE_MANAGER_SERVICE_ID                          = 5010,
+    DEVICE_SERVICE_MANAGER_SA_ID                     = 5100,
+    DISTRIBUTED_DEVICE_PROFILE_SA_ID                 = 6001,
+    SUBSYS_ACE_SYS_ABILITY_ID_BEGIN                  = 7001,
+    CA_DAEMON_ID                                     = 8001,
+    LAST_SYS_ABILITY_ID                              = 0x00ffffff,  // 16777215
+};
+
+static const std::map<int, std::string> saNameMap_ = {
+    { 200, "AccountMgr" },
+    { 301, "AIEngine" },
+    { BUNDLE_MGR_SERVICE_SYS_ABILITY_ID, "BundleMgr" },
+    { FORM_MGR_SERVICE_ID, "FormMgr" },
+    { WIFI_DEVICE_SYS_ABILITY_ID, "WifiDevice" },
+    { WIFI_HOTSPOT_SYS_ABILITY_ID, "WifiHotspot" },
+    { WIFI_ENHANCER_SYS_ABILITY_ID, "WifiEnhancer" },
+    { WIFI_P2P_SYS_ABILITY_ID, "WifiP2p" },
+    { BLUETOOTH_HOST_SYS_ABILITY_ID, "BluetoothHost" },
+    { NFC_MANAGER_SYS_ABILITY_ID, "NfcManager" },
+    { NET_MANAGER_SYS_ABILITY_ID, "NetManager" },
+    { DISTRIBUTED_KV_DATA_SERVICE_ABILITY_ID, "DistributedKvData" },
+    { DISTRIBUTED_SCHED_SA_ID, "DistributedSched" },
+    { DISTRIBUTED_SCHED_ADAPTER_SA_ID, "DistributedSchedAdapter" },
+    { DISTRIBUTED_SCENARIO_MGR_SA_ID, "DistributedScenarioMgr" },
+    { RES_SCHED_SYS_ABILITY_ID, "ResourceSched" },
+    { RESSCHEDD_SA_ID, "ResourceSchedDamon" },
+    { BACKGROUND_TASK_MANAGER_SERVICE_ID, "BackgroundTaskManager" },
+    { WORK_SCHEDULE_SERVICE_ID, "WorkSchedule" },
+    { LOCATION_GEO_CONVERT_SA_ID, "LocationGeoConvert" },
+    { LOCATION_LOCATOR_SA_ID, "LocationLocator" },
+    { LOCATION_GNSS_SA_ID, "LocationGnss" },
+    { LOCATION_NETWORK_LOCATING_SA_ID, "LocationNetworkLocating" },
+    { LOCATION_NOPOWER_LOCATING_SA_ID, "LocationNopowerLocating" },
+    { AUDIO_DISTRIBUTED_SERVICE_ID, "AudioDistributed" },
+    { COMMON_EVENT_SERVICE_ABILITY_ID, "CommonEventService" },
+    { ADVANCED_NOTIFICATION_SERVICE_ABILITY_ID, "AdvancedNotificationService" },
+    { POWER_MANAGER_SERVICE_ID, "PowerManagerService" },
+    { POWER_MANAGER_BATT_SERVICE_ID, "PowerManagerBatt" },
+    { POWER_MANAGER_BATT_STATS_SERVICE_ID, "BatteryStatsService" },
+    { 3502, "DpmsService" },
+    { 3510, "KeystoreService" },
+    { DEVICE_SECURITY_LEVEL_MANAGER_SA_ID, "DslmService" },
+    { SENSOR_SERVICE_ABILITY_ID, "SensorService" },
+    { MISCDEVICE_SERVICE_ABILITY_ID, "MiscDeviceService" },
+    { PASTEBOARD_SERVICE_ID, "DPasteboardService" },
+    { TELEPHONY_SYS_ABILITY_ID, "Telephony" },
+    { DCALL_SYS_ABILITY_ID, "DistributedCallMgr" },
+    { DISTRIBUTED_HARDWARE_DEVICEMANAGER_SA_ID, "DeviceManagerService" },
+    { USB_SYSTEM_ABILITY_ID, "UsbService" },
+    { DEVICE_SERVICE_MANAGER_SA_ID, "HdfDeviceServiceManager" },
+    { DISTRIBUTED_DEVICE_PROFILE_SA_ID, "DistributedDeviceProfile" },
+    { WINDOW_MANAGER_SERVICE_ID, "WindowManagerService" },
+    { DISPLAY_MANAGER_SERVICE_SA_ID, "DisplayManagerService" },
+    { WINDOW_MANAGER_ID, "WindowManager" },
+    { VSYNC_MANAGER_ID, "VsyncManager" },
+    { VSYNC_MANAGER_TEST_ID, "VsyncManagerTest" },
+    { GRAPHIC_DUMPER_SERVICE_SA_ID, "GraphicDumperService" },
+    { GRAPHIC_DUMPER_COMMAND_SA_ID, "GraphicDumperCommand" },
+    { ANIMATION_SERVER_SA_ID, "AnimationServer" },
+    { CA_DAEMON_ID, "CaDaemon"},
+    { ACCESSIBILITY_MANAGER_SERVICE_ID, "AccessibilityManagerService"},
+    { MEMORY_MANAGER_SA_ID, "MemoryManagerService" },
+};
+} // namespace OHOS
+
+#endif
diff --git a/ohos_ndk_aosp/includes/system_ability/system_ability_load_callback_stub.h b/ohos_ndk_aosp/includes/system_ability/system_ability_load_callback_stub.h
new file mode 100755
index 0000000000..9bf201f127
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/system_ability_load_callback_stub.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_SYSTEM_ABILITY_LOAD_CALLBACK_STUB_H
+#define SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_SYSTEM_ABILITY_LOAD_CALLBACK_STUB_H
+
+#include "iremote_stub.h"
+#include "isystem_ability_load_callback.h"
+
+namespace OHOS {
+class SystemAbilityLoadCallbackStub : public IRemoteStub<ISystemAbilityLoadCallback> {
+public:
+    int32_t OnRemoteRequest(uint32_t code, MessageParcel& data, MessageParcel& reply, MessageOption& option) override;
+
+private:
+    static bool CheckInputSystemAbilityId(int32_t systemAbilityId);
+    static bool EnforceInterceToken(MessageParcel& data);
+
+    int32_t OnLoadSystemAbilitySuccessInner(MessageParcel& data, MessageParcel& reply);
+    int32_t OnLoadSystemAbilityFailInner(MessageParcel& data, MessageParcel& reply);
+};
+}
+#endif /* SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_SYSTEM_ABILITY_LOAD_CALLBACK_STUB_H */
diff --git a/ohos_ndk_aosp/includes/system_ability/system_ability_manager_proxy.h b/ohos_ndk_aosp/includes/system_ability/system_ability_manager_proxy.h
new file mode 100755
index 0000000000..93304fa70d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/system_ability_manager_proxy.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef INTERFACES_INNERKITS_SAMGR_INCLUDE_SYSTEM_ABILITY_MANAGER_PROXY_H_
+#define INTERFACES_INNERKITS_SAMGR_INCLUDE_SYSTEM_ABILITY_MANAGER_PROXY_H_
+
+#include <string>
+#include "if_system_ability_manager.h"
+
+namespace OHOS {
+class SystemAbilityManagerProxy : public IRemoteProxy<ISystemAbilityManager> {
+public:
+    explicit SystemAbilityManagerProxy(const sptr<IRemoteObject>& impl)
+        : IRemoteProxy<ISystemAbilityManager>(impl) {}
+    ~SystemAbilityManagerProxy() = default;
+    std::vector<std::u16string> ListSystemAbilities(unsigned int dumpFlags) override;
+
+    // IntToString adapter interface
+    sptr<IRemoteObject> GetSystemAbility(int32_t systemAbilityId) override;
+    sptr<IRemoteObject> CheckSystemAbility(int32_t systemAbilityId) override;
+    int32_t RemoveSystemAbility(int32_t systemAbilityId) override;
+    int32_t SubscribeSystemAbility(int32_t systemAbilityId, const sptr<ISystemAbilityStatusChange>& listener) override;
+    int32_t UnSubscribeSystemAbility(int32_t systemAbilityId,
+        const sptr<ISystemAbilityStatusChange> &listener) override;
+    sptr<IRemoteObject> GetSystemAbility(int32_t systemAbilityId, const std::string& deviceId) override;
+    sptr<IRemoteObject> CheckSystemAbility(int32_t systemAbilityId, const std::string& deviceId) override;
+    int32_t AddOnDemandSystemAbilityInfo(int32_t systemAbilityId,
+        const std::u16string& localAbilityManagerName) override;
+    sptr<IRemoteObject> CheckSystemAbility(int32_t systemAbilityId, bool& isExist) override;
+    int32_t AddSystemAbility(int32_t systemAbilityId, const sptr<IRemoteObject>& ability,
+        const SAExtraProp& extraProp) override;
+
+    int32_t AddSystemProcess(const std::u16string& procName, const sptr<IRemoteObject>& procObject) override;
+    int32_t LoadSystemAbility(int32_t systemAbilityId, const sptr<ISystemAbilityLoadCallback>& callback) override;
+private:
+    sptr<IRemoteObject> GetSystemAbilityWrapper(int32_t systemAbilityId, const std::string& deviceId = "");
+    sptr<IRemoteObject> CheckSystemAbilityWrapper(int32_t code, MessageParcel& data);
+    int32_t MarshalSAExtraProp(const SAExtraProp& extraProp, MessageParcel& data) const;
+    int32_t AddSystemAbilityWrapper(int32_t code, MessageParcel& data);
+    int32_t RemoveSystemAbilityWrapper(int32_t code, MessageParcel& data);
+private:
+    static inline BrokerDelegator<SystemAbilityManagerProxy> delegator_;
+};
+} // namespace OHOS
+
+#endif // !defined(INTERFACES_INNERKITS_SAMGR_INCLUDE_SYSTEM_ABILITY_MANAGER_PROXY_H_)
diff --git a/ohos_ndk_aosp/includes/system_ability/system_ability_status_change_stub.h b/ohos_ndk_aosp/includes/system_ability/system_ability_status_change_stub.h
new file mode 100755
index 0000000000..e2205eef95
--- /dev/null
+++ b/ohos_ndk_aosp/includes/system_ability/system_ability_status_change_stub.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_SYSTEM_ABILITY_STATUS_CHANGE_STUB_H_
+#define SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_SYSTEM_ABILITY_STATUS_CHANGE_STUB_H_
+
+#include <map>
+#include "iremote_stub.h"
+#include "isystem_ability_status_change.h"
+
+namespace OHOS {
+class SystemAbilityStatusChangeStub : public IRemoteStub<ISystemAbilityStatusChange> {
+public:
+    SystemAbilityStatusChangeStub();
+    ~SystemAbilityStatusChangeStub() = default;
+    int32_t OnRemoteRequest(uint32_t code, MessageParcel& data, MessageParcel& reply, MessageOption& option) override;
+
+protected:
+    static bool CheckInputSysAbilityId(int32_t systemAbilityId);
+
+private:
+    int32_t OnAddSystemAbilityInner(MessageParcel& data, MessageParcel& reply);
+    int32_t OnRemoveSystemAbilityInner(MessageParcel& data, MessageParcel& reply);
+    static bool CanRequest();
+    static bool EnforceInterceToken(MessageParcel& data);
+
+    using SystemAbilityStatusChangeStubFunc =
+        int32_t (SystemAbilityStatusChangeStub::*)(MessageParcel& data, MessageParcel& reply);
+    std::map<uint32_t, SystemAbilityStatusChangeStubFunc> memberFuncMap_;
+};
+}
+#endif /* SAMGR_INTERFACES_INNERKITS_SAMGR_PROXY_INCLUDE_SYSTEM_ABILITY_STATUS_CHANGE_STUB_H_ */
diff --git a/ohos_ndk_aosp/includes/utils/ashmem.h b/ohos_ndk_aosp/includes/utils/ashmem.h
new file mode 100755
index 0000000000..82a57000d9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/ashmem.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_ASHMEM_H
+#define UTILS_BASE_ASHMEM_H
+
+#include <stddef.h>
+#include <linux/ashmem.h>
+#include "refbase.h"
+#include "parcel.h"
+
+namespace OHOS {
+int AshmemCreate(const char *name, size_t size);
+int AshmemSetProt(int fd, int prot);
+int AshmemGetSize(int fd);
+
+class Ashmem : public virtual RefBase {
+public:
+    static sptr<Ashmem> CreateAshmem(const char *name, int32_t size);
+    void CloseAshmem();
+    bool MapAshmem(int mapType);
+    bool MapReadAndWriteAshmem();
+    bool MapReadOnlyAshmem();
+    void UnmapAshmem();
+    bool SetProtection(int protectionType);
+    int GetProtection();
+    int32_t GetAshmemSize();
+    bool WriteToAshmem(const void *data, int32_t size, int32_t offset);
+    const void *ReadFromAshmem(int32_t size, int32_t offset);
+    Ashmem(int fd, int32_t size);
+    ~Ashmem();
+    int GetAshmemFd() const
+    {
+        return memoryFd_;
+    };
+private:
+    int memoryFd_;
+    int32_t memorySize_;
+    int flag_;
+    void *startAddr_;
+    bool CheckValid(int32_t size, int32_t offset, int cmd);
+};
+} // namespace OHOS
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/common_errors.h b/ohos_ndk_aosp/includes/utils/common_errors.h
new file mode 100755
index 0000000000..cf0634d829
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/common_errors.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_COMMON_ERRORS_H
+#define UTILS_COMMON_ERRORS_H
+
+namespace OHOS {
+namespace Utils {
+
+/**
+ * ErrCode layout
+ *
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * | Bit |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * |Field|Reserved|        Subsystem      |  Module      |                  Code                         |
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ *
+ * In this file, subsystem is "SUBSYS_COMMON".
+ */
+
+enum {
+    MODULE_DEFAULT              = 0,
+    MODULE_TIMER                = 1
+    // new module
+};
+
+} // Utils
+} // OHOS
+
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/utils/common_timer_errors.h b/ohos_ndk_aosp/includes/utils/common_timer_errors.h
new file mode 100755
index 0000000000..768ed99589
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/common_timer_errors.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_COMMON_TIMER_ERRORS_H
+#define UTILS_COMMON_TIMER_ERRORS_H
+
+#include <errno.h>
+#include "errors.h"
+#include "common_errors.h"
+
+namespace OHOS {
+namespace Utils {
+
+/**
+ * ErrCode layout
+ *
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * | Bit |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * |Field|Reserved|        Subsystem      |  Module      |                  Code                         |
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ *
+ * In this file, subsystem is "SUBSYS_COMMON" and module is "MODULE_TIMER".
+ */
+
+using ErrCode = int;
+
+// offset of timer module error, only be used in this file.
+constexpr ErrCode COMMON_TIMER_ERR_OFFSET = ErrCodeOffset(SUBSYS_COMMON, MODULE_TIMER);
+
+enum {
+    TIMER_ERR_OK                = 0,
+    TIMER_ERR_DEAL_FAILED       = COMMON_TIMER_ERR_OFFSET + EAGAIN,
+    TIMER_ERR_BADF              = COMMON_TIMER_ERR_OFFSET + EBADF,
+    TIMER_ERR_INVALID_VALUE     = COMMON_TIMER_ERR_OFFSET + EINVAL
+};
+
+} // Utils
+} // OHOS
+
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/utils/datetime_ex.h b/ohos_ndk_aosp/includes/utils/datetime_ex.h
new file mode 100755
index 0000000000..e37cc9aa46
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/datetime_ex.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DATETIME_EX_H
+#define DATETIME_EX_H
+
+#include <ctime>
+#include <cstdint>
+namespace OHOS {
+
+constexpr int64_t SEC_TO_NANOSEC = 1000000000;
+constexpr int64_t SEC_TO_MICROSEC = 1000000;
+constexpr int64_t SEC_TO_MILLISEC = 1000;
+constexpr int64_t MILLISEC_TO_NANOSEC = 1000000;
+constexpr int64_t MICROSEC_TO_NANOSEC = 1000;
+
+constexpr int SECONDS_PER_HOUR = 3600; // 60 * 60
+constexpr int SECONDS_PER_DAY = 86400; // 60 * 60 * 24
+
+static constexpr inline int64_t SecToNanosec(int64_t sec)
+{
+    return sec * SEC_TO_NANOSEC;
+}
+
+static constexpr inline int64_t MillisecToNanosec(int64_t millise)
+{
+    return millise * MILLISEC_TO_NANOSEC;
+}
+
+static constexpr inline int64_t MicrosecToNanosec(int64_t microsec)
+{
+    return microsec * MICROSEC_TO_NANOSEC;
+}
+
+static constexpr inline int64_t NanosecToSec(int64_t nanosec)
+{
+    return nanosec / SEC_TO_NANOSEC;
+}
+
+static constexpr inline int64_t NanosecToMillisec(int64_t nanosec)
+{
+    return nanosec / MILLISEC_TO_NANOSEC;
+}
+
+static constexpr inline int64_t NanosecToMicrosec(int64_t nanosec)
+{
+    return nanosec / MICROSEC_TO_NANOSEC;
+}
+
+/**
+ * The GetSecondsSince1970ToNow function get seconds from 1970 to now
+ */
+int64_t GetSecondsSince1970ToNow();
+
+/**
+ * The GetSecondsSince1970ToPointTime function get seconds from 1970 to inputtime
+ */
+int64_t GetSecondsSince1970ToPointTime(struct tm inputTm);
+
+/**
+ * The GetSecondsBetween function get seconds between inputTm1 and inputTm2.
+ */
+int64_t GetSecondsBetween(struct tm inputTm1, struct tm inputTm2);
+
+/**
+ * The GetDaysSince1970ToNow function get days from 1970 to now.
+ */
+int64_t GetDaysSince1970ToNow();
+
+/**
+ * The GetLocalTimeZone function get current timezone,
+ * return true if get success, else false.
+ */
+bool GetLocalTimeZone(int& timezone);
+
+/**
+* The GetSystemCurrentTime function get current time,
+* return true if get success, else false.
+*/
+bool GetSystemCurrentTime(struct tm* curTime);
+
+/**
+* The GetTickCount function get current milliseconds since the system was started.
+*/
+int64_t GetTickCount();
+
+/**
+* The GetMicroTickCount function get current microseconds since the system was started.
+*/
+int64_t GetMicroTickCount();
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/utils/directory_ex.h b/ohos_ndk_aosp/includes/utils/directory_ex.h
new file mode 100755
index 0000000000..3721cb6fa2
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/directory_ex.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DIRECTORY_EX_H
+#define DIRECTORY_EX_H
+
+#include <string>
+#include <vector>
+#include <sys/stat.h>
+
+namespace OHOS {
+
+/**
+ * The GetCurrentProcFullFileName function get the current process exe name.
+ */
+std::string GetCurrentProcFullFileName();
+
+/**
+ * The GetCurrentProcPath function get the current process exe path.
+ */
+std::string GetCurrentProcPath();
+
+/**
+ * The ExtractFilePath function extract the input file path.
+ */
+std::string ExtractFilePath(const std::string& fileFullName);
+
+/**
+ * The ExtractFilePath function extract the input file name.
+ */
+std::string ExtractFileName(const std::string& fileFullName);
+
+/**
+ * The ExtractFileExt function extract the input file name type.
+ */
+std::string ExtractFileExt(const std::string& fileName);
+
+/**
+ * The ExcludeTrailingPathDelimiter function exclude the end '/' from the strPath,
+ * return the path without the end '/'.
+ */
+std::string ExcludeTrailingPathDelimiter(const std::string& path);
+
+/**
+ * The IncludeTrailingPathDelimiter function include the end '/' from the strPath,
+ * return the path with the end '/'.
+ */
+std::string IncludeTrailingPathDelimiter(const std::string& path);
+
+/**
+ * The GetDirFiles function get all files in the path.
+ */
+void GetDirFiles(const std::string& path, std::vector<std::string>& files);
+
+/**
+ * The IsEmptyFolder function judge the path is empty,
+ * return true if is empty, else false.
+ */
+bool IsEmptyFolder(const std::string& path);
+
+/**
+ * The ForceCreateDirectory function is force create the dir with subdir,
+ * return true if create succ, else false.
+ */
+bool ForceCreateDirectory(const std::string& path);
+
+/**
+ * The ForceRemoveDirectory function is force delete the dir with subdir and files,
+ * return true if remove succ, else false.
+ */
+bool ForceRemoveDirectory(const std::string& path);
+
+/**
+ * The RemoveFile function is remove the input strFileName,
+ * return true if remove succ, else false.
+ */
+bool RemoveFile(const std::string& fileName);
+
+/**
+ * The GetFolderSize function is get the folder size(bytes).
+ */
+uint64_t GetFolderSize(const std::string& path);
+
+/**
+ * The ChangeModeFile function is change the input file authority,
+ * return true if change succ,  else false.
+ */
+bool ChangeModeFile(const std::string& fileName, const mode_t& mode);
+
+/**
+ * The ChangeModeDirectory function is change the input Directory authority, include subdir,
+ * return true if change succ,  else false.
+ */
+bool ChangeModeDirectory(const std::string& path, const mode_t& mode);
+
+/**
+* The PathToRealPath function is get real path from relative path,
+* return true if change succ, else false.
+*/
+bool PathToRealPath(const std::string& path, std::string& realPath);
+} // OHOS
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/utils/errors.h b/ohos_ndk_aosp/includes/utils/errors.h
new file mode 100755
index 0000000000..305bb10c05
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/errors.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_ERRORS_H
+#define UTILS_BASE_ERRORS_H
+
+#include <errno.h>
+
+namespace OHOS {
+
+/**
+ * ErrCode layout
+ *
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * | Bit |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * |Field|Reserved|        Subsystem      |  Module      |                  Code                         |
+ * +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ */
+
+using ErrCode = int;
+
+enum {
+    SUBSYS_COMMON                = 0,
+    SUBSYS_AAFWK                 = 1,
+    SUBSYS_ACCOUNT               = 2,
+    SUBSYS_AI                    = 3,
+    SUBSYS_APPEXECFWK            = 4,
+    SUBSYS_APPLICATIONS          = 5,
+    SUBSYS_ARVR                  = 6,
+    SUBSYS_ARVRHARDWARE          = 7,
+    SUBSYS_BARRIERFREE           = 8,
+    SUBSYS_BIOMETRICS            = 9,
+    SUBSYS_CCRUNTIME             = 10,
+    SUBSYS_COMMUNICATION         = 11,
+    SUBSYS_DFX                   = 12,
+    SUBSYS_DISTRIBUTEDDATAMNG    = 13,
+    SUBSYS_DISTRIBUTEDSCHEDULE   = 14,
+    SUBSYS_DRIVERS               = 15,
+    SUBSYS_GLOBAL                = 16,
+    SUBSYS_GRAPHIC               = 17,
+    SUBSYS_HBS                   = 18,
+    SUBSYS_IAWARE                = 19,
+    SUBSYS_IDE                   = 20,
+    SUBSYS_INTELLIACCESSORIES    = 21,
+    SUBSYS_INTELLISPEAKER        = 22,
+    SUBSYS_INTELLITV             = 23,
+    SUBSYS_IOT                   = 24,
+    SUBSYS_IOTHARDWARE           = 25,
+    SUBSYS_IVIHARDWARE           = 26,
+    SUBSYS_KERNEL                = 27,
+    SUBSYS_LOCATION              = 28,
+    SUBSYS_MSDP                  = 29,
+    SUBSYS_MULTIMEDIA            = 30,
+    SUBSYS_MULTIMODAINPUT        = 31,
+    SUBSYS_NOTIFICATION          = 32,
+    SUBSYS_POWERMNG              = 33,
+    SUBSYS_ROUTER                = 34,
+    SUBSYS_SECURITY              = 35,
+    SUBSYS_SENSORS               = 36,
+    SUBSYS_SMALLSERVICES         = 37,
+    SUBSYS_SOURCECODETRANSFORMER = 38,
+    SUBSYS_STARTUP               = 39,
+    SUBSYS_TELEPONY              = 40,
+    SUBSYS_UPDATE                = 41,
+    SUBSYS_USB                   = 42,
+    SUBSYS_WEARABLE              = 43,
+    SUBSYS_WEARABLEHARDWARE      = 44,
+    SUBSYS_IVI                   = 45,
+    SUBSYS_DISTRIBUTEDHARDWARE   = 46,
+    SUBSYS_DEVICEPROFILE         = 47
+    // new type
+};
+
+// be used to init the subsystem errorno.
+constexpr ErrCode ErrCodeOffset(unsigned int subsystem, unsigned int module = 0)
+{
+    constexpr int SUBSYSTEM_BIT_NUM = 21;
+    constexpr int MODULE_BIT_NUM = 16;
+    return (subsystem << SUBSYSTEM_BIT_NUM) | (module << MODULE_BIT_NUM);
+}
+
+// offset of common error, only be used in this file.
+constexpr ErrCode BASE_ERR_OFFSET = ErrCodeOffset(SUBSYS_COMMON);
+
+enum {
+    ERR_OK                = 0,
+    ERR_NO_MEMORY         = BASE_ERR_OFFSET + ENOMEM,
+    ERR_INVALID_OPERATION = BASE_ERR_OFFSET + ENOSYS,
+    ERR_INVALID_VALUE     = BASE_ERR_OFFSET + EINVAL,
+    ERR_NAME_NOT_FOUND    = BASE_ERR_OFFSET + ENOENT,
+    ERR_PERMISSION_DENIED = BASE_ERR_OFFSET + EPERM,
+    ERR_NO_INIT           = BASE_ERR_OFFSET + ENODEV,
+    ERR_ALREADY_EXISTS    = BASE_ERR_OFFSET + EEXIST,
+    ERR_DEAD_OBJECT       = BASE_ERR_OFFSET + EPIPE,
+    ERR_OVERFLOW          = BASE_ERR_OFFSET + EOVERFLOW,
+    ERR_ENOUGH_DATA       = BASE_ERR_OFFSET + ENODATA,
+    ERR_WOULD_BLOCK       = BASE_ERR_OFFSET + EWOULDBLOCK,
+    ERR_TIMED_OUT         = BASE_ERR_OFFSET + ETIMEDOUT
+};
+
+#define SUCCEEDED(errCode) ((errCode) == ERR_OK)
+#define FAILED(errCode) ((errCode) != ERR_OK)
+
+}
+
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/file_ex.h b/ohos_ndk_aosp/includes/utils/file_ex.h
new file mode 100644
index 0000000000..d9de3077e1
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/file_ex.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_FILE_EX_H
+#define UTILS_BASE_FILE_EX_H
+
+#include <string>
+#include <vector>
+
+namespace OHOS {
+
+bool LoadStringFromFile(const std::string& filePath, std::string& content);
+bool SaveStringToFile(const std::string& filePath, const std::string& content, bool truncated = true);
+bool LoadStringFromFd(int fd, std::string& content);
+bool SaveStringToFd(int fd, const std::string& content);
+bool LoadBufferFromFile(const std::string& filePath, std::vector<char>& content);
+bool SaveBufferToFile(const std::string& filePath, const std::vector<char>& content, bool truncated = true);
+bool FileExists(const std::string& fileName);
+bool StringExistsInFile(const std::string& fileName, const std::string& subStr, bool caseSensitive = true);
+int  CountStrInFile(const std::string& fileName, const std::string& subStr, bool caseSensitive = true);
+
+}
+
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/flat_obj.h b/ohos_ndk_aosp/includes/utils/flat_obj.h
new file mode 100755
index 0000000000..771a7c236e
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/flat_obj.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_FLAT_OBJ_H
+#define UTILS_BASE_FLAT_OBJ_H
+
+#include <sys/types.h>
+#include <linux/types.h>
+
+#ifdef BINDER_IPC_32BIT
+    typedef __u32 binder_size_t;
+    typedef __u32 binder_uintptr_t;
+#else
+    typedef __u64 binder_size_t;
+    typedef __u64 binder_uintptr_t;
+#endif
+
+struct parcel_binder_object_header {
+    __u32 type;
+};
+struct parcel_flat_binder_object {
+    struct parcel_binder_object_header hdr;
+    __u32 flags;
+    union {
+        binder_uintptr_t binder;
+        __u32 handle;
+    };
+    binder_uintptr_t cookie;
+};
+
+#endif
\ No newline at end of file
diff --git a/ohos_ndk_aosp/includes/utils/nocopyable.h b/ohos_ndk_aosp/includes/utils/nocopyable.h
new file mode 100644
index 0000000000..626451aa57
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/nocopyable.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_NOCOPYABLE_H
+#define UTILS_BASE_NOCOPYABLE_H
+
+namespace OHOS {
+
+#define DISALLOW_COPY_AND_MOVE(className)\
+    DISALLOW_COPY(className);\
+    DISALLOW_MOVE(className)
+
+#define DISALLOW_COPY(className)\
+    className(const className&) = delete;\
+    className& operator= (const className&) = delete
+
+#define DISALLOW_MOVE(className)\
+    className(className&&) = delete;\
+    className& operator= (className&&) = delete
+
+
+class NoCopyable {
+protected:
+    NoCopyable() {};
+    virtual ~NoCopyable() {};
+
+private:
+    DISALLOW_COPY_AND_MOVE(NoCopyable);
+};
+
+}
+
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/observer.h b/ohos_ndk_aosp/includes/utils/observer.h
new file mode 100644
index 0000000000..13e66830fe
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/observer.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_OBSERVER_H
+#define UTILS_BASE_OBSERVER_H
+
+#include <memory>
+#include <vector>
+#include <set>
+#include <mutex>
+
+namespace OHOS {
+
+
+struct ObserverArg {
+public:
+    virtual ~ObserverArg() = default;
+};
+
+class Observer;
+class Observable {
+public:
+    virtual ~Observable() = default;
+    void AddObserver(const std::shared_ptr<Observer>& o);
+    void RemoveObserver(const std::shared_ptr<Observer>& o);
+    void RemoveAllObservers();
+    void NotifyObservers();
+    void NotifyObservers(const ObserverArg* arg);
+    int GetObserversCount();
+
+protected:
+    bool HasChanged();
+    void SetChanged();
+    void ClearChanged();
+
+protected:
+    std::set<std::shared_ptr<Observer>> obs;
+    std::mutex mutex_;
+
+private:
+    bool changed_ = false;
+};
+
+class Observer {
+public:
+    virtual ~Observer() = default;
+    virtual void Update(const Observable* o, const ObserverArg* arg) = 0;
+};
+
+
+}
+
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/parcel.h b/ohos_ndk_aosp/includes/utils/parcel.h
new file mode 100755
index 0000000000..3f752d548a
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/parcel.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_UTILS_PARCEL_H
+#define OHOS_UTILS_PARCEL_H
+
+#include <string>
+#include <vector>
+#include "nocopyable.h"
+#include "refbase.h"
+#include "flat_obj.h"
+
+namespace OHOS {
+
+class Parcel;
+
+class Parcelable : public virtual RefBase {
+public:
+    virtual ~Parcelable() = default;
+
+    Parcelable();
+    explicit Parcelable(bool asRemote);
+
+    // Write a parcelable object to the given parcel.
+    // The object position is saved into Parcel if set asRemote_ to
+    // true, and this intends to use in kernel data transaction.
+    // Returns true being written on success or false if any error occur.
+    virtual bool Marshalling(Parcel &parcel) const = 0;
+
+    // NOTICE! A static Unmarshalling function must also be implemented, so
+    // that you can get data from the given parcel into this parcelable object.
+    // See "static TestParcelable *Unmarshalling(Parcel &parcel)" as an example.
+
+    enum BehaviorFlag { IPC = 0x01, RPC = 0x02, HOLD_OBJECT = 0x10 };
+
+    inline void SetBehavior(BehaviorFlag b) const
+    {
+        behavior_ |= static_cast<uint8_t>(b);
+    }
+
+    inline void ClearBehavior(BehaviorFlag b) const
+    {
+        behavior_ &= ~(static_cast<uint8_t>(b));
+    }
+
+    inline bool TestBehavior(BehaviorFlag b) const
+    {
+        return behavior_ & (static_cast<uint8_t>(b));
+    }
+
+public:
+    bool asRemote_;
+    mutable uint8_t behavior_;
+};
+
+class Allocator {
+public:
+    virtual ~Allocator() = default;
+
+    virtual void *Realloc(void *data, size_t newSize) = 0;
+
+    virtual void *Alloc(size_t size) = 0;
+
+    virtual void Dealloc(void *data) = 0;
+};
+
+class DefaultAllocator : public Allocator {
+public:
+    virtual void *Alloc(size_t size) override;
+
+    virtual void Dealloc(void *data) override;
+private:
+    virtual void *Realloc(void *data, size_t newSize) override;
+};
+
+class Parcel {
+public:
+    Parcel();
+    explicit Parcel(Allocator *allocator);
+
+    virtual ~Parcel();
+
+    size_t GetDataSize() const;
+
+    uintptr_t GetData() const;
+
+    binder_size_t GetObjectOffsets() const;
+
+    size_t GetOffsetsSize() const;
+
+    size_t GetWritableBytes() const;
+
+    size_t GetReadableBytes() const;
+
+    size_t GetDataCapacity() const;
+
+    bool SetDataCapacity(size_t newCapacity);
+
+    bool SetDataSize(size_t dataSize);
+
+    bool SetMaxCapacity(size_t maxCapacity);
+
+    bool WriteBool(bool value);
+
+    bool WriteInt8(int8_t value);
+
+    bool WriteInt16(int16_t value);
+
+    bool WriteInt32(int32_t value);
+
+    bool WriteInt64(int64_t value);
+
+    bool WriteUint8(uint8_t value);
+
+    bool WriteUint16(uint16_t value);
+
+    bool WriteUint32(uint32_t value);
+
+    bool WriteUint64(uint64_t value);
+
+    bool WriteFloat(float value);
+
+    bool WriteDouble(double value);
+
+    bool WritePointer(uintptr_t value);
+
+    bool WriteBuffer(const void *data, size_t size);
+
+    bool WriteBufferAddTerminator(const void *data, size_t size, size_t typeSize);
+
+    bool WriteUnpadBuffer(const void *data, size_t size);
+
+    bool WriteCString(const char *value);
+
+    bool WriteString(const std::string &value);
+
+    bool WriteString16(const std::u16string &value);
+
+    bool WriteString16WithLength(const char16_t *value, size_t len);
+
+    bool WriteString8WithLength(const char *value, size_t len);
+
+    bool WriteParcelable(const Parcelable *object);
+
+    bool WriteStrongParcelable(const sptr<Parcelable> &object);
+
+    bool WriteRemoteObject(const Parcelable *object);
+
+    template<typename T>
+    bool WriteObject(const sptr<T> &object);
+
+    bool ParseFrom(uintptr_t data, size_t size);
+
+    bool ReadBool();
+
+    int8_t ReadInt8();
+
+    int16_t ReadInt16();
+
+    int32_t ReadInt32();
+
+    int64_t ReadInt64();
+
+    uint8_t ReadUint8();
+
+    uint16_t ReadUint16();
+
+    uint32_t ReadUint32();
+
+    uint64_t ReadUint64();
+
+    float ReadFloat();
+
+    double ReadDouble();
+
+    uintptr_t ReadPointer();
+
+    bool ReadBool(bool &value);
+
+    bool ReadInt8(int8_t &value);
+
+    bool ReadInt16(int16_t &value);
+
+    bool ReadInt32(int32_t &value);
+
+    bool ReadInt64(int64_t &value);
+
+    bool ReadUint8(uint8_t &value);
+
+    bool ReadUint16(uint16_t &value);
+
+    bool ReadUint32(uint32_t &value);
+
+    bool ReadUint64(uint64_t &value);
+
+    bool ReadFloat(float &value);
+
+    bool ReadDouble(double &value);
+
+    const uint8_t *ReadBuffer(size_t length);
+
+    const uint8_t *ReadUnpadBuffer(size_t length);
+
+    void SkipBytes(size_t bytes);
+
+    const char *ReadCString();
+
+    const std::string ReadString();
+
+    bool ReadString(std::string &value);
+
+    const std::u16string ReadString16();
+
+    bool ReadString16(std::u16string &value);
+
+    const std::u16string ReadString16WithLength(int32_t &len);
+
+    const std::string ReadString8WithLength(int32_t &len);
+
+    bool RewindRead(size_t newPosition);
+
+    bool RewindWrite(size_t offsets);
+
+    size_t GetReadPosition();
+
+    size_t GetWritePosition();
+
+    template <typename T>
+    T *ReadParcelable();
+
+    template <typename T>
+    sptr<T> ReadStrongParcelable();
+
+    bool CheckOffsets();
+
+    template<typename T>
+    sptr<T> ReadObject();
+
+    bool SetAllocator(Allocator *allocator);
+
+    void InjectOffsets(binder_size_t offsets, size_t offsetSize);
+
+    void FlushBuffer();
+
+    template <typename T1, typename T2>
+    bool WriteVector(const std::vector<T1> &val, bool (Parcel::*Write)(T2));
+    bool WriteBoolVector(const std::vector<bool> &val);
+    bool WriteInt8Vector(const std::vector<int8_t> &val);
+    bool WriteInt16Vector(const std::vector<int16_t> &val);
+    bool WriteInt32Vector(const std::vector<int32_t> &val);
+    bool WriteInt64Vector(const std::vector<int64_t> &val);
+    bool WriteUInt8Vector(const std::vector<uint8_t> &val);
+    bool WriteUInt16Vector(const std::vector<uint16_t> &val);
+    bool WriteUInt32Vector(const std::vector<uint32_t> &val);
+    bool WriteUInt64Vector(const std::vector<uint64_t> &val);
+    bool WriteFloatVector(const std::vector<float> &val);
+    bool WriteDoubleVector(const std::vector<double> &val);
+    bool WriteStringVector(const std::vector<std::string> &val);
+    bool WriteString16Vector(const std::vector<std::u16string> &val);
+
+    template <typename T>
+    bool ReadVector(std::vector<T> *val, bool (Parcel::*Read)(T &));
+    bool ReadBoolVector(std::vector<bool> *val);
+    bool ReadInt8Vector(std::vector<int8_t> *val);
+    bool ReadInt16Vector(std::vector<int16_t> *val);
+    bool ReadInt32Vector(std::vector<int32_t> *val);
+    bool ReadInt64Vector(std::vector<int64_t> *val);
+    bool ReadUInt8Vector(std::vector<uint8_t> *val);
+    bool ReadUInt16Vector(std::vector<uint16_t> *val);
+    bool ReadUInt32Vector(std::vector<uint32_t> *val);
+    bool ReadUInt64Vector(std::vector<uint64_t> *val);
+    bool ReadFloatVector(std::vector<float> *val);
+    bool ReadDoubleVector(std::vector<double> *val);
+    bool ReadStringVector(std::vector<std::string> *val);
+    bool ReadString16Vector(std::vector<std::u16string> *val);
+
+    bool WriteBoolUnaligned(bool value);
+    bool WriteInt8Unaligned(int8_t value);
+    bool WriteInt16Unaligned(int16_t value);
+    bool WriteUint8Unaligned(uint8_t value);
+    bool WriteUint16Unaligned(uint16_t value);
+
+    bool ReadBoolUnaligned();
+    bool ReadInt8Unaligned(int8_t &value);
+    bool ReadInt16Unaligned(int16_t &value);
+    bool ReadUint8Unaligned(uint8_t &value);
+    bool ReadUint16Unaligned(uint16_t &value);
+
+private:
+    DISALLOW_COPY_AND_MOVE(Parcel);
+    template <typename T>
+    bool Write(T value);
+
+    template <typename T>
+    bool Read(T &value);
+
+    template <typename T>
+    T Read();
+
+    template <typename T>
+    bool ReadPadded(T &value);
+
+    inline size_t GetPadSize(size_t size)
+    {
+        const int SIZE_OFFSET = 3;
+        return (((size + SIZE_OFFSET) & (~SIZE_OFFSET)) - size);
+    }
+
+    bool WriteObjectOffset(binder_size_t offset);
+
+    size_t CalcNewCapacity(size_t minCapacity);
+
+    bool WriteDataBytes(const void *data, size_t size);
+
+    void WritePadBytes(size_t padded);
+
+    bool EnsureWritableCapacity(size_t desireCapacity);
+
+    bool EnsureObjectsCapacity();
+
+    bool WriteParcelableOffset(size_t offset);
+
+private:
+    uint8_t *data_;
+    size_t readCursor_;
+    size_t writeCursor_;
+    size_t dataSize_;
+    size_t dataCapacity_;
+    size_t maxDataCapacity_;
+    binder_size_t *objectOffsets_;
+    size_t objectCursor_;
+    size_t objectsCapacity_;
+    Allocator *allocator_;
+    std::vector<sptr<Parcelable>> objectHolder_;
+    bool writable_ = true;
+};
+
+template <typename T>
+bool Parcel::WriteObject(const sptr<T> &object)
+{
+    if (object == nullptr) {
+        return T::Marshalling(*this, object);
+    }
+    return WriteRemoteObject(object.GetRefPtr());
+}
+
+template <typename T>
+sptr<T> Parcel::ReadObject()
+{
+    if (!this->CheckOffsets()) {
+        return nullptr;
+    }
+    return T::Unmarshalling(*this);
+}
+
+// Read data from the given parcel into this parcelable object.
+template <typename T>
+T *Parcel::ReadParcelable()
+{
+    int32_t size = this->ReadInt32();
+    if (size == 0) {
+        return nullptr;
+    }
+
+    return T::Unmarshalling(*this);
+}
+
+// Read data from the given parcel into this parcelable object, return sptr.
+template <typename T>
+sptr<T> Parcel::ReadStrongParcelable()
+{
+    int32_t size = this->ReadInt32();
+    if (size == 0) {
+        return nullptr;
+    }
+
+    return T::Unmarshalling(*this);
+}
+
+} // namespace OHOS
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/pubdef.h b/ohos_ndk_aosp/includes/utils/pubdef.h
new file mode 100755
index 0000000000..ebfdcab8b4
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/pubdef.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_PUBDEF_H
+#define UTILS_BASE_PUBDEF_H
+
+namespace OHOS {
+
+#define B_TO_M(b) ((b) / 1024 / 1024)
+#define M_TO_B(m) ((m) * 1024 * 1024)
+#define B_TO_K(b) ((b) / 1024)
+#define K_TO_B(m) ((m) * 1024)
+
+#define HOUR_TO_SECOND(h) ((h) * 3600)
+#define SECOND_TO_HOUR(s) ((s) / 3600)
+
+#define ARRAY_SIZE(a) (sizeof((a)) / sizeof((a[0])))
+
+#define FREE_AND_NIL(p) do { if (p) { delete (p); (p) = nullptr; } } while(0)
+#define FREE_AND_NIL_ARRAY(p) do { if (p) { delete[] (p); (p) = nullptr; } } while(0)
+
+#define MAX(x, y)  (((x) > (y)) ? (x) : (y))
+#define MIN(x, y)  (((x) < (y)) ? (x) : (y))
+
+#define EPS (1e-8)
+#define EQUAL_TO_ZERO(x) (fabs(x) <= (EPS))
+
+// Used to retry syscalls that can return EINTR.
+#ifndef TEMP_FAILURE_RETRY
+#define TEMP_FAILURE_RETRY(exp)            \
+    ({                                     \
+    decltype(exp) _rc;                     \
+    do {                                   \
+        _rc = (exp);                       \
+    } while ((_rc == -1) && (errno == EINTR)); \
+    _rc;                                   \
+    })
+#endif
+}
+
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/refbase.h b/ohos_ndk_aosp/includes/utils/refbase.h
new file mode 100755
index 0000000000..4c4c24b3cf
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/refbase.h
@@ -0,0 +1,704 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_REFBASE_H
+#define UTILS_BASE_REFBASE_H
+
+#include <atomic>
+#include <functional>
+
+namespace OHOS {
+
+#define INITIAL_PRIMARY_VALUE (1 << 28)
+
+class RefBase;
+
+class RefCounter {
+public:
+    using RefPtrCallback = std::function<void()>;
+    friend class RefBase;
+
+    RefCounter();
+
+    explicit RefCounter(RefCounter *counter);
+
+    RefCounter &operator=(const RefCounter &counter);
+
+    virtual ~RefCounter();
+
+    void SetCallback(const RefPtrCallback& callback);
+
+    void RemoveCallback();
+
+    int GetRefCount();
+
+    void IncRefCount();
+
+    void DecRefCount();
+
+    bool IsRefPtrValid();
+
+    int IncStrongRefCount(const void *objectId);
+
+    int DecStrongRefCount(const void *objectId);
+
+    int GetStrongRefCount();
+
+    int IncWeakRefCount(const void *objectId);
+
+    int DecWeakRefCount(const void *objectId);
+
+    int GetWeakRefCount();
+
+    void SetAttemptAcquire();
+
+    bool IsAttemptAcquireSet();
+
+    void ClearAttemptAcquire();
+
+    bool AttemptIncStrongRef(const void *objectId, int &outCount);
+
+    bool IsLifeTimeExtended();
+
+    void ExtendObjectLifetime();
+
+private:
+    std::atomic<int> atomicStrong_;
+    std::atomic<int> atomicWeak_;
+    std::atomic<int> atomicRefCount_;
+    std::atomic<unsigned int> atomicFlags_;
+    std::atomic<int> atomicAttempt_;
+    RefPtrCallback callback_ = nullptr;
+    static constexpr unsigned int FLAG_EXTEND_LIFE_TIME = 0x00000002;
+};
+
+class WeakRefCounter {
+public:
+    WeakRefCounter(RefCounter *base, void *cookie);
+
+    virtual ~WeakRefCounter();
+
+    void *GetRefPtr();
+
+    void IncWeakRefCount(const void *objectId);
+
+    void DecWeakRefCount(const void *objectId);
+
+    bool AttemptIncStrongRef(const void *objectId);
+
+private:
+    std::atomic<int> atomicWeak_;
+    RefCounter *refCounter_ = nullptr;
+    void *cookie_ = nullptr;
+};
+
+class RefBase {
+public:
+    RefBase();
+
+    RefBase(const RefBase &refbase);
+
+    RefBase &operator=(const RefBase &refbase);
+
+    RefBase(RefBase &&refbase) noexcept;
+
+    RefBase &operator=(RefBase &&refbase) noexcept;
+
+    virtual ~RefBase();
+
+    virtual void RefPtrCallback();
+
+    void ExtendObjectLifetime();
+
+    void IncStrongRef(const void *objectId);
+
+    void DecStrongRef(const void *objectId);
+
+    int GetSptrRefCount();
+
+    WeakRefCounter *CreateWeakRef(void *cookie);
+
+    void IncWeakRef(const void *objectId);
+
+    void DecWeakRef(const void *objectId);
+
+    int GetWptrRefCount();
+
+    bool AttemptAcquire(const void *objectId);
+
+    bool AttemptIncStrongRef(const void *objectId);
+
+    bool IsAttemptAcquireSet();
+
+    bool IsExtendLifeTimeSet();
+
+    virtual void OnFirstStrongRef(const void *objectId);
+
+    virtual void OnLastStrongRef(const void *objectId);
+
+    virtual void OnLastWeakRef(const void *objectId);
+
+    virtual bool OnAttemptPromoted(const void *objectId);
+
+private:
+    RefCounter *refs_ = nullptr;
+};
+
+template <typename T>
+class wptr;
+
+template <typename T>
+
+class sptr {
+    friend class wptr<T>;
+
+public:
+    sptr();
+
+    ~sptr();
+
+    sptr(T *other);
+
+    sptr(const sptr<T> &other);
+
+    sptr(sptr<T> &&other);
+
+    sptr<T> &operator=(sptr<T> &&other);
+
+    template <typename O>
+    sptr(const sptr<O> &other);
+
+    inline sptr(WeakRefCounter *p, bool force);
+
+    inline T *GetRefPtr() const
+    {
+        return refs_;
+    }
+
+    inline void ForceSetRefPtr(T *other);
+
+    void clear();
+
+    inline operator T *() const
+    {
+        return refs_;
+    }
+
+    inline T &operator*() const
+    {
+        return *refs_;
+    }
+
+    inline T *operator->() const
+    {
+        return refs_;
+    }
+
+    inline bool operator!() const
+    {
+        return refs_ == nullptr;
+    }
+
+    sptr<T> &operator=(T *other);
+
+    sptr<T> &operator=(const sptr<T> &other);
+
+    sptr<T> &operator=(const wptr<T> &other);
+
+    template <typename O>
+    sptr<T> &operator=(const sptr<O> &other);
+
+    bool operator==(const T *other) const;
+
+    inline bool operator!=(const T *other) const
+    {
+        return !operator==(other);
+    }
+
+    bool operator==(const wptr<T> &other) const;
+
+    inline bool operator!=(const wptr<T> &other) const
+    {
+        return !operator==(other);
+    }
+
+    bool operator==(const sptr<T> &other) const;
+
+    inline bool operator!=(const sptr<T> &other) const
+    {
+        return !operator==(other);
+    }
+
+private:
+    T *refs_ = nullptr;
+};
+
+template <typename T>
+inline void sptr<T>::ForceSetRefPtr(T *other)
+{
+    refs_ = other;
+}
+
+template <typename T>
+inline sptr<T>::sptr()
+{
+    refs_ = nullptr;
+}
+
+template <typename T>
+inline sptr<T>::sptr(T *other)
+{
+    refs_ = other;
+    if (refs_ != nullptr) {
+        refs_->IncStrongRef(this);
+    }
+}
+
+template <typename T>
+inline sptr<T>::sptr(const sptr<T> &other)
+{
+    refs_ = other.GetRefPtr();
+    if (refs_ != nullptr) {
+        refs_->IncStrongRef(this);
+    }
+}
+
+template <typename T>
+sptr<T>::sptr(sptr<T> &&other)
+{
+    refs_ = other.GetRefPtr();
+    other.ForceSetRefPtr(nullptr);
+}
+
+template <typename T>
+sptr<T> &sptr<T>::operator=(sptr<T> &&other)
+{
+    if (refs_ != nullptr) {
+        refs_->DecStrongRef(this);
+    }
+    refs_ = other.GetRefPtr();
+    other.ForceSetRefPtr(nullptr);
+    return *this;
+}
+
+template <typename T>
+template <typename O>
+sptr<T>::sptr(const sptr<O> &other) : refs_(other.GetRefPtr())
+{
+    if (refs_ != nullptr) {
+        refs_->IncStrongRef(this);
+    }
+}
+
+template <typename T>
+inline sptr<T> &sptr<T>::operator=(T *other)
+{
+    if (other != nullptr) {
+        other->IncStrongRef(this);
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecStrongRef(this);
+    }
+
+    refs_ = other;
+    return *this;
+}
+
+template <typename T>
+inline sptr<T> &sptr<T>::operator=(const sptr<T> &other)
+{
+    T *otherRef(other.GetRefPtr());
+    if (otherRef != nullptr) {
+        otherRef->IncStrongRef(this);
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecStrongRef(this);
+    }
+
+    refs_ = otherRef;
+    return *this;
+}
+
+template <typename T>
+inline sptr<T> &sptr<T>::operator=(const wptr<T> &other)
+{
+    if (refs_ != nullptr) {
+        refs_->DecStrongRef(this);
+    }
+    if ((other != nullptr) && other.AttemptIncStrongRef(this)) {
+        refs_ = other.GetRefPtr();
+    } else {
+        refs_ = nullptr;
+    }
+
+    return *this;
+}
+
+template <typename T>
+template <typename O>
+sptr<T> &sptr<T>::operator=(const sptr<O> &other)
+{
+    T *otherRef(other.GetRefPtr());
+    if (otherRef != nullptr) {
+        otherRef->IncStrongRef(this);
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecStrongRef(this);
+    }
+
+    refs_ = otherRef;
+    return *this;
+}
+
+template <typename T>
+inline bool sptr<T>::operator==(const T *other) const
+{
+    return other == refs_;
+}
+
+template <typename T>
+inline bool sptr<T>::operator==(const wptr<T> &other) const
+{
+    return refs_ == other.GetRefPtr();
+}
+
+template <typename T>
+inline bool sptr<T>::operator==(const sptr<T> &other) const
+{
+    return refs_ == other.GetRefPtr();
+}
+
+template<typename T>
+void sptr<T>::clear()
+{
+    if (refs_) {
+        refs_->DecStrongRef(this);
+        refs_ = 0;
+    }
+}
+
+template <typename T>
+inline sptr<T>::~sptr()
+{
+    if (refs_ != nullptr) {
+        refs_->DecStrongRef(this);
+    }
+}
+
+template <typename T>
+inline sptr<T>::sptr(WeakRefCounter *p, bool /* force */)
+{
+    if ((p != nullptr) && p->AttemptIncStrongRef(this)) {
+        refs_ = reinterpret_cast<T *>(p->GetRefPtr());
+    } else {
+        refs_ = nullptr;
+    }
+}
+
+template <typename T>
+class wptr {
+    template <typename O>
+    friend class wptr;
+
+public:
+    wptr();
+
+    wptr(T *other);
+
+    wptr(const wptr<T> &other);
+
+    wptr(const sptr<T> &other);
+
+    template <typename O>
+    wptr(const wptr<O> &other);
+
+    template <typename O>
+    wptr(const sptr<O> &other);
+
+    wptr<T> &operator=(T *other);
+
+    template <typename O>
+    wptr<T> &operator=(O *other);
+
+    wptr<T> &operator=(const wptr<T> &other);
+
+    wptr<T> &operator=(const sptr<T> &other);
+
+    template <typename O>
+    wptr<T> &operator=(const wptr<O> &other);
+
+    template <typename O>
+    wptr<T> &operator=(const sptr<O> &other);
+
+    inline T *operator*() const
+    {
+        return *refs_;
+    }
+    inline T *operator->() const
+    {
+        return reinterpret_cast<T *>(refs_->GetRefPtr());
+    }
+
+    bool operator==(const T *other) const;
+
+    inline bool operator!=(const T *other) const
+    {
+        return !operator==(other);
+    };
+
+    bool operator==(const wptr<T> &other) const;
+
+    inline bool operator!=(const wptr<T> &other) const
+    {
+        return !operator==(other);
+    }
+
+    bool operator==(const sptr<T> &other) const;
+
+    inline bool operator!=(const sptr<T> &other) const
+    {
+        return !operator==(other);
+    }
+
+    T *GetRefPtr() const;
+
+    inline bool AttemptIncStrongRef(const void *objectId) const
+    {
+        return refs_->AttemptIncStrongRef(objectId);
+    }
+
+    const sptr<T> promote() const;
+
+    ~wptr();
+
+private:
+    WeakRefCounter *refs_ = nullptr;
+};
+
+template <typename T>
+inline T *wptr<T>::GetRefPtr() const
+{
+    return (refs_ != nullptr) ? reinterpret_cast<T *>(refs_->GetRefPtr()) : nullptr;
+}
+
+template <typename T>
+wptr<T>::wptr()
+{
+    refs_ = nullptr;
+}
+
+template <typename T>
+wptr<T>::wptr(T *other)
+{
+    if (other != nullptr) {
+        refs_ = other->CreateWeakRef(other);
+        if (refs_ != nullptr) {
+            refs_->IncWeakRefCount(this);
+        }
+    } else {
+        refs_ = nullptr;
+    }
+}
+
+template <typename T>
+wptr<T>::wptr(const wptr<T> &other)
+{
+    refs_ = other.refs_;
+    if (refs_ != nullptr) {
+        refs_->IncWeakRefCount(this);
+    }
+}
+
+template <typename T>
+wptr<T>::wptr(const sptr<T> &other)
+{
+    if (other.GetRefPtr() != nullptr) {
+        refs_ = other->CreateWeakRef(other.GetRefPtr());
+        if (refs_ != nullptr) {
+            refs_->IncWeakRefCount(this);
+        }
+    }
+}
+
+template <typename T>
+template <typename O>
+wptr<T>::wptr(const wptr<O> &other)
+{
+    refs_ = other.refs_;
+    if (refs_ != nullptr) {
+        refs_->IncWeakRefCount(this);
+    }
+}
+
+template <typename T>
+template <typename O>
+wptr<T>::wptr(const sptr<O> &other)
+{
+    if (other.GetRefPtr() != nullptr) {
+        refs_ = other->CreateWeakRef(other.GetRefPtr());
+        if (refs_ != nullptr) {
+            refs_->IncWeakRefCount(this);
+        }
+    }
+}
+
+template <typename T>
+wptr<T> &wptr<T>::operator=(T *other)
+{
+    WeakRefCounter *newWeakRef = nullptr;
+    if (other != nullptr) {
+        newWeakRef = other->CreateWeakRef(other);
+        if (newWeakRef != nullptr) {
+            newWeakRef->IncWeakRefCount(this);
+        }
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+
+    refs_ = newWeakRef;
+    return *this;
+}
+
+template <typename T>
+template <typename O>
+wptr<T> &wptr<T>::operator=(O *other)
+{
+    T *object = reinterpret_cast<T *>(other);
+    WeakRefCounter *newWeakRef = nullptr;
+    if (object != nullptr) {
+        newWeakRef = object->CreateWeakRef(object);
+        if (newWeakRef != nullptr) {
+            newWeakRef->IncWeakRefCount(this);
+        }
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+
+    refs_ = newWeakRef;
+    return *this;
+}
+
+template <typename T>
+inline wptr<T> &wptr<T>::operator=(const wptr<T> &other)
+{
+    if (other.refs_ != nullptr) {
+        other.refs_->IncWeakRefCount(this);
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+
+    refs_ = other.refs_;
+    return *this;
+}
+
+template <typename T>
+inline wptr<T> &wptr<T>::operator=(const sptr<T> &other)
+{
+    WeakRefCounter *newWeakRef = nullptr;
+    if (other.GetRefPtr() != nullptr) {
+        newWeakRef = other->CreateWeakRef(other.GetRefPtr());
+        if (newWeakRef != nullptr) {
+            newWeakRef->IncWeakRefCount(this);
+        }
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+
+    refs_ = newWeakRef;
+    return *this;
+}
+
+template <typename T>
+template <typename O>
+wptr<T> &wptr<T>::operator=(const wptr<O> &other)
+{
+    if (other.refs_ != nullptr) {
+        other.refs_->IncWeakRefCount(this);
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+
+    refs_ = other.refs_;
+    return *this;
+}
+
+template <typename T>
+template <typename O>
+wptr<T> &wptr<T>::operator=(const sptr<O> &other)
+{
+    WeakRefCounter *newWeakRef = nullptr;
+    if (other.GetRefPtr() != nullptr) {
+        newWeakRef = other->CreateWeakRef(other->GetRefPtr());
+        if (newWeakRef != nullptr) {
+            newWeakRef->IncWeakRefCount(this);
+        }
+    }
+
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+
+    refs_ = newWeakRef;
+    return *this;
+}
+
+template <typename T>
+inline bool wptr<T>::operator==(const T *other) const
+{
+    return GetRefPtr() == other;
+}
+
+template <typename T>
+inline bool wptr<T>::operator==(const wptr<T> &other) const
+{
+    return GetRefPtr() == other.GetRefPtr();
+}
+
+template <typename T>
+inline bool wptr<T>::operator==(const sptr<T> &other) const
+{
+    return GetRefPtr() == other.GetRefPtr();
+}
+
+template <typename T>
+inline const sptr<T> wptr<T>::promote() const
+{
+    return sptr<T>(refs_, true);
+}
+
+template <typename T>
+inline wptr<T>::~wptr()
+{
+    if (refs_ != nullptr) {
+        refs_->DecWeakRefCount(this);
+    }
+}
+
+} // namespace OHOS
+
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/rwlock.h b/ohos_ndk_aosp/includes/utils/rwlock.h
new file mode 100755
index 0000000000..b53b8637e9
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/rwlock.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_RWLOCK_H
+#define UTILS_RWLOCK_H
+
+#include <atomic>
+#include <thread>
+
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace Utils {
+
+class RWLock : NoCopyable {
+public:
+    enum LockStatus {
+        LOCK_STATUS_WRITE = -1,
+        LOCK_STATUS_FREE = 0,
+    };
+
+    RWLock() : RWLock(true) {}
+    explicit RWLock(bool writeFirst);
+    virtual ~RWLock() {}
+
+    void LockRead();
+    void UnLockRead();
+
+    void LockWrite();
+    void UnLockWrite();
+
+private:
+    bool writeFirst_;
+    std::thread::id writeThreadID_;
+
+    // Resource lock counter, -1 is write state, 0 is free state, and greater than 0 is shared read state
+    std::atomic_int lockCount_;
+
+    // Thread counter waiting for write lock
+    std::atomic_uint writeWaitCount_;
+};
+
+template <typename RWLockable>
+class UniqueWriteGuard : NoCopyable {
+public:
+    explicit UniqueWriteGuard(RWLockable &rwLockable)
+        : rwLockable_(rwLockable)
+    {
+        rwLockable_.LockWrite();
+    }
+
+    ~UniqueWriteGuard()
+    {
+        rwLockable_.UnLockWrite();
+    }
+
+private:
+    UniqueWriteGuard() = delete;
+
+private:
+    RWLockable &rwLockable_;
+};
+
+
+template <typename RWLockable>
+class UniqueReadGuard : NoCopyable {
+public:
+    explicit UniqueReadGuard(RWLockable &rwLockable)
+        : rwLockable_(rwLockable)
+    {
+        rwLockable_.LockRead();
+    }
+
+    ~UniqueReadGuard()
+    {
+        rwLockable_.UnLockRead();
+    }
+
+private:
+    UniqueReadGuard() = delete;
+
+private:
+    RWLockable &rwLockable_;
+};
+
+} // namespace Utils
+} // namespace OHOS
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/safe_block_queue.h b/ohos_ndk_aosp/includes/utils/safe_block_queue.h
new file mode 100755
index 0000000000..f026169fc1
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/safe_block_queue.h
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_BLOCK_QUEUE_H
+#define UTILS_BASE_BLOCK_QUEUE_H
+
+#include <climits>
+#include <condition_variable>
+#include <mutex>
+#include <queue>
+#include <atomic>
+
+namespace OHOS {
+
+template <typename T>
+class SafeBlockQueue {
+public:
+    SafeBlockQueue(int capacity) : maxSize_(capacity)
+    {
+    }
+
+    virtual void Push(T const& elem)
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        while (queueT_.size() >= maxSize_) {
+            // queue full , waiting for jobs to be taken
+            cvNotFull_.wait(lock, [&]() { return (queueT_.size() < maxSize_); });
+        }
+
+        // here means not full we can push in
+        queueT_.push(elem);
+        cvNotEmpty_.notify_one();
+    }
+
+    T Pop()
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+
+        while (queueT_.empty()) {
+            // queue empty, waiting for tasks to be Push
+            cvNotEmpty_.wait(lock, [&] { return !queueT_.empty(); });
+        }
+
+        T elem = queueT_.front();
+        queueT_.pop();
+        cvNotFull_.notify_one();
+        return elem;
+    }
+
+    virtual bool PushNoWait(T const& elem)
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        if (queueT_.size() >= maxSize_) {
+            return false;
+        }
+        // here means not full we can push in
+        queueT_.push(elem);
+        cvNotEmpty_.notify_one();
+        return true;
+    }
+
+    bool PopNotWait(T& outtask)
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        if (queueT_.empty()) {
+            return false;
+        }
+        outtask = queueT_.front();
+        queueT_.pop();
+
+        cvNotFull_.notify_one();
+
+        return true;
+    }
+
+    unsigned int Size()
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        return queueT_.size();
+    }
+
+    bool IsEmpty()
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        return queueT_.empty();
+    }
+
+    bool IsFull()
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        return queueT_.size() == maxSize_;
+    }
+
+    virtual ~SafeBlockQueue() {};
+
+protected:
+    unsigned long maxSize_;
+    std::mutex mutexLock_;
+    std::condition_variable cvNotEmpty_;
+    std::condition_variable cvNotFull_;
+    std::queue<T> queueT_;
+};
+
+template <typename T>
+class SafeBlockQueueTracking : public SafeBlockQueue<T> {
+public:
+    SafeBlockQueueTracking(int capacity) : SafeBlockQueue<T>(capacity)
+    {
+        unfinishedTaskCount_ = 0;
+    }
+
+    virtual ~SafeBlockQueueTracking() {};
+
+    virtual void Push(T const& elem)
+    {
+        unfinishedTaskCount_++;
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        while (queueT_.size() >= maxSize_) {
+            // queue full , waiting for jobs to be taken
+            cvNotFull_.wait(lock, [&]() { return (queueT_.size() < maxSize_); });
+        }
+
+        // here means not full we can push in
+        queueT_.push(elem);
+
+        cvNotEmpty_.notify_one();
+    }
+
+    virtual bool PushNoWait(T const& elem)
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        if (queueT_.size() >= maxSize_) {
+            return false;
+        }
+        // here means not full we can push in
+        queueT_.push(elem);
+        unfinishedTaskCount_++;
+        cvNotEmpty_.notify_one();
+        return true;
+    }
+
+    bool OneTaskDone()
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        int unfinished = unfinishedTaskCount_ - 1;
+
+        if (unfinished <= 0) {
+            if (unfinished < 0) {
+                return false; // false mean call elem done too many times
+            }
+            cvAllTasksDone_.notify_all();
+        }
+
+        unfinishedTaskCount_ = unfinished;
+        return true;
+    }
+
+    void Join()
+    {
+        std::unique_lock<std::mutex> lock(mutexLock_);
+        cvAllTasksDone_.wait(lock, [&] { return unfinishedTaskCount_ == 0; });
+    }
+
+    int GetUnfinishTaskNum()
+    {
+        return unfinishedTaskCount_;
+    }
+
+protected:
+    using SafeBlockQueue<T>::maxSize_;
+    using SafeBlockQueue<T>::mutexLock_;
+    using SafeBlockQueue<T>::cvNotEmpty_;
+    using SafeBlockQueue<T>::cvNotFull_;
+    using SafeBlockQueue<T>::queueT_;
+
+    std::atomic<int> unfinishedTaskCount_;
+    std::condition_variable cvAllTasksDone_;
+};
+
+} // namespace OHOS
+
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/safe_map.h b/ohos_ndk_aosp/includes/utils/safe_map.h
new file mode 100755
index 0000000000..f32a647399
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/safe_map.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_SAFE_MAP_H
+#define UTILS_BASE_SAFE_MAP_H
+
+#include <map>
+#include <mutex>
+
+namespace OHOS {
+
+template <typename K, typename V>
+class SafeMap {
+public:
+    SafeMap() {}
+
+    ~SafeMap() {}
+
+    SafeMap(const SafeMap& rhs)
+    {
+        map_ = rhs.map_;
+    }
+
+    SafeMap& operator=(const SafeMap& rhs)
+    {
+        if (&rhs != this) {
+            map_ = rhs.map_;
+        }
+
+        return *this;
+    }
+
+    V& operator[](const K& key)
+    {
+        return map_[key];
+    }
+
+    // when multithread calling size() return a tmp status, some threads may insert just after size() call
+    int Size()
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        return map_.size();
+    }
+
+    // when multithread calling Empty() return a tmp status, some threads may insert just after Empty() call
+    bool IsEmpty()
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        return map_.empty();
+    }
+
+    bool Insert(const K& key, const V& value)
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        auto ret = map_.insert(std::pair<K, V>(key, value));
+        return ret.second;
+    }
+
+    void EnsureInsert(const K& key, const V& value)
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        auto ret = map_.insert(std::pair<K, V>(key, value));
+        // find key and cannot insert
+        if (!ret.second) {
+            map_.erase(ret.first);
+            map_.insert(std::pair<K, V>(key, value));
+            return;
+        }
+        return;
+    }
+
+    bool Find(const K& key, V& value)
+    {
+        bool ret = false;
+        std::lock_guard<std::mutex> lock(mutex_);
+
+        auto iter = map_.find(key);
+        if (iter != map_.end()) {
+            value = iter->second;
+            ret = true;
+        }
+
+        return ret;
+    }
+
+    bool FindOldAndSetNew(const K& key, V& oldValue, const V& newValue)
+    {
+        bool ret = false;
+        std::lock_guard<std::mutex> lock(mutex_);
+        if (map_.size() > 0) {
+            auto iter = map_.find(key);
+            if (iter != map_.end()) {
+                oldValue = iter->second;
+                map_.erase(iter);
+                map_.insert(std::pair<K, V>(key, newValue));
+                ret = true;
+            }
+        }
+
+        return ret;
+    }
+
+    void Erase(const K& key)
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        map_.erase(key);
+    }
+
+    void Clear()
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        map_.clear();
+        return;
+    }
+
+private:
+    std::mutex mutex_;
+    std::map<K, V> map_;
+};
+
+} // namespace OHOS
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/safe_queue.h b/ohos_ndk_aosp/includes/utils/safe_queue.h
new file mode 100755
index 0000000000..d96004119a
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/safe_queue.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_SAFE_QUEUE_H
+#define UTILS_BASE_SAFE_QUEUE_H
+
+#include <deque>
+#include <mutex>
+
+namespace OHOS {
+
+template <typename T>
+class SafeQueueInner {
+
+public:
+    SafeQueueInner() {}
+
+    virtual ~SafeQueueInner()
+    {
+        if (!deque_.empty()) {
+            deque_.clear();
+        }
+    }
+
+    void Erase(T& Object)
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        deque_.remove(Object);
+    }
+
+    bool Empty()
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        return deque_.empty();
+    }
+
+    void Push(const T& pt)
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        return DoPush(pt);
+    }
+
+    void Clear()
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        if (!deque_.empty()) {
+            deque_.clear();
+        }
+
+        return;
+    }
+
+    int Size()
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        return deque_.size();
+    }
+
+    bool Pop(T& pt)
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+        return DoPop(pt);
+    }
+
+protected:
+    virtual void DoPush(const T& pt) = 0;
+    virtual bool DoPop(T& pt) = 0;
+
+    std::deque<T> deque_;
+    std::mutex mutex_;
+};
+
+template <typename T>
+class SafeQueue : public SafeQueueInner<T> {
+
+protected:
+    using SafeQueueInner<T>::deque_;
+    using SafeQueueInner<T>::mutex_;
+
+    virtual void DoPush(const T& pt) override
+    {
+        deque_.push_back(pt);
+    }
+
+    virtual bool DoPop(T& pt) override
+    {
+        if (deque_.size() > 0) {
+            pt = deque_.front();
+            deque_.pop_front();
+            return true;
+        }
+
+        return false;
+    }
+};
+
+template <typename T>
+class SafeStack : public SafeQueueInner<T> {
+
+protected:
+    using SafeQueueInner<T>::deque_;
+    using SafeQueueInner<T>::mutex_;
+
+    virtual void DoPush(const T& pt) override
+    {
+        deque_.push_back(pt);
+    }
+
+    virtual bool DoPop(T& pt) override
+    {
+        if (deque_.size() > 0) {
+            pt = deque_.back();
+            deque_.pop_back();
+            return true;
+        }
+
+        return false;
+    }
+};
+
+} // namespace OHOS
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/securec.h b/ohos_ndk_aosp/includes/utils/securec.h
new file mode 100755
index 0000000000..553eaf49b1
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/securec.h
@@ -0,0 +1,538 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __SECUREC_H__5D13A042_DC3F_4ED9_A8D1_882811274C27
+#define __SECUREC_H__5D13A042_DC3F_4ED9_A8D1_882811274C27
+
+/* Compile in kernel under macro control */
+#ifndef SECUREC_IN_KERNEL
+#ifdef __KERNEL__
+#define SECUREC_IN_KERNEL 1
+#else
+#define SECUREC_IN_KERNEL 0
+#endif
+#endif
+
+/* If you need high performance, enable the SECUREC_WITH_PERFORMANCE_ADDONS macro, default is enable .
+ * The macro is automatically closed on the windows platform in securectyp.h.
+ */
+#ifndef SECUREC_WITH_PERFORMANCE_ADDONS
+#if SECUREC_IN_KERNEL
+#define SECUREC_WITH_PERFORMANCE_ADDONS 0
+#else
+#define SECUREC_WITH_PERFORMANCE_ADDONS 1
+#endif
+#endif
+
+#include "securectype.h"
+#include <stdarg.h>
+
+#ifndef SECUREC_HAVE_ERRNO_H
+#if SECUREC_IN_KERNEL
+#define SECUREC_HAVE_ERRNO_H 0
+#else
+#define SECUREC_HAVE_ERRNO_H 1
+#endif
+#endif
+
+/* EINVAL ERANGE may defined in errno.h */
+#if SECUREC_HAVE_ERRNO_H
+#include <errno.h>
+#endif
+
+/* If stack size on some embedded platform is limited, you can define the following macro
+ * which will put some variables on heap instead of stack.
+ * SECUREC_STACK_SIZE_LESS_THAN_1K
+ */
+
+/* define error code */
+#if !defined(__STDC_WANT_LIB_EXT1__) || (defined(__STDC_WANT_LIB_EXT1__) && (__STDC_WANT_LIB_EXT1__ == 0))
+#ifndef SECUREC_DEFINED_ERRNO_TYPE
+#define SECUREC_DEFINED_ERRNO_TYPE
+/* just check whether macrodefinition exists. */
+#ifndef errno_t
+typedef int errno_t;
+#endif
+#endif
+#endif
+
+/* success */
+#ifndef EOK
+#define EOK (0)
+#endif
+
+#ifndef EINVAL
+/* The src buffer is not correct and destination buffer can't not be reset */
+#define EINVAL (22)
+#endif
+
+#ifndef EINVAL_AND_RESET
+/* Once the error is detected, the dest buffer must be rest! */
+#define EINVAL_AND_RESET (22 | 128)
+#endif
+
+#ifndef ERANGE
+/* The destination buffer is not long enough and destination buffer can not be reset */
+#define ERANGE (34)
+#endif
+
+#ifndef ERANGE_AND_RESET
+/* Once the error is detected, the dest buffer must be rest! */
+#define ERANGE_AND_RESET  (34 | 128)
+#endif
+
+#ifndef EOVERLAP_AND_RESET
+/* Once the buffer overlap is detected, the dest buffer must be rest! */
+#define EOVERLAP_AND_RESET (54 | 128)
+#endif
+
+/* if you need export the function of this library in Win32 dll, use __declspec(dllexport) */
+#ifdef SECUREC_IS_DLL_LIBRARY
+#ifdef SECUREC_DLL_EXPORT
+#define SECUREC_API __declspec(dllexport)
+#else
+#define SECUREC_API __declspec(dllimport)
+#endif
+#else
+/* Standardized function declaration . If a security function is declared in the your code,
+ * it may cause a compilation alarm,Please delete the security function you declared
+ */
+#define SECUREC_API extern
+#endif
+
+#ifndef SECUREC_SNPRINTF_TRUNCATED
+#define SECUREC_SNPRINTF_TRUNCATED 1
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+    * @Description:The memset_s function copies the value of c (converted to an unsigned char) into each of the first count characters of the object pointed to by dest.
+    * @param dest - destination  address
+    * @param destMax -The maximum length of destination buffer
+    * @param c - the value to be copied
+    * @param count -copies first count characters of  dest
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t memset_s(void *dest, size_t destMax, int c, size_t count);
+
+    /* The memset_s security function is not provided in Windows system, but other security functions are provided. In this case, can only use the memset_s function */
+#ifndef SECUREC_ONLY_DECLARE_MEMSET
+
+    /**
+    * @Description:The wmemcpy_s function copies n successive wide characters from the object pointed to by src into the object pointed to by dest.
+    * @param dest - destination  address
+    * @param destMax -The maximum length of destination buffer
+    * @param src -source  address
+    * @param count -copies count wide characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+#if SECUREC_IN_KERNEL == 0
+    SECUREC_API errno_t wmemcpy_s(wchar_t *dest, size_t destMax, const wchar_t *src, size_t count);
+#endif
+    /**
+    * @Description:The memmove_s function copies n characters from the object pointed to by src into the object pointed to by dest.
+    * @param dest - destination  address
+    * @param destMax -The maximum length of destination buffer
+    * @param src -source  address
+    * @param count -copies count wide characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t memmove_s(void *dest, size_t destMax, const void *src, size_t count);
+#if SECUREC_IN_KERNEL == 0
+   /**
+    * @Description:The wmemmove_s function copies n successive wide characters from the object pointed to by src into the object pointed to by dest.
+    * @param dest - destination  address
+    * @param destMax -The maximum length of destination buffer
+    * @param src -source  address
+    * @param count -copies count wide characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t wmemmove_s(wchar_t *dest, size_t destMax, const wchar_t *src, size_t count);
+
+    /**
+    * @Description:The wcscpy_s function copies the wide string pointed to by strSrc (including theterminating null wide character) into the array pointed to by strDest
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer
+    * @param strSrc -source  address
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t wcscpy_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc);
+
+    /**
+    * @Description:The wcsncpy_s function copies not more than n successive wide characters (not including the terminating null wide character)
+    *                       from the array pointed to by strSrc to the array pointed to by strDest
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating wide character)
+    * @param strSrc -source  address
+    * @param count -copies count wide characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t wcsncpy_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count);
+
+    /**
+    * @Description:The wcscat_s function appends a copy of the wide string pointed to by strSrc (including the terminating null wide character)
+    *                     to the end of the wide string pointed to by strDest
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating wide character)
+    * @param strSrc -source  address
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t wcscat_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc);
+
+    /**
+    * @Description:The wcsncat_s function appends not more than n successive wide characters (not including the terminating null wide character)
+    *                       from the array pointed to by strSrc to the end of the wide string pointed to by strDest.
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating wide character)
+    * @param strSrc -source  address
+    * @param count -copies count wide characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t wcsncat_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count);
+
+    /**
+    * @Description: The  strtok_s  function parses a string into a sequence of tokens,On the first call to strtok_s the string to be parsed should be specified in strToken.
+    *                       In each subsequent call that should parse the same string, strToken should be NULL
+    * @param strToken - the string to be delimited
+    * @param strDelimit -specifies a set of characters that delimit the tokens in the parsed string
+    * @param context -is a pointer to a char * variable that is used internally by strtok_s function
+    * @return:returns a pointer to the first character of a token, or a null pointer if there is no token or there is a runtime-constraint violation.
+    */
+    SECUREC_API char *strtok_s(char *strToken, const char *strDelimit, char **context);
+
+     /**
+    * @Description: The  wcstok_s  function  is  the  wide-character  equivalent  of the strtok_s function
+    * @param strToken - the string to be delimited
+    * @param strDelimit -specifies a set of characters that delimit the tokens in the parsed string
+    * @param context -is a pointer to a char * variable that is used internally by strtok_s function
+    * @return:returns a pointer to the first character of a token, or a null pointer if there is no token or there is a runtime-constraint violation.
+    */
+    SECUREC_API wchar_t *wcstok_s(wchar_t *strToken, const wchar_t *strDelimit, wchar_t **context);
+
+    /**
+    * @Description: The sprintf_s function is equivalent to the sprintf function except for the parameter destMax and the explicit runtime-constraints violation
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null byte ('\0'))
+    * @param format - format string
+    * @return:success the number of characters printed(not including the terminating null byte ('\0')), If an error occurred return -1.
+    */
+    SECUREC_API int sprintf_s(char *strDest, size_t destMax, const char *format, ...) SECUREC_ATTRIBUTE(3, 4);
+
+    /**
+    * @Description: The  swprintf_s  function  is  the  wide-character  equivalent  of the sprintf_s function
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null )
+    * @param format - format string
+    * @return:success the number of characters printed(not including the terminating null wide characte), If an error occurred return -1.
+    */
+    SECUREC_API int swprintf_s(wchar_t *strDest, size_t destMax, const wchar_t *format, ...);
+
+    /**
+    * @Description: The vsprintf_s function is equivalent to the vsprintf function except for the parameter destMax and the explicit runtime-constraints violation
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null wide characte)
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:return the number of characters printed(not including the terminating null byte ('\0')), If an error occurred return -1.
+    */
+    SECUREC_API int vsprintf_s(char *strDest, size_t destMax, const char *format,
+                               va_list arglist) SECUREC_ATTRIBUTE(3, 0);
+
+   /**
+    * @Description: The  vswprintf_s  function  is  the  wide-character  equivalent  of the vsprintf_s function
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null )
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:return the number of characters printed(not including the terminating null wide characte), If an error occurred return -1.
+    */
+    SECUREC_API int vswprintf_s(wchar_t *strDest, size_t destMax, const wchar_t *format, va_list arglist);
+
+    /**
+    * @Description: The vsnprintf_s function is equivalent to the vsnprintf function except for the parameter destMax/count and the explicit runtime-constraints violation
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null  byte ('\0'))
+    * @param count - do not write more than count bytes to strDest(not including the terminating null  byte ('\0'))
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:return the number of characters printed(not including the terminating null byte ('\0')), If an error occurred return -1.Pay special attention to returning -1 when truncation occurs
+    */
+    SECUREC_API int vsnprintf_s(char *strDest, size_t destMax, size_t count, const char *format,
+                                va_list arglist) SECUREC_ATTRIBUTE(4, 0);
+
+    /**
+    * @Description: The snprintf_s function is equivalent to the snprintf function except for the parameter destMax/count and the explicit runtime-constraints violation
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null  byte ('\0'))
+    * @param count - do not write more than count bytes to strDest(not including the terminating null  byte ('\0'))
+    * @param format - format string
+    * @return:return the number of characters printed(not including the terminating null byte ('\0')), If an error occurred return -1.Pay special attention to returning -1 when truncation occurs
+    */
+    SECUREC_API int snprintf_s(char *strDest, size_t destMax, size_t count, const char *format,
+                               ...) SECUREC_ATTRIBUTE(4, 5);
+
+#if SECUREC_SNPRINTF_TRUNCATED
+    /**
+    * @Description: The vsnprintf_truncated_s function is equivalent to the vsnprintf_s function except  no count parameter  and return value
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null  byte ('\0'))
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:return the number of characters printed(not including the terminating null byte ('\0')), If an error occurred return -1.Pay special attention to returning destMax - 1 when truncation occurs
+    */
+    SECUREC_API int vsnprintf_truncated_s(char *strDest, size_t destMax, const char *format,
+                                   va_list arglist) SECUREC_ATTRIBUTE(3, 0);
+
+    /**
+    * @Description: The snprintf_truncated_s function is equivalent to the snprintf_2 function except  no count parameter  and return value
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null  byte ('\0'))
+    * @param format - format string
+    * @return:return the number of characters printed(not including the terminating null byte ('\0')), If an error occurred return -1.Pay special attention to returning destMax - 1 when truncation occurs
+    */
+    SECUREC_API int snprintf_truncated_s(char *strDest, size_t destMax, const char *format, ...) SECUREC_ATTRIBUTE(3, 4);
+#endif
+    /**
+    * @Description: The scanf_s function is equivalent to fscanf_s with the argument stdin interposed before the arguments to scanf_s
+    * @param format - format string
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int scanf_s(const char *format, ...);
+
+    /**
+    * @Description: The  wscanf_s  function  is  the  wide-character  equivalent  of the scanf_s function
+    * @param format - format string
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int wscanf_s(const wchar_t *format, ...);
+
+    /**
+    * @Description: The vscanf_s function is equivalent to scanf_s, with the variable argument list replaced by arglist
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int vscanf_s(const char *format, va_list arglist);
+
+    /**
+    * @Description: The  vwscanf_s  function  is  the  wide-character  equivalent  of the vscanf_s function
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int vwscanf_s(const wchar_t *format, va_list arglist);
+
+    /**
+    * @Description: The fscanf_s function is equivalent to fscanf except that the c, s, and [ conversion specifiers apply to a pair of arguments (unless assignment suppression is indicated by a*)
+    * @param stream - stdio file stream
+    * @param format - format string
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int fscanf_s(FILE *stream, const char *format, ...);
+
+    /**
+    * @Description: The  fwscanf_s  function  is  the  wide-character  equivalent  of the fscanf_s function
+    * @param stream - stdio file stream
+    * @param format - format string
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int fwscanf_s(FILE *stream, const wchar_t *format, ...);
+
+    /**
+    * @Description: The vfscanf_s function is equivalent to fscanf_s, with the variable argument list replaced by arglist
+    * @param stream - stdio file stream
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int vfscanf_s(FILE *stream, const char *format, va_list arglist);
+
+    /**
+    * @Description: The  vfwscanf_s  function  is  the  wide-character  equivalent  of the vfscanf_s function
+    * @param stream - stdio file stream
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int vfwscanf_s(FILE *stream, const wchar_t *format, va_list arglist);
+
+    /**
+    * @Description: The sscanf_s function is equivalent to fscanf_s, except that input is obtained from a string (specified by the argument buffer) rather than from a stream
+    * @param buffer -  read character from  buffer
+    * @param format - format string
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int sscanf_s(const char *buffer, const char *format, ...);
+
+    /**
+    * @Description: The  swscanf_s  function  is  the  wide-character  equivalent  of the sscanf_s function
+    * @param buffer -  read character from  buffer
+    * @param format - format string
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int swscanf_s(const wchar_t *buffer, const wchar_t *format, ...);
+
+    /**
+    * @Description: The vsscanf_s function is equivalent to sscanf_s, with the variable argument list replaced by arglist
+    * @param buffer -  read character from  buffer
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int vsscanf_s(const char *buffer, const char *format, va_list arglist);
+
+    /**
+    * @Description: The  vswscanf_s  function  is  the  wide-character  equivalent  of the vsscanf_s function
+    * @param buffer -  read character from  buffer
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:returns the number of input items assigned, If an error occurred return -1.
+    */
+    SECUREC_API int vswscanf_s(const wchar_t *buffer, const wchar_t *format, va_list arglist);
+
+    /**
+    * @Description:The gets_s function reads at most one less than the number of characters specified by destMax from the stream pointed to by stdin, into the array pointed to by buffer
+    * @param buffer - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating null character)
+    * @return  buffer if there was no runtime-constraint violation,If an error occurred return NULL.
+    */
+    SECUREC_API char *gets_s(char *buffer, size_t destMax);
+#endif
+
+    /**
+    * @Description:The memcpy_s function copies n characters from the object pointed to by src into the object pointed to by dest.
+    * @param dest - destination  address
+    * @param destMax -The maximum length of destination buffer
+    * @param src -source  address
+    * @param count -copies count  characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t memcpy_s(void *dest, size_t destMax, const void *src, size_t count);
+
+    /**
+    * @Description:The strcpy_s function copies the string pointed to by strSrc (including the terminating null character) into the array pointed to by strDest
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating null character)
+    * @param strSrc -source  address
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t strcpy_s(char *strDest, size_t destMax, const char *strSrc);
+
+    /**
+    * @Description:The strncpy_s function copies not more than n successive characters (not including the terminating null character)
+    *                     from the array pointed to by strSrc to the array pointed to by strDest
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating null character)
+    * @param strSrc -source  address
+    * @param count -copies count  characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t strncpy_s(char *strDest, size_t destMax, const char *strSrc, size_t count);
+
+    /**
+    * @Description:The strcat_s function appends a copy of the  string pointed to by strSrc (including the terminating null  character)
+    *                     to the end of the  string pointed to by strDest
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating null wide character)
+    * @param strSrc -source  address
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t strcat_s(char *strDest, size_t destMax, const char *strSrc);
+
+    /**
+    * @Description:The strncat_s function appends not more than n successive  characters (not including the terminating null  character)
+    *                       from the array pointed to by strSrc to the end of the  string pointed to by strDest.
+    * @param strDest - destination  address
+    * @param destMax -The maximum length of destination buffer(including the terminating null character)
+    * @param strSrc -source  address
+    * @param count -copies count  characters from the  src
+    * @return  EOK if there was no runtime-constraint violation
+    */
+    SECUREC_API errno_t strncat_s(char *strDest, size_t destMax, const char *strSrc, size_t count);
+#if SECUREC_IN_KERNEL == 0
+    /* those functions are used by macro ,must declare hare , also for  without function declaration warning */
+    extern errno_t strncpy_error(char *strDest, size_t destMax, const char *strSrc, size_t count);
+    extern errno_t strcpy_error(char *strDest, size_t destMax, const char *strSrc);
+#endif
+#endif
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+    /* those functions are used by macro */
+    extern errno_t memset_sOptAsm(void *dest, size_t destMax, int c, size_t count);
+    extern errno_t memset_sOptTc(void *dest, size_t destMax, int c, size_t count);
+    extern errno_t memcpy_sOptAsm(void *dest, size_t destMax, const void *src, size_t count);
+    extern errno_t memcpy_sOptTc(void *dest, size_t destMax, const void *src, size_t count);
+
+/* strcpy_sp is a macro, NOT a function in performance optimization mode. */
+#define strcpy_sp(dest, destMax, src)  ((__builtin_constant_p((destMax)) && \
+                                         __builtin_constant_p((src))) ?  \
+                                        SECUREC_STRCPY_SM((dest), (destMax), (src)) : \
+                                        strcpy_s((dest), (destMax), (src)))
+
+/* strncpy_sp is a macro, NOT a function in performance optimization mode. */
+#define strncpy_sp(dest, destMax, src, count)  ((__builtin_constant_p((count)) && \
+                                                 __builtin_constant_p((destMax)) && \
+                                                 __builtin_constant_p((src))) ?  \
+                                                SECUREC_STRNCPY_SM((dest), (destMax), (src), (count)) : \
+                                                strncpy_s((dest), (destMax), (src), (count)))
+
+/* strcat_sp is a macro, NOT a function in performance optimization mode. */
+#define strcat_sp(dest, destMax, src) ((__builtin_constant_p((destMax)) && \
+                                        __builtin_constant_p((src))) ?  \
+                                       SECUREC_STRCAT_SM((dest), (destMax), (src)) : \
+                                       strcat_s((dest), (destMax), (src)))
+
+ /* strncat_sp is a macro, NOT a function in performance optimization mode. */
+#define strncat_sp(dest, destMax, src, count) ((__builtin_constant_p((count)) &&  \
+                                                __builtin_constant_p((destMax)) && \
+                                                __builtin_constant_p((src))) ?  \
+                                               SECUREC_STRNCAT_SM((dest), (destMax), (src), (count)) : \
+                                               strncat_s((dest), (destMax), (src), (count)))
+
+/* memcpy_sp is a macro, NOT a function in performance optimization mode. */
+#define memcpy_sp(dest, destMax, src, count)  (__builtin_constant_p((count)) ? \
+                                               (SECUREC_MEMCPY_SM((dest), (destMax),  (src), (count))) : \
+                                               (__builtin_constant_p((destMax)) ? \
+                                                (((size_t)(destMax) > 0 && \
+                                                 (((unsigned long long)(destMax) & \
+                                                   (unsigned long long)(-2)) < SECUREC_MEM_MAX_LEN)) ? \
+                                                  memcpy_sOptTc((dest), (destMax), (src), (count)) : ERANGE ) : \
+                                                  memcpy_sOptAsm((dest), (destMax), (src), (count))))
+
+/* memset_sp is a macro, NOT a function in performance optimization mode. */
+#define memset_sp(dest, destMax, c, count)  (__builtin_constant_p((count)) ? \
+                                             (SECUREC_MEMSET_SM((dest), (destMax),  (c), (count))) : \
+                                             (__builtin_constant_p((destMax)) ? \
+                                              (((size_t)(destMax) > 0 && \
+                                              (((unsigned long long)(destMax) & \
+                                               (unsigned long long)(-2)) < SECUREC_MEM_MAX_LEN)) ? \
+                                                memset_sOptTc((dest), (destMax), (c), (count)) : ERANGE ) : \
+                                                memset_sOptAsm((dest), (destMax), (c), (count))))
+#else
+#define strcpy_sp   strcpy_s
+#define strncpy_sp  strncpy_s
+#define strcat_sp   strcat_s
+#define strncat_sp  strncat_s
+#define memcpy_sp   memcpy_s
+#define memset_sp   memset_s
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __SECUREC_H__5D13A042_DC3F_4ED9_A8D1_882811274C27 */
diff --git a/ohos_ndk_aosp/includes/utils/securec_p.h b/ohos_ndk_aosp/includes/utils/securec_p.h
new file mode 100755
index 0000000000..03cd7d573c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/securec_p.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __SECUREC_P_H__
+#define __SECUREC_P_H__
+
+#include "securec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+    * @Description: The vsnprintfp_s function is equivalent to the vsnprintf function except for the parameter destMax/count
+    *               and the explicit runtime-constraints violation
+    * @param strDest -  produce output according to a format ,write to the character string strDest
+    * @param destMax - The maximum length of destination buffer(including the terminating null  byte ('\0'))
+    * @param count - do not write more than count bytes to strDest(not including the terminating null  byte ('\0'))
+    * @param priv_on - if true, any not %{public} prefix formatter arguments will be printed as "<private>"
+    * @param format - format string
+    * @param arglist - instead of  a variable  number of arguments
+    * @return:return the number of characters printed(not including the terminating null byte ('\0')),
+    *         If an error occurred return -1.Pay special attention to returning -1 when truncation occurs
+    */
+    SECUREC_API int vsnprintfp_s(char *strDest, size_t destMax, size_t count, int priv,  const char *format,
+                                va_list arglist) SECUREC_ATTRIBUTE(5, 0);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __SECUREC_P_H__ */
diff --git a/ohos_ndk_aosp/includes/utils/securectype.h b/ohos_ndk_aosp/includes/utils/securectype.h
new file mode 100755
index 0000000000..564c9f4741
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/securectype.h
@@ -0,0 +1,279 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* [Standardize-exceptions]: Performance-sensitive
+ * [reason]: Strict parameter verification has been done before use
+ */
+
+#ifndef __SECURECTYPE_H__A7BBB686_AADA_451B_B9F9_44DACDAE18A7
+#define __SECURECTYPE_H__A7BBB686_AADA_451B_B9F9_44DACDAE18A7
+
+#ifndef SECUREC_ONLY_DECLARE_MEMSET
+/* Shielding VC symbol redefinition warning */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#ifdef __STDC_WANT_SECURE_LIB__
+#undef __STDC_WANT_SECURE_LIB__
+#endif
+#define __STDC_WANT_SECURE_LIB__ 0
+#ifdef _CRTIMP_ALTERNATIVE
+#undef _CRTIMP_ALTERNATIVE
+#endif
+#define _CRTIMP_ALTERNATIVE     //comment microsoft *_s function
+#endif
+#endif
+
+#if SECUREC_IN_KERNEL
+#include <linux/kernel.h>
+#include <linux/module.h>
+#else
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#endif
+
+/* if enable SECUREC_COMPATIBLE_WIN_FORMAT, the output format will be compatible to Windows. */
+#if (defined(_WIN32) || defined(_WIN64) || defined(_MSC_VER))
+#define SECUREC_COMPATIBLE_WIN_FORMAT
+#endif
+
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+/* in windows platform, can't use optimized function for there is no __builtin_constant_p like function */
+/* If need optimized macro, can define this: define __builtin_constant_p(x) 0 */
+#ifdef SECUREC_WITH_PERFORMANCE_ADDONS
+#undef SECUREC_WITH_PERFORMANCE_ADDONS
+#define SECUREC_WITH_PERFORMANCE_ADDONS 0
+#endif
+#endif
+
+#if defined(__VXWORKS__) || defined(__vxworks) || defined(__VXWORKS) || defined(_VXWORKS_PLATFORM_)  || \
+    defined(SECUREC_VXWORKS_VERSION_5_4)
+#if  !defined(SECUREC_VXWORKS_PLATFORM)
+#define SECUREC_VXWORKS_PLATFORM
+#endif
+#endif
+
+/* if enable SECUREC_COMPATIBLE_LINUX_FORMAT, the output format will be compatible to Linux. */
+#if !(defined(SECUREC_COMPATIBLE_WIN_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM))
+#define SECUREC_COMPATIBLE_LINUX_FORMAT
+#endif
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+#include <stddef.h>
+#endif
+
+/* add  the -DSECUREC_SUPPORT_FORMAT_WARNING  compiler option to supoort  -Wformat.
+ * default does not check the format is that the same data type in the actual code
+ * in the product is different in the original data type definition of VxWorks and Linux.
+ */
+#ifndef SECUREC_SUPPORT_FORMAT_WARNING
+#define SECUREC_SUPPORT_FORMAT_WARNING 0
+#endif
+
+/* SECUREC_PCLINT for tool do not recognize __attribute__  just for pclint */
+#if SECUREC_SUPPORT_FORMAT_WARNING && !defined(SECUREC_PCLINT)
+#define SECUREC_ATTRIBUTE(x,y)  __attribute__((format(printf, (x), (y))))
+#else
+#define SECUREC_ATTRIBUTE(x,y)
+#endif
+
+/* SECUREC_PCLINT for tool do not recognize __builtin_expect ,just for pclint */
+#if defined(__GNUC__) && \
+    ((__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3 /* above 3.4 */ ))) && \
+    !defined(SECUREC_PCLINT)
+/* This is a built-in function that can be used without a declaration, if you encounter an undeclared compilation alarm,
+ * you can add -DSECUREC_NEED_BUILTIN_EXPECT_DECLARE to compiler options
+ */
+#if defined(SECUREC_NEED_BUILTIN_EXPECT_DECLARE)
+long __builtin_expect(long exp, long c);
+#endif
+#define SECUREC_LIKELY(x) __builtin_expect(!!(x), 1)
+#define SECUREC_UNLIKELY(x) __builtin_expect(!!(x), 0)
+#else
+#define SECUREC_LIKELY(x) (x)
+#define SECUREC_UNLIKELY(x) (x)
+#endif
+
+/* define the max length of the string */
+#define SECUREC_STRING_MAX_LEN (0x7fffffffUL)
+#define SECUREC_WCHAR_STRING_MAX_LEN (SECUREC_STRING_MAX_LEN / sizeof(wchar_t))
+
+/* add SECUREC_MEM_MAX_LEN for memcpy and memmove */
+#define SECUREC_MEM_MAX_LEN (0x7fffffffUL)
+#define SECUREC_WCHAR_MEM_MAX_LEN (SECUREC_MEM_MAX_LEN / sizeof(wchar_t))
+
+#if SECUREC_STRING_MAX_LEN > 0x7fffffff
+#error "max string is 2G"
+#endif
+
+#if (defined(__GNUC__ ) && defined(__SIZEOF_POINTER__ ))
+#if (__SIZEOF_POINTER__ != 4) && (__SIZEOF_POINTER__ != 8)
+#error "unsupported system"
+#endif
+#endif
+
+#ifndef SECUREC_MALLOC
+#define SECUREC_MALLOC(x) malloc((size_t)(x))
+#endif
+
+#ifndef SECUREC_FREE
+#define SECUREC_FREE(x)   free((void *)(x))
+#endif
+
+#if defined(_WIN64) || defined(WIN64) || defined(__LP64__) || defined(_LP64)
+#define SECUREC_ON_64BITS
+#endif
+
+#if (!defined(SECUREC_ON_64BITS) && defined(__GNUC__ ) && defined(__SIZEOF_POINTER__ ))
+#if __SIZEOF_POINTER__ == 8
+#define SECUREC_ON_64BITS
+#endif
+#endif
+
+#if defined(__SVR4) || defined(__svr4__)
+#define SECUREC_ON_SOLARIS
+#endif
+
+#if (defined(__hpux) || defined(_AIX) || defined(SECUREC_ON_SOLARIS))
+#define SECUREC_ON_UNIX
+#endif
+
+/* codes should run under the macro SECUREC_COMPATIBLE_LINUX_FORMAT in unknown system on default,
+ * and strtold. The function
+ * strtold is referenced first at ISO9899:1999(C99), and some old compilers can
+ * not support these functions. Here provides a macro to open these functions:
+ * SECUREC_SUPPORT_STRTOLD  -- if defined, strtold will   be used
+ */
+#ifndef SECUREC_SUPPORT_STRTOLD
+#define SECUREC_SUPPORT_STRTOLD 0
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT))
+#if defined(__USE_ISOC99)  || \
+    (defined(_AIX) && defined(_ISOC99_SOURCE)) || \
+    (defined(__hpux) && defined(__ia64)) || \
+    (defined(SECUREC_ON_SOLARIS) &&  (!defined(_STRICT_STDC) && !defined(__XOPEN_OR_POSIX)) || \
+     defined(_STDC_C99) || defined(__EXTENSIONS__))
+#undef  SECUREC_SUPPORT_STRTOLD
+#define SECUREC_SUPPORT_STRTOLD 1
+#endif
+#endif
+#if ((defined(SECUREC_WRLINUX_BELOW4) || defined(_WRLINUX_BELOW4_)))
+#undef  SECUREC_SUPPORT_STRTOLD
+#define SECUREC_SUPPORT_STRTOLD 0
+#endif
+#endif
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+
+#ifndef SECUREC_TWO_MIN
+#define SECUREC_TWO_MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+/* for strncpy_s performance optimization */
+#define SECUREC_STRNCPY_SM(dest, destMax, src, count) \
+    (((void *)dest != NULL && (void *)src != NULL  && (size_t)destMax >0 && \
+        (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN) && \
+        (SECUREC_TWO_MIN(count , strlen(src)) + 1) <= (size_t)destMax ) ? \
+        ((count < strlen(src))? (memcpy(dest, src, count), *((char *)dest + count) = '\0', EOK): \
+        (memcpy(dest, src, strlen(src) + 1), EOK ) ) :(strncpy_error(dest, destMax, src, count)))
+
+#define SECUREC_STRCPY_SM(dest, destMax, src) \
+    (((void *)dest != NULL && (void *)src != NULL && (size_t)destMax >0 && \
+        (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN) && \
+        (strlen(src) + 1) <= (size_t)destMax )? (memcpy(dest, src, strlen(src) + 1), EOK): \
+        (strcpy_error(dest, destMax, src)))
+
+/* for strcat_s performance optimization */
+#if defined(__GNUC__)
+#define SECUREC_STRCAT_SM(dest, destMax, src) \
+    ({ \
+        int catRet = EOK; \
+        if ((void *)dest != NULL && (void *)src != NULL && (size_t)(destMax) >0 && \
+            (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN)) { \
+            char *catTmpDst = (dest); \
+            size_t catRestSize = (destMax); \
+            while(catRestSize > 0 && *catTmpDst) { \
+                ++catTmpDst; \
+                --catRestSize; \
+            } \
+            if (catRestSize == 0) { \
+                catRet = EINVAL; \
+            } else if ((strlen(src) + 1) <= catRestSize) { \
+                memcpy(catTmpDst, (src), strlen(src) + 1); \
+                catRet = EOK; \
+            } else { \
+                catRet = ERANGE; \
+            } \
+            if (catRet != EOK) { \
+                catRet = strcat_s((dest), (destMax), (src)); \
+            } \
+        } else { \
+            catRet = strcat_s((dest), (destMax), (src)); \
+        } \
+        catRet; \
+    })
+#else
+#define SECUREC_STRCAT_SM(dest, destMax, src) strcat_s(dest, destMax, src)
+#endif
+
+/* for strncat_s performance optimization */
+#if defined(__GNUC__)
+#define SECUREC_STRNCAT_SM(dest, destMax, src, count) \
+    ({ \
+        int ncatRet = EOK; \
+        if ((void *)dest != NULL && (void *)src != NULL && (size_t)destMax > 0 && \
+            (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN)  && \
+            (((unsigned long long)(count) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN)) { \
+            char *ncatTmpDest = (dest); \
+            size_t ncatRestSize = (destMax); \
+            while(ncatRestSize > 0 && *ncatTmpDest) { \
+                ++ncatTmpDest; \
+                --ncatRestSize; \
+            } \
+            if (ncatRestSize == 0) { \
+                ncatRet = EINVAL; \
+            } else if ((SECUREC_TWO_MIN((count) , strlen(src)) + 1) <= ncatRestSize ) { \
+                if ((count) < strlen(src)) { \
+                    memcpy(ncatTmpDest, (src), (count)); \
+                    *(ncatTmpDest + (count)) = '\0'; \
+                } else { \
+                    memcpy(ncatTmpDest, (src), strlen(src) + 1); \
+                } \
+            } else { \
+                ncatRet = ERANGE; \
+            } \
+            if (ncatRet != EOK) { \
+                ncatRet = strncat_s((dest), (destMax), (src), (count)); \
+            } \
+        } else { \
+            ncatRet = strncat_s((dest), (destMax), (src), (count)); \
+        } \
+        ncatRet; \
+    })
+#else
+#define SECUREC_STRNCAT_SM(dest, destMax, src, count) strncat_s(dest, destMax, src, count)
+#endif
+
+/* SECUREC_MEMCPY_SM do NOT check buffer overlap by default */
+#define  SECUREC_MEMCPY_SM(dest, destMax, src, count) \
+    (!(((size_t)destMax == 0 )||(((unsigned long long)(destMax) & (unsigned long long)(-2)) > SECUREC_MEM_MAX_LEN) || \
+        ((size_t)count > (size_t)destMax) || ((void *)dest) == NULL || ((void *)src == NULL))? \
+        (memcpy(dest, src, count), EOK) : \
+        (memcpy_s(dest, destMax, src, count)))
+
+#define  SECUREC_MEMSET_SM(dest, destMax, c, count) \
+    (!(((size_t)destMax == 0 ) || (((unsigned long long)(destMax) & (unsigned long long)(-2)) > SECUREC_MEM_MAX_LEN) || \
+        ((void *)dest == NULL) || ((size_t)count > (size_t)destMax)) ? \
+        (memset(dest, c, count), EOK) : \
+        ( memset_s(dest, destMax, c, count)))
+
+#endif
+#endif /* __SECURECTYPE_H__A7BBB686_AADA_451B_B9F9_44DACDAE18A7 */
diff --git a/ohos_ndk_aosp/includes/utils/semaphore_ex.h b/ohos_ndk_aosp/includes/utils/semaphore_ex.h
new file mode 100755
index 0000000000..f44eabc770
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/semaphore_ex.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef SEMAPHORE_EX_H
+#define SEMAPHORE_EX_H
+
+#include "nocopyable.h"
+
+#include <iostream>
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include <string>
+#include <time.h> // timespec since c11
+
+namespace OHOS {
+
+const int INVALID_SEMA_VALUE = -1;
+
+class NamedSemaphore : public NoCopyable {
+public:
+    NamedSemaphore(size_t);
+    NamedSemaphore(const std::string&, size_t);
+    ~NamedSemaphore();
+
+    bool Create();
+    bool Unlink();
+
+    bool Open();
+    bool Close();
+
+    bool Wait();
+    bool TryWait();
+    bool TimedWait(const struct timespec& ts);
+    bool Post();
+
+    int GetValue() const;
+
+private:
+    std::string name_;
+    int maxCount_;
+    void* sema_;
+    bool named_;
+};
+
+class Semaphore : public NoCopyable {
+public:
+    Semaphore(int value = 1) : count_(value) {}
+    ~Semaphore() = default;
+
+    void Wait();
+    void Post();
+
+private:
+    int count_;
+    std::mutex mutex_;
+    std::condition_variable cv_;
+};
+
+} // OHOS
+
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/singleton.h b/ohos_ndk_aosp/includes/utils/singleton.h
new file mode 100755
index 0000000000..b831f9032d
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/singleton.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_SINGLETON_H
+#define UTILS_BASE_SINGLETON_H
+
+#include "nocopyable.h"
+#include <mutex>
+#include <memory>
+
+namespace OHOS {
+
+#define DECLARE_DELAYED_SINGLETON(MyClass)\
+public:\
+    ~MyClass();\
+private:\
+    friend DelayedSingleton<MyClass>;\
+    MyClass();
+
+#define DECLARE_DELAYED_REF_SINGLETON(MyClass)\
+private:\
+    friend DelayedRefSingleton<MyClass>;\
+    ~MyClass();\
+    MyClass();
+
+
+#define DECLARE_SINGLETON(MyClass)\
+private:\
+    friend Singleton<MyClass>;\
+    MyClass& operator=(const MyClass&) = delete;\
+    MyClass(const MyClass&) = delete;\
+    MyClass();\
+    ~MyClass();
+
+
+template<typename T>
+class DelayedSingleton : public NoCopyable {
+public:
+    static std::shared_ptr<T> GetInstance();
+    static void DestroyInstance();
+
+private:
+    static std::shared_ptr<T> instance_;
+    static std::mutex mutex_;
+};
+
+template<typename T>
+std::shared_ptr<T> DelayedSingleton<T>::instance_ = nullptr;
+
+template<typename T>
+std::mutex DelayedSingleton<T>::mutex_;
+
+template<typename T>
+std::shared_ptr<T> DelayedSingleton<T>::GetInstance()
+{
+    if (instance_ == nullptr) {
+        std::lock_guard<std::mutex> lock(mutex_);
+        if (instance_ == nullptr) {
+            std::shared_ptr<T> temp(new T);
+            instance_ = temp;
+        }
+    }
+
+    return instance_;
+}
+
+template<typename T>
+void DelayedSingleton<T>::DestroyInstance()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (instance_ != nullptr) {
+        instance_.reset();
+        instance_ = nullptr;
+    }
+}
+
+
+
+template<typename T>
+class DelayedRefSingleton : public NoCopyable {
+public:
+    static T& GetInstance();
+
+private:
+    static T* instance_;
+    static std::mutex mutex_;
+};
+
+template<typename T>
+T* DelayedRefSingleton<T>::instance_ = nullptr;
+
+template<typename T>
+std::mutex DelayedRefSingleton<T>::mutex_;
+
+template<typename T>
+T& DelayedRefSingleton<T>::GetInstance()
+{
+    if (instance_ == nullptr) {
+        std::lock_guard<std::mutex> lock(mutex_);
+        if (instance_ == nullptr) {
+            instance_ = new T();
+        }
+    }
+
+    return *instance_;
+}
+
+template<typename T>
+class Singleton : public NoCopyable {
+public:
+    static T& GetInstance() { return instance_; }
+
+private:
+    static T instance_;
+};
+
+template<typename T>
+T Singleton<T>::instance_;
+} // namespace OHOS
+
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/sorted_vector.h b/ohos_ndk_aosp/includes/utils/sorted_vector.h
new file mode 100755
index 0000000000..2877445bd0
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/sorted_vector.h
@@ -0,0 +1,259 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_BASE_SORTED_VECTOR_H
+#define UTILS_BASE_SORTED_VECTOR_H
+
+#include <algorithm>
+#include <functional>
+#include <iostream>
+#include <sys/types.h>
+#include <vector>
+
+namespace OHOS {
+
+template <class TYPE, bool AllowDuplicate = true>
+class SortedVector {
+
+public:
+    using value_type = TYPE;
+    using size_type = std::size_t;
+    using iterator = typename std::vector<TYPE>::iterator;
+    using const_iterator = typename std::vector<TYPE>::const_iterator;
+
+    // cont and dest
+
+    SortedVector();
+
+    SortedVector(const SortedVector<TYPE, false>& rhs);
+
+    SortedVector(const SortedVector<TYPE, true>& rhs);
+
+    SortedVector(const std::vector<TYPE>& orivect);
+
+    virtual ~SortedVector() {};
+    // copy operator
+    SortedVector<TYPE, AllowDuplicate>& operator=(const SortedVector<TYPE, false>& rhs);
+    SortedVector<TYPE, AllowDuplicate>& operator=(const SortedVector<TYPE, true>& rhs);
+
+    inline void Clear() { vec_.clear(); }
+    inline size_t Size() const { return vec_.size(); }
+    inline bool IsEmpty() const { return vec_.empty(); }
+    inline size_t Capacity() const { return vec_.capacity(); }
+
+    ssize_t SetCapcity(size_t size)
+    {
+        if (size < vec_.capacity()) {
+            return CAPCITY_NOT_CHANGED;
+        }
+
+        vec_.reserve(size);
+        return size;
+    }
+
+    // Cstyle access
+    // when use it , you should make sure it sorted~!
+    inline const TYPE* Array() const { return vec_.data(); };
+    TYPE* EditArray() { return vec_.data(); };
+
+    ssize_t IndexOf(const TYPE& item) const;
+    size_t OrderOf(const TYPE& item) const;
+
+    // accessors
+    inline const TYPE& operator[](size_t index) const { return vec_[index]; }
+
+    const TYPE& Back() const { return vec_.back(); }
+    const TYPE& Front() const { return vec_.front(); }
+    void PopBack() { return vec_.pop_back(); }
+
+    const TYPE& MirrorItemAt(ssize_t index) const
+    {
+        if (index < 0) {
+            return *(vec_.end() + index);
+        }
+        return *(vec_.begin() + index);
+    };
+
+    // modify the array
+    ssize_t Add(const TYPE& item);
+    TYPE& EditItemAt(size_t index)
+    {
+        return vec_[index];
+    }
+
+    // merge a vector into this one
+    size_t Merge(const std::vector<TYPE>& invec);
+    size_t Merge(const SortedVector<TYPE, AllowDuplicate>& sortedVector);
+
+    // erase an item at index
+    iterator Erase(size_t index)
+    {
+        if (index >= vec_.size()) {
+            return vec_.end();
+        }
+        return vec_.erase(vec_.begin() + index);
+    }
+
+    iterator Begin()
+    {
+        return vec_.begin();
+    }
+
+    const_iterator Begin() const
+    {
+        return vec_.begin();
+    }
+
+    iterator End()
+    {
+        return vec_.end();
+    }
+
+    const_iterator End() const
+    {
+        return vec_.end();
+    }
+
+    static const ssize_t NOT_FOUND = -1;
+    static const ssize_t ADD_FAIL = -1;
+    static const ssize_t CAPCITY_NOT_CHANGED = -1;
+
+private:
+    std::vector<TYPE> vec_;
+};
+
+template <class TYPE, bool AllowDuplicate>
+inline SortedVector<TYPE, AllowDuplicate>::SortedVector()
+    : vec_() {}
+
+template <class TYPE, bool AllowDuplicate>
+SortedVector<TYPE, AllowDuplicate>::SortedVector(const SortedVector<TYPE, false>& rhs)
+{
+    // this class: AllowDuplicate or Not AllowDuplicate same type
+    std::copy(rhs.Begin(), rhs.End(), std::back_inserter(vec_));
+}
+
+template <class TYPE, bool AllowDuplicate>
+SortedVector<TYPE, AllowDuplicate>::SortedVector(const SortedVector<TYPE, true>& rhs)
+{
+
+    if (AllowDuplicate) {
+        std::copy(rhs.Begin(), rhs.End(), std::back_inserter(vec_));
+    } else {
+        // AllowDuplicate to Not AllowDuplicate
+        std::unique_copy(rhs.Begin(), rhs.End(), std::back_inserter(vec_));
+    }
+}
+
+// copy operator
+template <class TYPE, bool AllowDuplicate>
+SortedVector<TYPE, AllowDuplicate>& SortedVector<TYPE, AllowDuplicate>::operator=(const SortedVector<TYPE, false>& rhs)
+{
+    // this class: AllowDuplicate or Not AllowDuplicate same type
+    vec_.clear();
+    std::copy(rhs.Begin(), rhs.End(), std::back_inserter(vec_));
+    return *this;
+}
+
+// copy operator
+template <class TYPE, bool AllowDuplicate>
+SortedVector<TYPE, AllowDuplicate>& SortedVector<TYPE, AllowDuplicate>::operator=(const SortedVector<TYPE, true>& rhs)
+{
+    vec_.clear();
+
+    if (AllowDuplicate) {
+        std::copy(rhs.Begin(), rhs.End(), std::back_inserter(vec_));
+    } else {
+        // AllowDuplicate to Not AllowDuplicate
+        std::unique_copy(rhs.Begin(), rhs.End(), std::back_inserter(vec_));
+    }
+
+    return *this;
+}
+
+template <class TYPE, bool AllowDuplicate>
+ssize_t SortedVector<TYPE, AllowDuplicate>::IndexOf(const TYPE& item) const
+{
+    if (vec_.empty()) {
+        return NOT_FOUND;
+    }
+
+    auto it = std::lower_bound(std::begin(vec_), std::end(vec_), item);
+    if (it == vec_.end() || !(*it == item)) {
+        return NOT_FOUND;
+    }
+    return it - vec_.begin();
+}
+
+template <class TYPE, bool AllowDuplicate>
+size_t SortedVector<TYPE, AllowDuplicate>::OrderOf(const TYPE& item) const
+{
+    auto it = std::upper_bound(vec_.begin(), vec_.end(), item);
+    return it - vec_.begin();
+}
+
+template <class TYPE, bool AllowDuplicate>
+ssize_t SortedVector<TYPE, AllowDuplicate>::Add(const TYPE& item)
+{
+    ssize_t index = IndexOf(item);
+    if (index != NOT_FOUND && !AllowDuplicate) {
+        return ADD_FAIL;
+    }
+
+    auto it = std::upper_bound(vec_.begin(), vec_.end(), item);
+    it = vec_.insert(it, item);
+    return it - vec_.begin();
+}
+
+template <class TYPE, bool AllowDuplicate>
+SortedVector<TYPE, AllowDuplicate>::SortedVector(const std::vector<TYPE>& invec)
+{
+    if (invec.empty()) {
+        return;
+    }
+
+    std::vector<TYPE> newvector(invec);
+    std::sort(newvector.begin(), newvector.end());
+    if (AllowDuplicate) {
+        vec_.swap(newvector);
+    } else {
+        std::unique_copy(newvector.begin(), newvector.end(), std::back_inserter(vec_));
+    }
+}
+
+template <class TYPE, bool AllowDuplicate>
+size_t SortedVector<TYPE, AllowDuplicate>::Merge(const std::vector<TYPE>& invec)
+{
+    SortedVector<TYPE, AllowDuplicate> sortedVector(invec);
+    Merge(sortedVector);
+    return vec_.size();
+}
+
+template <class TYPE, bool AllowDuplicate>
+size_t SortedVector<TYPE, AllowDuplicate>::Merge(const SortedVector<TYPE, AllowDuplicate>& sortedVector)
+{
+    std::vector<TYPE> newVec;
+    std::merge(vec_.begin(), vec_.end(), sortedVector.Begin(), sortedVector.End(), std::back_inserter(newVec));
+    if (!AllowDuplicate) {
+        vec_.clear();
+        std::unique_copy(newVec.begin(), newVec.end(), std::back_inserter(vec_));
+    } else {
+        vec_.swap(newVec);
+    }
+    return vec_.size();
+}
+
+} // namespace OHOS
+#endif
diff --git a/ohos_ndk_aosp/includes/utils/string_ex.h b/ohos_ndk_aosp/includes/utils/string_ex.h
new file mode 100755
index 0000000000..41be2adcd3
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/string_ex.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef STRING_EX_H
+#define STRING_EX_H
+
+#include <string>
+#include <vector>
+
+namespace OHOS {
+
+/**
+ * The UpperStr function convert all letters of str to uppercase.
+ */
+std::string UpperStr(const std::string& str);
+
+/**
+ * The LowerStr function convert all letters of str to lowercase.
+ */
+std::string LowerStr(const std::string& str);
+
+/**
+ * The ReplaceStr function will replace src with dst int base.
+ */
+std::string ReplaceStr(const std::string& str, const std::string& src, const std::string& dst);
+
+/**
+ * The TrimStr function will trim str by cTrim front and end.
+ */
+std::string TrimStr(const std::string& str, const char cTrim = ' ');
+
+/**
+ * The DexToHexString function convert decimal to hexadecimal string.
+ */
+std::string DexToHexString(int value, bool upper = true);
+
+/**
+ * The SplitStr function will split str by strSep.
+ */
+void SplitStr(const std::string& str, const std::string& sep, std::vector<std::string>& strs,
+              bool canEmpty = false, bool needTrim = true);
+
+/**
+ * The ToString function convert int and double and so on to str.
+ */
+template<class T>
+inline std::string ToString(T iValue)
+{
+    return std::to_string(iValue);
+}
+
+/**
+ * The StrToInt function convert str to int.
+ */
+bool StrToInt(const std::string& str, int& value);
+
+/**
+ * The IsNumericStr function judge all characters of the string are numbers,
+ * return true if all are numbers, else false.
+ */
+bool IsNumericStr(const std::string& str);
+
+/**
+ * The IsAlphaStr function judge all characters of the string are alphabet,
+ * return true if all are alphabet, else false.
+ */
+bool IsAlphaStr(const std::string& str);
+
+/**
+ * The IsUpperStr function judge all characters of the string are uppercase,
+ * return true if all are uppercase, else false.
+ */
+bool IsUpperStr(const std::string& str);
+
+/**
+ * The IsLowerStr function judge all characters of the string are lowercase,
+ * return true if all are lowercase, else false.
+ */
+bool IsLowerStr(const std::string& str);
+
+/**
+ * The IsSubStr function judge the sub in str,
+ * return true if sub in str, else false.
+ */
+bool IsSubStr(const std::string& str, const std::string& sub);
+
+/**
+ * The GetFirstSubStrBetween function get the first sub_str between left and right
+ * return the rightstr pos, if failed return string::npos.
+ */
+std::string::size_type GetFirstSubStrBetween(const std::string& str, const std::string& left,
+                                             const std::string& right, std::string& sub);
+
+/**
+ * The GetSubStrBetween function get the sub strings between left and right.
+ */
+void GetSubStrBetween(const std::string& str, const std::string& left,
+                      const std::string& right, std::vector<std::string>& sub);
+
+/**
+ * The IsSameTextStr function judge the first's letter is same with second,
+ * return true if same, else false.
+ */
+bool IsSameTextStr(const std::string& first, const std::string& second);
+
+bool IsAsciiString(const std::string& str);
+
+/**
+ * The str16ToStr8 function convert string16 to string8.
+ * If convert failed, return an empty string.
+ */
+std::string Str16ToStr8(const std::u16string& str16);
+
+/**
+ * The Str8ToStr16 function convert string8 to string16.
+ * If convert failed, return an empty u16string.
+ */
+std::u16string Str8ToStr16(const std::string& str);
+} // namespace OHOS
+
+#endif // STRING_EX_H
diff --git a/ohos_ndk_aosp/includes/utils/thread_ex.h b/ohos_ndk_aosp/includes/utils/thread_ex.h
new file mode 100755
index 0000000000..7bc0e8a639
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/thread_ex.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef UTILS_THREAD_EX_H
+#define UTILS_THREAD_EX_H
+
+#include <pthread.h>
+#include <string>
+#include <mutex>
+#include <condition_variable>
+
+namespace OHOS {
+
+enum class ThreadStatus {
+    OK,
+    WOULD_BLOCK,
+    INVALID_OPERATION,
+    UNKNOWN_ERROR,
+};
+
+enum ThreadPrio {
+    THREAD_PROI_NORMAL = 0,
+    THREAD_PROI_LOW = 10,
+    THREAD_PROI_LOWEST = 19,
+};
+
+constexpr int INVALID_PTHREAD_T = -1;
+constexpr int MAX_THREAD_NAME_LEN = 15;
+
+class Thread {
+public:
+    Thread();
+    virtual ~Thread();
+
+    ThreadStatus Start(const std::string& name, int32_t priority = THREAD_PROI_NORMAL, size_t stack = 0);
+
+    ThreadStatus NotifyExitSync();
+    virtual void NotifyExitAsync();
+
+    virtual bool ReadyToWork();
+
+    bool IsExitPending() const;
+    bool IsRunning() const;
+
+    pthread_t GetThread() const { return thread_; }
+protected:
+    virtual bool Run() = 0; // Derived class must implement Run()
+
+private:
+    Thread& operator=(const Thread&) = delete;
+    static int ThreadStart(void* args);
+    ThreadStatus Join(); // pthread created as detached
+
+private:
+    pthread_t thread_;
+    mutable std::mutex lock_;
+    std::condition_variable cvThreadExited_;
+    ThreadStatus status_;
+    volatile bool exitPending_;
+    volatile bool running_;
+};
+
+} // namespace OHOS
+
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/thread_pool.h b/ohos_ndk_aosp/includes/utils/thread_pool.h
new file mode 100755
index 0000000000..7bea3b688c
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/thread_pool.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef THREAD_POOL_H
+#define THREAD_POOL_H
+
+#include "nocopyable.h"
+
+#include <thread>
+#include <mutex>
+#include <functional>
+#include <string>
+#include <condition_variable>
+#include <deque>
+#include <vector>
+
+namespace OHOS {
+
+const int INVALID_SEMA_VALUE = -1;
+
+class ThreadPool : public NoCopyable {
+public:
+    typedef std::function<void()> Task;
+
+    explicit ThreadPool(const std::string &name = std::string());
+    ~ThreadPool();
+
+    uint32_t Start(int threadsNum);
+    void Stop();
+    void AddTask(const Task& f);
+    void SetMaxTaskNum(int maxSize) { maxTaskNum_ = maxSize; }
+
+    // for testability
+    size_t GetMaxTaskNum() const { return maxTaskNum_; }
+    size_t GetCurTaskNum();
+    size_t GetThreadsNum() const { return threads_.size(); }
+    std::string GetName() const { return myName_; }
+
+private:
+    // tasks in the queue reach the maximum set by maxQueueSize, means thread pool is full load.
+    bool Overloaded() const;
+    void WorkInThread(); // main        function in each thread.
+    Task ScheduleTask(); // fetch a task from the queue and execute
+
+private:
+    std::string myName_;
+    std::mutex mutex_;
+    std::condition_variable hasTaskToDo_;
+    std::condition_variable acceptNewTask_;
+    std::vector<std::thread> threads_;
+    std::deque<Task> tasks_;
+    size_t maxTaskNum_;
+    bool running_;
+};
+
+} // namespace OHOS
+
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/timer.h b/ohos_ndk_aosp/includes/utils/timer.h
new file mode 100755
index 0000000000..8b09ee4c15
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/timer.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UTILS_TIMER_H
+#define UTILS_TIMER_H
+
+#include <sys/types.h>
+#include <cstdint>
+#include <string>
+#include <list>
+#include <map>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+#include "../src/event_reactor.h"
+
+namespace OHOS {
+namespace Utils {
+
+class Timer {
+public:
+    using TimerCallback = std::function<void ()>;
+    using TimerCallbackPtr = std::shared_ptr<TimerCallback>;
+    using TimerListCallback = std::function<void (int timerFd)>;
+
+public:
+    /*
+     * if performance-sensitive, change "timeout" larger before Setup
+     * default-value(1000ms), performance-estimate: occupy fixed-100us in every default-value(1000ms)
+     * timeout: range [-1, INT32MAX], but [-1,0] is not recommended
+     *          -1: wait for ever(until event-trigger);
+     *          0: no wait, occupy too much cpu time;
+     *          others: wait(until event-trigger)
+     */
+    explicit Timer(const std::string& name, int timeoutMs = 1000);
+    virtual ~Timer() {}
+
+    virtual uint32_t Setup();
+
+    /*
+     * useJoin true:    use std::thread::join(default)
+     *         false:   use std::thread::detach(not recommended)
+     * if timeoutMs = -1 and no valid event-trigger in epoll_wait:
+     *                  use std::thread::detach inside to avoid deadloop
+     */
+    virtual void Shutdown(bool useJoin = true);
+
+    uint32_t Register(const TimerCallback& callback, uint32_t interval /* ms */, bool once = false);
+    void Unregister(uint32_t timerId);
+
+private:
+    void MainLoop();
+    void OnTimer(int timerFd);
+    virtual uint32_t DoRegister(const TimerListCallback& callback, uint32_t interval, bool once, int &timerFd);
+    virtual void DoUnregister(uint32_t interval);
+    void DoTimerListCallback(const TimerListCallback& callback, int timerFd);
+    uint32_t GetValidId(uint32_t timerId) const;
+    int GetTimerFd(uint32_t interval /* ms */);
+    void EraseUnusedTimerId(uint32_t interval, const std::vector<uint32_t>& unusedIds);
+
+private:
+    struct TimerEntry {
+        uint32_t       timerId;  // unique id
+        uint32_t       interval;  // million second
+        TimerCallback  callback;
+        bool           once;
+        int            timerFd;
+    };
+
+    using TimerEntryPtr = std::shared_ptr<TimerEntry>;
+    using TimerEntryList = std::list<TimerEntryPtr>;
+
+    std::map<uint32_t, TimerEntryList> intervalToTimers_;  // interval to TimerEntryList
+    std::map<uint32_t, TimerEntryPtr> timerToEntries_;  // timer_id to TimerEntry
+
+    std::string name_;
+    int timeoutMs_;
+    std::thread thread_;
+    std::unique_ptr<EventReactor> reactor_;
+    std::map<uint32_t, uint32_t> timers_;  // timer_fd to interval
+    std::mutex mutex_;
+};
+
+} // namespace Utils
+} // namespace OHOS
+#endif
+
diff --git a/ohos_ndk_aosp/includes/utils/unique_fd.h b/ohos_ndk_aosp/includes/utils/unique_fd.h
new file mode 100755
index 0000000000..24a00dedce
--- /dev/null
+++ b/ohos_ndk_aosp/includes/utils/unique_fd.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UNIQUE_FD_H
+#define UNIQUE_FD_H
+
+#include <unistd.h>
+
+namespace OHOS {
+class DefaultDeleter {
+public:
+    static void Close(int fd)
+    {
+        if (fd >= 0) {
+            close(fd);
+        }
+    }
+};
+
+template <typename Deleter>
+class UniqueFdAddDeletor;
+template <typename Deleter>
+bool operator==(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+template <typename Deleter>
+bool operator!=(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+template <typename Deleter>
+bool operator>=(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+template <typename Deleter>
+bool operator>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+template <typename Deleter>
+bool operator<=(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+template <typename Deleter>
+bool operator<(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+template <typename Deleter = DefaultDeleter>
+class UniqueFdAddDeletor final {
+
+    friend bool operator==<Deleter>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+    friend bool operator!=<Deleter>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+    friend bool operator>=<Deleter>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+    friend bool operator><Deleter>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+    friend bool operator<=<Deleter>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+    friend bool operator< <Deleter>(const int& lhs, const UniqueFdAddDeletor<Deleter>& rhs);
+
+public:
+    explicit UniqueFdAddDeletor(const int& value)
+        : fd_(value)
+    {
+    }
+    UniqueFdAddDeletor()
+        : fd_(-1)
+    {
+    }
+    ~UniqueFdAddDeletor() { Reset(-1); }
+
+    // get fd out
+    int Release()
+    {
+        int tmp = fd_;
+        fd_ = -1;
+        return tmp;
+    }
+
+    // this is dangerous, when you use it , you should know it, donot operator on the ret
+    operator int() const { return Get(); } // NOLINT
+    // this is dangerous, when you use it , you should know it, donot operator on the ret
+    int Get() const
+    {
+        return fd_;
+    }
+
+    // we need move fd from one to another
+    UniqueFdAddDeletor(UniqueFdAddDeletor&& rhs)
+    {
+        int rhsfd = rhs.Release();
+        fd_ = rhsfd;
+    }
+
+    UniqueFdAddDeletor& operator=(UniqueFdAddDeletor&& rhs)
+    {
+        int rhsfd = rhs.Release();
+        Reset(rhsfd);
+        return *this;
+    }
+
+    bool operator==(const int& rhs) const
+    {
+        return fd_ == rhs;
+    }
+
+    bool operator!=(const int& rhs) const
+    {
+        return !(fd_ == rhs);
+    }
+    bool operator>=(const int& rhs) const
+    {
+        return fd_ >= rhs;
+    }
+
+    bool operator>(const int& rhs) const
+    {
+        return fd_ > rhs;
+    }
+
+    bool operator<=(const int& rhs) const
+    {
+        return fd_ <= rhs;
+    }
+
+    bool operator<(const int& rhs) const
+    {
+        return fd_ < rhs;
+    }
+
+private:
+    int fd_ = -1;
+
+    void Reset(int newValue)
+    {
+        if (fd_ >= 0) {
+            Deleter::Close(fd_);
+        }
+        fd_ = newValue;
+    }
+
+    // disallow copy ctor and copy assign
+    UniqueFdAddDeletor(const UniqueFdAddDeletor& rhs) = delete;
+    UniqueFdAddDeletor& operator=(const UniqueFdAddDeletor& rhs) = delete;
+};
+
+template <typename Deleter = DefaultDeleter>
+bool operator==(const int& lhs, const UniqueFdAddDeletor<Deleter>& uniqueFd)
+{
+    return lhs == uniqueFd.fd_;
+}
+
+template <typename Deleter = DefaultDeleter>
+bool operator!=(const int& lhs, const UniqueFdAddDeletor<Deleter>& uniqueFd)
+{
+    return !(lhs == uniqueFd.fd_);
+}
+
+template <typename Deleter = DefaultDeleter>
+bool operator>=(const int& lhs, const UniqueFdAddDeletor<Deleter>& uniqueFd)
+{
+    return lhs >= uniqueFd.fd_;
+}
+
+template <typename Deleter = DefaultDeleter>
+bool operator>(const int& lhs, const UniqueFdAddDeletor<Deleter>& uniqueFd)
+{
+    return lhs > uniqueFd.fd_;
+}
+
+template <typename Deleter = DefaultDeleter>
+bool operator<=(const int& lhs, const UniqueFdAddDeletor<Deleter>& uniqueFd)
+{
+    return lhs <= uniqueFd.fd_;
+}
+
+template <typename Deleter = DefaultDeleter>
+bool operator<(const int& lhs, const UniqueFdAddDeletor<Deleter>& uniqueFd)
+{
+    return lhs < uniqueFd.fd_;
+}
+
+using UniqueFd = UniqueFdAddDeletor<DefaultDeleter>;
+} // namespace OHOS
+#endif
diff --git a/ohos_ndk_aosp/libs/libeventhandler.z.so b/ohos_ndk_aosp/libs/libeventhandler.z.so
new file mode 100755
index 0000000000..c618342622
Binary files /dev/null and b/ohos_ndk_aosp/libs/libeventhandler.z.so differ
diff --git a/ohos_ndk_aosp/libs/libhilog.so b/ohos_ndk_aosp/libs/libhilog.so
new file mode 100755
index 0000000000..5dc858e6e4
Binary files /dev/null and b/ohos_ndk_aosp/libs/libhilog.so differ
diff --git a/ohos_ndk_aosp/libs/libinputmethod_ability.z.so b/ohos_ndk_aosp/libs/libinputmethod_ability.z.so
new file mode 100755
index 0000000000..83ccbab51f
Binary files /dev/null and b/ohos_ndk_aosp/libs/libinputmethod_ability.z.so differ
diff --git a/ohos_ndk_aosp/libs/libinputmethod_client.z.so b/ohos_ndk_aosp/libs/libinputmethod_client.z.so
new file mode 100755
index 0000000000..0e3d497f79
Binary files /dev/null and b/ohos_ndk_aosp/libs/libinputmethod_client.z.so differ
diff --git a/ohos_ndk_aosp/libs/libipc_core.z.so b/ohos_ndk_aosp/libs/libipc_core.z.so
new file mode 100755
index 0000000000..c5007c7ff9
Binary files /dev/null and b/ohos_ndk_aosp/libs/libipc_core.z.so differ
diff --git a/ohos_ndk_aosp/libs/libmedia_client.z.so b/ohos_ndk_aosp/libs/libmedia_client.z.so
new file mode 100755
index 0000000000..f6596871fa
Binary files /dev/null and b/ohos_ndk_aosp/libs/libmedia_client.z.so differ
diff --git a/ohos_ndk_aosp/libs/libsurface.z.so b/ohos_ndk_aosp/libs/libsurface.z.so
new file mode 100755
index 0000000000..cc223000ff
Binary files /dev/null and b/ohos_ndk_aosp/libs/libsurface.z.so differ
diff --git a/ohos_ndk_aosp/libs/libutils.z.so b/ohos_ndk_aosp/libs/libutils.z.so
new file mode 100755
index 0000000000..f737ea3319
Binary files /dev/null and b/ohos_ndk_aosp/libs/libutils.z.so differ
diff --git a/ohos_nweb/BUILD.gn b/ohos_nweb/BUILD.gn
index c87c2a462f..aa77be3230 100644
--- a/ohos_nweb/BUILD.gn
+++ b/ohos_nweb/BUILD.gn
@@ -181,10 +181,28 @@ executable("web_render") {
   sources = [
     "src/ohos_nweb_main.cc",
   ]
+  deps = [
+    ":nweb_hilog",
+  ]
+}
+ 
+shared_library("libnweb_render") {
+  defines = [
+    "OHOS_NWEB",
+  ]
+ 
+  include_dirs = [
+    "include",
+  ]
+  include_dirs += ohos_src_includes
+ 
+  sources = [
+    "src/nweb_render_main.cc",
+  ]
 
   deps = [
     ":nweb_hilog",
     "//cef:libweb_engine",
     "//cef:libcef_dll_wrapper",
   ]
-}
\ No newline at end of file
+}
diff --git a/ohos_nweb/include/nweb.h b/ohos_nweb/include/nweb.h
index 707d3a6fd8..10c2f66e40 100755
--- a/ohos_nweb/include/nweb.h
+++ b/ohos_nweb/include/nweb.h
@@ -150,7 +150,7 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      *
      * @return the last HitTestResult
      */
-     virtual const HitTestResult GetHitTestResult() const = 0;
+     virtual HitTestResult GetHitTestResult() const = 0;
 
     /**
      * Sets the background color for this view.
diff --git a/ohos_nweb/include/nweb_access_request.h b/ohos_nweb/include/nweb_access_request.h
index 853c91ec86..6592ba26ee 100644
--- a/ohos_nweb/include/nweb_access_request.h
+++ b/ohos_nweb/include/nweb_access_request.h
@@ -11,47 +11,47 @@
 
 namespace OHOS::NWeb {
 class OHOS_NWEB_EXPORT NWebAccessRequest {
- public:
-  NWebAccessRequest() = default;
-
-  virtual ~NWebAccessRequest() = default;
-
-  enum Resources {
-    GEOLOCATION = 1 << 0,
-    VIDEO_CAPTURE = 1 << 1,
-    AUDIO_CAPTURE = 1 << 2,
-    PROTECTED_MEDIA_ID = 1 << 3,
-    MIDI_SYSEX = 1 << 4,
-  };
-
-  /**
-   * Get the origin of the web page which is trying to access the resource.
-   *
-   * @return the origin of the web page which is trying to access the resource.
-   */
-  virtual std::string Origin() = 0;
-
-  /**
-   * Get the resource id the web page is trying to access.
-   *
-   * @return the resource id the web page is trying to access.
-   */
-  virtual int ResourceAcessId() = 0;
-
-  /**
-   * Agree the origin to access the given resources.
-   * The granted access is only valid for this WebView.
-   *
-   * @param resourceId id of the resource agreed to be accessed by origin. It
-   * must be equal to requested resource id returned by {@link
-   * #GetResourceAcessId()}.
-   */
-  virtual void Agree(int resourceId) = 0;
-
-  /**
-   * Refuse the request.
-   */
-  virtual void Refuse() = 0;
+public:
+    NWebAccessRequest() = default;
+
+    virtual ~NWebAccessRequest() = default;
+
+    enum Resources {
+        GEOLOCATION = 1 << 0,
+        VIDEO_CAPTURE = 1 << 1,
+        AUDIO_CAPTURE = 1 << 2,
+        PROTECTED_MEDIA_ID = 1 << 3,
+        MIDI_SYSEX = 1 << 4,
+    };
+
+    /**
+    * Get the origin of the web page which is trying to access the resource.
+    *
+    * @return the origin of the web page which is trying to access the resource.
+    */
+    virtual std::string Origin() = 0;
+
+    /**
+    * Get the resource id the web page is trying to access.
+    *
+    * @return the resource id the web page is trying to access.
+    */
+    virtual int ResourceAcessId() = 0;
+
+    /**
+    * Agree the origin to access the given resources.
+    * The granted access is only valid for this WebView.
+    *
+    * @param resourceId id of the resource agreed to be accessed by origin. It
+    * must be equal to requested resource id returned by {@link
+    * #GetResourceAcessId()}.
+    */
+    virtual void Agree(int resourceId) = 0;
+
+    /**
+    * Refuse the request.
+    */
+    virtual void Refuse() = 0;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_console_log.h b/ohos_nweb/include/nweb_console_log.h
index 2089061420..b0a8d6bbd9 100644
--- a/ohos_nweb/include/nweb_console_log.h
+++ b/ohos_nweb/include/nweb_console_log.h
@@ -76,4 +76,4 @@ private:
 };
 }
 
-#endif
\ No newline at end of file
+#endif // NWEB_CONSOLE_LOG_H
\ No newline at end of file
diff --git a/ohos_nweb/include/nweb_cookie_manager.h b/ohos_nweb/include/nweb_cookie_manager.h
index 11800d8579..4e2c33aaf9 100644
--- a/ohos_nweb/include/nweb_cookie_manager.h
+++ b/ohos_nweb/include/nweb_cookie_manager.h
@@ -31,7 +31,6 @@ public:
      * @return true if the instance send and accept cookies.
      */
     virtual bool IsAcceptCookieAllowed() const = 0;
-    
     /**
      * @brief Sets whether the instance should send and accept cookies.
      * By default this is set to true and the nweb accepts cookies.
@@ -39,21 +38,18 @@ public:
      * @param accept whether the instance should send and accept cookies.
      */
     virtual void PutAcceptCookieEnabled(bool accept) = 0;
-    
     /**
      * @brief Get whether instances can send and accept cookies for file scheme URLs.
      *
      * @return true if instances send and accept cookies for file scheme URLs.
      */
     virtual bool IsFileURLSchemeCookiesAllowed() const = 0;
-    
     /**
      * @brief Sets whether the instance should send and accept cookies for file scheme URLs.
      *
      * @param allow whether the instance should send and accept cookies for file scheme URLs.
      */
     virtual void PutAcceptFileURLSchemeCookiesEnabled(bool allow) = 0;
-    
     /**
      * @brief Gets all the cookies for the given URL.
      *
@@ -62,7 +58,6 @@ public:
      */
     virtual void ReturnCookie(const std::string &url,
                               std::shared_ptr<NWebValueCallback<std::string>> callback) = 0;
-    
     /**
      * @brief GSets a single cookie (key-value pair) for the given URL.
      *
@@ -73,14 +68,12 @@ public:
     virtual void SetCookie(const std::string &url,
                            const std::string &value,
                            std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
-    
     /**
      * @brief Gets whether there are stored cookies.
      *
      * @param callback a callback to be executed when the cookie has checked.
      */
     virtual void ExistCookies(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
-    
     /**
      * @brief Ensures all cookies currently accessible through the ReturnCookie API are written to
      * persistent storage.
@@ -88,14 +81,12 @@ public:
      * @param callback a callback to be executed when cookies has Stored.
      */
     virtual void Store(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
-    
     /**
      * @brief Removes all session cookies, which are cookies without an expiration date.
      *
      * @param callback a callback to be executed when all session cookies has removed.
      */
     virtual void DeleteSessionCookies(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
-    
     /**
      * @brief Removes all cookies.
      *
diff --git a/ohos_nweb/include/nweb_geolocation_callback_interface.h b/ohos_nweb/include/nweb_geolocation_callback_interface.h
index 4a95f8e8db..5fe586d606 100644
--- a/ohos_nweb/include/nweb_geolocation_callback_interface.h
+++ b/ohos_nweb/include/nweb_geolocation_callback_interface.h
@@ -11,21 +11,21 @@
 
 namespace OHOS::NWeb {
 class OHOS_NWEB_EXPORT NWebGeolocationCallbackInterface {
- public:
-  NWebGeolocationCallbackInterface() = default;
+public:
+    NWebGeolocationCallbackInterface() = default;
 
-  virtual ~NWebGeolocationCallbackInterface() = default;
-  /**
-   * @brief Report the geolocation permission status from usrs.
-   *
-   * @param origin The origin that ask for the geolocation permission.
-   * @param allow The geolocation permission status.
-   * @param retain Whether to allow the geolocation permission status to be
-   * saved to the system.
-   */
-  virtual void GeolocationCallbackInvoke(const std::string& origin,
-                                         bool allow,
-                                         bool retain) = 0;
+    virtual ~NWebGeolocationCallbackInterface() = default;
+    /**
+    * @brief Report the geolocation permission status from usrs.
+    *
+    * @param origin The origin that ask for the geolocation permission.
+    * @param allow The geolocation permission status.
+    * @param retain Whether to allow the geolocation permission status to be
+    * saved to the system.
+    */
+    virtual void GeolocationCallbackInvoke(const std::string& origin,
+                                           bool allow,
+                                           bool retain) = 0;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_handler.h b/ohos_nweb/include/nweb_handler.h
index af68a9a3d1..ce72bc9580 100644
--- a/ohos_nweb/include/nweb_handler.h
+++ b/ohos_nweb/include/nweb_handler.h
@@ -24,287 +24,283 @@ namespace OHOS::NWeb {
  * @brief Describes how pixel bits encoder color data.
  */
 enum class ImageColorType {
-  // Unknown color type.
-  COLOR_TYPE_UNKNOWN = -1,
+    // Unknown color type.
+    COLOR_TYPE_UNKNOWN = -1,
 
-  // RGBA with 8 bits per pixel (32bits total).
-  COLOR_TYPE_RGBA_8888 = 0,
+    // RGBA with 8 bits per pixel (32bits total).
+    COLOR_TYPE_RGBA_8888 = 0,
 
-  // BGRA with 8 bits per pixel (32bits total).
-  COLOR_TYPE_BGRA_8888 = 1,
+    // BGRA with 8 bits per pixel (32bits total).
+    COLOR_TYPE_BGRA_8888 = 1,
 };
 
 /**
  * @brief Describes how to interpret the alpha value of a pixel.
  */
 enum class ImageAlphaType {
-  // Unknown alpha type.
-  ALPHA_TYPE_UNKNOWN = -1,
+    // Unknown alpha type.
+    ALPHA_TYPE_UNKNOWN = -1,
 
-  // No transparency. The alpha component is ignored.
-  ALPHA_TYPE_OPAQUE = 0,
+    // No transparency. The alpha component is ignored.
+    ALPHA_TYPE_OPAQUE = 0,
 
-  // Transparency with pre-multiplied alpha component.
-  ALPHA_TYPE_PREMULTIPLIED = 1,
+    // Transparency with pre-multiplied alpha component.
+    ALPHA_TYPE_PREMULTIPLIED = 1,
 
-  // Transparency with post-multiplied alpha component.
-  ALPHA_TYPE_POSTMULTIPLIED = 2,
+    // Transparency with post-multiplied alpha component.
+    ALPHA_TYPE_POSTMULTIPLIED = 2,
 };
 
 class OHOS_NWEB_EXPORT NWebHandler {
- public:
-  NWebHandler() = default;
-
-  virtual ~NWebHandler() = default;
-
-  virtual void SetNWeb(std::shared_ptr<NWeb> nweb) {}
-
-  virtual void OnProxyDied() {}
-
-  virtual void OnRouterPush(const std::string& param) {}
-
-  virtual void OnMessage(const std::string& param) {}
-
-  /**
-   * @brief Notify the SDK that a web site has finished loading. This method is
-   * called only for main frame.
-   *
-   * @param httpStatusCode The status code for the http request.
-   * @param url The url of the web site.
-   */
-  virtual void OnPageLoadEnd(int httpStatusCode, const std::string& url) {}
-
-  /**
-   * @brief Notify the SDK that a web site has started loading. This method is
-   * called once for each main frame load.
-   *
-   * @param url The url to be loaded.
-   */
-  virtual void OnPageLoadBegin(const std::string& url) {}
-
-  /**
-   * @brief Report a load error to the SDK.
-   *
-   * @param errorCode The error code.
-   * @param description The error description.
-   * @param failingUrl The failed url.
-   */
-  virtual void OnPageLoadError(int errorCode,
-                               const std::string& description,
-                               const std::string& failingUrl) {}
-
-  /**
-   * @brief Give the SDK a chance to decide wheather to continue loading the
-   * url.
-   *
-   * @param url The url to be loaded.
-   * @return true to cancel the loading, false to continue the loading.
-   */
-  virtual bool OnHandleInterceptUrlLoading(const std::string& url) {
-    return false;
-  }
-
-  /**
-   * @brief Notify the SDK that the nweb will load the resource specified by
-   * the given url.
-   *
-   * @param url The url of the resource.
-   */
-  virtual void OnResource(const std::string& url) {}
-
-  /**
-   * @brief Notify the SDK of the changed document title.
-   *
-   * @param title The document title.
-   */
-  virtual void OnPageTitle(const std::string& title) {}
-
-  /**
-   * @brief Notify the SDK the current progress of loading a web site.
-   *
-   * @param newProgress Loading progress, an integer between 0 and 100.
-   */
-  virtual void OnLoadingProgress(int newProgress) {}
-
-  /**
-   * @brief Request display and focus for a new nweb.
-   *
-   */
-  virtual void OnFocus() {}
-
-  /**
-   * @brief Obtains a list of all visited history items, used for link coloring
-   *
-   * @retval visited history
-   */
-  virtual const std::vector<std::string> VisitedUrlHistory() {
-    return std::vector<std::string>();
-  }
-
-  /**
-   * @brief Notify the host application of a resource request and allow the
-   * application to return the data.
-   *
-   * @param request the resource response's MIME type, for example {
-   * "text/html"}.
-   *
-   * @retval if NWebUrlResourceResponse is null ,No interception.
-   */
-  virtual std::shared_ptr<NWebUrlResourceResponse> OnHandleInterceptRequest(
-      std::shared_ptr<NWebUrlResourceRequest> request) {
-    return nullptr;
-  }
-
-  /**
-   * @brief Report web resource loading error to the SDK. These errors usually
-   * indicate inability to connect to the server.
-   *
-   * @param request The request information.
-   * @param error The error information.
-   */
-  virtual void OnResourceLoadError(
-      std::shared_ptr<NWebUrlResourceRequest> request,
-      std::shared_ptr<NWebUrlResourceError> error) {}
-
-  /**
-   * @brief Notify the SDK that an HTTP error has been received from the server
-   * while loading a resource.
-   *
-   * @param request The request information.
-   * @param errorResponse The error occurred.
-   */
-  virtual void OnHttpError(
-      std::shared_ptr<NWebUrlResourceRequest> request,
-      std::shared_ptr<NWebUrlResourceResponse> errorResponse) {}
-
-  /**
-   * @brief Notify the SDK of a new favicon for the current web site.
-   *
-   * @param data The raw image data for the icon.
-   * @param width The width of the icon in pixel.
-   * @param height The height of the icon in pixel.
-   * @param color_type The color data encoding type.
-   * @param alpha_type The alpha value of any pixel.
-   */
-  virtual void OnPageIcon(const void* data,
-                          size_t width,
-                          size_t height,
-                          ImageColorType color_type,
-                          ImageAlphaType alpha_type) {}
-
-  /**
-   * @brief Notify the SDK of the url for an touch icon.
-   *
-   * @param icon_url The icon url.
-   * @param precomposed The touch icon type.
-   */
-  virtual void OnDesktopIconUrl(const std::string& icon_url, bool precomposed) {
-  }
-
-  /**
-   * @brief Report a JavaScript console message to the host application.
-   *
-   * @param message Details of the console message.
-   * @return Return true to stop the message from being output to the console.
-   */
-  virtual bool OnConsoleLog(const NWebConsoleLog& message) { return false; }
-
-  /**
-   * @brief Show prompt to ask for the geolocation permission.
-   *
-   * @param origin  String: the origin of the resource to get geolocation
-   * @param callback  GeolocationCallbackInterface: callback to report
-   * geolocation
-   */
-  virtual void OnGeolocationShow(const std::string& origin,
-                                 NWebGeolocationCallbackInterface* callback) {}
-
-  /**
-   * @brief Notify the host application that the web page wants to display a
-   * JavaScript alert() dialog.
-   *
-   * @param url  String: The url of the page requesting the dialog.
-   * @param message  String: The message of the dialog.
-   * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
-   * confirm that the user closed the window.
-   * @return To show a custom dialog, the app should return true.
-   */
-  virtual bool OnAlertDialogByJS(const std::string& url,
-                                 const std::string& message,
-                                 std::shared_ptr<NWebJSDialogResult> result) {
-    return false;
-  }
-
-  /**
-   * @brief Notify the host application that the web page wants to handle
-   * JavaScript onbeforeunload.
-   *
-   * @param url  String: The url of the page requesting.
-   * @param message  String: The message of the dialog.
-   * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
-   * confirm that the user closed the window.
-   * @return To show a custom dialog, the app should return true.
-   */
-  virtual bool OnBeforeUnloadByJS(const std::string& url,
-                                  const std::string& message,
-                                  std::shared_ptr<NWebJSDialogResult> result) {
-    return false;
-  }
-
-  /**
-   * @brief Notify the host application that the web page wants to display a
-   * JavaScript prompt() dialog.
-   *
-   * @param url  String: The url of the page requesting the dialog.
-   * @param message  String: The message of the dialog.
-   * @param defaultValue  String: The default value of the input message.
-   * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
-   * confirm that the user closed the window.
-   * @return To show a custom dialog, the app should return true.
-   */
-  virtual bool OnPromptDialogByJs(const std::string& url,
-                                  const std::string& message,
-                                  const std::string& defaultValue,
-                                  std::shared_ptr<NWebJSDialogResult> result) {
-    return false;
-  }
-
-  /**
-   * @brief Notify the host application that the web page wants to display a
-   * JavaScript Confirm() dialog.
-   *
-   * @param url  String: The url of the page requesting the dialog.
-   * @param message  String: The message of the dialog.
-   * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
-   * confirm that the user closed the window.
-   * @return To show a custom dialog, the app should return true.
-   */
-  virtual bool OnConfirmDialogByJS(const std::string& url,
+public:
+    NWebHandler() = default;
+
+    virtual ~NWebHandler() = default;
+
+    virtual void SetNWeb(std::shared_ptr<NWeb> nweb) {}
+
+    virtual void OnProxyDied() {}
+
+    virtual void OnRouterPush(const std::string& param) {}
+
+    virtual void OnMessage(const std::string& param) {}
+
+    /**
+     * @brief Notify the SDK that a web site has finished loading. This method is
+     * called only for main frame.
+     *
+     * @param httpStatusCode The status code for the http request.
+     * @param url The url of the web site.
+     */
+    virtual void OnPageLoadEnd(int httpStatusCode, const std::string& url) {}
+
+    /**
+     * @brief Notify the SDK that a web site has started loading. This method is
+     * called once for each main frame load.
+     *
+     * @param url The url to be loaded.
+     */
+    virtual void OnPageLoadBegin(const std::string& url) {}
+
+    /**
+     * @brief Report a load error to the SDK.
+     *
+     * @param errorCode The error code.
+     * @param description The error description.
+     * @param failingUrl The failed url.
+     */
+    virtual void OnPageLoadError(int errorCode,
+                                 const std::string& description,
+                                 const std::string& failingUrl) {}
+
+    /**
+     * @brief Give the SDK a chance to decide wheather to continue loading the
+     * url.
+     *
+     * @param url The url to be loaded.
+     * @return true to cancel the loading, false to continue the loading.
+     */
+    virtual bool OnHandleInterceptUrlLoading(const std::string& url) {
+        return false;
+    }
+
+    /**
+     * @brief Notify the SDK that the nweb will load the resource specified by
+     * the given url.
+     *
+     * @param url The url of the resource.
+     */
+    virtual void OnResource(const std::string& url) {}
+
+    /**
+     * @brief Notify the SDK of the changed document title.
+     *
+     * @param title The document title.
+     */
+    virtual void OnPageTitle(const std::string& title) {}
+
+    /**
+     * @brief Notify the SDK the current progress of loading a web site.
+     *
+     * @param newProgress Loading progress, an integer between 0 and 100.
+     */
+    virtual void OnLoadingProgress(int newProgress) {}
+
+    /**
+     * @brief Request display and focus for a new nweb.
+     *
+     */
+    virtual void OnFocus() {}
+
+    /**
+     * @brief Obtains a list of all visited history items, used for link coloring
+     *
+     * @retval visited history
+     */
+    virtual const std::vector<std::string> VisitedUrlHistory() {
+        return std::vector<std::string>();
+    }
+
+    /**
+     * @brief Notify the host application of a resource request and allow the
+     * application to return the data.
+     *
+     * @param request the resource response's MIME type, for example {
+     * "text/html"}.
+     *
+     * @retval if NWebUrlResourceResponse is null ,No interception.
+     */
+    virtual std::shared_ptr<NWebUrlResourceResponse> OnHandleInterceptRequest(
+        std::shared_ptr<NWebUrlResourceRequest> request) {
+        return nullptr;
+    }
+
+    /**
+     * @brief Report web resource loading error to the SDK. These errors usually
+     * indicate inability to connect to the server.
+     *
+     * @param request The request information.
+     * @param error The error information.
+     */
+    virtual void OnResourceLoadError(std::shared_ptr<NWebUrlResourceRequest> request,
+                                     std::shared_ptr<NWebUrlResourceError> error) {}
+
+    /**
+     * @brief Notify the SDK that an HTTP error has been received from the server
+     * while loading a resource.
+     *
+     * @param request The request information.
+     * @param errorResponse The error occurred.
+     */
+    virtual void OnHttpError(std::shared_ptr<NWebUrlResourceRequest> request,
+                             std::shared_ptr<NWebUrlResourceResponse> errorResponse) {}
+
+    /**
+     * @brief Notify the SDK of a new favicon for the current web site.
+     *
+     * @param data The raw image data for the icon.
+     * @param width The width of the icon in pixel.
+     * @param height The height of the icon in pixel.
+     * @param color_type The color data encoding type.
+     * @param alpha_type The alpha value of any pixel.
+     */
+    virtual void OnPageIcon(const void* data,
+                            size_t width,
+                            size_t height,
+                            ImageColorType color_type,
+                            ImageAlphaType alpha_type) {}
+
+    /**
+     * @brief Notify the SDK of the url for an touch icon.
+     *
+     * @param icon_url The icon url.
+     * @param precomposed The touch icon type.
+     */
+    virtual void OnDesktopIconUrl(const std::string& icon_url, bool precomposed) {
+    }
+
+    /**
+     * @brief Report a JavaScript console message to the host application.
+     *
+     * @param message Details of the console message.
+     * @return Return true to stop the message from being output to the console.
+     */
+    virtual bool OnConsoleLog(const NWebConsoleLog& message) { return false; }
+
+    /**
+     * @brief Show prompt to ask for the geolocation permission.
+     *
+     * @param origin  String: the origin of the resource to get geolocation
+     * @param callback  GeolocationCallbackInterface: callback to report
+     * geolocation
+     */
+    virtual void OnGeolocationShow(const std::string& origin,
+                                   NWebGeolocationCallbackInterface* callback) {}
+
+    /**
+     * @brief Notify the host application that the web page wants to display a
+     * JavaScript alert() dialog.
+     *
+     * @param url  String: The url of the page requesting the dialog.
+     * @param message  String: The message of the dialog.
+     * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
+     * confirm that the user closed the window.
+     * @return To show a custom dialog, the app should return true.
+     */
+    virtual bool OnAlertDialogByJS(const std::string& url,
                                    const std::string& message,
                                    std::shared_ptr<NWebJSDialogResult> result) {
-    return false;
-  }
-
-  /**
-   * @brief Hide prompt to ask for the geolocation permission.
-   */
-  virtual void OnGeolocationHide() {}
-
-  /**
-   * @brief
-   *
-   * @param request  String:
-   */
-  virtual void OnPermissionRequest(
-      std::shared_ptr<NWebAccessRequest> request) {}
-
-  /**
-   * @brief
-   *
-   * @param request  String:
-   */
-  virtual void OnPermissionRequestCanceled(
-      std::shared_ptr<NWebAccessRequest> request) {}
+        return false;
+    }
+
+    /**
+     * @brief Notify the host application that the web page wants to handle
+     * JavaScript onbeforeunload.
+     *
+     * @param url  String: The url of the page requesting.
+     * @param message  String: The message of the dialog.
+     * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
+     * confirm that the user closed the window.
+     * @return To show a custom dialog, the app should return true.
+     */
+    virtual bool OnBeforeUnloadByJS(const std::string& url,
+                                    const std::string& message,
+                                    std::shared_ptr<NWebJSDialogResult> result) {
+        return false;
+    }
+
+    /**
+     * @brief Notify the host application that the web page wants to display a
+     * JavaScript prompt() dialog.
+     *
+     * @param url  String: The url of the page requesting the dialog.
+     * @param message  String: The message of the dialog.
+     * @param defaultValue  String: The default value of the input message.
+     * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
+     * confirm that the user closed the window.
+     * @return To show a custom dialog, the app should return true.
+     */
+    virtual bool OnPromptDialogByJs(const std::string& url,
+                                    const std::string& message,
+                                    const std::string& defaultValue,
+                                    std::shared_ptr<NWebJSDialogResult> result) {
+        return false;
+    }
+
+    /**
+     * @brief Notify the host application that the web page wants to display a
+     * JavaScript Confirm() dialog.
+     *
+     * @param url  String: The url of the page requesting the dialog.
+     * @param message  String: The message of the dialog.
+     * @param result  std::shared_ptr<NWebJSDialogResult>: A NWebJSDialogResult to
+     * confirm that the user closed the window.
+     * @return To show a custom dialog, the app should return true.
+     */
+    virtual bool OnConfirmDialogByJS(const std::string& url,
+                                     const std::string& message,
+                                     std::shared_ptr<NWebJSDialogResult> result) {
+        return false;
+    }
+
+    /**
+     * @brief Hide prompt to ask for the geolocation permission.
+     */
+    virtual void OnGeolocationHide() {}
+
+    /**
+     * @brief
+     *
+     * @param request  String:
+     */
+    virtual void OnPermissionRequest(std::shared_ptr<NWebAccessRequest> request) {}
+
+    /**
+     * @brief
+     *
+     * @param request  String:
+     */
+    virtual void OnPermissionRequestCanceled(std::shared_ptr<NWebAccessRequest> request) {}
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_hit_testresult.h b/ohos_nweb/include/nweb_hit_testresult.h
index 4eb0d0915b..510e471280 100755
--- a/ohos_nweb/include/nweb_hit_testresult.h
+++ b/ohos_nweb/include/nweb_hit_testresult.h
@@ -75,7 +75,6 @@ public:
 private:
     int type_;
     std::string extra_;
-
 };
 }
 
diff --git a/ohos_nweb/include/nweb_js_dialog_result.h b/ohos_nweb/include/nweb_js_dialog_result.h
index 13b0fe51f0..693a050f4a 100644
--- a/ohos_nweb/include/nweb_js_dialog_result.h
+++ b/ohos_nweb/include/nweb_js_dialog_result.h
@@ -12,19 +12,16 @@ namespace OHOS::NWeb {
 class OHOS_NWEB_EXPORT NWebJSDialogResult {
 public:
     virtual ~NWebJSDialogResult() = default;
-
     /**
      * @brief Handle a confirmation response from the user.
      */
     virtual void Confirm() = 0;
-
     /**
      * @brief Handle a confirmation response from the user with input message.
      *
      * @param message confirm message.
      */
     virtual void Confirm(const std::string &message) = 0;
-    
     /**
      * @brief Handle the result if the user cancelled the dialog.
      */
diff --git a/ohos_nweb/include/nweb_preference.h b/ohos_nweb/include/nweb_preference.h
index ca85253000..cd9f3b430a 100644
--- a/ohos_nweb/include/nweb_preference.h
+++ b/ohos_nweb/include/nweb_preference.h
@@ -10,13 +10,11 @@
 
 namespace OHOS::NWeb {
 class OHOS_NWEB_EXPORT NWebPreference {
-    public:
+public:
     NWebPreference() = default;
     virtual ~NWebPreference() = default;
-
     enum AccessMode { ALWAYS_ALLOW = 0, NEVER_ALLOW = 1, COMPATIBILITY_MODE = 2 };
-
-    /* synchronous set web settings and web preferences */
+    /* synchronous set NWebPreference and web preferences */
     virtual void PutEnableContentAccess(bool flag) = 0;
     virtual void PutEnableRawFileAccess(bool flag) = 0;
     virtual void PutEnableRawFileAccessFromFileURLs(bool flag) = 0;
@@ -46,7 +44,7 @@ class OHOS_NWEB_EXPORT NWebPreference {
     AccessMode mode) = 0;
     virtual void PutZoomingFunctionEnabled(bool flag) = 0;
 
-    /* get methods*/
+    /* get methods */
     virtual bool EnableContentAccess() = 0;
     virtual bool EnableRawFileAccess() = 0;
     virtual bool EnableRawFileAccessFromFileURLs() = 0;
diff --git a/ohos_nweb/include/nweb_url_resource_error.h b/ohos_nweb/include/nweb_url_resource_error.h
index b24b7fbd90..dafc312994 100644
--- a/ohos_nweb/include/nweb_url_resource_error.h
+++ b/ohos_nweb/include/nweb_url_resource_error.h
@@ -19,7 +19,7 @@ public:
      * @brief Gets the error description.
      *
      * @brief Gets the ErrorInfo.
-     * 
+     *
      * @return The description of the error.
      */
     virtual const std::string &ErrorInfo() const = 0;
diff --git a/ohos_nweb/include/nweb_value.h b/ohos_nweb/include/nweb_value.h
index ee4c745e3c..e08d162fe9 100644
--- a/ohos_nweb/include/nweb_value.h
+++ b/ohos_nweb/include/nweb_value.h
@@ -16,55 +16,55 @@ namespace OHOS::NWeb {
         bool b;
     };
 
-    class OHOS_NWEB_EXPORT NWebValue {
-    public:
-        enum class Type : unsigned char {
-            NONE = 0,
-            BOOLEAN,
-            INTEGER,
-            DOUBLE,
-            STRING,
-            BINARY,
-            DICTIONARY,
-            LIST
-        };
+class OHOS_NWEB_EXPORT NWebValue {
+public:
+    enum class Type : unsigned char {
+        NONE = 0,
+        BOOLEAN,
+        INTEGER,
+        DOUBLE,
+        STRING,
+        BINARY,
+        DICTIONARY,
+        LIST
+    };
 
-        NWebValue(Type type) : type_(type) {}
+    NWebValue(Type type) : type_(type) {}
 
-        ~NWebValue() = default;
+    ~NWebValue() = default;
 
-        bool GetBoolean() { return data_.b; }
+    bool GetBoolean() { return data_.b; }
 
-        void SetBoolean(bool b) { data_.b = b; }
+    void SetBoolean(bool b) { data_.b = b; }
 
-        void SetString(std::string str) { str_ = str; }
+    void SetString(std::string str) { str_ = str; }
 
-        std::string GetString() { return str_; }
+    std::string GetString() { return str_; }
 
-        void SetDouble(double dou) { data_.f = dou; }
+    void SetDouble(double dou) { data_.f = dou; }
 
-        double GetDouble() { return data_.f; }
+    double GetDouble() { return data_.f; }
 
-        void SetInt(int num) { data_.n = num; }
+    void SetInt(int num) { data_.n = num; }
 
-        int GetInt() { return data_.n; }
+    int GetInt() { return data_.n; }
 
-        void SetJsonString(std::string json_string) { str_json_ = json_string; }
+    void SetJsonString(std::string json_string) { str_json_ = json_string; }
 
-        std::string GetJsonString() { return str_json_; }
+    std::string GetJsonString() { return str_json_; }
 
-        Type GetType() { return type_; }
+    Type GetType() { return type_; }
 
-        void SetType(Type type) { type_ = type; }
+    void SetType(Type type) { type_ = type; }
 
-        int error_ = 0;
+    int error_ = 0;
 
-    private:
-        Type type_ = Type::NONE;
-        data_union data_;
-        std::string str_;
-        std::string str_json_;
-    };
+private:
+    Type type_ = Type::NONE;
+    data_union data_;
+    std::string str_;
+    std::string str_json_;
+};
 }
 
 #endif  // NWEB_VALUE_H_
diff --git a/ohos_nweb/include/nweb_value_callback.h b/ohos_nweb/include/nweb_value_callback.h
index aeba1f792a..4f521b4232 100644
--- a/ohos_nweb/include/nweb_value_callback.h
+++ b/ohos_nweb/include/nweb_value_callback.h
@@ -8,7 +8,7 @@
 #include "nweb_export.h"
 
 namespace OHOS::NWeb {
-template <typename T>
+template<typename T>
 class OHOS_NWEB_EXPORT NWebValueCallback {
 public:
     NWebValueCallback() = default;
diff --git a/ohos_nweb/src/cef_delegate/nweb_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_delegate.cc
index 16a7c15f74..475195e136 100755
--- a/ohos_nweb/src/cef_delegate/nweb_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_delegate.cc
@@ -107,6 +107,10 @@ void NWebDelegate::Resize(uint32_t width, uint32_t height) {
   if (render_handler_ != nullptr) {
     render_handler_->Resize(width, height);
   }
+  auto browser = GetBrowser();
+  if (browser != nullptr && browser->GetHost() != nullptr) {
+    browser->GetHost()->WasResized();
+  }
 }
 
 void NWebDelegate::OnTouchPress(int32_t id, double x, double y) {
diff --git a/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc b/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc
index 893b92a9bb..31046871ce 100644
--- a/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_geolocation_callback.cc
@@ -13,14 +13,16 @@ void NWebGeolocationCallback::GeolocationCallbackInvoke(
     const std::string& origin,
     bool allow,
     bool retain) {
-  if (retain) {
-    if (allow) {
-      browser_->GetGeolocationPermissions()->Enabled(origin);
-    } else {
-      browser_->GetGeolocationPermissions()->Disabled(origin);
-    }
-  }
-  browser_->GetPermissionRequestDelegate()->NotifyGeolocationPermission(allow,
-                                                                        origin);
+  LOG(ERROR) << "NWebGeolocationCallback::GeolocationCallbackInvoke";
+  return;
+  // if (retain) {
+  //   if (allow) {
+  //     browser_->GetGeolocationPermissions()->Enabled(origin);
+  //   } else {
+  //     browser_->GetGeolocationPermissions()->Disabled(origin);
+  //   }
+  // }
+  // browser_->GetPermissionRequestDelegate()->NotifyGeolocationPermission(false,
+  //                                                                       origin);
 }
 }  // namespace OHOS::NWeb
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
index 6c3bef39d1..6fc789fd1e 100755
--- a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
@@ -294,7 +294,9 @@ void NWebHandlerDelegate::OnLoadStart(CefRefPtr<CefBrowser> browser,
                                       CefRefPtr<CefFrame> frame,
                                       TransitionType transition_type) {
   LOG(INFO) << "NWebHandlerDelegate::OnLoadStart";
-
+  if (browser != nullptr && browser->GetHost() != nullptr) {
+    browser->GetHost()->SetFocus(true);
+  }
   if (nweb_handler_ != nullptr) {
     nweb_handler_->OnPageLoadBegin(frame->GetURL().ToString());
   }
diff --git a/ohos_nweb/src/cef_delegate/nweb_render_handler.cc b/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
index 4b85ca9122..ae7be00613 100644
--- a/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
@@ -53,7 +53,21 @@ void NWebRenderHandler::OnPaint(CefRefPtr<CefBrowser> browser,
                                 int height) {
   // run render callback to take buffer.
   // note: buffer must be consumed asap with no lock protected
-  if (render_update_cb_ != nullptr) {
+  if (render_update_cb_ == nullptr) {
+    return;
+  }
+  if (width != width_ || height != height_) {
+    LOG(INFO) << "frame size(" << width << "*" << height
+              << ") is not identical to request size (" << width_ << "*"
+              << height_ << "), drop this frame";
+    constexpr uint8_t kBitsPerPixel = 4;
+    uint32_t white_frame_size = width_ * height_ * kBitsPerPixel;
+    char* white_frame = new char[white_frame_size];
+    const char pixel_in_white = 0xFF;
+    (void)memset(white_frame, pixel_in_white, white_frame_size);
+    render_update_cb_(white_frame);
+    delete[] white_frame;
+  } else {
     render_update_cb_(reinterpret_cast<const char*>(buffer));
   }
 }
diff --git a/ohos_nweb/src/nweb_execute_process.cc b/ohos_nweb/src/nweb_execute_process.cc
new file mode 100644
index 0000000000..02e9ea1950
--- /dev/null
+++ b/ohos_nweb/src/nweb_execute_process.cc
@@ -0,0 +1,35 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+ 
+#include <unistd.h>
+#include <sstream>
+ 
+#include "include/cef_app.h"
+#include "nweb_export.h"
+#include "nweb_hilog.h"
+ 
+extern "C" OHOS_NWEB_EXPORT void NWebRenderMain(const char* args) {
+  WVLOG_I("NWebRenderMain start, pid=%{public}d", getpid());
+ 
+  std::string args_str = args;
+  std::stringstream args_ss(args_str);
+  const char separator = '#';
+  std::vector<std::string> argv_str;
+  std::string arg_str;
+  while(std::getline(args_ss, arg_str, separator)) {
+    argv_str.push_back(arg_str);
+  }
+  
+  std::vector<char*> argv_cstr;
+  int argc = argv_str.size();
+  argv_cstr.reserve(argc + 1);
+  for (const auto& arg : argv_str)
+    argv_cstr.push_back(const_cast<char*>(arg.c_str()));
+  argv_cstr.push_back(nullptr);
+ 
+  CefMainArgs main_args(argc, const_cast<char**>(argv_cstr.data()));
+  (void)CefExecuteProcess(main_args, NULL, NULL);
+ 
+  WVLOG_I("NWebRenderMain end, pid=%{public}d", getpid());
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/nweb_impl.cc b/ohos_nweb/src/nweb_impl.cc
index 925a5561ef..21eeab89f2 100755
--- a/ohos_nweb/src/nweb_impl.cc
+++ b/ohos_nweb/src/nweb_impl.cc
@@ -135,9 +135,11 @@ bool NWebImpl::InitWebEngine() {
 void NWebImpl::InitWebEngineArgs(const NWebInitArgs& init_args) {
   web_engine_args_.clear();
   web_engine_args_.emplace_back("/system/bin/web_render");
+  // web_engine_args_.emplace_back("--disable-gpu");
   web_engine_args_.emplace_back("--in-process-gpu");
   web_engine_args_.emplace_back("--disable-dev-shm-usage");
   web_engine_args_.emplace_back("--no-unsandboxed-zygote");
+  web_engine_args_.emplace_back("--no-zygote");
   web_engine_args_.emplace_back("--off-screen-frame-rate=60");
   web_engine_args_.emplace_back("--enable-features=UseOzonePlatform");
   web_engine_args_.emplace_back("-ozone-platform=headless");
@@ -335,7 +337,7 @@ std::string NWebImpl::Title() {
   return nweb_delegate_->Title();
 }
 
-const HitTestResult NWebImpl::GetHitTestResult() const {
+HitTestResult NWebImpl::GetHitTestResult() const {
   return nweb_delegate_->GetHitTestResult();
 }
 
diff --git a/ohos_nweb/src/nweb_impl.h b/ohos_nweb/src/nweb_impl.h
index 559f8487f2..dd0c16f178 100755
--- a/ohos_nweb/src/nweb_impl.h
+++ b/ohos_nweb/src/nweb_impl.h
@@ -56,7 +56,7 @@ class NWebImpl : public NWeb {
   void SetNWebHandler(std::shared_ptr<NWebHandler> handler) override;
   const std::shared_ptr<NWebHandler> GetNWebHandler() const override;
   std::string Title() override;
-  const HitTestResult GetHitTestResult() const override;
+  HitTestResult GetHitTestResult() const override;
   int PageLoadProgress() override;
   int ContentHeight() override;
   float Scale() override;
diff --git a/ohos_nweb/src/nweb_input_handler.cc b/ohos_nweb/src/nweb_input_handler.cc
index 710cbc5df4..78ea32c2b0 100644
--- a/ohos_nweb/src/nweb_input_handler.cc
+++ b/ohos_nweb/src/nweb_input_handler.cc
@@ -60,16 +60,6 @@ void NWebInputHandler::OnTouchMove(int32_t id, double x, double y) {
     return;
   }
 
-  // For multi-finger touch-move event get from ArkUI, some fingers may start
-  // move without previous touch-press event, which may cause these fingers
-  // unrecognized by web_engine, and multi-finger gestures like pinch unsupport.
-  // For this reason, the first touch-move event would be treated as touch-press
-  // event.
-  if (touch_press_id_map_.find(id) == touch_press_id_map_.end() ||
-      !touch_press_id_map_.at(id)) {
-    this->OnTouchPress(id, x, y);
-  }
-
   nweb_delegate_->OnTouchMove(id, x, y);
   last_x_ = x;
   last_y_ = y;
diff --git a/ohos_nweb/src/nweb_inputmethod_handler.cc b/ohos_nweb/src/nweb_inputmethod_handler.cc
index 0456edc290..5bb55cf39c 100644
--- a/ohos_nweb/src/nweb_inputmethod_handler.cc
+++ b/ohos_nweb/src/nweb_inputmethod_handler.cc
@@ -41,7 +41,12 @@ class OnTextChangedListenerImpl
   }
 
   void SendKeyboardInfo(const OHOS::MiscServices::KeyboardInfo& info) override {
-
+    auto status = info.GetKeyboardStatus();
+    if (status == OHOS::MiscServices::KeyboardStatus::SHOW) {
+      handler_->SetIMEStatus(true);
+    } else if (status == OHOS::MiscServices::KeyboardStatus::HIDE) {
+      handler_->SetIMEStatus(false);
+    }
   }
 
   void SetKeyboardStatus(bool status) override {
@@ -76,11 +81,14 @@ class InputMethodTask : public CefTask {
 };
 
 NWebInputMethodHandler::NWebInputMethodHandler()
-    : selected_from_(0), selected_to_(0) {}
+    : selected_from_(0), selected_to_(0) {
+  g_listener = nullptr;
+}
 
 NWebInputMethodHandler::~NWebInputMethodHandler() {}
 
 void NWebInputMethodHandler::Attach(CefRefPtr<CefBrowser> browser) {
+  composing_text_.clear();
   browser_ = browser;
   if (ime_shown_) {
     return;
@@ -105,6 +113,11 @@ void NWebInputMethodHandler::OnTextSelectionChanged(
     CefRefPtr<CefBrowser> browser,
     const CefString& selected_text,
     const CefRange& selected_range) {
+  if (ime_text_composing_ && !composing_text_.empty()) {
+    if (browser_ != nullptr && browser_->GetHost() != nullptr) {
+      browser_->GetHost()->ImeFinishComposingText(false);
+    }
+  }
   selected_text_ = selected_text.ToString16();
   selected_from_ = selected_range.from;
   selected_to_ = selected_range.to;
@@ -148,6 +161,7 @@ void NWebInputMethodHandler::SetIMEStatusOnUI(bool status) {
   if (!status && ime_text_composing_) {
     browser_->GetHost()->ImeFinishComposingText(false);
     ime_text_composing_ = false;
+    composing_text_.clear();
   }
   ime_shown_ = status;
 }
diff --git a/ohos_nweb/src/nweb_render_main.cc b/ohos_nweb/src/nweb_render_main.cc
new file mode 100644
index 0000000000..b0b3122e56
--- /dev/null
+++ b/ohos_nweb/src/nweb_render_main.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+ 
+#include <unistd.h>
+#include <sstream>
+ 
+#include "include/cef_app.h"
+#include "nweb_export.h"
+#include "nweb_hilog.h"
+ 
+extern "C" OHOS_NWEB_EXPORT void NWebRenderMain(const char* args) {
+  WVLOG_I("NWebRenderMain start, pid=%{public}d", getpid());
+ 
+  std::string args_str = args;
+  std::stringstream args_ss(args_str);
+  const char separator = '#';
+  std::vector<std::string> argv_str;
+  std::string arg_str;
+  while(std::getline(args_ss, arg_str, separator)) {
+    argv_str.push_back(arg_str);
+  }
+  std::vector<char*> argv_cstr;
+  int argc = argv_str.size();
+  argv_cstr.reserve(argc + 1);
+  for (const auto& arg : argv_str)
+    argv_cstr.push_back(const_cast<char*>(arg.c_str()));
+  argv_cstr.push_back(nullptr);
+ 
+  CefMainArgs main_args(argc, const_cast<char**>(argv_cstr.data()));
+  (void)CefExecuteProcess(main_args, NULL, NULL);
+ 
+  WVLOG_I("NWebRenderMain end, pid=%{public}d", getpid());
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/ohos_nweb_main.cc b/ohos_nweb/src/ohos_nweb_main.cc
index defaae1499..bcce6266f6 100644
--- a/ohos_nweb/src/ohos_nweb_main.cc
+++ b/ohos_nweb/src/ohos_nweb_main.cc
@@ -3,15 +3,67 @@
 // found in the LICENSE file.
 
 #include <unistd.h>
+#include <dlfcn.h>
 #include "include/cef_app.h"
 #include "nweb_hilog.h"
 
 int main(int argc, const char* argv[]) {
   WVLOG_I("nweb subprocess %{public}s begin, pid=%{public}d", argv[0],
           getpid());
-
-  CefMainArgs main_args(argc, const_cast<char**>(argv));
-  (void)CefExecuteProcess(main_args, NULL, NULL);
+#ifdef __MUSL__
+  Dl_namespace dlns;
+  dlns_init(&dlns, "nweb_test_ns");
+  dlns_create(&dlns, "/data/app/el1/bundle/public/com.ohos.nweb/libs/arm");
+  const std::string LIB_PATH_NWEB_RENDER = "libnweb_render.so";
+  const std::string LIB_PATH_WEB_ENGINE = "libweb_engine.so";
+  void *libHandleWebEngine = dlopen_ns(&dlns, LIB_PATH_WEB_ENGINE.c_str(), RTLD_NOW);
+  if (libHandleWebEngine == nullptr) {
+      WVLOG_E("fail to dlopen %{public}s, errmsg=%{public}s", LIB_PATH_WEB_ENGINE.c_str(), dlerror());
+      return -1;
+  }
+  void *libHandleNWebRender = dlopen_ns(&dlns, LIB_PATH_NWEB_RENDER.c_str(), RTLD_NOW);
+  if (libHandleNWebRender == nullptr) {
+      WVLOG_E("fail to dlopen %{public}s, errmsg=%{public}s", LIB_PATH_NWEB_RENDER.c_str(), dlerror());
+      return -1;
+  }
+#else
+  const std::string LOAD_LIB_DIR_INSTALLATION = "/data/app/el1/bundle/public/com.ohos.nweb/libs/arm";
+  const std::string LIB_PATH_WEB_ENGINE = LOAD_LIB_DIR_INSTALLATION + "/libweb_engine.so";
+  const std::string LIB_PATH_NWEB_RENDER = LOAD_LIB_DIR_INSTALLATION + "/libnweb_render.so";
+  void *libHandleWebEngine = ::dlopen(LIB_PATH_WEB_ENGINE.c_str(), RTLD_NOW);
+  if (libHandleWebEngine == nullptr) {
+    WVLOG_E("fail to dlopen %{public}s, errmsg=%{public}s", LIB_PATH_WEB_ENGINE.c_str(), dlerror());
+    return -1;
+  }
+  void *libHandleNWebRender = ::dlopen(LIB_PATH_NWEB_RENDER.c_str(), RTLD_NOW);
+  if (libHandleNWebRender == nullptr) {
+    WVLOG_E("fail to dlopen %{public}s, errmsg=%{public}s", LIB_PATH_NWEB_RENDER.c_str(), dlerror());
+    return -1;
+  }
+#endif
+  using NWebRenderMainFunc = void (*)(const char* args);
+  const std::string NWEB_RENDER_MAIN = "NWebRenderMain";
+  NWebRenderMainFunc func =
+        reinterpret_cast<NWebRenderMainFunc>(dlsym(libHandleNWebRender, NWEB_RENDER_MAIN.c_str()));
+  if (func == nullptr) {
+    WVLOG_E("fail to dlsym %{public}s from libnweb_render.so", NWEB_RENDER_MAIN.c_str());
+    return -1;
+  }
+  std::stringstream argv_ss;
+  const char separator = '#';
+  for (int i=0; i<argc-1; ++i) {
+    argv_ss << argv[i] << separator;
+  }
+  argv_ss << argv[argc-1];
+  func(argv_ss.str().data());
+  if (libHandleWebEngine != nullptr) {
+    ::dlclose(libHandleWebEngine);
+    libHandleWebEngine = nullptr;
+  }
+  if (libHandleNWebRender != nullptr) {
+    ::dlclose(libHandleNWebRender);
+    libHandleNWebRender = nullptr;
+  }
 
   WVLOG_I("nweb subprocess %{public}s end, pid=%{public}d", argv[0],
           getpid());
diff --git a/sandbox/win/src/sandbox.h b/sandbox/win/src/sandbox.h
index 9dfebfcc17..d4ab27f084 100644
--- a/sandbox/win/src/sandbox.h
+++ b/sandbox/win/src/sandbox.h
@@ -140,7 +140,7 @@ class BrokerServices {
 //   }
 //
 // For more information see the BrokerServices API documentation.
-class TargetServices {
+class [[clang::lto_visibility_public]] TargetServices {
  public:
   // Initializes the target. Must call this function before any other.
   // returns ALL_OK if successful. All other return values imply failure.
diff --git a/services/device/geolocation/BUILD.gn b/services/device/geolocation/BUILD.gn
index 27c8bcf097..8bc76eac2b 100644
--- a/services/device/geolocation/BUILD.gn
+++ b/services/device/geolocation/BUILD.gn
@@ -64,20 +64,20 @@ source_set("geolocation") {
     "//services/network/public/cpp",
   ]
 
-  if (is_ohos) {
-    sources += [
-      "ohos/location_provider_ohos.cc",
-      "ohos/location_provider_ohos.h",
-    ]
-    import("//build/config/ohos/config.gni")
-    include_dirs = ohos_src_includes
-    lib_dirs = ohos_libs_dir
-    libs = [
-      "locator_sdk.z",
-      "ipc_core.z",
-      "lbsservice_common.z",
-    ]
-  }
+#if (is_ohos) {
+#  sources += [
+#    "ohos/location_provider_ohos.cc",
+#    "ohos/location_provider_ohos.h",
+#  ]
+#  import("//build/config/ohos/config.gni")
+#  include_dirs = ohos_src_includes
+#  lib_dirs = ohos_libs_dir
+#  libs = [
+#    "locator_sdk.z",
+#    "ipc_core.z",
+#    "lbsservice_common.z",
+#  ]
+#}
 
   if (is_android) {
     sources += [
diff --git a/services/device/geolocation/location_arbitrator.cc b/services/device/geolocation/location_arbitrator.cc
index 3932492409..a36fdcaf39 100644
--- a/services/device/geolocation/location_arbitrator.cc
+++ b/services/device/geolocation/location_arbitrator.cc
@@ -163,7 +163,7 @@ LocationArbitrator::NewNetworkLocationProvider(
 
 std::unique_ptr<LocationProvider>
 LocationArbitrator::NewSystemLocationProvider() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   return nullptr;
 #else
   return device::NewSystemLocationProvider();
diff --git a/services/network/cors/cors_url_loader.cc b/services/network/cors/cors_url_loader.cc
index 374ea34a12..c2a4e52a90 100644
--- a/services/network/cors/cors_url_loader.cc
+++ b/services/network/cors/cors_url_loader.cc
@@ -296,13 +296,6 @@ void CorsURLLoader::OnReceiveRedirect(const net::RedirectInfo& redirect_info,
   DCHECK(forwarding_client_);
   DCHECK(!deferred_redirect_url_);
 
-  if (request_.redirect_mode == mojom::RedirectMode::kManual) {
-    deferred_redirect_url_ = std::make_unique<GURL>(redirect_info.new_url);
-    forwarding_client_->OnReceiveRedirect(redirect_info,
-                                          std::move(response_head));
-    return;
-  }
-
   // If |CORS flag| is set and a CORS check for |request| and |response| returns
   // failure, then return a network error.
   if (fetch_cors_flag_ && IsCorsEnabledRequestMode(request_.mode)) {
@@ -320,6 +313,13 @@ void CorsURLLoader::OnReceiveRedirect(const net::RedirectInfo& redirect_info,
     }
   }
 
+  if (request_.redirect_mode == mojom::RedirectMode::kManual) {
+    deferred_redirect_url_ = std::make_unique<GURL>(redirect_info.new_url);
+    forwarding_client_->OnReceiveRedirect(redirect_info,
+                                          std::move(response_head));
+    return;
+  }
+
   timing_allow_failed_flag_ = !PassesTimingAllowOriginCheck(*response_head);
 
   // Because we initiate a new request on redirect in some cases, we cannot
diff --git a/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc b/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc
index 77cd931b5f..c16affe394 100644
--- a/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc
+++ b/services/resource_coordinator/memory_instrumentation/coordinator_impl.cc
@@ -105,7 +105,8 @@ void CoordinatorImpl::RegisterClientProcess(
     const base::Optional<std::string>& service_name) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   mojo::Remote<mojom::ClientProcess> process(std::move(client_process));
-  coordinator_receivers_.Add(this, std::move(receiver), process_id);
+  if (receiver.is_valid())
+    coordinator_receivers_.Add(this, std::move(receiver), process_id);
   process.set_disconnect_handler(
       base::BindOnce(&CoordinatorImpl::UnregisterClientProcess,
                      base::Unretained(this), process_id));
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.cc b/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.cc
index ca0e8d8441..ae9ef93eaf 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.cc
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.cc
@@ -24,6 +24,11 @@ void ClientProcessImpl::CreateInstance(
     mojo::PendingReceiver<mojom::ClientProcess> receiver,
     mojo::PendingRemote<mojom::Coordinator> coordinator,
     bool is_browser_process) {
+  // Intentionally disallow non-browser processes from ever holding a
+  // Coordinator.
+  if (!is_browser_process)
+    coordinator.reset();
+
   static ClientProcessImpl* instance = nullptr;
   if (!instance) {
     instance = new ClientProcessImpl(
@@ -39,10 +44,12 @@ ClientProcessImpl::ClientProcessImpl(
     mojo::PendingRemote<mojom::Coordinator> coordinator,
     bool is_browser_process,
     bool initialize_memory_instrumentation)
-    : receiver_(this, std::move(receiver)) {
+    : receiver_(this, std::move(receiver)),
+      is_browser_process_(is_browser_process) {
   if (initialize_memory_instrumentation) {
     // Initialize the public-facing MemoryInstrumentation helper.
-    MemoryInstrumentation::CreateInstance(std::move(coordinator));
+    MemoryInstrumentation::CreateInstance(std::move(coordinator),
+                                          is_browser_process);
   } else {
     coordinator_.Bind(std::move(coordinator));
   }
@@ -109,6 +116,8 @@ void ClientProcessImpl::OnChromeMemoryDumpDone(
 void ClientProcessImpl::RequestGlobalMemoryDump_NoCallback(
     base::trace_event::MemoryDumpType dump_type,
     base::trace_event::MemoryDumpLevelOfDetail level_of_detail) {
+  CHECK(is_browser_process_);
+
   if (!task_runner_->RunsTasksInCurrentSequence()) {
     task_runner_->PostTask(
         FROM_HERE,
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.h b/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.h
index 6dd8c55823..8c2c20c449 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.h
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/client_process_impl.h
@@ -96,6 +96,9 @@ class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MEMORY_INSTRUMENTATION)
   mojo::Remote<mojom::Coordinator> coordinator_;
   scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
 
+  // Only browser process is allowed to request memory dumps.
+  const bool is_browser_process_;
+
   // TODO(crbug.com/728199): The observer is only used to setup and tear down
   // MemoryDumpManager in each process. Setting up MemoryDumpManager should
   // be moved away from TracingObserver.
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc b/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc
index c81d5f83bf..ec90ab9211 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.cc
@@ -21,10 +21,11 @@ void WrapGlobalMemoryDump(
 
 // static
 void MemoryInstrumentation::CreateInstance(
-    mojo::PendingRemote<memory_instrumentation::mojom::Coordinator>
-        coordinator) {
+    mojo::PendingRemote<memory_instrumentation::mojom::Coordinator> coordinator,
+    bool is_browser_process) {
   DCHECK(!g_instance);
-  g_instance = new MemoryInstrumentation(std::move(coordinator));
+  g_instance =
+      new MemoryInstrumentation(std::move(coordinator), is_browser_process);
 }
 
 // static
@@ -33,8 +34,10 @@ MemoryInstrumentation* MemoryInstrumentation::GetInstance() {
 }
 
 MemoryInstrumentation::MemoryInstrumentation(
-    mojo::PendingRemote<memory_instrumentation::mojom::Coordinator> coordinator)
-    : coordinator_(std::move(coordinator)) {}
+    mojo::PendingRemote<memory_instrumentation::mojom::Coordinator> coordinator,
+    bool is_browser_process)
+    : coordinator_(std::move(coordinator)),
+      is_browser_process_(is_browser_process) {}
 
 MemoryInstrumentation::~MemoryInstrumentation() {
   g_instance = nullptr;
@@ -43,6 +46,7 @@ MemoryInstrumentation::~MemoryInstrumentation() {
 void MemoryInstrumentation::RequestGlobalDump(
     const std::vector<std::string>& allocator_dump_names,
     RequestGlobalDumpCallback callback) {
+  CHECK(is_browser_process_);
   coordinator_->RequestGlobalMemoryDump(
       MemoryDumpType::SUMMARY_ONLY, MemoryDumpLevelOfDetail::BACKGROUND,
       MemoryDumpDeterminism::NONE, allocator_dump_names,
@@ -52,6 +56,7 @@ void MemoryInstrumentation::RequestGlobalDump(
 void MemoryInstrumentation::RequestPrivateMemoryFootprint(
     base::ProcessId pid,
     RequestGlobalDumpCallback callback) {
+  CHECK(is_browser_process_);
   coordinator_->RequestPrivateMemoryFootprint(
       pid, base::BindOnce(&WrapGlobalMemoryDump, std::move(callback)));
 }
@@ -60,6 +65,7 @@ void MemoryInstrumentation::RequestGlobalDumpForPid(
     base::ProcessId pid,
     const std::vector<std::string>& allocator_dump_names,
     RequestGlobalDumpCallback callback) {
+  CHECK(is_browser_process_);
   coordinator_->RequestGlobalMemoryDumpForPid(
       pid, allocator_dump_names,
       base::BindOnce(&WrapGlobalMemoryDump, std::move(callback)));
@@ -70,6 +76,7 @@ void MemoryInstrumentation::RequestGlobalDumpAndAppendToTrace(
     MemoryDumpLevelOfDetail level_of_detail,
     MemoryDumpDeterminism determinism,
     RequestGlobalMemoryDumpAndAppendToTraceCallback callback) {
+  CHECK(is_browser_process_);
   coordinator_->RequestGlobalMemoryDumpAndAppendToTrace(
       dump_type, level_of_detail, determinism, std::move(callback));
 }
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h b/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h
index 3264917890..72157b5345 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h
@@ -34,7 +34,8 @@ class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MEMORY_INSTRUMENTATION)
 
   static void CreateInstance(
       mojo::PendingRemote<memory_instrumentation::mojom::Coordinator>
-          coordinator);
+          coordinator,
+      bool is_browser_process);
   static MemoryInstrumentation* GetInstance();
 
   // Retrieves a Coordinator interface to communicate with the service. This is
@@ -100,12 +101,16 @@ class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MEMORY_INSTRUMENTATION)
  private:
   explicit MemoryInstrumentation(
       mojo::PendingRemote<memory_instrumentation::mojom::Coordinator>
-          coordinator);
+          coordinator,
+      bool is_browser_process);
   ~MemoryInstrumentation();
 
   const mojo::SharedRemote<memory_instrumentation::mojom::Coordinator>
       coordinator_;
 
+  // Only browser process is allowed to request memory dumps.
+  const bool is_browser_process_;
+
   DISALLOW_COPY_AND_ASSIGN(MemoryInstrumentation);
 };
 
diff --git a/services/viz/public/cpp/gpu/context_provider_command_buffer.cc b/services/viz/public/cpp/gpu/context_provider_command_buffer.cc
index 2a37d497b4..7b4ee07dbb 100644
--- a/services/viz/public/cpp/gpu/context_provider_command_buffer.cc
+++ b/services/viz/public/cpp/gpu/context_provider_command_buffer.cc
@@ -477,9 +477,13 @@ const gpu::GpuFeatureInfo& ContextProviderCommandBuffer::GetGpuFeatureInfo()
 void ContextProviderCommandBuffer::OnLostContext() {
   CheckValidThreadOrLockAcquired();
 
-  // Ensure |this| isn't destroyed in the middle of OnLostContext() if observers
-  // drop all references to it.
-  scoped_refptr<ContextProviderCommandBuffer> ref(this);
+  // Observers may drop the last persistent references to `this`, but there may
+  // be weak references in use further up the stack. This task is posted to
+  // ensure that destruction is deferred until it's safe.
+  base::SequencedTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE,
+      base::BindOnce([](scoped_refptr<ContextProviderCommandBuffer>) {},
+                     base::WrapRefCounted(this)));
 
   for (auto& observer : observers_)
     observer.OnContextLost();
diff --git a/storage/browser/blob/blob_registry_impl.cc b/storage/browser/blob/blob_registry_impl.cc
index 34e736e80d..2479803044 100644
--- a/storage/browser/blob/blob_registry_impl.cc
+++ b/storage/browser/blob/blob_registry_impl.cc
@@ -629,13 +629,14 @@ void BlobRegistryImpl::GetBlobFromUUID(
 void BlobRegistryImpl::URLStoreForOrigin(
     const url::Origin& origin,
     mojo::PendingAssociatedReceiver<blink::mojom::BlobURLStore> receiver) {
-  // TODO(mek): Pass origin on to BlobURLStoreImpl so it can use it to generate
-  // Blob URLs, and verify at this point that the renderer can create URLs for
-  // that origin.
   Delegate* delegate = receivers_.current_context().get();
   DCHECK(delegate);
+  if (!origin.opaque() && !delegate->CanCommitURL(origin.GetURL())) {
+    mojo::ReportBadMessage(
+        "Non committable origin passed to BlobRegistryImpl::URLStoreForOrigin");
+  }
   auto self_owned_associated_receiver = mojo::MakeSelfOwnedAssociatedReceiver(
-      std::make_unique<BlobURLStoreImpl>(url_registry_, delegate),
+      std::make_unique<BlobURLStoreImpl>(origin, url_registry_),
       std::move(receiver));
   if (g_url_store_creation_hook)
     g_url_store_creation_hook->Run(self_owned_associated_receiver);
diff --git a/storage/browser/blob/blob_url_store_impl.cc b/storage/browser/blob/blob_url_store_impl.cc
index b46ee60849..02281e3e5f 100644
--- a/storage/browser/blob/blob_url_store_impl.cc
+++ b/storage/browser/blob/blob_url_store_impl.cc
@@ -5,6 +5,7 @@
 #include "storage/browser/blob/blob_url_store_impl.h"
 
 #include "base/bind.h"
+#include "base/strings/strcat.h"
 #include "mojo/public/cpp/bindings/receiver_set.h"
 #include "storage/browser/blob/blob_impl.h"
 #include "storage/browser/blob/blob_url_loader_factory.h"
@@ -58,9 +59,9 @@ class BlobURLTokenImpl : public blink::mojom::BlobURLToken {
   const base::UnguessableToken token_;
 };
 
-BlobURLStoreImpl::BlobURLStoreImpl(base::WeakPtr<BlobUrlRegistry> registry,
-                                   BlobRegistryImpl::Delegate* delegate)
-    : registry_(std::move(registry)), delegate_(delegate) {}
+BlobURLStoreImpl::BlobURLStoreImpl(const url::Origin& origin,
+                                   base::WeakPtr<BlobUrlRegistry> registry)
+    : origin_(origin), registry_(std::move(registry)) {}
 
 BlobURLStoreImpl::~BlobURLStoreImpl() {
   if (registry_) {
@@ -72,20 +73,9 @@ BlobURLStoreImpl::~BlobURLStoreImpl() {
 void BlobURLStoreImpl::Register(mojo::PendingRemote<blink::mojom::Blob> blob,
                                 const GURL& url,
                                 RegisterCallback callback) {
-  if (!url.SchemeIsBlob()) {
-    mojo::ReportBadMessage("Invalid scheme passed to BlobURLStore::Register");
-    std::move(callback).Run();
-    return;
-  }
-  if (!delegate_->CanCommitURL(url)) {
-    mojo::ReportBadMessage(
-        "Non committable URL passed to BlobURLStore::Register");
-    std::move(callback).Run();
-    return;
-  }
-  if (BlobUrlUtils::UrlHasFragment(url)) {
-    mojo::ReportBadMessage(
-        "URL with fragment passed to BlobURLStore::Register");
+  // TODO(mek): Generate blob URLs here, rather than validating the URLs the
+  // renderer process generated.
+  if (!BlobUrlIsValid(url, "Register")) {
     std::move(callback).Run();
     return;
   }
@@ -97,19 +87,8 @@ void BlobURLStoreImpl::Register(mojo::PendingRemote<blink::mojom::Blob> blob,
 }
 
 void BlobURLStoreImpl::Revoke(const GURL& url) {
-  if (!url.SchemeIsBlob()) {
-    mojo::ReportBadMessage("Invalid scheme passed to BlobURLStore::Revoke");
-    return;
-  }
-  if (!delegate_->CanCommitURL(url)) {
-    mojo::ReportBadMessage(
-        "Non committable URL passed to BlobURLStore::Revoke");
+  if (!BlobUrlIsValid(url, "Revoke"))
     return;
-  }
-  if (BlobUrlUtils::UrlHasFragment(url)) {
-    mojo::ReportBadMessage("URL with fragment passed to BlobURLStore::Revoke");
-    return;
-  }
 
   if (registry_)
     registry_->RemoveUrlMapping(url);
@@ -125,6 +104,40 @@ void BlobURLStoreImpl::Resolve(const GURL& url, ResolveCallback callback) {
   std::move(callback).Run(std::move(blob));
 }
 
+bool BlobURLStoreImpl::BlobUrlIsValid(const GURL& url,
+                                      const char* method) const {
+  if (!url.SchemeIsBlob()) {
+    mojo::ReportBadMessage(
+        base::StrCat({"Invalid scheme passed to BlobURLStore::", method}));
+    return false;
+  }
+  url::Origin url_origin = url::Origin::Create(url);
+  // For file:// origins blink sometimes creates blob URLs with "null" as origin
+  // and other times "file://" (based on a runtime setting). On the other hand,
+  // `origin_` will always be a non-opaque file: origin for pages loaded from
+  // file:// URLs. To deal with this, we treat file:// origins and
+  // opaque origins separately from non-opaque origins.
+  bool valid_origin = true;
+  if (url_origin.scheme() == url::kFileScheme) {
+    valid_origin = origin_.scheme() == url::kFileScheme;
+  } else if (url_origin.opaque()) {
+    valid_origin = origin_.opaque() || origin_.scheme() == url::kFileScheme;
+  } else {
+    valid_origin = origin_ == url_origin;
+  }
+  if (!valid_origin) {
+    mojo::ReportBadMessage(base::StrCat(
+        {"URL with invalid origin passed to BlobURLStore::", method}));
+    return false;
+  }
+  if (BlobUrlUtils::UrlHasFragment(url)) {
+    mojo::ReportBadMessage(
+        base::StrCat({"URL with fragment passed to BlobURLStore::", method}));
+    return false;
+  }
+  return true;
+}
+
 void BlobURLStoreImpl::ResolveAsURLLoaderFactory(
     const GURL& url,
     mojo::PendingReceiver<network::mojom::URLLoaderFactory> receiver) {
diff --git a/storage/browser/blob/blob_url_store_impl.h b/storage/browser/blob/blob_url_store_impl.h
index 6b4a738a46..3cada75583 100644
--- a/storage/browser/blob/blob_url_store_impl.h
+++ b/storage/browser/blob/blob_url_store_impl.h
@@ -11,8 +11,9 @@
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "mojo/public/cpp/bindings/remote.h"
-#include "storage/browser/blob/blob_registry_impl.h"
+#include "storage/browser/blob/blob_url_registry.h"
 #include "third_party/blink/public/mojom/blob/blob_url_store.mojom.h"
+#include "url/origin.h"
 
 namespace storage {
 
@@ -21,8 +22,8 @@ class BlobUrlRegistry;
 class COMPONENT_EXPORT(STORAGE_BROWSER) BlobURLStoreImpl
     : public blink::mojom::BlobURLStore {
  public:
-  BlobURLStoreImpl(base::WeakPtr<BlobUrlRegistry> registry,
-                   BlobRegistryImpl::Delegate* delegate);
+  BlobURLStoreImpl(const url::Origin& origin,
+                   base::WeakPtr<BlobUrlRegistry> registry);
   ~BlobURLStoreImpl() override;
 
   void Register(mojo::PendingRemote<blink::mojom::Blob> blob,
@@ -39,8 +40,12 @@ class COMPONENT_EXPORT(STORAGE_BROWSER) BlobURLStoreImpl
       mojo::PendingReceiver<blink::mojom::BlobURLToken> token) override;
 
  private:
+  // Checks if the passed in url is a valid blob url for this blob url store.
+  // Returns false and reports a bad mojo message if not.
+  bool BlobUrlIsValid(const GURL& url, const char* method) const;
+
+  const url::Origin origin_;
   base::WeakPtr<BlobUrlRegistry> registry_;
-  BlobRegistryImpl::Delegate* delegate_;
 
   std::set<GURL> urls_;
 
diff --git a/storage/browser/blob/blob_url_store_impl_unittest.cc b/storage/browser/blob/blob_url_store_impl_unittest.cc
index 69428d0ade..52d17152b3 100644
--- a/storage/browser/blob/blob_url_store_impl_unittest.cc
+++ b/storage/browser/blob/blob_url_store_impl_unittest.cc
@@ -17,7 +17,6 @@
 #include "storage/browser/blob/blob_impl.h"
 #include "storage/browser/blob/blob_storage_context.h"
 #include "storage/browser/blob/blob_url_registry.h"
-#include "storage/browser/test/mock_blob_registry_delegate.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 using blink::mojom::BlobURLStore;
@@ -69,9 +68,9 @@ class BlobURLStoreImplTest : public testing::Test {
 
   mojo::PendingRemote<BlobURLStore> CreateURLStore() {
     mojo::PendingRemote<BlobURLStore> result;
-    mojo::MakeSelfOwnedReceiver(std::make_unique<BlobURLStoreImpl>(
-                                    url_registry_.AsWeakPtr(), &delegate_),
-                                result.InitWithNewPipeAndPassReceiver());
+    mojo::MakeSelfOwnedReceiver(
+        std::make_unique<BlobURLStoreImpl>(kOrigin, url_registry_.AsWeakPtr()),
+        result.InitWithNewPipeAndPassReceiver());
     return result;
   }
 
@@ -101,15 +100,19 @@ class BlobURLStoreImplTest : public testing::Test {
   }
 
   const std::string kId = "id";
-  const GURL kValidUrl = GURL("blob:id");
+  const url::Origin kOrigin = url::Origin::Create(GURL("https://example.com"));
+  const GURL kValidUrl = GURL("blob:" + kOrigin.Serialize() + "/id1");
+  const GURL kValidUrl2 = GURL("blob:" + kOrigin.Serialize() + "/id2");
   const GURL kInvalidUrl = GURL("bolb:id");
-  const GURL kFragmentUrl = GURL("blob:id#fragment");
+  const GURL kFragmentUrl = GURL(kValidUrl.spec() + "#fragment");
+  const url::Origin kWrongOrigin =
+      url::Origin::Create(GURL("https://test.com"));
+  const GURL kWrongOriginUrl = GURL("blob:" + kWrongOrigin.Serialize() + "/id");
 
  protected:
   base::test::TaskEnvironment task_environment_;
   std::unique_ptr<BlobStorageContext> context_;
   BlobUrlRegistry url_registry_;
-  MockBlobRegistryDelegate delegate_;
   std::vector<std::string> bad_messages_;
 };
 
@@ -118,7 +121,7 @@ TEST_F(BlobURLStoreImplTest, BasicRegisterRevoke) {
       CreateBlobFromString(kId, "hello world");
 
   // Register a URL and make sure the URL keeps the blob alive.
-  BlobURLStoreImpl url_store(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store(kOrigin, url_registry_.AsWeakPtr());
   RegisterURL(&url_store, std::move(blob), kValidUrl);
 
   blob = url_registry_.GetBlobFromUrl(kValidUrl);
@@ -146,15 +149,13 @@ TEST_F(BlobURLStoreImplTest, RegisterInvalidScheme) {
   EXPECT_EQ(1u, bad_messages_.size());
 }
 
-TEST_F(BlobURLStoreImplTest, RegisterCantCommit) {
+TEST_F(BlobURLStoreImplTest, RegisterWrongOrigin) {
   mojo::PendingRemote<blink::mojom::Blob> blob =
       CreateBlobFromString(kId, "hello world");
 
-  delegate_.can_commit_url_result = false;
-
   mojo::Remote<BlobURLStore> url_store(CreateURLStore());
-  RegisterURL(url_store.get(), std::move(blob), kValidUrl);
-  EXPECT_FALSE(url_registry_.GetBlobFromUrl(kValidUrl));
+  RegisterURL(url_store.get(), std::move(blob), kWrongOriginUrl);
+  EXPECT_FALSE(url_registry_.GetBlobFromUrl(kWrongOriginUrl));
   EXPECT_EQ(1u, bad_messages_.size());
 }
 
@@ -169,14 +170,13 @@ TEST_F(BlobURLStoreImplTest, RegisterUrlFragment) {
 }
 
 TEST_F(BlobURLStoreImplTest, ImplicitRevoke) {
-  const GURL kValidUrl2("blob:id2");
   mojo::Remote<blink::mojom::Blob> blob(
       CreateBlobFromString(kId, "hello world"));
   mojo::PendingRemote<blink::mojom::Blob> blob2;
   blob->Clone(blob2.InitWithNewPipeAndPassReceiver());
 
   auto url_store =
-      std::make_unique<BlobURLStoreImpl>(url_registry_.AsWeakPtr(), &delegate_);
+      std::make_unique<BlobURLStoreImpl>(kOrigin, url_registry_.AsWeakPtr());
   RegisterURL(url_store.get(), blob.Unbind(), kValidUrl);
   EXPECT_TRUE(url_registry_.GetBlobFromUrl(kValidUrl));
   RegisterURL(url_store.get(), std::move(blob2), kValidUrl2);
@@ -192,8 +192,8 @@ TEST_F(BlobURLStoreImplTest, RevokeThroughDifferentURLStore) {
   mojo::PendingRemote<blink::mojom::Blob> blob =
       CreateBlobFromString(kId, "hello world");
 
-  BlobURLStoreImpl url_store1(url_registry_.AsWeakPtr(), &delegate_);
-  BlobURLStoreImpl url_store2(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store1(kOrigin, url_registry_.AsWeakPtr());
+  BlobURLStoreImpl url_store2(kOrigin, url_registry_.AsWeakPtr());
 
   RegisterURL(&url_store1, std::move(blob), kValidUrl);
   EXPECT_TRUE(url_registry_.GetBlobFromUrl(kValidUrl));
@@ -209,11 +209,9 @@ TEST_F(BlobURLStoreImplTest, RevokeInvalidScheme) {
   EXPECT_EQ(1u, bad_messages_.size());
 }
 
-TEST_F(BlobURLStoreImplTest, RevokeCantCommit) {
-  delegate_.can_commit_url_result = false;
-
+TEST_F(BlobURLStoreImplTest, RevokeWrongOrigin) {
   mojo::Remote<BlobURLStore> url_store(CreateURLStore());
-  url_store->Revoke(kValidUrl);
+  url_store->Revoke(kWrongOriginUrl);
   url_store.FlushForTesting();
   EXPECT_EQ(1u, bad_messages_.size());
 }
@@ -229,7 +227,7 @@ TEST_F(BlobURLStoreImplTest, Resolve) {
   mojo::PendingRemote<blink::mojom::Blob> blob =
       CreateBlobFromString(kId, "hello world");
 
-  BlobURLStoreImpl url_store(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store(kOrigin, url_registry_.AsWeakPtr());
   RegisterURL(&url_store, std::move(blob), kValidUrl);
 
   blob = ResolveURL(&url_store, kValidUrl);
@@ -244,7 +242,7 @@ TEST_F(BlobURLStoreImplTest, Resolve) {
 }
 
 TEST_F(BlobURLStoreImplTest, ResolveNonExistentURL) {
-  BlobURLStoreImpl url_store(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store(kOrigin, url_registry_.AsWeakPtr());
 
   mojo::PendingRemote<blink::mojom::Blob> blob =
       ResolveURL(&url_store, kValidUrl);
@@ -254,7 +252,7 @@ TEST_F(BlobURLStoreImplTest, ResolveNonExistentURL) {
 }
 
 TEST_F(BlobURLStoreImplTest, ResolveInvalidURL) {
-  BlobURLStoreImpl url_store(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store(kOrigin, url_registry_.AsWeakPtr());
 
   mojo::PendingRemote<blink::mojom::Blob> blob =
       ResolveURL(&url_store, kInvalidUrl);
@@ -265,7 +263,7 @@ TEST_F(BlobURLStoreImplTest, ResolveAsURLLoaderFactory) {
   mojo::PendingRemote<blink::mojom::Blob> blob =
       CreateBlobFromString(kId, "hello world");
 
-  BlobURLStoreImpl url_store(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store(kOrigin, url_registry_.AsWeakPtr());
   RegisterURL(&url_store, std::move(blob), kValidUrl);
 
   mojo::Remote<network::mojom::URLLoaderFactory> factory;
@@ -291,7 +289,7 @@ TEST_F(BlobURLStoreImplTest, ResolveForNavigation) {
   mojo::PendingRemote<blink::mojom::Blob> blob =
       CreateBlobFromString(kId, "hello world");
 
-  BlobURLStoreImpl url_store(url_registry_.AsWeakPtr(), &delegate_);
+  BlobURLStoreImpl url_store(kOrigin, url_registry_.AsWeakPtr());
   RegisterURL(&url_store, std::move(blob), kValidUrl);
 
   mojo::Remote<blink::mojom::BlobURLToken> token_remote;
diff --git a/third_party/angle/src/libANGLE/Framebuffer.cpp b/third_party/angle/src/libANGLE/Framebuffer.cpp
index 7d9856d15c..48cf822901 100644
--- a/third_party/angle/src/libANGLE/Framebuffer.cpp
+++ b/third_party/angle/src/libANGLE/Framebuffer.cpp
@@ -1925,6 +1925,14 @@ void Framebuffer::onSubjectStateChange(angle::SubjectIndex index, angle::Subject
             return;
         }
 
+        // This can be triggered by freeing TextureStorage in D3D back-end.
+        if (message == angle::SubjectMessage::StorageReleased)
+        {
+            mDirtyBits.set(index);
+            invalidateCompletenessCache();
+            return;
+        }
+
         // This can be triggered by the GL back-end TextureGL class.
         ASSERT(message == angle::SubjectMessage::DirtyBitsFlagged);
         return;
diff --git a/third_party/angle/src/libANGLE/Observer.h b/third_party/angle/src/libANGLE/Observer.h
index ae83677c77..bb2acd0210 100644
--- a/third_party/angle/src/libANGLE/Observer.h
+++ b/third_party/angle/src/libANGLE/Observer.h
@@ -54,6 +54,9 @@ enum class SubjectMessage
 
     // Indicates an external change to the default framebuffer.
     SurfaceChanged,
+
+    // Indicates a Storage of back-end in gl::Texture has been released.
+    StorageReleased,
 };
 
 // The observing class inherits from this interface class.
diff --git a/third_party/angle/src/libANGLE/Texture.cpp b/third_party/angle/src/libANGLE/Texture.cpp
index e90bfd7c7d..09aa3a5fb5 100644
--- a/third_party/angle/src/libANGLE/Texture.cpp
+++ b/third_party/angle/src/libANGLE/Texture.cpp
@@ -2236,6 +2236,15 @@ void Texture::onSubjectStateChange(angle::SubjectIndex index, angle::SubjectMess
                 mState.setImageDesc(TextureTarget::Buffer, 0, desc);
             }
             break;
+        case angle::SubjectMessage::StorageReleased:
+            // When the TextureStorage is released, it needs to update the
+            // RenderTargetCache of the Framebuffer attaching this Texture.
+            // This is currently only for D3D back-end. See http://crbug.com/1234829
+            if (index == rx::kTextureImageImplObserverMessageIndex)
+            {
+                onStateChange(angle::SubjectMessage::StorageReleased);
+            }
+            break;
         case angle::SubjectMessage::SubjectMapped:
         case angle::SubjectMessage::SubjectUnmapped:
         case angle::SubjectMessage::BindingChanged:
diff --git a/third_party/angle/src/libANGLE/renderer/d3d/TextureD3D.cpp b/third_party/angle/src/libANGLE/renderer/d3d/TextureD3D.cpp
index 3a1b58b282..fc5ace1c05 100644
--- a/third_party/angle/src/libANGLE/renderer/d3d/TextureD3D.cpp
+++ b/third_party/angle/src/libANGLE/renderer/d3d/TextureD3D.cpp
@@ -710,6 +710,8 @@ angle::Result TextureD3D::releaseTexStorage(const gl::Context *context)
         return angle::Result::Continue;
     }
 
+    onStateChange(angle::SubjectMessage::StorageReleased);
+
     auto err = mTexStorage->onDestroy(context);
     SafeDelete(mTexStorage);
     return err;
diff --git a/third_party/angle/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp b/third_party/angle/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp
index 8321bb60cd..7588a161eb 100644
--- a/third_party/angle/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp
+++ b/third_party/angle/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp
@@ -2179,28 +2179,35 @@ angle::Result GenerateInitialTextureData(
     const d3d11::DXGIFormatSize &dxgiFormatInfo =
         d3d11::GetDXGIFormatSizeInfo(d3dFormatInfo.texFormat);
 
-    unsigned int rowPitch     = dxgiFormatInfo.pixelBytes * width;
-    unsigned int depthPitch   = rowPitch * height;
-    unsigned int maxImageSize = depthPitch * depth;
+    using CheckedSize        = angle::CheckedNumeric<size_t>;
+    CheckedSize rowPitch     = CheckedSize(dxgiFormatInfo.pixelBytes) * CheckedSize(width);
+    CheckedSize depthPitch   = rowPitch * CheckedSize(height);
+    CheckedSize maxImageSize = depthPitch * CheckedSize(depth);
+
+    Context11 *context11 = GetImplAs<Context11>(context);
+    ANGLE_CHECK_GL_ALLOC(context11, maxImageSize.IsValid());
 
     angle::MemoryBuffer *scratchBuffer = nullptr;
-    ANGLE_CHECK_GL_ALLOC(GetImplAs<Context11>(context),
-                         context->getScratchBuffer(maxImageSize, &scratchBuffer));
+    ANGLE_CHECK_GL_ALLOC(context11,
+                         context->getScratchBuffer(maxImageSize.ValueOrDie(), &scratchBuffer));
 
-    d3dFormatInfo.dataInitializerFunction(width, height, depth, scratchBuffer->data(), rowPitch,
-                                          depthPitch);
+    d3dFormatInfo.dataInitializerFunction(width, height, depth, scratchBuffer->data(),
+                                          rowPitch.ValueOrDie(), depthPitch.ValueOrDie());
 
     for (unsigned int i = 0; i < mipLevels; i++)
     {
         unsigned int mipWidth  = std::max(width >> i, 1U);
         unsigned int mipHeight = std::max(height >> i, 1U);
 
-        unsigned int mipRowPitch   = dxgiFormatInfo.pixelBytes * mipWidth;
-        unsigned int mipDepthPitch = mipRowPitch * mipHeight;
+        using CheckedUINT         = angle::CheckedNumeric<UINT>;
+        CheckedUINT mipRowPitch   = CheckedUINT(dxgiFormatInfo.pixelBytes) * CheckedUINT(mipWidth);
+        CheckedUINT mipDepthPitch = mipRowPitch * CheckedUINT(mipHeight);
+
+        ANGLE_CHECK_GL_ALLOC(context11, mipRowPitch.IsValid() && mipDepthPitch.IsValid());
 
         outSubresourceData->at(i).pSysMem          = scratchBuffer->data();
-        outSubresourceData->at(i).SysMemPitch      = mipRowPitch;
-        outSubresourceData->at(i).SysMemSlicePitch = mipDepthPitch;
+        outSubresourceData->at(i).SysMemPitch      = mipRowPitch.ValueOrDie();
+        outSubresourceData->at(i).SysMemSlicePitch = mipDepthPitch.ValueOrDie();
     }
 
     return angle::Result::Continue;
diff --git a/third_party/angle/src/libANGLE/renderer/vulkan/TextureVk.cpp b/third_party/angle/src/libANGLE/renderer/vulkan/TextureVk.cpp
index f995fbd0c2..f2d2cf76bb 100644
--- a/third_party/angle/src/libANGLE/renderer/vulkan/TextureVk.cpp
+++ b/third_party/angle/src/libANGLE/renderer/vulkan/TextureVk.cpp
@@ -1283,6 +1283,10 @@ angle::Result TextureVk::setStorageMultisample(const gl::Context *context,
     {
         releaseAndDeleteImageAndViews(contextVk);
     }
+    else if (mImage)
+    {
+        mImage->releaseStagingBuffer(contextVk->getRenderer());
+    }
 
     const vk::Format &format = renderer->getFormat(internalformat);
     ANGLE_TRY(ensureImageAllocated(contextVk, format));
diff --git a/third_party/angle/src/libANGLE/validationES.cpp b/third_party/angle/src/libANGLE/validationES.cpp
index e49c3927d0..b2a2406a23 100644
--- a/third_party/angle/src/libANGLE/validationES.cpp
+++ b/third_party/angle/src/libANGLE/validationES.cpp
@@ -3923,6 +3923,12 @@ const char *ValidateDrawStates(const Context *context)
             {
                 return kVertexBufferBoundForTransformFeedback;
             }
+
+            // Validate that we are rendering with a linked program.
+            if (!program->isLinked())
+            {
+                return kProgramNotLinked;
+            }
         }
     }
 
diff --git a/third_party/angle/src/tests/gl_tests/GLSLTest.cpp b/third_party/angle/src/tests/gl_tests/GLSLTest.cpp
index 851ccb4768..51b880df15 100644
--- a/third_party/angle/src/tests/gl_tests/GLSLTest.cpp
+++ b/third_party/angle/src/tests/gl_tests/GLSLTest.cpp
@@ -10493,6 +10493,54 @@ void main()
     GLuint program = CompileProgram(kVS, kFS);
     EXPECT_EQ(0u, program);
 }
+
+// Tests an unsuccessful re-link using glBindAttribLocation.
+TEST_P(GLSLTest_ES3, UnsuccessfulRelinkWithBindAttribLocation)
+{
+    // Make a simple program.
+    ANGLE_GL_PROGRAM(testProgram, essl1_shaders::vs::Simple(), essl1_shaders::fs::Green());
+
+    // Install the executable.
+    glUseProgram(testProgram);
+
+    // Re-link with a bad XFB varying and a bound attrib location.
+    const char *tfVaryings = "gl_FragColor";
+    glTransformFeedbackVaryings(testProgram, 1, &tfVaryings, GL_SEPARATE_ATTRIBS);
+    glBindAttribLocation(testProgram, 8, essl1_shaders::PositionAttrib());
+    glLinkProgram(testProgram);
+    GLint linkStatus = 999;
+    glGetProgramiv(testProgram, GL_LINK_STATUS, &linkStatus);
+    ASSERT_GL_NO_ERROR();
+    ASSERT_EQ(linkStatus, GL_FALSE);
+
+    // Under normal GL this is not an error.
+    glDrawArrays(GL_TRIANGLES, 79, 16);
+    EXPECT_GL_NO_ERROR();
+}
+
+// Tests an unsuccessful re-link using glBindAttribLocation under WebGL.
+TEST_P(WebGL2GLSLTest, UnsuccessfulRelinkWithBindAttribLocation)
+{
+    // Make a simple program.
+    ANGLE_GL_PROGRAM(testProgram, essl1_shaders::vs::Simple(), essl1_shaders::fs::Green());
+
+    // Install the executable.
+    glUseProgram(testProgram);
+
+    // Re-link with a bad XFB varying and a bound attrib location.
+    const char *tfVaryings = "gl_FragColor";
+    glTransformFeedbackVaryings(testProgram, 1, &tfVaryings, GL_SEPARATE_ATTRIBS);
+    glBindAttribLocation(testProgram, 8, essl1_shaders::PositionAttrib());
+    glLinkProgram(testProgram);
+    GLint linkStatus = 999;
+    glGetProgramiv(testProgram, GL_LINK_STATUS, &linkStatus);
+    ASSERT_GL_NO_ERROR();
+    ASSERT_EQ(linkStatus, GL_FALSE);
+
+    // Under WebGL this is an error.
+    glDrawArrays(GL_TRIANGLES, 79, 16);
+    EXPECT_GL_ERROR(GL_INVALID_OPERATION);
+}
 }  // anonymous namespace
 
 ANGLE_INSTANTIATE_TEST_ES2_AND_ES3(GLSLTest);
diff --git a/third_party/angle/src/tests/gl_tests/TextureTest.cpp b/third_party/angle/src/tests/gl_tests/TextureTest.cpp
index 23ea81694a..2dfcc0d00f 100644
--- a/third_party/angle/src/tests/gl_tests/TextureTest.cpp
+++ b/third_party/angle/src/tests/gl_tests/TextureTest.cpp
@@ -8151,6 +8151,26 @@ TEST_P(Texture2DTestES3, NonZeroBaseEmulatedClear)
     EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::black);
 }
 
+// Test if the RenderTargetCache is updated when the TextureStorage object is freed
+TEST_P(Texture2DTestES3, UpdateRenderTargetCacheOnDestroyTexStorage)
+{
+    ANGLE_GL_PROGRAM(drawRed, essl3_shaders::vs::Simple(), essl3_shaders::fs::Red());
+    const GLenum attachments[] = {GL_COLOR_ATTACHMENT0};
+
+    GLTexture tex;
+    GLFramebuffer fb;
+    glBindTexture(GL_TEXTURE_2D, tex);
+    glTexStorage2D(GL_TEXTURE_2D, 2, GL_RGBA8, 100, 1);
+    glBindFramebuffer(GL_FRAMEBUFFER, fb);
+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);
+    glInvalidateFramebuffer(GL_FRAMEBUFFER, 1, attachments);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 1);
+    drawQuad(drawRed, essl3_shaders::PositionAttrib(), 1.0f);
+    EXPECT_GL_NO_ERROR();
+
+    EXPECT_PIXEL_RECT_EQ(0, 0, 100, 1, GLColor::red);
+}
+
 // Draw a quad with an integer texture with a non-zero base level, and test that the color of the
 // texture is output.
 TEST_P(Texture2DIntegerTestES3, IntegerTextureNonZeroBaseLevel)
@@ -8750,6 +8770,73 @@ void main()
     glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);
 }
 
+class TextureChangeStorageUploadTest : public ANGLETest
+{
+  protected:
+    TextureChangeStorageUploadTest()
+    {
+        setWindowWidth(256);
+        setWindowHeight(256);
+        setConfigRedBits(8);
+        setConfigGreenBits(8);
+        setConfigBlueBits(8);
+        setConfigAlphaBits(8);
+    }
+
+    void testSetUp() override
+    {
+        mProgram = CompileProgram(essl1_shaders::vs::Simple(), essl1_shaders::fs::UniformColor());
+        if (mProgram == 0)
+        {
+            FAIL() << "shader compilation failed.";
+        }
+
+        mColorLocation = glGetUniformLocation(mProgram, essl1_shaders::ColorUniform());
+
+        glUseProgram(mProgram);
+
+        glClearColor(0, 0, 0, 0);
+        glClearDepthf(0.0);
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        glEnable(GL_BLEND);
+        glDisable(GL_DEPTH_TEST);
+
+        glGenTextures(1, &mTexture);
+        ASSERT_GL_NO_ERROR();
+    }
+
+    void testTearDown() override
+    {
+        glDeleteTextures(1, &mTexture);
+        glDeleteProgram(mProgram);
+    }
+
+    GLuint mProgram;
+    GLint mColorLocation;
+    GLuint mTexture;
+};
+
+// Verify that respecifying storage and re-uploading doesn't crash.
+TEST_P(TextureChangeStorageUploadTest, Basic)
+{
+    constexpr int kImageSize        = 8;  // 4 doesn't trip ASAN
+    constexpr int kSmallerImageSize = kImageSize / 2;
+    EXPECT_GT(kImageSize, kSmallerImageSize);
+    EXPECT_GT(kSmallerImageSize / 2, 0);
+
+    std::array<GLColor, kImageSize * kImageSize> kColor;
+
+    glBindTexture(GL_TEXTURE_2D, mTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, kImageSize, kImageSize, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+                 kColor.data());
+    glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, kSmallerImageSize, kSmallerImageSize);
+    // need partial update to sidestep optimizations that remove the full upload
+    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, kSmallerImageSize / 2, kSmallerImageSize / 2, GL_RGBA,
+                    GL_UNSIGNED_BYTE, kColor.data());
+    EXPECT_GL_NO_ERROR();
+}
+
 // Use this to select which configurations (e.g. which renderer, which GLES major version) these
 // tests should be run against.
 #define ES2_EMULATE_COPY_TEX_IMAGE()                          \
@@ -8858,4 +8945,6 @@ ANGLE_INSTANTIATE_TEST_ES31(TextureBufferTestES31);
 GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(CopyImageTestES31);
 ANGLE_INSTANTIATE_TEST_ES31(CopyImageTestES31);
 
+ANGLE_INSTANTIATE_TEST_ES3(TextureChangeStorageUploadTest);
+
 }  // anonymous namespace
diff --git a/third_party/blink/common/frame/user_activation_state.cc b/third_party/blink/common/frame/user_activation_state.cc
index 5ec774f5ce..5804a6b026 100644
--- a/third_party/blink/common/frame/user_activation_state.cc
+++ b/third_party/blink/common/frame/user_activation_state.cc
@@ -11,6 +11,23 @@ using blink::mojom::UserActivationNotificationType;
 
 namespace blink {
 
+namespace {
+
+// Indicates if |notification_type| should be considered restricted.  See
+// |LastActivationWasRestricted| for details.
+bool IsRestricted(UserActivationNotificationType notification_type) {
+  return notification_type == UserActivationNotificationType::
+                                  kExtensionMessagingBothPrivileged ||
+         notification_type == UserActivationNotificationType::
+                                  kExtensionMessagingSenderPrivileged ||
+         notification_type == UserActivationNotificationType::
+                                  kExtensionMessagingReceiverPrivileged ||
+         notification_type == UserActivationNotificationType::
+                                  kExtensionMessagingNeitherPrivileged;
+}
+
+}  // namespace
+
 // The expiry time should be long enough to allow network round trips even in a
 // very slow connection (to support xhr-like calls with user activation), yet
 // not too long to make an "unattended" page feel activated.
@@ -23,6 +40,7 @@ UserActivationState::UserActivationState()
 void UserActivationState::Activate(
     UserActivationNotificationType notification_type) {
   has_been_active_ = true;
+  last_activation_was_restricted_ = IsRestricted(notification_type);
   ActivateTransientState();
 
   // Update states for UMA.
@@ -36,6 +54,7 @@ void UserActivationState::Activate(
 
 void UserActivationState::Clear() {
   has_been_active_ = false;
+  last_activation_was_restricted_ = false;
   first_notification_type_ = UserActivationNotificationType::kNone;
   last_notification_type_ = UserActivationNotificationType::kNone;
   DeactivateTransientState();
@@ -70,6 +89,10 @@ bool UserActivationState::ConsumeIfActive() {
   return true;
 }
 
+bool UserActivationState::LastActivationWasRestricted() const {
+  return last_activation_was_restricted_;
+}
+
 void UserActivationState::RecordPreconsumptionUma() const {
   if (!IsActiveInternal())
     return;
diff --git a/third_party/blink/public/common/frame/user_activation_state.h b/third_party/blink/public/common/frame/user_activation_state.h
index aa1a421c1c..380165d265 100644
--- a/third_party/blink/public/common/frame/user_activation_state.h
+++ b/third_party/blink/public/common/frame/user_activation_state.h
@@ -94,6 +94,9 @@ class BLINK_COMMON_EXPORT UserActivationState {
   // true and updates the transient state timestamp to "now".
   //
   // The |notification_type| parameter is used for histograms only.
+  //
+  // TODO(mustaq): When removing |notification_type|, explicitly pass
+  // |is_restricted| as a parameter here.
   void Activate(mojom::UserActivationNotificationType notification_type);
 
   void Clear();
@@ -110,6 +113,21 @@ class BLINK_COMMON_EXPORT UserActivationState {
   // successfully consumed.
   bool ConsumeIfActive();
 
+  // Indicates if the last user activation notification was restricted in
+  // nature.  This is a non-spec-compliant state, added only for compat reasons.
+  //
+  // Please don't add any new dependency to it!
+  //
+  // More details: A user activation on a frame is marked as restricted when the
+  // frame is neither an ancestor nor of the same-origin w.r.t. the frame where
+  // user interaction happened.  In other words, the restricted activation does
+  // not follow the tracking mechanism mentioned in the HTML spec and above.
+  // This non-standard activation in Chrome prevents breaking old extensions
+  // that (historically) expect a synthetic user activation to be available in
+  // an "unexposed" script-context (say in an extension's background script)
+  // after receiving an extension message under certain conditions.
+  bool LastActivationWasRestricted() const;
+
   // Records UMA stats related to consumption.  Must be called:
   // - before |ConsumeIfActive()| to record correct stats, and
   // - only once during consumption propagation to suppress over-counting.
@@ -126,6 +144,8 @@ class BLINK_COMMON_EXPORT UserActivationState {
   bool has_been_active_ = false;
   base::TimeTicks transient_state_expiry_time_;
 
+  bool last_activation_was_restricted_ = false;
+
   // Tracks the expiry of |kInteraction| notification for UMA data.
   base::TimeTicks transient_state_expiry_time_for_interaction_;
 
diff --git a/third_party/blink/public/mojom/service_worker/dispatch_fetch_event_params.mojom b/third_party/blink/public/mojom/service_worker/dispatch_fetch_event_params.mojom
index 382be0b3dd..c95a2e2551 100644
--- a/third_party/blink/public/mojom/service_worker/dispatch_fetch_event_params.mojom
+++ b/third_party/blink/public/mojom/service_worker/dispatch_fetch_event_params.mojom
@@ -9,13 +9,6 @@ import "third_party/blink/public/mojom/blob/blob.mojom";
 import "third_party/blink/public/mojom/fetch/fetch_api_request.mojom";
 import "third_party/blink/public/mojom/timing/worker_timing_container.mojom";
 
-// Used for service worker navigation preload, to create
-// FetchEvent#preloadResponse.
-struct FetchEventPreloadHandle {
-  pending_remote<network.mojom.URLLoader> url_loader;
-  pending_receiver<network.mojom.URLLoaderClient> url_loader_client_receiver;
-};
-
 // Parameters used for dispatching a FetchEvent.
 struct DispatchFetchEventParams {
   // FetchEvent#request.
@@ -23,8 +16,9 @@ struct DispatchFetchEventParams {
 
   // FetchEvent#clientId.
   string client_id;
+
   // FetchEvent#preloadResponse.
-  FetchEventPreloadHandle? preload_handle;
+  pending_receiver<network.mojom.URLLoaderClient>? preload_url_loader_client_receiver;
 
   // This is currently null for navigation because it's still being implemented.
   // TODO(https://crbug.com/900700): Make this non-nullable when implementation
diff --git a/third_party/blink/public/mojom/webauthn/authenticator.mojom b/third_party/blink/public/mojom/webauthn/authenticator.mojom
index fd2d994705..25d66267c3 100644
--- a/third_party/blink/public/mojom/webauthn/authenticator.mojom
+++ b/third_party/blink/public/mojom/webauthn/authenticator.mojom
@@ -12,6 +12,12 @@ import "url/mojom/url.mojom";
 // credentials and use already-created credentials to get assertions.
 // See https://w3c.github.io/webauthn/.
 
+// The maximum allowable list size for vectors of
+// `PublicKeyCredentialDescriptor` (i.e.
+// `PublicKeyCredentialCreationOptions.exclude_credentials` and
+// `PublicKeyCredentialRequestOptions.allow_credentials`).
+const uint32 kPublicKeyCredentialDescriptorListMaxSize = 64;
+
 enum AuthenticatorStatus {
   SUCCESS,
   PENDING_REQUEST,
diff --git a/third_party/blink/public/web/modules/service_worker/web_service_worker_context_client.h b/third_party/blink/public/web/modules/service_worker/web_service_worker_context_client.h
index 48e3e7ecec..ad64e9ba7f 100644
--- a/third_party/blink/public/web/modules/service_worker/web_service_worker_context_client.h
+++ b/third_party/blink/public/web/modules/service_worker/web_service_worker_context_client.h
@@ -31,8 +31,6 @@
 #ifndef THIRD_PARTY_BLINK_PUBLIC_WEB_MODULES_SERVICE_WORKER_WEB_SERVICE_WORKER_CONTEXT_CLIENT_H_
 #define THIRD_PARTY_BLINK_PUBLIC_WEB_MODULES_SERVICE_WORKER_WEB_SERVICE_WORKER_CONTEXT_CLIENT_H_
 
-#include <memory>
-
 #include "base/memory/scoped_refptr.h"
 #include "base/time/time.h"
 #include "services/network/public/mojom/url_loader.mojom-shared.h"
@@ -54,14 +52,6 @@ namespace blink {
 class WebServiceWorkerContextProxy;
 class WebString;
 
-// Used to pass the mojom struct blink.mojom.FetchEventPreloadHandle across the
-// boundary between //content and Blink.
-struct WebFetchEventPreloadHandle {
-  CrossVariantMojoRemote<network::mojom::URLLoaderInterfaceBase> url_loader;
-  CrossVariantMojoReceiver<network::mojom::URLLoaderClientInterfaceBase>
-      url_loader_client_receiver;
-};
-
 // WebServiceWorkerContextClient is a "client" of a service worker execution
 // context. This interface is implemented by the embedder and allows the
 // embedder to communicate with the service worker execution context.  It is
@@ -167,7 +157,8 @@ class WebServiceWorkerContextClient {
   virtual void SetupNavigationPreload(
       int fetch_event_id,
       const WebURL& url,
-      std::unique_ptr<WebFetchEventPreloadHandle> preload_handle) {}
+      CrossVariantMojoReceiver<network::mojom::URLLoaderClientInterfaceBase>
+          preload_url_loader_client_receiver) {}
 
   // Called when we need to request to terminate this worker due to idle
   // timeout.
diff --git a/third_party/blink/public/web/web_local_frame.h b/third_party/blink/public/web/web_local_frame.h
index 151d9e3de3..2355b99e90 100644
--- a/third_party/blink/public/web/web_local_frame.h
+++ b/third_party/blink/public/web/web_local_frame.h
@@ -777,20 +777,23 @@ class WebLocalFrame : public WebFrame {
 
   // User activation -----------------------------------------------------------
 
-  // See blink::LocalFrame::NotifyUserActivation().
+  // See |blink::LocalFrame::NotifyUserActivation()|.
   virtual void NotifyUserActivation(
       mojom::UserActivationNotificationType notification_type) = 0;
 
-  // See blink::LocalFrame::HasStickyUserActivation().
+  // See |blink::Frame::HasStickyUserActivation()|.
   virtual bool HasStickyUserActivation() = 0;
 
-  // See blink::LocalFrame::HasTransientUserActivation().
+  // See |blink::Frame::HasTransientUserActivation()|.
   virtual bool HasTransientUserActivation() = 0;
 
-  // See blink::LocalFrame::ConsumeTransientUserActivation().
+  // See |blink::LocalFrame::ConsumeTransientUserActivation()|.
   virtual bool ConsumeTransientUserActivation(
       UserActivationUpdateSource update_source =
           UserActivationUpdateSource::kRenderer) = 0;
+  
+  // See |blink::Frame::LastActivationWasRestricted()|.
+  virtual bool LastActivationWasRestricted() const = 0;
 
   // Optimization Guide --------------------------------------------------------
 
diff --git a/third_party/blink/renderer/core/animation/animation.cc b/third_party/blink/renderer/core/animation/animation.cc
index ea45c19829..02e5bc4ef1 100644
--- a/third_party/blink/renderer/core/animation/animation.cc
+++ b/third_party/blink/renderer/core/animation/animation.cc
@@ -2096,10 +2096,6 @@ bool Animation::Update(TimingUpdateReason reason) {
 
   if (reason == kTimingUpdateForAnimationFrame) {
     if (idle || CalculateAnimationPlayState() == kFinished) {
-      // TODO(crbug.com/1029348): Per spec, we should have a microtask
-      // checkpoint right after the update cycle. Once this is fixed we should
-      // no longer need to force a synchronous resolution here.
-      AsyncFinishMicrotask();
       finished_ = true;
     }
   }
diff --git a/third_party/blink/renderer/core/animation/document_animations.cc b/third_party/blink/renderer/core/animation/document_animations.cc
index c7ed01c694..04ec203f21 100644
--- a/third_party/blink/renderer/core/animation/document_animations.cc
+++ b/third_party/blink/renderer/core/animation/document_animations.cc
@@ -44,6 +44,7 @@
 #include "third_party/blink/renderer/core/page/page.h"
 #include "third_party/blink/renderer/core/page/page_animator.h"
 #include "third_party/blink/renderer/platform/bindings/microtask.h"
+#include "third_party/blink/renderer/platform/heap/persistent.h"
 
 namespace blink {
 
@@ -254,10 +255,13 @@ void DocumentAnimations::RemoveReplacedAnimations(
 
   // The list of animations for removal is constructed in reverse composite
   // ordering for efficiency. Flip the ordering to ensure that events are
-  // dispatched in composite order.
+  // dispatched in composite order.  Queue as a microtask so that the finished
+  // event is dispatched ahead of the remove event.
   for (auto it = animations_to_remove.rbegin();
        it != animations_to_remove.rend(); it++) {
-    (*it)->RemoveReplacedAnimation();
+    Animation* animation = *it;
+    Microtask::EnqueueMicrotask(WTF::Bind(&Animation::RemoveReplacedAnimation,
+                                          WrapWeakPersistent(animation)));
   }
 }
 
diff --git a/third_party/blink/renderer/core/display_lock/display_lock_utilities.cc b/third_party/blink/renderer/core/display_lock/display_lock_utilities.cc
index b751822d19..715a830c65 100644
--- a/third_party/blink/renderer/core/display_lock/display_lock_utilities.cc
+++ b/third_party/blink/renderer/core/display_lock/display_lock_utilities.cc
@@ -173,6 +173,9 @@ DisplayLockUtilities::ScopedForcedUpdate::Impl::Impl(const Node* node,
   if (!RuntimeEnabledFeatures::CSSContentVisibilityEnabled())
     return;
 
+  if (!node_)
+    return;
+
   auto* owner_node = GetFrameOwnerNode(node);
   if (owner_node)
     parent_frame_impl_ = MakeGarbageCollected<Impl>(owner_node, true);
@@ -215,6 +218,8 @@ DisplayLockUtilities::ScopedForcedUpdate::Impl::Impl(const Node* node,
 }
 
 void DisplayLockUtilities::ScopedForcedUpdate::Impl::Destroy() {
+  if (!node_)
+    return;
   if (RuntimeEnabledFeatures::CSSContentVisibilityEnabled())
     node_->GetDocument().GetDisplayLockDocumentState().EndNodeForcedScope(this);
   if (parent_frame_impl_)
diff --git a/third_party/blink/renderer/core/display_lock/display_lock_utilities.h b/third_party/blink/renderer/core/display_lock/display_lock_utilities.h
index 6e6839e2c1..022ac073ca 100644
--- a/third_party/blink/renderer/core/display_lock/display_lock_utilities.h
+++ b/third_party/blink/renderer/core/display_lock/display_lock_utilities.h
@@ -8,6 +8,7 @@
 #include "third_party/blink/renderer/core/core_export.h"
 #include "third_party/blink/renderer/core/display_lock/display_lock_context.h"
 #include "third_party/blink/renderer/core/editing/ephemeral_range.h"
+#include "third_party/blink/renderer/core/editing/frame_selection.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
 namespace blink {
@@ -51,6 +52,8 @@ class CORE_EXPORT DisplayLockUtilities {
     friend void Document::EnsurePaintLocationDataValidForNode(
         const Node* node,
         DocumentUpdateReason reason);
+    friend VisibleSelection
+    FrameSelection::ComputeVisibleSelectionInDOMTreeDeprecated() const;
 
     friend class DisplayLockContext;
 
diff --git a/third_party/blink/renderer/core/dom/document.cc b/third_party/blink/renderer/core/dom/document.cc
index 40c41eae6f..ef07a29ca8 100644
--- a/third_party/blink/renderer/core/dom/document.cc
+++ b/third_party/blink/renderer/core/dom/document.cc
@@ -323,7 +323,6 @@
 #include "third_party/blink/renderer/platform/loader/fetch/resource_fetcher.h"
 #include "third_party/blink/renderer/platform/network/content_security_policy_parsers.h"
 #include "third_party/blink/renderer/platform/network/http_parsers.h"
-#include "third_party/blink/renderer/platform/network/network_state_notifier.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/scheduler/public/event_loop.h"
 #include "third_party/blink/renderer/platform/scheduler/public/frame_or_worker_scheduler.h"
@@ -577,43 +576,6 @@ uint64_t Document::global_tree_version_ = 0;
 
 static bool g_threaded_parsing_enabled_for_testing = true;
 
-class Document::NetworkStateObserver final
-    : public GarbageCollected<Document::NetworkStateObserver>,
-      public NetworkStateNotifier::NetworkStateObserver,
-      public ExecutionContextLifecycleObserver {
- public:
-  explicit NetworkStateObserver(ExecutionContext* context)
-      : ExecutionContextLifecycleObserver(context) {
-    online_observer_handle_ = GetNetworkStateNotifier().AddOnLineObserver(
-        this, GetExecutionContext()->GetTaskRunner(TaskType::kNetworking));
-  }
-
-  void OnLineStateChange(bool on_line) override {
-    AtomicString event_name =
-        on_line ? event_type_names::kOnline : event_type_names::kOffline;
-    auto* window = To<LocalDOMWindow>(GetExecutionContext());
-    window->DispatchEvent(*Event::Create(event_name));
-    probe::NetworkStateChanged(window->GetFrame(), on_line);
-  }
-
-  void ContextDestroyed() override {
-    UnregisterAsObserver(GetExecutionContext());
-  }
-
-  void UnregisterAsObserver(ExecutionContext* context) {
-    DCHECK(context);
-    online_observer_handle_ = nullptr;
-  }
-
-  void Trace(Visitor* visitor) const override {
-    ExecutionContextLifecycleObserver::Trace(visitor);
-  }
-
- private:
-  std::unique_ptr<NetworkStateNotifier::NetworkStateObserverHandle>
-      online_observer_handle_;
-};
-
 ExplicitlySetAttrElementsMap* Document::GetExplicitlySetAttrElementsMap(
     Element* element) {
   DCHECK(element);
@@ -2945,12 +2907,6 @@ void Document::Initialize() {
 
   if (View())
     View()->DidAttachDocument();
-
-  // Observer(s) should not be initialized until the document is initialized /
-  // attached to a frame. Otherwise
-  // ExecutionContextLifecycleObserver::contextDestroyed wouldn't be fired.
-  network_state_observer_ =
-      MakeGarbageCollected<NetworkStateObserver>(GetExecutionContext());
 }
 
 void Document::Shutdown() {
@@ -8162,7 +8118,6 @@ void Document::Trace(Visitor* visitor) const {
   visitor->Trace(intersection_observer_controller_);
   visitor->Trace(snap_coordinator_);
   visitor->Trace(property_registry_);
-  visitor->Trace(network_state_observer_);
   visitor->Trace(policy_);
   visitor->Trace(slot_assignment_engine_);
   visitor->Trace(viewport_data_);
diff --git a/third_party/blink/renderer/core/dom/document.h b/third_party/blink/renderer/core/dom/document.h
index b134657c84..dde3cfc634 100644
--- a/third_party/blink/renderer/core/dom/document.h
+++ b/third_party/blink/renderer/core/dom/document.h
@@ -1720,7 +1720,6 @@ class CORE_EXPORT Document : public ContainerNode,
                            BeforeMatchExpandedHiddenMatchableUkm);
   FRIEND_TEST_ALL_PREFIXES(TextFinderSimTest,
                            BeforeMatchExpandedHiddenMatchableUkmNoHandler);
-  class NetworkStateObserver;
 
   friend class AXContext;
   void AddAXContext(AXContext*);
@@ -2112,8 +2111,6 @@ class CORE_EXPORT Document : public ContainerNode,
 
   TaskHandle sensitive_input_edited_task_;
 
-  Member<NetworkStateObserver> network_state_observer_;
-
   // |ukm_recorder_| and |source_id_| will allow objects that are part of
   // the document to record UKM.
   std::unique_ptr<ukm::UkmRecorder> ukm_recorder_;
diff --git a/third_party/blink/renderer/core/editing/frame_selection.cc b/third_party/blink/renderer/core/editing/frame_selection.cc
index d0133cc8da..f59557caeb 100644
--- a/third_party/blink/renderer/core/editing/frame_selection.cc
+++ b/third_party/blink/renderer/core/editing/frame_selection.cc
@@ -158,6 +158,10 @@ VisibleSelection FrameSelection::ComputeVisibleSelectionInDOMTreeDeprecated()
     const {
   // TODO(editing-dev): Hoist UpdateStyleAndLayout
   // to caller. See http://crbug.com/590369 for more details.
+  DisplayLockUtilities::ScopedForcedUpdate base_scope(
+      GetSelectionInDOMTree().Base().AnchorNode());
+  DisplayLockUtilities::ScopedForcedUpdate extent_scope(
+      GetSelectionInDOMTree().Extent().AnchorNode());
   GetDocument().UpdateStyleAndLayout(DocumentUpdateReason::kSelection);
   return ComputeVisibleSelectionInDOMTree();
 }
diff --git a/third_party/blink/renderer/core/frame/frame.h b/third_party/blink/renderer/core/frame/frame.h
index 485c1b1dd3..fa767917b2 100644
--- a/third_party/blink/renderer/core/frame/frame.h
+++ b/third_party/blink/renderer/core/frame/frame.h
@@ -212,6 +212,12 @@ class CORE_EXPORT Frame : public GarbageCollected<Frame> {
     return user_activation_state_.HasBeenActive();
   }
 
+  // Returns if the last user activation for this frame was restricted in
+  // nature.
+  bool LastActivationWasRestricted() const {
+    return user_activation_state_.LastActivationWasRestricted();
+  }
+
   // Resets the user activation state of this frame.
   void ClearUserActivation() { user_activation_state_.Clear(); }
 
diff --git a/third_party/blink/renderer/core/frame/local_dom_window.cc b/third_party/blink/renderer/core/frame/local_dom_window.cc
index 62dac665c1..b93ae92cb6 100644
--- a/third_party/blink/renderer/core/frame/local_dom_window.cc
+++ b/third_party/blink/renderer/core/frame/local_dom_window.cc
@@ -128,6 +128,7 @@
 #include "third_party/blink/renderer/platform/bindings/script_state.h"
 #include "third_party/blink/renderer/platform/heap/heap.h"
 #include "third_party/blink/renderer/platform/loader/fetch/resource_fetcher.h"
+#include "third_party/blink/renderer/platform/network/network_state_notifier.h"
 #include "third_party/blink/renderer/platform/scheduler/public/dummy_schedulers.h"
 #include "third_party/blink/renderer/platform/scheduler/public/post_cross_thread_task.h"
 #include "third_party/blink/renderer/platform/timer.h"
@@ -163,6 +164,38 @@ bool ShouldRecordPostMessageIncomingFrameUkmEvent(
 
 }  // namespace
 
+class LocalDOMWindow::NetworkStateObserver final
+    : public GarbageCollected<LocalDOMWindow::NetworkStateObserver>,
+      public NetworkStateNotifier::NetworkStateObserver,
+      public ExecutionContextLifecycleObserver {
+ public:
+  explicit NetworkStateObserver(ExecutionContext* context)
+      : ExecutionContextLifecycleObserver(context) {}
+
+  void Initialize() {
+    online_observer_handle_ = GetNetworkStateNotifier().AddOnLineObserver(
+        this, GetExecutionContext()->GetTaskRunner(TaskType::kNetworking));
+  }
+
+  void OnLineStateChange(bool on_line) override {
+    AtomicString event_name =
+        on_line ? event_type_names::kOnline : event_type_names::kOffline;
+    auto* window = To<LocalDOMWindow>(GetExecutionContext());
+    window->DispatchEvent(*Event::Create(event_name));
+    probe::NetworkStateChanged(window->GetFrame(), on_line);
+  }
+
+  void ContextDestroyed() override { online_observer_handle_ = nullptr; }
+
+  void Trace(Visitor* visitor) const override {
+    ExecutionContextLifecycleObserver::Trace(visitor);
+  }
+
+ private:
+  std::unique_ptr<NetworkStateNotifier::NetworkStateObserverHandle>
+      online_observer_handle_;
+};
+
 LocalDOMWindow::LocalDOMWindow(LocalFrame& frame, WindowAgent* agent)
     : DOMWindow(frame),
       ExecutionContext(V8PerIsolateData::MainThreadIsolate(), agent),
@@ -180,7 +213,9 @@ LocalDOMWindow::LocalDOMWindow(LocalFrame& frame, WindowAgent* agent)
       isolated_world_csp_map_(
           MakeGarbageCollected<
               HeapHashMap<int, Member<ContentSecurityPolicy>>>()),
-      token_(frame.GetLocalFrameToken()) {}
+      token_(frame.GetLocalFrameToken()),
+      network_state_observer_(
+          MakeGarbageCollected<NetworkStateObserver>(this)) {}
 
 void LocalDOMWindow::BindContentSecurityPolicy() {
   DCHECK(!GetContentSecurityPolicy()->IsBound());
@@ -190,6 +225,7 @@ void LocalDOMWindow::BindContentSecurityPolicy() {
 
 void LocalDOMWindow::Initialize() {
   GetAgent()->AttachContext(this);
+  network_state_observer_->Initialize();
 }
 
 void LocalDOMWindow::ResetWindowAgent(WindowAgent* agent) {
@@ -2094,6 +2130,7 @@ void LocalDOMWindow::Trace(Visitor* visitor) const {
   visitor->Trace(spell_checker_);
   visitor->Trace(text_suggestion_controller_);
   visitor->Trace(isolated_world_csp_map_);
+  visitor->Trace(network_state_observer_);
   DOMWindow::Trace(visitor);
   ExecutionContext::Trace(visitor);
   Supplementable<LocalDOMWindow>::Trace(visitor);
diff --git a/third_party/blink/renderer/core/frame/local_dom_window.h b/third_party/blink/renderer/core/frame/local_dom_window.h
index 54799ba940..0ad3914d6b 100644
--- a/third_party/blink/renderer/core/frame/local_dom_window.h
+++ b/third_party/blink/renderer/core/frame/local_dom_window.h
@@ -445,6 +445,8 @@ class CORE_EXPORT LocalDOMWindow final : public DOMWindow,
                            LocalDOMWindow* source) override;
 
  private:
+  class NetworkStateObserver;
+
   // Intentionally private to prevent redundant checks when the type is
   // already LocalDOMWindow.
   bool IsLocalDOMWindow() const override { return true; }
@@ -543,6 +545,9 @@ class CORE_EXPORT LocalDOMWindow final : public DOMWindow,
   // this UKM is logged.
   // TODO(crbug.com/1112491): Remove when no longer needed.
   Deque<ukm::SourceId> post_message_ukm_recorded_source_ids_;
+
+  // Fire "online" and "offline" events.
+  Member<NetworkStateObserver> network_state_observer_;
 };
 
 template <>
diff --git a/third_party/blink/renderer/core/frame/web_local_frame_impl.cc b/third_party/blink/renderer/core/frame/web_local_frame_impl.cc
index ce2ed9317c..3991250d8a 100644
--- a/third_party/blink/renderer/core/frame/web_local_frame_impl.cc
+++ b/third_party/blink/renderer/core/frame/web_local_frame_impl.cc
@@ -651,6 +651,10 @@ bool WebLocalFrameImpl::ConsumeTransientUserActivation(
   return LocalFrame::ConsumeTransientUserActivation(GetFrame(), update_source);
 }
 
+bool WebLocalFrameImpl::LastActivationWasRestricted() const {
+  return GetFrame()->LastActivationWasRestricted();
+}
+
 void WebLocalFrameImpl::SetOptimizationGuideHints(
     const WebOptimizationGuideHints& web_hints) {
   if (!GetFrame())
@@ -2071,6 +2075,16 @@ LocalFrame* WebLocalFrameImpl::CreateChildFrame(
       policy_container_receiver =
           policy_container_remote.InitWithNewEndpointAndPassReceiver();
 
+  FramePolicy frame_policy = owner_element->GetFramePolicy();
+  // Documents create iframes, iframes host new documents. Both are associated
+  // with sandbox flags. They are required to be stricter or equal as we go
+  // down. The iframe owner element only returns the additional restrictions
+  // defined in the HTMLIFrameElement's sanbox attribute. It needs to be
+  // combined with the document's sandbox flags to get the frame's sandbox
+  // policy right.
+  frame_policy.sandbox_flags |=
+      GetFrame()->GetDocument()->GetExecutionContext()->GetSandboxFlags();
+
   // FIXME: Using subResourceAttributeName as fallback is not a perfect
   // solution. subResourceAttributeName returns just one attribute name. The
   // element might not have the attribute, and there might be other attributes
@@ -2080,8 +2094,7 @@ LocalFrame* WebLocalFrameImpl::CreateChildFrame(
           scope, name,
           owner_element->getAttribute(
               owner_element->SubResourceAttributeName()),
-          owner_element->GetFramePolicy(), owner_properties,
-          owner_element->OwnerType(),
+          std::move(frame_policy), owner_properties, owner_element->OwnerType(),
           WebPolicyContainerBindParams{std::move(policy_container_receiver)}));
   if (!webframe_child)
     return nullptr;
diff --git a/third_party/blink/renderer/core/frame/web_local_frame_impl.h b/third_party/blink/renderer/core/frame/web_local_frame_impl.h
index 7bd9fc4698..3c905f1dfd 100644
--- a/third_party/blink/renderer/core/frame/web_local_frame_impl.h
+++ b/third_party/blink/renderer/core/frame/web_local_frame_impl.h
@@ -324,6 +324,7 @@ class CORE_EXPORT WebLocalFrameImpl final
   bool HasStickyUserActivation() override;
   bool HasTransientUserActivation() override;
   bool ConsumeTransientUserActivation(UserActivationUpdateSource) override;
+  bool LastActivationWasRestricted() const override;
   void SetOptimizationGuideHints(const WebOptimizationGuideHints&) override;
   void SetTargetToCurrentHistoryItem(const WebString& target) override;
   void UpdateCurrentHistoryItem() override;
diff --git a/third_party/blink/renderer/core/html/html_iframe_element.cc b/third_party/blink/renderer/core/html/html_iframe_element.cc
index cfa0b2e78b..ab26e9398f 100644
--- a/third_party/blink/renderer/core/html/html_iframe_element.cc
+++ b/third_party/blink/renderer/core/html/html_iframe_element.cc
@@ -207,16 +207,27 @@ void HTMLIFrameElement::ParseAttribute(
       UpdateContainerPolicy();
     }
   } else if (name == html_names::kCspAttr) {
+    static const size_t kMaxLengthCSPAttribute = 4096;
     if (value && (value.Contains('\n') || value.Contains('\r') ||
                   !MatchesTheSerializedCSPGrammar(value.GetString()))) {
+      // TODO(antoniosartori): It would be safer to block loading iframes with
+      // invalid 'csp' attribute.
       required_csp_ = g_null_atom;
       GetDocument().AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
           mojom::blink::ConsoleMessageSource::kOther,
           mojom::blink::ConsoleMessageLevel::kError,
           "'csp' attribute is invalid: " + value));
-      return;
-    }
-    if (required_csp_ != value) {
+    } else if (value && value.length() > kMaxLengthCSPAttribute) {
+      // TODO(antoniosartori): It would be safer to block loading iframes with
+      // invalid 'csp' attribute.
+      required_csp_ = g_null_atom;
+      GetDocument().AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
+          mojom::blink::ConsoleMessageSource::kOther,
+          mojom::blink::ConsoleMessageLevel::kError,
+          String::Format("'csp' attribute too long. The max length for the "
+                         "'csp' attribute is %zu bytes.",
+                         kMaxLengthCSPAttribute)));
+    } else if (required_csp_ != value) {
       required_csp_ = value;
       CSPAttributeChanged();
       UseCounter::Count(GetDocument(), WebFeature::kIFrameCSPAttribute);
diff --git a/third_party/blink/renderer/core/html/parser/css_preload_scanner.cc b/third_party/blink/renderer/core/html/parser/css_preload_scanner.cc
index 99f25715af..4f3ee7e9cf 100644
--- a/third_party/blink/renderer/core/html/parser/css_preload_scanner.cc
+++ b/third_party/blink/renderer/core/html/parser/css_preload_scanner.cc
@@ -259,8 +259,7 @@ void CSSPreloadScanner::EmitRule(const SegmentedString& source) {
     auto request = PreloadRequest::CreateIfNeeded(
         fetch_initiator_type_names::kCSS, position, url,
         *predicted_base_element_url_, ResourceType::kCSSStyleSheet,
-        referrer_policy_, PreloadRequest::kBaseUrlIsReferrer,
-        ResourceFetcher::kImageNotImageSet, exclusion_info_);
+        referrer_policy_, ResourceFetcher::kImageNotImageSet, exclusion_info_);
     if (request) {
       // FIXME: Should this be including the charset in the preload request?
       requests_->push_back(std::move(request));
diff --git a/third_party/blink/renderer/core/html/parser/html_preload_scanner.cc b/third_party/blink/renderer/core/html/parser/html_preload_scanner.cc
index ea4b201b0a..99ab6cd142 100644
--- a/third_party/blink/renderer/core/html/parser/html_preload_scanner.cc
+++ b/third_party/blink/renderer/core/html/parser/html_preload_scanner.cc
@@ -321,9 +321,8 @@ class TokenPreloadScanner::StartTagScanner {
             : document_parameters.referrer_policy;
     auto request = PreloadRequest::CreateIfNeeded(
         InitiatorFor(tag_impl_), position, url_to_load_, predicted_base_url,
-        type.value(), referrer_policy, PreloadRequest::kDocumentIsReferrer,
-        is_image_set, exclusion_info, resource_width, client_hints_preferences,
-        request_type);
+        type.value(), referrer_policy, is_image_set, exclusion_info,
+        resource_width, client_hints_preferences, request_type);
     if (!request)
       return nullptr;
 
diff --git a/third_party/blink/renderer/core/html/parser/html_resource_preloader_test.cc b/third_party/blink/renderer/core/html/parser/html_resource_preloader_test.cc
index 9dbe2ef393..ddd9f3de6a 100644
--- a/third_party/blink/renderer/core/html/parser/html_resource_preloader_test.cc
+++ b/third_party/blink/renderer/core/html/parser/html_resource_preloader_test.cc
@@ -58,10 +58,9 @@ class HTMLResourcePreloaderTest : public PageTestBase {
     auto preload_request = PreloadRequest::CreateIfNeeded(
         String(), TextPosition::MinimumPosition(), test_case.url,
         KURL(test_case.base_url), ResourceType::kImage,
-        network::mojom::ReferrerPolicy(), PreloadRequest::kDocumentIsReferrer,
-        ResourceFetcher::kImageNotImageSet, nullptr /* exclusion_info */,
-        FetchParameters::ResourceWidth(), ClientHintsPreferences(),
-        PreloadRequest::kRequestTypePreconnect);
+        network::mojom::ReferrerPolicy(), ResourceFetcher::kImageNotImageSet,
+        nullptr /* exclusion_info */, FetchParameters::ResourceWidth(),
+        ClientHintsPreferences(), PreloadRequest::kRequestTypePreconnect);
     DCHECK(preload_request);
     if (test_case.is_cors)
       preload_request->SetCrossOrigin(kCrossOriginAttributeAnonymous);
diff --git a/third_party/blink/renderer/core/html/parser/preload_request.cc b/third_party/blink/renderer/core/html/parser/preload_request.cc
index 73c57ab7c8..ec351968e7 100644
--- a/third_party/blink/renderer/core/html/parser/preload_request.cc
+++ b/third_party/blink/renderer/core/html/parser/preload_request.cc
@@ -61,7 +61,6 @@ std::unique_ptr<PreloadRequest> PreloadRequest::CreateIfNeeded(
     const KURL& base_url,
     ResourceType resource_type,
     const network::mojom::ReferrerPolicy referrer_policy,
-    ReferrerSource referrer_source,
     ResourceFetcher::IsImageSet is_image_set,
     const ExclusionInfo* exclusion_info,
     const FetchParameters::ResourceWidth& resource_width,
@@ -82,7 +81,7 @@ std::unique_ptr<PreloadRequest> PreloadRequest::CreateIfNeeded(
   return base::WrapUnique(new PreloadRequest(
       initiator_name, initiator_position, resource_url, base_url, resource_type,
       resource_width, client_hints_preferences, request_type, referrer_policy,
-      referrer_source, is_image_set));
+      is_image_set));
 }
 
 Resource* PreloadRequest::Start(Document* document) {
@@ -98,9 +97,6 @@ Resource* PreloadRequest::Start(Document* document) {
 
   ResourceRequest resource_request(url);
   resource_request.SetReferrerPolicy(referrer_policy_);
-  if (referrer_source_ == kBaseUrlIsReferrer) {
-    resource_request.SetReferrerString(base_url_.StrippedForUseAsReferrer());
-  }
 
   resource_request.SetRequestContext(
       ResourceFetcher::DetermineRequestContext(resource_type_, is_image_set_));
diff --git a/third_party/blink/renderer/core/html/parser/preload_request.h b/third_party/blink/renderer/core/html/parser/preload_request.h
index 8f0d11c50f..9f64caa47e 100644
--- a/third_party/blink/renderer/core/html/parser/preload_request.h
+++ b/third_party/blink/renderer/core/html/parser/preload_request.h
@@ -62,8 +62,6 @@ class CORE_EXPORT PreloadRequest {
     kRequestTypeLinkRelPreload
   };
 
-  enum ReferrerSource { kDocumentIsReferrer, kBaseUrlIsReferrer };
-
   static std::unique_ptr<PreloadRequest> CreateIfNeeded(
       const String& initiator_name,
       const TextPosition& initiator_position,
@@ -71,7 +69,6 @@ class CORE_EXPORT PreloadRequest {
       const KURL& base_url,
       ResourceType resource_type,
       const network::mojom::ReferrerPolicy referrer_policy,
-      ReferrerSource referrer_source,
       ResourceFetcher::IsImageSet is_image_set,
       const ExclusionInfo* exclusion_info,
       const FetchParameters::ResourceWidth& resource_width =
@@ -154,7 +151,6 @@ class CORE_EXPORT PreloadRequest {
                  const ClientHintsPreferences& client_hints_preferences,
                  RequestType request_type,
                  const network::mojom::ReferrerPolicy referrer_policy,
-                 ReferrerSource referrer_source,
                  ResourceFetcher::IsImageSet is_image_set)
       : initiator_name_(initiator_name),
         initiator_position_(initiator_position),
@@ -169,7 +165,6 @@ class CORE_EXPORT PreloadRequest {
         client_hints_preferences_(client_hints_preferences),
         request_type_(request_type),
         referrer_policy_(referrer_policy),
-        referrer_source_(referrer_source),
         from_insertion_scanner_(false),
         is_image_set_(is_image_set),
         is_lazy_load_image_enabled_(false) {}
@@ -191,7 +186,6 @@ class CORE_EXPORT PreloadRequest {
   const ClientHintsPreferences client_hints_preferences_;
   const RequestType request_type_;
   const network::mojom::ReferrerPolicy referrer_policy_;
-  const ReferrerSource referrer_source_;
   IntegrityMetadataSet integrity_metadata_;
   RenderBlockingBehavior render_blocking_behavior_ =
       RenderBlockingBehavior::kUnset;
diff --git a/third_party/blink/renderer/core/layout/layout_inline.cc b/third_party/blink/renderer/core/layout/layout_inline.cc
index e59adae120..d3fa773216 100644
--- a/third_party/blink/renderer/core/layout/layout_inline.cc
+++ b/third_party/blink/renderer/core/layout/layout_inline.cc
@@ -574,15 +574,13 @@ void LayoutInline::SplitInlines(LayoutBlockFlow* from_block,
   // nest to a much greater depth (see bugzilla bug 13430) but for now we have a
   // limit. This *will* result in incorrect rendering, but the alternative is to
   // hang forever.
-  const unsigned kCMaxSplitDepth = 200;
   Vector<LayoutInline*> inlines_to_clone;
   LayoutInline* top_most_inline = this;
   for (LayoutObject* o = this; o != from_block; o = o->Parent()) {
     if (o->IsLayoutNGInsideListMarker())
       continue;
     top_most_inline = To<LayoutInline>(o);
-    if (inlines_to_clone.size() < kCMaxSplitDepth)
-      inlines_to_clone.push_back(top_most_inline);
+    inlines_to_clone.push_back(top_most_inline);
     // Keep walking up the chain to ensure |topMostInline| is a child of
     // |fromBlock|, to avoid assertion failure when |fromBlock|'s children are
     // moved to |toBlock| below.
diff --git a/third_party/blink/renderer/core/loader/threaded_icon_loader.cc b/third_party/blink/renderer/core/loader/threaded_icon_loader.cc
index c995ac8660..40d0b51332 100644
--- a/third_party/blink/renderer/core/loader/threaded_icon_loader.cc
+++ b/third_party/blink/renderer/core/loader/threaded_icon_loader.cc
@@ -11,6 +11,7 @@
 #include "skia/ext/image_operations.h"
 #include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-blink.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context.h"
+#include "third_party/blink/renderer/platform/graphics/skia/skia_utils.h"
 #include "third_party/blink/renderer/platform/image-decoders/image_decoder.h"
 #include "third_party/blink/renderer/platform/image-decoders/image_frame.h"
 #include "third_party/blink/renderer/platform/image-decoders/segment_reader.h"
@@ -24,6 +25,80 @@
 
 namespace blink {
 
+namespace {
+
+void DecodeAndResizeImage(
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+    scoped_refptr<SegmentReader> data,
+    gfx::Size resize_dimensions,
+    CrossThreadOnceFunction<void(SkBitmap, double)> done_callback) {
+  auto notify_complete = [&](SkBitmap icon, double resize_scale) {
+    // This is needed so it can be moved cross-thread.
+    icon.setImmutable();
+    PostCrossThreadTask(*task_runner, FROM_HERE,
+                        CrossThreadBindOnce(std::move(done_callback),
+                                            std::move(icon), resize_scale));
+  };
+
+  std::unique_ptr<ImageDecoder> decoder = ImageDecoder::Create(
+      std::move(data), /* data_complete= */ true,
+      ImageDecoder::kAlphaPremultiplied, ImageDecoder::kDefaultBitDepth,
+      ColorBehavior::TransformToSRGB());
+
+  if (!decoder) {
+    notify_complete(SkBitmap(), -1.0);
+    return;
+  }
+
+  ImageFrame* image_frame = decoder->DecodeFrameBufferAtIndex(0);
+
+  if (!image_frame) {
+    notify_complete(SkBitmap(), -1.0);
+    return;
+  }
+
+  SkBitmap decoded_icon = image_frame->Bitmap();
+  if (resize_dimensions.IsEmpty()) {
+    notify_complete(std::move(decoded_icon), 1.0);
+    return;
+  }
+
+  // If the icon is larger than |resize_dimensions| permits, we need to
+  // resize it as well. This can be done synchronously given that we're on a
+  // background thread already.
+  double scale = std::min(
+      static_cast<double>(resize_dimensions.width()) / decoded_icon.width(),
+      static_cast<double>(resize_dimensions.height()) / decoded_icon.height());
+
+  if (scale >= 1.0) {
+    notify_complete(std::move(decoded_icon), 1.0);
+    return;
+  }
+
+  int resized_width =
+      base::ranges::clamp(static_cast<int>(scale * decoded_icon.width()), 1,
+                  resize_dimensions.width());
+  int resized_height =
+      base::ranges::clamp(static_cast<int>(scale * decoded_icon.height()), 1,
+                  resize_dimensions.height());
+
+  // Use the RESIZE_GOOD quality allowing the implementation to pick an
+  // appropriate method for the resize. Can be increased to RESIZE_BETTER
+  // or RESIZE_BEST if the quality looks poor.
+  SkBitmap resized_icon = skia::ImageOperations::Resize(
+      decoded_icon, skia::ImageOperations::RESIZE_GOOD, resized_width,
+      resized_height);
+
+  if (resized_icon.isNull()) {
+    notify_complete(std::move(decoded_icon), 1.0);
+    return;
+  }
+
+  notify_complete(std::move(resized_icon), scale);
+}
+
+}  // namespace
+
 void ThreadedIconLoader::Start(
     ExecutionContext* execution_context,
     const ResourceRequestHead& resource_request,
@@ -83,87 +158,18 @@ void ThreadedIconLoader::DidFinishLoading(uint64_t resource_identifier) {
   worker_pool::PostTask(
       FROM_HERE,
       CrossThreadBindOnce(
-          &ThreadedIconLoader::DecodeAndResizeImageOnBackgroundThread,
-          WrapCrossThreadPersistent(this), std::move(task_runner),
-          SegmentReader::CreateFromSharedBuffer(std::move(data_))));
-}
-
-void ThreadedIconLoader::DecodeAndResizeImageOnBackgroundThread(
-    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
-    scoped_refptr<SegmentReader> data) {
-  DCHECK(task_runner);
-  DCHECK(data);
-
-  auto notify_complete = [&](double refactor_scale) {
-    PostCrossThreadTask(
-        *task_runner, FROM_HERE,
-        CrossThreadBindOnce(&ThreadedIconLoader::OnBackgroundTaskComplete,
-                            WrapCrossThreadPersistent(this), refactor_scale));
-  };
-
-  std::unique_ptr<ImageDecoder> decoder = ImageDecoder::Create(
-      std::move(data), /* data_complete= */ true,
-      ImageDecoder::kAlphaPremultiplied, ImageDecoder::kDefaultBitDepth,
-      ColorBehavior::TransformToSRGB());
-
-  if (!decoder) {
-    notify_complete(-1.0);
-    return;
-  }
-
-  ImageFrame* image_frame = decoder->DecodeFrameBufferAtIndex(0);
-
-  if (!image_frame) {
-    notify_complete(-1.0);
-    return;
-  }
-
-  decoded_icon_ = image_frame->Bitmap();
-  if (!resize_dimensions_) {
-    notify_complete(1.0);
-    return;
-  }
-
-  // If the icon is larger than |resize_dimensions_| permits, we need to resize
-  // it as well. This can be done synchronously given that we're on a
-  // background thread already.
-  double scale = std::min(
-      static_cast<double>(resize_dimensions_->width()) / decoded_icon_.width(),
-      static_cast<double>(resize_dimensions_->height()) /
-          decoded_icon_.height());
-
-  if (scale >= 1.0) {
-    notify_complete(1.0);
-    return;
-  }
-
-  int resized_width =
-      base::ClampToRange(static_cast<int>(scale * decoded_icon_.width()), 1,
-                         resize_dimensions_->width());
-  int resized_height =
-      base::ClampToRange(static_cast<int>(scale * decoded_icon_.height()), 1,
-                         resize_dimensions_->height());
-
-  // Use the RESIZE_GOOD quality allowing the implementation to pick an
-  // appropriate method for the resize. Can be increased to RESIZE_BETTER
-  // or RESIZE_BEST if the quality looks poor.
-  SkBitmap resized_icon = skia::ImageOperations::Resize(
-      decoded_icon_, skia::ImageOperations::RESIZE_GOOD, resized_width,
-      resized_height);
-
-  if (resized_icon.isNull()) {
-    notify_complete(1.0);
-    return;
-  }
-
-  decoded_icon_ = std::move(resized_icon);
-  notify_complete(scale);
+          &DecodeAndResizeImage, std::move(task_runner),
+          SegmentReader::CreateFromSharedBuffer(std::move(data_)),
+          resize_dimensions_ ? *resize_dimensions_ : gfx::Size(),
+          CrossThreadBindOnce(&ThreadedIconLoader::OnBackgroundTaskComplete,
+                              WrapCrossThreadWeakPersistent(this))));
 }
 
-void ThreadedIconLoader::OnBackgroundTaskComplete(double resize_scale) {
+void ThreadedIconLoader::OnBackgroundTaskComplete(SkBitmap icon,
+                                                  double resize_scale) {
   if (stopped_)
     return;
-  std::move(icon_callback_).Run(std::move(decoded_icon_), resize_scale);
+  std::move(icon_callback_).Run(std::move(icon), resize_scale);
 }
 
 void ThreadedIconLoader::DidFail(const ResourceError& error) {
diff --git a/third_party/blink/renderer/core/loader/threaded_icon_loader.h b/third_party/blink/renderer/core/loader/threaded_icon_loader.h
index 4497f329a0..41fba43ad7 100644
--- a/third_party/blink/renderer/core/loader/threaded_icon_loader.h
+++ b/third_party/blink/renderer/core/loader/threaded_icon_loader.h
@@ -18,7 +18,6 @@
 namespace blink {
 
 class ResourceRequestHead;
-class SegmentReader;
 
 // Utility class for loading, decoding, and potentially rescaling an icon on a
 // background thread. Note that icons are only downscaled and never upscaled.
@@ -52,11 +51,7 @@ class CORE_EXPORT ThreadedIconLoader final
   void Trace(Visitor* visitor) const override;
 
  private:
-  void DecodeAndResizeImageOnBackgroundThread(
-      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
-      scoped_refptr<SegmentReader> data);
-
-  void OnBackgroundTaskComplete(double resize_scale);
+  void OnBackgroundTaskComplete(SkBitmap icon, double resize_scale);
 
   Member<ThreadableLoader> threadable_loader_;
 
@@ -64,9 +59,7 @@ class CORE_EXPORT ThreadedIconLoader final
   // of the image data starts.
   scoped_refptr<SharedBuffer> data_;
 
-  // Accessed from main thread and background thread.
   base::Optional<gfx::Size> resize_dimensions_;
-  SkBitmap decoded_icon_;
 
   IconCallback icon_callback_;
 
diff --git a/third_party/blink/renderer/core/streams/build.gni b/third_party/blink/renderer/core/streams/build.gni
index 57a106353b..744d47f1a1 100644
--- a/third_party/blink/renderer/core/streams/build.gni
+++ b/third_party/blink/renderer/core/streams/build.gni
@@ -43,6 +43,7 @@ blink_core_sources_streams = [
   "transform_stream_default_controller.cc",
   "transform_stream_default_controller.h",
   "transform_stream_transformer.h",
+  "underlying_sink_base.cc",
   "underlying_sink_base.h",
   "underlying_source_base.cc",
   "underlying_source_base.h",
diff --git a/third_party/blink/renderer/core/streams/underlying_sink_base.cc b/third_party/blink/renderer/core/streams/underlying_sink_base.cc
new file mode 100644
index 0000000000..a10d4f1865
--- /dev/null
+++ b/third_party/blink/renderer/core/streams/underlying_sink_base.cc
@@ -0,0 +1,29 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/core/streams/underlying_sink_base.h"
+
+#include "third_party/blink/renderer/core/streams/writable_stream_default_controller.h"
+#include "v8/include/v8.h"
+
+namespace blink {
+
+ScriptPromise UnderlyingSinkBase::start(ScriptState* script_state,
+                                        ScriptValue controller,
+                                        ExceptionState& exception_state) {
+  controller_ = WritableStreamDefaultController::From(script_state, controller);
+  return start(script_state, controller_, exception_state);
+}
+
+ScriptValue UnderlyingSinkBase::type(ScriptState* script_state) const {
+  auto* isolate = script_state->GetIsolate();
+  return ScriptValue(isolate, v8::Undefined(isolate));
+}
+
+void UnderlyingSinkBase::Trace(Visitor* visitor) const {
+  visitor->Trace(controller_);
+  ScriptWrappable::Trace(visitor);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/core/streams/underlying_sink_base.h b/third_party/blink/renderer/core/streams/underlying_sink_base.h
index 3b07d87f06..07ba729fc3 100644
--- a/third_party/blink/renderer/core/streams/underlying_sink_base.h
+++ b/third_party/blink/renderer/core/streams/underlying_sink_base.h
@@ -6,16 +6,20 @@
 #define THIRD_PARTY_BLINK_RENDERER_CORE_STREAMS_UNDERLYING_SINK_BASE_H_
 
 #include "third_party/blink/renderer/bindings/core/v8/script_promise.h"
+#include "third_party/blink/renderer/bindings/core/v8/script_value.h"
 #include "third_party/blink/renderer/core/core_export.h"
-#include "third_party/blink/renderer/core/streams/writable_stream_default_controller.h"
 #include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
 #include "third_party/blink/renderer/platform/heap/visitor.h"
 
+// Various files depend on us exporting this header.
+// TODO(ricea): Clean up the dependencies and remove this include.
+#include "third_party/blink/renderer/core/streams/writable_stream_default_controller.h"
+
 namespace blink {
 
 class ExceptionState;
-class ScriptValue;
 class ScriptState;
+class WritableStreamDefaultController;
 
 class CORE_EXPORT UnderlyingSinkBase : public ScriptWrappable {
   DEFINE_WRAPPERTYPEINFO();
@@ -38,12 +42,8 @@ class CORE_EXPORT UnderlyingSinkBase : public ScriptWrappable {
                               ScriptValue reason,
                               ExceptionState&) = 0;
 
-  ScriptPromise start(ScriptState* script_state,
-                      ScriptValue controller,
-                      ExceptionState& exception_state) {
-    controller_ = WritableStreamDefaultController::From(controller);
-    return start(script_state, controller_, exception_state);
-  }
+  ScriptPromise start(ScriptState*, ScriptValue controller, ExceptionState&);
+
   ScriptPromise write(ScriptState* script_state,
                       ScriptValue chunk,
                       ScriptValue controller,
@@ -52,10 +52,11 @@ class CORE_EXPORT UnderlyingSinkBase : public ScriptWrappable {
     return write(script_state, chunk, controller_, exception_state);
   }
 
-  void Trace(Visitor* visitor) const override {
-    visitor->Trace(controller_);
-    ScriptWrappable::Trace(visitor);
-  }
+  // Returns a JavaScript "undefined" value. This is required by the
+  // WritableStream Create() method.
+  ScriptValue type(ScriptState*) const;
+
+  void Trace(Visitor*) const override;
 
  protected:
   WritableStreamDefaultController* Controller() const { return controller_; }
diff --git a/third_party/blink/renderer/core/streams/underlying_sink_base.idl b/third_party/blink/renderer/core/streams/underlying_sink_base.idl
index 8351141cbc..470eb527b1 100644
--- a/third_party/blink/renderer/core/streams/underlying_sink_base.idl
+++ b/third_party/blink/renderer/core/streams/underlying_sink_base.idl
@@ -14,4 +14,7 @@ interface UnderlyingSinkBase {
     [CallWith=ScriptState, RaisesException] Promise<void> write(any chunk, any controller);
     [CallWith=ScriptState, RaisesException] Promise<void> close();
     [CallWith=ScriptState, RaisesException] Promise<void> abort(any reason);
+
+    // This only exists to prevent Object.prototype.type being accessed.
+    [CallWith=ScriptState] readonly attribute any type;
 };
diff --git a/third_party/blink/renderer/core/streams/writable_stream_default_controller.cc b/third_party/blink/renderer/core/streams/writable_stream_default_controller.cc
index cc76647826..9f60d988f7 100644
--- a/third_party/blink/renderer/core/streams/writable_stream_default_controller.cc
+++ b/third_party/blink/renderer/core/streams/writable_stream_default_controller.cc
@@ -21,10 +21,14 @@
 namespace blink {
 
 WritableStreamDefaultController* WritableStreamDefaultController::From(
+    ScriptState* script_state,
     ScriptValue controller) {
-  DCHECK(controller.IsObject());
-  return V8WritableStreamDefaultController::ToImpl(
-      controller.V8Value().As<v8::Object>());
+  CHECK(controller.IsObject());
+  auto* controller_impl =
+      V8WritableStreamDefaultController::ToImplWithTypeCheck(
+          script_state->GetIsolate(), controller.V8Value().As<v8::Object>());
+  CHECK(controller_impl);
+  return controller_impl;
 }
 
 // Only used internally. Not reachable from JavaScript.
diff --git a/third_party/blink/renderer/core/streams/writable_stream_default_controller.h b/third_party/blink/renderer/core/streams/writable_stream_default_controller.h
index 3351dcd694..8be6764217 100644
--- a/third_party/blink/renderer/core/streams/writable_stream_default_controller.h
+++ b/third_party/blink/renderer/core/streams/writable_stream_default_controller.h
@@ -27,7 +27,7 @@ class CORE_EXPORT WritableStreamDefaultController final
   DEFINE_WRAPPERTYPEINFO();
 
  public:
-  static WritableStreamDefaultController* From(ScriptValue);
+  static WritableStreamDefaultController* From(ScriptState*, ScriptValue);
 
   // The JavaScript-exposed constructor throws automatically as no constructor
   // is specified in the IDL. This constructor is used internally during
diff --git a/third_party/blink/renderer/modules/cache_storage/cache.cc b/third_party/blink/renderer/modules/cache_storage/cache.cc
index 5482ce90e5..0ec3a20cff 100644
--- a/third_party/blink/renderer/modules/cache_storage/cache.cc
+++ b/third_party/blink/renderer/modules/cache_storage/cache.cc
@@ -101,7 +101,7 @@ void ValidateResponseForPut(const Response* response,
     exception_state.ThrowTypeError("Vary header contains *");
     return;
   }
-  if (response->GetResponse()->InternalStatus() == 206) {
+  if (response->GetResponse()->Status() == 206) {
     exception_state.ThrowTypeError(
         "Partial response (status code 206) is unsupported");
     return;
diff --git a/third_party/blink/renderer/modules/content_index/content_index_icon_loader.cc b/third_party/blink/renderer/modules/content_index/content_index_icon_loader.cc
index 79f4224fd9..3b5f52a9be 100644
--- a/third_party/blink/renderer/modules/content_index/content_index_icon_loader.cc
+++ b/third_party/blink/renderer/modules/content_index/content_index_icon_loader.cc
@@ -26,6 +26,7 @@ constexpr base::TimeDelta kIconFetchTimeout = base::TimeDelta::FromSeconds(30);
 void FetchIcon(ExecutionContext* execution_context,
                const KURL& icon_url,
                const gfx::Size& icon_size,
+               ThreadedIconLoader* threaded_icon_loader,
                ThreadedIconLoader::IconCallback callback) {
   ResourceRequest resource_request(icon_url);
   resource_request.SetRequestContext(mojom::blink::RequestContextType::IMAGE);
@@ -34,7 +35,6 @@ void FetchIcon(ExecutionContext* execution_context,
   resource_request.SetPriority(ResourceLoadPriority::kMedium);
   resource_request.SetTimeoutInterval(kIconFetchTimeout);
 
-  auto* threaded_icon_loader = MakeGarbageCollected<ThreadedIconLoader>();
   threaded_icon_loader->Start(execution_context, resource_request, icon_size,
                               std::move(callback));
 }
@@ -100,16 +100,21 @@ void ContentIndexIconLoader::Start(
     if (icon_url.IsEmpty())
       icon_url = KURL(image_resources[0].src);
 
+    auto* threaded_icon_loader = MakeGarbageCollected<ThreadedIconLoader>();
     // |icons_ptr| is safe to use since it is owned by |barrier_closure|.
     FetchIcon(
-        execution_context, icon_url, icon_size,
+        execution_context, icon_url, icon_size, threaded_icon_loader,
         WTF::Bind(
             [](base::OnceClosure done_closure, Vector<SkBitmap>* icons_ptr,
-               SkBitmap icon, double resize_scale) {
+               ThreadedIconLoader* icon_loader, SkBitmap icon,
+               double resize_scale) {
               icons_ptr->push_back(std::move(icon));
               std::move(done_closure).Run();
             },
-            barrier_closure, WTF::Unretained(icons_ptr)));
+            barrier_closure, WTF::Unretained(icons_ptr),
+            // Pass |threaded_icon_loader| to the callback to make sure it
+            // doesn't get destroyed.
+            WrapPersistent(threaded_icon_loader)));
   }
 }
 
diff --git a/third_party/blink/renderer/modules/credentialmanager/credentials_container.cc b/third_party/blink/renderer/modules/credentialmanager/credentials_container.cc
index 1061445c91..8aaf8511d0 100644
--- a/third_party/blink/renderer/modules/credentialmanager/credentials_container.cc
+++ b/third_party/blink/renderer/modules/credentialmanager/credentials_container.cc
@@ -311,6 +311,11 @@ bool IsArrayBufferOrViewBelowSizeLimit(
       .IsValid();
 }
 
+bool IsCredentialDescriptorListBelowSizeLimit(
+    const HeapVector<Member<PublicKeyCredentialDescriptor>>& list) {
+  return list.size() <= mojom::blink::kPublicKeyCredentialDescriptorListMaxSize;
+}
+
 DOMException* CredentialManagerErrorToDOMException(
     CredentialManagerError reason) {
   switch (reason) {
@@ -984,6 +989,16 @@ ScriptPromise CredentialsContainer::get(
           "RangeError"));
       return promise;
     }
+
+    if (!IsCredentialDescriptorListBelowSizeLimit(
+            options->publicKey()->allowCredentials())) {
+      resolver->Reject(
+          DOMException::Create("The `allowCredentials` attribute exceeds the "
+                               "maximum allowed size (64).",
+                               "RangeError"));
+      return promise;
+    }
+
     if (public_key_options->hasExtensions()) {
       if (public_key_options->extensions()->hasAppid()) {
         const auto& appid = public_key_options->extensions()->appid();
@@ -1259,10 +1274,19 @@ ScriptPromise CredentialsContainer::create(
       return promise;
     }
 
+    if (!IsCredentialDescriptorListBelowSizeLimit(
+            options->publicKey()->excludeCredentials())) {
+      resolver->Reject(
+          DOMException::Create("The `excludeCredentials` attribute exceeds the "
+                              "maximum allowed size (64).",
+                              "RangeError"));
+      return promise;
+    }
+
     for (const auto& credential : options->publicKey()->excludeCredentials()) {
       if (!IsArrayBufferOrViewBelowSizeLimit(credential->id())) {
         resolver->Reject(DOMException::Create(
-            "The `excludedCredentials.id` attribute exceeds the maximum "
+            "The `excludeCredentials.id` attribute exceeds the maximum "
             "allowed size.",
             "RangeError"));
         return promise;
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection_handler.cc b/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection_handler.cc
index 9265e14be8..84a8825ec8 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection_handler.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection_handler.cc
@@ -1629,7 +1629,8 @@ void RTCPeerConnectionHandler::AddICECandidate(
        handler_weak_ptr = weak_factory_.GetWeakPtr(),
        tracker_weak_ptr =
            WrapCrossThreadWeakPersistent(peer_connection_tracker_.Get()),
-       candidate, persistent_request = WrapCrossThreadPersistent(request),
+       persistent_candidate = WrapCrossThreadPersistent(candidate),
+       persistent_request = WrapCrossThreadPersistent(request),
        callback_on_task_runner =
            std::move(callback_on_task_runner)](webrtc::RTCError result) {
         // Grab a snapshot of all the session descriptions. AddIceCandidate may
@@ -1657,7 +1658,7 @@ void RTCPeerConnectionHandler::AddICECandidate(
                 std::move(current_local_description),
                 std::move(pending_remote_description),
                 std::move(current_remote_description),
-                WrapCrossThreadPersistent(candidate), std::move(result),
+                std::move(persistent_candidate), std::move(result),
                 std::move(persistent_request)));
       });
 }
diff --git a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc
index 862a8a747c..bed557e4f4 100644
--- a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc
+++ b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc
@@ -1508,11 +1508,12 @@ void ServiceWorkerGlobalScope::StartFetchEvent(
       params->request->url.ElidedString().Utf8());
 
   // Set up for navigation preload (FetchEvent#preloadResponse) if needed.
-  const bool navigation_preload_sent = !!params->preload_handle;
+  bool navigation_preload_sent = !!params->preload_url_loader_client_receiver;
   if (navigation_preload_sent) {
     To<ServiceWorkerGlobalScopeProxy>(ReportingProxy())
-        .SetupNavigationPreload(event_id, params->request->url,
-                                std::move(params->preload_handle));
+        .SetupNavigationPreload(
+            event_id, params->request->url,
+            std::move(params->preload_url_loader_client_receiver));
   }
 
   ScriptState::Scope scope(ScriptController()->GetScriptState());
diff --git a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.cc b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.cc
index 397d579ed7..bae1f3ac2a 100644
--- a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.cc
+++ b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.cc
@@ -258,14 +258,11 @@ bool ServiceWorkerGlobalScopeProxy::IsServiceWorkerGlobalScopeProxy() const {
 void ServiceWorkerGlobalScopeProxy::SetupNavigationPreload(
     int fetch_event_id,
     const KURL& url,
-    mojom::blink::FetchEventPreloadHandlePtr preload_handle) {
+    mojo::PendingReceiver<network::mojom::blink::URLLoaderClient>
+        preload_url_loader_client_receiver) {
   DCHECK_CALLED_ON_VALID_THREAD(worker_thread_checker_);
-  auto web_preload_handle = std::make_unique<WebFetchEventPreloadHandle>();
-  web_preload_handle->url_loader = std::move(preload_handle->url_loader);
-  web_preload_handle->url_loader_client_receiver =
-      std::move(preload_handle->url_loader_client_receiver);
-  Client().SetupNavigationPreload(fetch_event_id, url,
-                                  std::move(web_preload_handle));
+  Client().SetupNavigationPreload(
+      fetch_event_id, url, std::move(preload_url_loader_client_receiver));
 }
 
 void ServiceWorkerGlobalScopeProxy::RequestTermination(
diff --git a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.h b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.h
index 783dbe1919..d54a2449da 100644
--- a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.h
+++ b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope_proxy.h
@@ -129,7 +129,8 @@ class ServiceWorkerGlobalScopeProxy final : public WebServiceWorkerContextProxy,
   void SetupNavigationPreload(
       int fetch_event_id,
       const KURL& url,
-      mojom::blink::FetchEventPreloadHandlePtr preload_handle);
+      mojo::PendingReceiver<network::mojom::blink::URLLoaderClient>
+          preload_url_loader_client_receiver);
   void RequestTermination(WTF::CrossThreadOnceFunction<void(bool)> callback);
 
   // Detaches this proxy object entirely from the outside world, clearing out
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc b/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc
index cf863b343b..f6a0dc5e5c 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc
@@ -37,6 +37,7 @@
 #include "third_party/blink/renderer/platform/bindings/exception_messages.h"
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
+#include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 #include "third_party/fdlibm/ieee754.h"
 
 #if defined(ARCH_CPU_X86_FAMILY)
@@ -133,7 +134,12 @@ float AudioParamTimeline::ExponentialRampAtTime(double t,
                                                 double time1,
                                                 float value2,
                                                 double time2) {
-  return value1 * fdlibm::pow(value2 / value1, (t - time1) / (time2 - time1));
+  DCHECK(!std::isnan(value1) && std::isfinite(value1));
+  DCHECK(!std::isnan(value2) && std::isfinite(value2));
+
+  return (value1 == 0.0f || std::signbit(value1) != std::signbit(value2))
+      ? value1
+      : value1 * fdlibm::pow(value2 / value1, (t - time1) / (time2 - time1));
 }
 
 // Compute the value of a set target event at time t with the given event
@@ -998,6 +1004,8 @@ float AudioParamTimeline::ValuesForFrameRangeImpl(
     std::tie(value2, time2, next_event_type) =
         HandleCancelValues(event, next_event, value2, time2);
 
+    DCHECK(!std::isnan(value1));
+    DCHECK(!std::isnan(value2));
     DCHECK_GE(time2, time1);
 
     // |fillToEndFrame| is the exclusive upper bound of the last frame to be
@@ -1057,7 +1065,6 @@ float AudioParamTimeline::ValuesForFrameRangeImpl(
           value = event->Value();
           write_index =
               FillWithDefault(values, value, fill_to_frame, write_index);
-
           break;
         }
 
@@ -1400,6 +1407,7 @@ AudioParamTimeline::HandleCancelValues(const ParamEvent* current_event,
               value2 = ExponentialRampAtTime(next_event->Time(), value1, time1,
                                              saved_event->Value(),
                                              saved_event->Time());
+              DCHECK(!std::isnan(value1));
               break;
             case ParamEvent::kSetValueCurve:
             case ParamEvent::kSetValueCurveEnd:
diff --git a/third_party/blink/renderer/modules/webgpu/dawn_callback.h b/third_party/blink/renderer/modules/webgpu/dawn_callback.h
index 812ac5b490..33f4aedcf6 100644
--- a/third_party/blink/renderer/modules/webgpu/dawn_callback.h
+++ b/third_party/blink/renderer/modules/webgpu/dawn_callback.h
@@ -17,8 +17,8 @@ namespace blink {
 // void* and passed to Dawn C callbacks.
 //
 // Example:
-//   DawnCallback<F>* callback =
-//     CreateDawnCallback(WTF::Bind(func, arg1));
+//   DawnOnceCallback<F>* callback =
+//     BindDawnOnceCallback(func, arg1);
 //
 //   // |someDawnFunction| expects callback function with arguments:
 //   //    Args... args, void* userdata.
@@ -26,81 +26,119 @@ namespace blink {
 //   GetProcs().someDawnFunction(
 //     callback->UnboundCallback(), callback->AsUserdata());
 template <typename Callback>
-class DawnCallback;
+class DawnCallbackBase;
+
+template <typename Callback>
+class DawnOnceCallback;
+
+template <typename Callback>
+class DawnRepeatingCallback;
 
 template <template <typename> class BaseCallbackTemplate,
           typename R,
           typename... Args>
-class DawnCallback<BaseCallbackTemplate<R(Args...)>> {
+class DawnCallbackBase<BaseCallbackTemplate<R(Args...)>> {
   using BaseCallback = BaseCallbackTemplate<R(Args...)>;
-  using UnboundCallbackFunction = R (*)(Args..., void*);
 
+  static constexpr bool is_once_callback =
+      std::is_same<BaseCallback, base::OnceCallback<R(Args...)>>::value;
+  static constexpr bool is_repeating_callback =
+      std::is_same<BaseCallback, base::RepeatingCallback<R(Args...)>>::value;
   static_assert(
-      std::is_same<BaseCallback, base::OnceCallback<R(Args...)>>::value ||
-          std::is_same<BaseCallback,
-                       base::RepeatingCallback<R(Args...)>>::value,
+      is_once_callback || is_repeating_callback,
       "Callback must be base::OnceCallback or base::RepeatingCallback");
 
  public:
-  explicit DawnCallback(BaseCallback callback)
+  explicit DawnCallbackBase(BaseCallback callback)
       : callback_(std::move(callback)) {}
 
+  void* AsUserdata() { return static_cast<void*>(this); }
+
+ protected:
+  using UnboundCallbackFunction = R (*)(Args..., void*);
+
+  static DawnCallbackBase* FromUserdata(void* userdata) {
+    return static_cast<DawnCallbackBase*>(userdata);
+  }
+
   R Run(Args... args) && {
+    static_assert(
+        is_once_callback,
+        "Run on a moved receiver must only be called on a once callback.");
     return std::move(callback_).Run(std::forward<Args>(args)...);
   }
 
   R Run(Args... args) const& {
+    static_assert(is_repeating_callback,
+                  "Run on a unmoved receiver must only be called on a "
+                  "repeating callback.");
     return callback_.Run(std::forward<Args>(args)...);
   }
 
-  void Reset() { callback_.Reset(); }
+ private:
+  BaseCallback callback_;
+};
+
+template <typename R, typename... Args>
+class DawnOnceCallback<R(Args...)>
+    : public DawnCallbackBase<base::OnceCallback<R(Args...)>> {
+  using BaseCallback = base::OnceCallback<R(Args...)>;
+
+ public:
+  using DawnCallbackBase<BaseCallback>::DawnCallbackBase;
 
-  static R CallUnboundCallback(Args... args, void* handle) {
+  typename DawnCallbackBase<BaseCallback>::UnboundCallbackFunction
+  UnboundCallback() {
+    return CallUnboundOnceCallback;
+  }
+
+ private:
+  static R CallUnboundOnceCallback(Args... args, void* handle) {
     // After this non-repeating callback is run, it should delete itself.
     auto callback =
-        std::unique_ptr<DawnCallback>(DawnCallback::FromUserdata(handle));
+        std::unique_ptr<DawnOnceCallback>(static_cast<DawnOnceCallback*>(
+            DawnCallbackBase<BaseCallback>::FromUserdata(handle)));
     return std::move(*callback).Run(std::forward<Args>(args)...);
   }
+};
 
-  static R CallUnboundRepeatingCallback(Args... args, void* handle) {
-    return DawnCallback::FromUserdata(handle)->Run(std::forward<Args>(args)...);
-  }
+template <typename R, typename... Args>
+class DawnRepeatingCallback<R(Args...)>
+    : public DawnCallbackBase<base::RepeatingCallback<R(Args...)>> {
+  using BaseCallback = base::RepeatingCallback<R(Args...)>;
 
-  UnboundCallbackFunction UnboundCallback() { return CallUnboundCallback; }
+ public:
+  using DawnCallbackBase<BaseCallback>::DawnCallbackBase;
 
-  UnboundCallbackFunction UnboundRepeatingCallback() {
+  typename DawnCallbackBase<BaseCallback>::UnboundCallbackFunction
+  UnboundCallback() {
     return CallUnboundRepeatingCallback;
   }
 
-  void* AsUserdata() { return static_cast<void*>(this); }
-
-  static DawnCallback* FromUserdata(void* userdata) {
-    return static_cast<DawnCallback*>(userdata);
-  }
-
  private:
-  BaseCallback callback_;
+  static R CallUnboundRepeatingCallback(Args... args, void* handle) {
+    return static_cast<DawnRepeatingCallback*>(
+               DawnCallbackBase<BaseCallback>::FromUserdata(handle))
+        ->Run(std::forward<Args>(args)...);
+  }
 };
 
-template <typename CallbackType>
-DawnCallback<CallbackType>* CreateDawnCallback(CallbackType cb) {
-  return new DawnCallback<CallbackType>(std::move(cb));
-}
-
 template <typename FunctionType, typename... BoundParameters>
-auto BindDawnCallback(FunctionType&& function,
-                      BoundParameters&&... bound_parameters) {
-  return CreateDawnCallback(
-      WTF::Bind(std::forward<FunctionType>(function),
-                std::forward<BoundParameters>(bound_parameters)...));
+auto BindDawnOnceCallback(FunctionType&& function,
+                          BoundParameters&&... bound_parameters) {
+  auto cb = WTF::Bind(std::forward<FunctionType>(function),
+                      std::forward<BoundParameters>(bound_parameters)...);
+  return new DawnOnceCallback<typename decltype(cb)::RunType>(std::move(cb));
 }
 
 template <typename FunctionType, typename... BoundParameters>
-auto BindRepeatingDawnCallback(FunctionType&& function,
+auto BindDawnRepeatingCallback(FunctionType&& function,
                                BoundParameters&&... bound_parameters) {
-  return CreateDawnCallback(
+  auto cb =
       WTF::BindRepeating(std::forward<FunctionType>(function),
-                         std::forward<BoundParameters>(bound_parameters)...));
+                         std::forward<BoundParameters>(bound_parameters)...);
+  return std::make_unique<
+      DawnRepeatingCallback<typename decltype(cb)::RunType>>(std::move(cb));
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc b/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc
index c73982b6e0..f79c81b8ca 100644
--- a/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc
+++ b/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc
@@ -152,8 +152,8 @@ ScriptPromise GPUBuffer::MapAsyncImpl(ScriptState* script_state,
 
   // And send the command, leaving remaining validation to Dawn.
   auto* callback =
-      BindDawnCallback(&GPUBuffer::OnMapAsyncCallback, WrapPersistent(this),
-                       WrapPersistent(resolver));
+      BindDawnOnceCallback(&GPUBuffer::OnMapAsyncCallback, WrapPersistent(this),
+                           WrapPersistent(resolver));
 
   GetProcs().bufferMapAsync(GetHandle(), mode, map_offset, map_size,
                             callback->UnboundCallback(),
diff --git a/third_party/blink/renderer/modules/webgpu/gpu_device.cc b/third_party/blink/renderer/modules/webgpu/gpu_device.cc
index 598f73bf45..c9dbf1567d 100644
--- a/third_party/blink/renderer/modules/webgpu/gpu_device.cc
+++ b/third_party/blink/renderer/modules/webgpu/gpu_device.cc
@@ -69,13 +69,19 @@ GPUDevice::GPUDevice(ExecutionContext* execution_context,
           this,
           GetProcs().deviceGetDefaultQueue(GetHandle()))),
       lost_property_(MakeGarbageCollected<LostProperty>(execution_context)),
-      error_callback_(BindRepeatingDawnCallback(&GPUDevice::OnUncapturedError,
+      error_callback_(BindDawnRepeatingCallback(&GPUDevice::OnUncapturedError,
                                                 WrapWeakPersistent(this))),
-      lost_callback_(BindDawnCallback(&GPUDevice::OnDeviceLostError,
-                                      WrapWeakPersistent(this))) {
+      // Note: This is a *repeating* callback even though we expect it to only
+      // be called once. This is because it may be called *zero* times.
+      // Because it might never be called, the GPUDevice needs to own the
+      // allocation so it can be appropriately freed on destruction. Thus, the
+      // callback should not be a OnceCallback which self-deletes after it is
+      // called.
+      lost_callback_(BindDawnRepeatingCallback(&GPUDevice::OnDeviceLostError,
+                                               WrapWeakPersistent(this))) {
   DCHECK(dawn_device);
   GetProcs().deviceSetUncapturedErrorCallback(
-      GetHandle(), error_callback_->UnboundRepeatingCallback(),
+      GetHandle(), error_callback_->UnboundCallback(),
       error_callback_->AsUserdata());
   GetProcs().deviceSetDeviceLostCallback(GetHandle(),
                                          lost_callback_->UnboundCallback(),
@@ -84,6 +90,13 @@ GPUDevice::GPUDevice(ExecutionContext* execution_context,
   setLabel(descriptor->label());
 }
 
+GPUDevice::~GPUDevice() {
+  // Clear the callbacks since we can't handle callbacks after finalization.
+  // error_callback_, logging_callback_, and lost_callback_ will be deleted.
+  GetProcs().deviceSetUncapturedErrorCallback(GetHandle(), nullptr, nullptr);
+  GetProcs().deviceSetDeviceLostCallback(GetHandle(), nullptr, nullptr);
+}
+
 void GPUDevice::InjectError(WGPUErrorType type, const char* message) {
   GetProcs().deviceInjectError(GetHandle(), type, message);
 }
@@ -133,12 +146,6 @@ void GPUDevice::OnUncapturedError(WGPUErrorType errorType,
 }
 
 void GPUDevice::OnDeviceLostError(const char* message) {
-  // This function is called by a callback created by BindDawnCallback.
-  // Release the unique_ptr holding it since BindDawnCallback is self-deleting.
-  // This is stored as a unique_ptr because the lost callback may never be
-  // called.
-  lost_callback_.release();
-
   AddConsoleWarning(message);
 
   if (lost_property_->GetState() == LostProperty::kPending) {
@@ -311,8 +318,8 @@ ScriptPromise GPUDevice::createComputePipelineAsync(
       AsDawnType(descriptor, &label, &computeStageDescriptor);
 
   auto* callback =
-      BindDawnCallback(&GPUDevice::OnCreateComputePipelineAsyncCallback,
-                       WrapPersistent(this), WrapPersistent(resolver));
+      BindDawnOnceCallback(&GPUDevice::OnCreateComputePipelineAsyncCallback,
+                            WrapPersistent(this), WrapPersistent(resolver));
   GetProcs().deviceCreateComputePipelineAsync(GetHandle(), &dawn_desc,
                                               callback->UnboundCallback(),
                                               callback->AsUserdata());
@@ -366,8 +373,8 @@ ScriptPromise GPUDevice::popErrorScope(ScriptState* script_state) {
   ScriptPromise promise = resolver->Promise();
 
   auto* callback =
-      BindDawnCallback(&GPUDevice::OnPopErrorScopeCallback,
-                       WrapPersistent(this), WrapPersistent(resolver));
+      BindDawnOnceCallback(&GPUDevice::OnPopErrorScopeCallback,
+                           WrapPersistent(this), WrapPersistent(resolver));
 
   if (!GetProcs().devicePopErrorScope(GetHandle(), callback->UnboundCallback(),
                                       callback->AsUserdata())) {
diff --git a/third_party/blink/renderer/modules/webgpu/gpu_device.h b/third_party/blink/renderer/modules/webgpu/gpu_device.h
index 0dd29ab339..2613671b65 100644
--- a/third_party/blink/renderer/modules/webgpu/gpu_device.h
+++ b/third_party/blink/renderer/modules/webgpu/gpu_device.h
@@ -61,6 +61,7 @@ class GPUDevice final : public EventTargetWithInlineData,
                      GPUAdapter* adapter,
                      WGPUDevice dawn_device,
                      const GPUDeviceDescriptor* descriptor);
+  ~GPUDevice() override;
 
   void Trace(Visitor* visitor) const override;
 
@@ -154,15 +155,12 @@ class GPUDevice final : public EventTargetWithInlineData,
   Vector<String> feature_name_list_;
   Member<GPUQueue> queue_;
   Member<LostProperty> lost_property_;
-  std::unique_ptr<
-      DawnCallback<base::RepeatingCallback<void(WGPUErrorType, const char*)>>>
-      error_callback_;
+  std::unique_ptr<DawnRepeatingCallback<void(WGPUErrorType, const char*)>> error_callback_;
   // lost_callback_ is stored as a unique_ptr since it may never be called.
   // We need to be sure to free it on deletion of the device.
   // Inside OnDeviceLostError we'll release the unique_ptr to avoid a double
   // free.
-  std::unique_ptr<DawnCallback<base::OnceCallback<void(const char*)>>>
-      lost_callback_;
+  std::unique_ptr<DawnRepeatingCallback<void(const char*)>> lost_callback_;
 
   static constexpr int kMaxAllowedConsoleWarnings = 500;
   int allowed_console_warnings_remaining_ = kMaxAllowedConsoleWarnings;
diff --git a/third_party/blink/renderer/modules/webgpu/gpu_fence.cc b/third_party/blink/renderer/modules/webgpu/gpu_fence.cc
index c384d4788e..2e1376b35e 100644
--- a/third_party/blink/renderer/modules/webgpu/gpu_fence.cc
+++ b/third_party/blink/renderer/modules/webgpu/gpu_fence.cc
@@ -44,8 +44,8 @@ ScriptPromise GPUFence::onCompletion(ScriptState* script_state,
   ScriptPromise promise = resolver->Promise();
 
   auto* callback =
-      BindDawnCallback(&GPUFence::OnCompletionCallback, WrapPersistent(this),
-                       WrapPersistent(resolver));
+      BindDawnOnceCallback(&GPUFence::OnCompletionCallback, WrapPersistent(this),
+                            WrapPersistent(resolver));
 
   GetProcs().fenceOnCompletion(GetHandle(), value, callback->UnboundCallback(),
                                callback->AsUserdata());
diff --git a/third_party/blink/renderer/modules/webgpu/gpu_queue.cc b/third_party/blink/renderer/modules/webgpu/gpu_queue.cc
index 5aa7ea019d..80235a96da 100644
--- a/third_party/blink/renderer/modules/webgpu/gpu_queue.cc
+++ b/third_party/blink/renderer/modules/webgpu/gpu_queue.cc
@@ -207,8 +207,8 @@ ScriptPromise GPUQueue::onSubmittedWorkDone(ScriptState* script_state) {
   ScriptPromise promise = resolver->Promise();
 
   auto* callback =
-      BindDawnCallback(&GPUQueue::OnWorkDoneCallback, WrapPersistent(this),
-                       WrapPersistent(resolver));
+      BindDawnOnceCallback(&GPUQueue::OnWorkDoneCallback, WrapPersistent(this),
+                           WrapPersistent(resolver));
 
   GetProcs().queueOnSubmittedWorkDone(
       GetHandle(), 0u, callback->UnboundCallback(), callback->AsUserdata());
diff --git a/third_party/blink/renderer/platform/audio/hrtf_database_loader.cc b/third_party/blink/renderer/platform/audio/hrtf_database_loader.cc
index 034ded03d1..01cb98a111 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_database_loader.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_database_loader.cc
@@ -86,6 +86,8 @@ void HRTFDatabaseLoader::LoadTask() {
 void HRTFDatabaseLoader::LoadAsynchronously() {
   DCHECK(IsMainThread());
 
+  MutexLocker locker(lock_);
+
   // m_hrtfDatabase and m_thread should both be unset because this should be a
   // new HRTFDatabaseLoader object that was just created by
   // createAndLoadAsynchronouslyIfNecessary and because we haven't started
@@ -122,6 +124,10 @@ void HRTFDatabaseLoader::CleanupTask(base::WaitableEvent* sync) {
 }
 
 void HRTFDatabaseLoader::WaitForLoaderThreadCompletion() {
+  // We can lock this because this is called from either the main thread or
+  // the offline audio rendering thread.
+  MutexLocker locker(lock_);
+
   if (!thread_)
     return;
 
diff --git a/third_party/blink/renderer/platform/audio/hrtf_database_loader.h b/third_party/blink/renderer/platform/audio/hrtf_database_loader.h
index 3ce476fa68..a94997b4f7 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_database_loader.h
+++ b/third_party/blink/renderer/platform/audio/hrtf_database_loader.h
@@ -64,8 +64,8 @@ class PLATFORM_EXPORT HRTFDatabaseLoader final
   // must be called from the audio thread.
   bool IsLoaded() { return Database(); }
 
-  // waitForLoaderThreadCompletion() may be called more than once and is
-  // thread-safe.
+  // May be called from both main and audio thread, and also can be called more
+  // than once.
   void WaitForLoaderThreadCompletion();
 
   // Returns the database or nullptr if the database doesn't yet exist.  Must
@@ -87,11 +87,10 @@ class PLATFORM_EXPORT HRTFDatabaseLoader final
   void LoadTask();
   void CleanupTask(base::WaitableEvent*);
 
-  // Holding a m_lock is required when accessing m_hrtfDatabase since we access
-  // it from multiple threads.
+  // |lock_| MUST be held when accessing |hrtf_database_| or |thread_| because
+  // it can be accessed by multiple threads (e.g multiple AudioContexts).
   Mutex lock_;
   std::unique_ptr<HRTFDatabase> hrtf_database_;
-
   std::unique_ptr<Thread> thread_;
 
   float database_sample_rate_;
diff --git a/third_party/blink/renderer/platform/graphics/skia/skia_utils.h b/third_party/blink/renderer/platform/graphics/skia/skia_utils.h
index 997893fef2..a946c28cac 100644
--- a/third_party/blink/renderer/platform/graphics/skia/skia_utils.h
+++ b/third_party/blink/renderer/platform/graphics/skia/skia_utils.h
@@ -39,7 +39,9 @@
 #include "third_party/blink/renderer/platform/graphics/image.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/transforms/affine_transform.h"
+#include "third_party/blink/renderer/platform/wtf/cross_thread_copier.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkData.h"
@@ -197,4 +199,25 @@ PLATFORM_EXPORT sk_sp<SkData> TryAllocateSkData(size_t size);
 
 }  // namespace blink
 
+namespace WTF {
+
+// We define CrossThreadCopier<SKBitMap> here because we cannot include skia
+// headers in platform/wtf.
+template <>
+struct CrossThreadCopier<SkBitmap> {
+  STATIC_ONLY(CrossThreadCopier);
+
+  using Type = SkBitmap;
+  static SkBitmap Copy(const SkBitmap& bitmap) {
+    CHECK(bitmap.isImmutable() || bitmap.isNull()) << "Only immutable bitmaps can be transferred.";
+    return bitmap;
+  }
+  static SkBitmap Copy(SkBitmap&& bitmap) {
+    CHECK(bitmap.isImmutable() || bitmap.isNull()) << "Only immutable bitmaps can be transferred.";
+    return std::move(bitmap);
+  }
+};
+
+}  // namespace WTF
+
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_SKIA_SKIA_UTILS_H_
diff --git a/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc b/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
index 3c445ddaa2..e367e9b803 100644
--- a/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
+++ b/third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc
@@ -1877,6 +1877,19 @@ void ResourceFetcher::HandleLoaderFinish(Resource* resource,
   }
 
   resource->VirtualTimePauser().UnpauseVirtualTime();
+
+  // A response should not serve partial content if it was not requested via a
+  // Range header: https://fetch.spec.whatwg.org/#main-fetch so keep it out
+  // of the preload cache in case of a non-206 response (which generates an
+  // error).
+  if (resource->GetResponse().GetType() ==
+          network::mojom::FetchResponseType::kOpaque &&
+      resource->GetResponse().HasRangeRequested() &&
+      !resource->GetResourceRequest().HttpHeaderFields().Contains(
+          net::HttpRequestHeaders::kRange)) {
+    RemovePreload(resource);
+  }
+
   if (type == kDidFinishLoading) {
     resource->Finish(response_end, freezable_task_runner_.get());
 
diff --git a/third_party/blink/renderer/platform/mediastream/media_stream_source.cc b/third_party/blink/renderer/platform/mediastream/media_stream_source.cc
index a8dab81cc2..0f86e118f6 100644
--- a/third_party/blink/renderer/platform/mediastream/media_stream_source.cc
+++ b/third_party/blink/renderer/platform/mediastream/media_stream_source.cc
@@ -32,6 +32,7 @@
 
 #include "third_party/blink/public/platform/modules/webrtc/webrtc_logging.h"
 #include "third_party/blink/renderer/platform/audio/audio_bus.h"
+#include "third_party/blink/renderer/platform/heap/persistent.h"
 #include "third_party/blink/renderer/platform/mediastream/media_stream_audio_source.h"
 #include "third_party/blink/renderer/platform/mediastream/webaudio_destination_consumer.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
@@ -176,28 +177,17 @@ void MediaStreamSource::SetReadyState(ReadyState ready_state) {
     ready_state_ = ready_state;
 
     // Observers may dispatch events which create and add new Observers;
-    // take a snapshot so as to safely iterate.
-    HeapVector<Member<Observer>> observers;
-    CopyToVector(observers_, observers);
-    for (auto observer : observers)
-      observer->SourceChangedState();
-
-    // setReadyState() will be invoked via the MediaStreamComponent::dispose()
-    // prefinalizer, allocating |observers|. Which means that |observers| will
-    // live until the next GC (but be unreferenced by other heap objects),
-    // _but_ it will potentially contain references to Observers that were
-    // GCed after the MediaStreamComponent prefinalizer had completed.
-    //
-    // So, if the next GC is a conservative one _and_ it happens to find
-    // a reference to |observers| when scanning the stack, we're in trouble
-    // as it contains references to now-dead objects.
-    //
-    // Work around this by explicitly clearing the vector backing store.
-    //
-    // TODO(sof): consider adding run-time checks that disallows this kind
-    // of dead object revivification by default.
-    for (wtf_size_t i = 0; i < observers.size(); ++i)
-      observers[i] = nullptr;
+    // take a snapshot so as to safely iterate. Wrap the observers in
+    // weak persistents to allow cancelling callbacks in case they are reclaimed
+    // until the callback is executed.
+    Vector<base::OnceClosure> observer_callbacks;
+    for (const auto& it : observers_) {
+      observer_callbacks.push_back(WTF::Bind(&Observer::SourceChangedState,
+                                             WrapWeakPersistent(it.Get())));
+    }
+    for (auto& observer_callback : observer_callbacks) {
+      std::move(observer_callback).Run();
+    }
   }
 }
 
diff --git a/third_party/blink/web_tests/external/wpt/common/security-features/subresource/stylesheet.py b/third_party/blink/web_tests/external/wpt/common/security-features/subresource/stylesheet.py
index 29079af922..05db249250 100644
--- a/third_party/blink/web_tests/external/wpt/common/security-features/subresource/stylesheet.py
+++ b/third_party/blink/web_tests/external/wpt/common/security-features/subresource/stylesheet.py
@@ -23,6 +23,12 @@ def generate_payload(request, server_data):
             u"id": isomorphic_decode(request.GET[b"id"]),
             u"property": isomorphic_decode(request.GET[b"property"])}
 
+    # A `'stylesheet-only'`-type stylesheet has no nested resources; this is
+    # useful in tests that cover referrers for stylesheet fetches (e.g. fetches
+    # triggered by `@import` statements).
+    elif type == b'stylesheet-only':
+        return u''
+
 def generate_import_rule(request, server_data):
     return u"@import url('%(url)s');" % {
         u"url": subresource.create_url(request, swap_origin=True,
diff --git a/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html b/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
index a9ad787408..e0a31db8e2 100644
--- a/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
+++ b/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
@@ -59,6 +59,9 @@
       { "name": "Wrong and dangerous value of `csp` should not trigger sending Sec-Required-CSP Header - report-to present",
         "csp": "script-src 'unsafe-inline'; report-to resources/dummy-report.php",
         "expected": null },
+      { "name": "Sec-Required-CSP is not sent if `csp` attribute is longer than 4096 bytes",
+        "csp": "style-src " + Array.from(Array(2044).keys()).map(i => 'a').join(' '),
+        "expected":  null },
     ];
 
     tests.forEach(test => {
diff --git a/third_party/blink/web_tests/external/wpt/css/css-contain/content-visibility/meter-selection-crash.html b/third_party/blink/web_tests/external/wpt/css/css-contain/content-visibility/meter-selection-crash.html
new file mode 100644
index 0000000000..9edca97568
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/css/css-contain/content-visibility/meter-selection-crash.html
@@ -0,0 +1,21 @@
+<!doctype HTML>
+<link rel=author href="mailto:vmpstr@chromium.org">
+<link rel="help" href="https://drafts.csswg.org/css-contain/#content-visibility">
+<meta name="assert" content="meter, iframe, and selection API should not crash">
+
+<style>
+* {
+  all: initial;
+  content-visibility: hidden;
+}
+</style>
+
+<meter></meter><iframe id="frame"></iframe>
+<script>
+function runTest() {
+  var range_beadc = window.getSelection();
+  var elem1 = document.getElementById("frame");
+  range_beadc.setBaseAndExtent(elem1, 0, document.getElementById("none"), 0);
+}
+onload = runTest;
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/css/css-inline/inline-crash.html b/third_party/blink/web_tests/external/wpt/css/css-inline/inline-crash.html
new file mode 100644
index 0000000000..65008f74ce
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/css/css-inline/inline-crash.html
@@ -0,0 +1,210 @@
+<!DOCTYPE html>
+<link rel="help" href="https://bugs.chromium.org/p/chromium/issues/detail?id=1245786">
+<style>
+  nav{ position: absolute; }
+  body > * { position: relative; }
+</style>
+<body>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<span>
+<div>
+<nav>
diff --git a/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js b/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js
index eed44e0414..9f1ff98c65 100644
--- a/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js
+++ b/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js
@@ -1,6 +1,7 @@
 // META: script=/common/get-host-info.sub.js
 
 var redirectLocation = "cors-top.txt";
+const { ORIGIN, REMOTE_ORIGIN } = get_host_info();
 
 function testRedirect(origin, redirectStatus, redirectMode, corsMode) {
   var url = new URL("../resources/redirect.py", self.location);
@@ -47,4 +48,12 @@ for (var origin of ["same-origin", "cross-origin"]) {
   }
 }
 
+promise_test(async (t) => {
+  const destination = `${ORIGIN}/common/blank.html`;
+  // We use /common/redirect.py intentionally, as we want a CORS error.
+  const url =
+    `${REMOTE_ORIGIN}/common/redirect.py?location=${destination}`;
+  await promise_rejects_js(t, TypeError,  fetch(url, { redirect: "manual" }));
+}, "manual redirect with a CORS error should be rejected");
+
 done();
diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/resources/partial-text.py b/third_party/blink/web_tests/external/wpt/fetch/range/resources/partial-text.py
new file mode 100644
index 0000000000..a0058551d5
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/fetch/range/resources/partial-text.py
@@ -0,0 +1,47 @@
+"""
+This generates a partial response for a 100-byte text file.
+"""
+import re
+
+from wptserve.utils import isomorphic_decode
+
+def main(request, response):
+    total_length = int(request.GET.first(b'length', b'100'))
+    partial_code = int(request.GET.first(b'partial', b'206'))
+    range_header = request.headers.get(b'Range', b'')
+
+    # Send a 200 if there is no range request
+    if not range_header:
+        to_send = ''.zfill(total_length)
+        response.headers.set(b"Content-Type", b"text/plain")
+        response.headers.set(b"Cache-Control", b"no-cache")
+        response.headers.set(b"Content-Length", total_length)
+        response.content = to_send
+        return
+
+    # Simple range parsing, requires specifically "bytes=xxx-xxxx"
+    range_header_match = re.search(r'^bytes=(\d*)-(\d*)$', isomorphic_decode(range_header))
+    start, end = range_header_match.groups()
+    start = int(start)
+    end = int(end) if end else total_length
+    length = end - start
+
+    # Error the request if the range goes beyond the length
+    if length <= 0 or end > total_length:
+        response.set_error(416, u"Range Not Satisfiable")
+        response.write()
+        return
+
+    # Generate a partial response of the requested length
+    to_send = ''.zfill(length)
+    response.headers.set(b"Content-Type", b"text/plain")
+    response.headers.set(b"Accept-Ranges", b"bytes")
+    response.headers.set(b"Cache-Control", b"no-cache")
+    response.status = partial_code
+
+    content_range = b"bytes %d-%d/%d" % (start, end, total_length)
+
+    response.headers.set(b"Content-Range", content_range)
+    response.headers.set(b"Content-Length", length)
+
+    response.content = to_send
diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js b/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js
index 3680c0c471..b47823f03b 100644
--- a/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js
+++ b/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js
@@ -12,7 +12,7 @@ async function broadcast(msg) {
   }
 }
 
-addEventListener('fetch', event => {
+addEventListener('fetch', async event => {
   /** @type Request */
   const request = event.request;
   const url = new URL(request.url);
@@ -34,6 +34,11 @@ addEventListener('fetch', event => {
     case 'broadcast-accept-encoding':
       broadcastAcceptEncoding(event);
       return;
+    case 'record-media-range-request':
+      return recordMediaRangeRequest(event);
+    case 'use-media-range-request':
+      useMediaRangeRequest(event);
+      return;
   }
 });
 
@@ -157,3 +162,57 @@ function broadcastAcceptEncoding(event) {
   // Just send back any response, it isn't important for the test.
   event.respondWith(new Response(''));
 }
+
+let rangeResponse = {};
+
+async function recordMediaRangeRequest(event) {
+  /** @type Request */
+  const request = event.request;
+  const url = new URL(request.url);
+  const urlParams = new URLSearchParams(url.search);
+  const size = urlParams.get("size");
+  const id = urlParams.get('id');
+  const key = 'size' + size;
+
+  if (key in rangeResponse) {
+    // Don't re-fetch ranges we already have.
+    const clonedResponse = rangeResponse[key].clone();
+    event.respondWith(clonedResponse);
+  } else if (event.request.headers.get("range") === "bytes=0-") {
+    // Generate a bogus 206 response to trigger subsequent range requests
+    // of the desired size.
+    const length = urlParams.get("length") + 100;
+    const body = "A".repeat(Number(size));
+    event.respondWith(new Response(body, {status: 206, headers: {
+      "Content-Type": "audio/mp4",
+      "Content-Range": `bytes 0-1/${length}`
+    }}));
+  } else if (event.request.headers.get("range") === `bytes=${Number(size)}-`) {
+    // Pass through actual range requests which will attempt to fetch up to the
+    // length in the original response which is bigger than the actual resource
+    // to make sure 206 and 416 responses are treated the same.
+    rangeResponse[key] = await fetch(event.request);
+
+    // Let the client know we have the range response for the given ID
+    broadcast({id});
+  } else {
+    event.respondWith(Promise.reject(Error("Invalid Request")));
+  }
+}
+
+function useMediaRangeRequest(event) {
+  /** @type Request */
+  const request = event.request;
+  const url = new URL(request.url);
+  const urlParams = new URLSearchParams(url.search);
+  const size = urlParams.get("size");
+  const key = 'size' + size;
+
+  // Send a clone of the range response to preload.
+  if (key in rangeResponse) {
+    const clonedResponse = rangeResponse[key].clone();
+    event.respondWith(clonedResponse);
+  } else {
+    event.respondWith(Promise.reject(Error("Invalid Request")));
+  }
+}
diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js b/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js
index 16ed737f63..ad2853b33d 100644
--- a/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js
+++ b/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js
@@ -8,6 +8,18 @@ function loadScript(url, { doc = document }={}) {
   })
 }
 
+function preloadImage(url, { doc = document }={}) {
+  return new Promise((resolve, reject) => {
+    const preload = doc.createElement('link');
+    preload.rel = 'preload';
+    preload.as = 'image';
+    preload.onload = () => resolve();
+    preload.onerror = () => resolve();
+    preload.href = url;
+    doc.body.appendChild(preload);
+  })
+}
+
 /**
  *
  * @param {Document} document
diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt
index 134b0a7abd..a9577f0172 100644
--- a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt
+++ b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt
@@ -4,6 +4,7 @@ PASS Defer range header passthrough tests to service worker
 PASS Ranged response not allowed following no-cors ranged request
 PASS Non-opaque ranged response executed
 FAIL Accept-Encoding should not appear in a service worker assert_equals: Accept-Encoding should not be set for media expected (object) null but got (string) "identity;q=1, *;q=0"
+PASS Opaque range preload successes and failures should be indistinguishable
 PASS Range headers correctly preserved
 PASS Range headers correctly removed
 PASS Headers correctly filtered
diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js
index 76f80e9416..42e4ac6d75 100644
--- a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js
+++ b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js
@@ -149,3 +149,78 @@ promise_test(async t => {
 
   assert_equals((await audioBroadcast).acceptEncoding, null, "Accept-Encoding should not be set for media");
 }, `Accept-Encoding should not appear in a service worker`);
+
+promise_test(async t => {
+  const scope = BASE_SCOPE + Math.random();
+  await setupRegistration(t, scope);
+  const iframe = await with_iframe(scope);
+  const w = iframe.contentWindow;
+  const length = 100;
+  const count = 3;
+  const counts = {};
+
+  // test a single range request size
+  async function testSizedRange(size, partialResponseCode) {
+    const rangeId = Math.random() + '';
+    const rangeBroadcast = awaitMessage(w.navigator.serviceWorker, rangeId);
+
+    // Create a bogus audo element to trick the browser into sending
+    // cross-origin range requests that can be manipulated by the service worker.
+    const sound_url = new URL('partial-text.py', w.location);
+    sound_url.hostname = REMOTE_HOST;
+    sound_url.searchParams.set('action', 'record-media-range-request');
+    sound_url.searchParams.set('length', length);
+    sound_url.searchParams.set('size', size);
+    sound_url.searchParams.set('partial', partialResponseCode);
+    sound_url.searchParams.set('id', rangeId);
+    appendAudio(w.document, sound_url);
+
+    // wait for the range requests to happen
+    await rangeBroadcast;
+
+    // Create multiple preload requests and count the number of resource timing
+    // entries that get created to make sure 206 and 416 range responses are treated
+    // the same.
+    const url = new URL('partial-text.py', w.location);
+    url.searchParams.set('action', 'use-media-range-request');
+    url.searchParams.set('size', size);
+    counts['size' + size] = 0;
+    for (let i = 0; i < count; i++) {
+      await preloadImage(url, { doc: w.document });
+    }
+  }
+
+  // Test range requests from 1 smaller than the correct size to 1 larger than
+  // the correct size to exercise the various permutations using the default 206
+  // response code for successful range requests.
+  for (let size = length - 1; size <= length + 1; size++) {
+    await testSizedRange(size, '206');
+  }
+
+  // Test a successful range request using a 200 response.
+  await testSizedRange(length - 2, '200');
+
+  // Check the resource timing entries and count the reported number of fetches of each type
+  const resources = w.performance.getEntriesByType("resource");
+  for (const entry of resources) {
+    const url = new URL(entry.name);
+    if (url.searchParams.has('action') &&
+        url.searchParams.get('action') == 'use-media-range-request' &&
+        url.searchParams.has('size')) {
+      counts['size' + url.searchParams.get('size')]++;
+    }
+  }
+
+  // Make sure there are a non-zero number of preload requests and they are all the same
+  let counts_valid = true;
+  const first = 'size' + (length - 2);
+  for (let size = length - 2; size <= length + 1; size++) {
+    let key = 'size' + size;
+    if (!(key in counts) || counts[key] <= 0 || counts[key] != counts[first]) {
+      counts_valid = false;
+      break;
+    }
+  }
+
+  assert_true(counts_valid, `Opaque range request preloads were different for error and success`);
+}, `Opaque range preload successes and failures should be indistinguishable`);
diff --git a/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/popup-from-initial-empty-sandboxed-document.window.js b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/popup-from-initial-empty-sandboxed-document.window.js
new file mode 100644
index 0000000000..e70a52ae8a
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/popup-from-initial-empty-sandboxed-document.window.js
@@ -0,0 +1,49 @@
+// META: timeout=long
+// META: script=/common/utils.js
+// META: script=/common/dispatcher/dispatcher.js
+
+// Regression test for: https://crbug.com/1256822.
+//
+// From a sandboxed iframe allowing popups, scripts, and same-origin. Open a
+// popup using the WindowProxy of a new iframe that is still on the initial
+// empty document. Check that the sandbox flags are properly inherited.
+
+const executorUrl = uuid =>
+  (new URL(`./resources/executor.html?uuid=${uuid}`, window.location)).href;
+
+// Return true if the execution context is sandboxed.
+const isSandboxed = () => {
+  try {
+    // Setting document.domain in sandboxed document throw errors.
+    document.domain = document.domain;
+    return false;
+  } catch (error) {
+    return true;
+  }
+}
+
+promise_test(async test => {
+  // 1. Create a sandboxed iframe, allowing popups, same-origin and scripts.
+  const iframe_token = token();
+  const iframe_document = new RemoteContext(iframe_token);
+  const iframe_url = executorUrl(iframe_token);
+  const iframe = document.createElement("iframe");
+  iframe.sandbox = "allow-same-origin allow-scripts allow-popups";
+  iframe.src = iframe_url;
+  document.body.appendChild(iframe);
+  assert_true(await iframe_document.execute_script(isSandboxed),
+    "iframe is sandboxed");
+
+  // 2. From the sandboxed iframe, create an empty iframe, and open a popup
+  //    using it's WindowProxy. The popup must inherit sandbox flags.
+  const popup_token = token();
+  const popup_document = new RemoteContext(popup_token);
+  const popup_url = executorUrl(popup_token);
+  iframe_document.execute_script((popup_url) => {
+    let iframe = document.createElement("iframe");
+    iframe.name = "iframe_name";
+    document.body.appendChild(iframe);
+    iframe_name.open(popup_url);
+  }, [popup_url]);
+  assert_true(await popup_document.execute_script(isSandboxed), "popup is sandboxed");
+});
diff --git a/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/execute-postmessage.html b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/execute-postmessage.html
new file mode 100644
index 0000000000..89bd268f9c
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/execute-postmessage.html
@@ -0,0 +1,5 @@
+<script>
+  // Execute arbitrary code from somewhere else, via postMessage.
+  window.addEventListener("message", event => eval(event.data));
+  window.opener.postMessage("ready", "*");
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/executor.html b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/executor.html
index 89bd268f9c..67b9783fec 100644
--- a/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/executor.html
+++ b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/resources/executor.html
@@ -1,5 +1,7 @@
+<script src="/common/dispatcher/dispatcher.js"></script>
 <script>
-  // Execute arbitrary code from somewhere else, via postMessage.
-  window.addEventListener("message", event => eval(event.data));
-  window.opener.postMessage("ready", "*");
+  const params = new URLSearchParams(window.location.search);
+  const uuid = params.get("uuid");
+  const executor = new Executor(uuid);
+  executor.execute();
 </script>
diff --git a/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/window-open-blank-from-different-initiator.html b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/window-open-blank-from-different-initiator.html
index 28345d2a8e..91817c3db4 100644
--- a/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/window-open-blank-from-different-initiator.html
+++ b/third_party/blink/web_tests/external/wpt/html/browsers/sandboxing/window-open-blank-from-different-initiator.html
@@ -30,7 +30,7 @@ const runTest = (description, createNewPopup) => {
   promise_test(async test => {
     // Open a same-origin window with a different CSP.
     const executor_path =
-      "/html/browsers/sandboxing/resources/executor.html?pipe=";
+      "/html/browsers/sandboxing/resources/execute-postmessage.html?pipe=";
     const csp = "|header(Content-Security-Policy, " +
                 "sandbox" +
                 " allow-scripts" +
diff --git a/third_party/blink/web_tests/external/wpt/referrer-policy/css-integration/child-css/internal-import-stylesheet-with-differentorigin-base-url-from-preload.tentative.html b/third_party/blink/web_tests/external/wpt/referrer-policy/css-integration/child-css/internal-import-stylesheet-with-differentorigin-base-url-from-preload.tentative.html
new file mode 100644
index 0000000000..4d2228c9a3
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/referrer-policy/css-integration/child-css/internal-import-stylesheet-with-differentorigin-base-url-from-preload.tentative.html
@@ -0,0 +1,47 @@
+<!DOCTYPE html>
+<title>CSS integration - child CSS fetch from inline stylesheet</title>
+<link rel="help" href="https://crbug.com/1158645" />
+
+<head>
+  <meta name="referrer" content="origin">
+</head>
+
+<body>
+
+  <script src="/resources/testharness.js"></script>
+  <script src="/resources/testharnessreport.js"></script>
+  <script src="/common/utils.js"></script>
+  <!-- Common global functions for referrer-policy tests. -->
+  <script src="/common/security-features/resources/common.sub.js"></script>
+
+  <script>
+    promise_test(function (css_test) {
+        let id = token();
+        let url_prefix = location.protocol + "//www." + location.hostname +
+          ":" + location.port;
+        let css_url = url_prefix +
+          "/common/security-features/subresource/stylesheet.py?id=" + id +
+          "&type=stylesheet-only";
+        let check_url = url_prefix +
+          "/common/security-features/subresource/stylesheet.py" +
+          "?id=" + id + "&report-headers";
+
+        const frame = document.createElement('iframe');
+        const contents = `
+              <base href="http://other-site.example" />
+              <style type=text/css>
+                @import url('${css_url}');
+              </style>`;
+        frame.srcdoc = contents;
+        document.body.appendChild(frame);
+        return timeoutPromise(css_test, 1000)
+          .then(() => requestViaXhr(check_url))
+          .then(function (message) {
+            assert_own_property(message, "headers");
+            assert_own_property(message, "referrer");
+            assert_equals(message.referrer, location.origin + "/");
+          });
+      }, "A child stylesheet from inline style should use the document's" +
+      " URL, not the document's base URL, as its referrer, even when the " +
+      "HTML parser preloads the stylesheet.");
+  </script>
diff --git a/third_party/blink/web_tests/external/wpt/referrer-policy/css-integration/child-css/internal-import-stylesheet-with-differentorigin-base-url.tentative.html b/third_party/blink/web_tests/external/wpt/referrer-policy/css-integration/child-css/internal-import-stylesheet-with-differentorigin-base-url.tentative.html
new file mode 100644
index 0000000000..7130e2a14a
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/referrer-policy/css-integration/child-css/internal-import-stylesheet-with-differentorigin-base-url.tentative.html
@@ -0,0 +1,47 @@
+<!DOCTYPE html>
+<title>CSS integration - Child css from internal stylesheet</title>
+<link rel="help" href="https://crbug.com/1158645" />
+
+<head>
+  <meta name="referrer" content="origin">
+</head>
+
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="/common/utils.js"></script>
+<!-- Common global functions for referrer-policy tests. -->
+<script src="/common/security-features/resources/common.sub.js"></script>
+
+<!-- This has to follow the <script> tags, or it will make the .js files
+fail to load. -->
+<base href="http://other-site.example" />
+
+<script>
+  promise_test(function (css_test) {
+      let id = token();
+      let url_prefix = location.protocol + "//www1." + location.hostname +
+        ":" + location.port;
+      let css_url = url_prefix +
+        "/common/security-features/subresource/stylesheet.py?id=" + id +
+        "&stylesheet-only";
+      let check_url = url_prefix +
+        "/common/security-features/subresource/stylesheet.py" +
+        "?id=" + id + "&report-headers";
+
+      let style = document.createElement("style");
+      style.type = 'text/css';
+      style.appendChild(document.createTextNode("@import url('" + css_url +
+        "');"));
+      document.head.appendChild(style);
+      return timeoutPromise(css_test, 1000)
+        .then(() => requestViaXhr(check_url))
+        .then(function (message) {
+          assert_own_property(message, "headers");
+          assert_own_property(message, "referrer");
+          assert_equals(message.referrer, location.origin + "/");
+        });
+    },
+    "A child stylesheet from inline style should use the document's URL, not " +
+    "the document's base URL, as its referrer."
+  );
+</script>
diff --git a/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js b/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js
index b45910a3b8..f60c4b905e 100644
--- a/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js
+++ b/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js
@@ -144,7 +144,14 @@ cache_test(function(cache, test) {
               'Test framework error: The status code should be 0 for an ' +
               ' opaque-filtered response. This is actually HTTP 206.');
           response = fetch_result.clone();
-          return promise_rejects_js(test, TypeError, cache.put(request, fetch_result));
+          return cache.put(request, fetch_result);
+        })
+      .then(function() {
+          return cache.match(test_url);
+        })
+      .then(function(result) {
+          assert_not_equals(result, undefined,
+              'Cache.put should store an entry for the opaque response');
         });
   }, 'Cache.put with opaque-filtered HTTP 206 response');
 
diff --git a/third_party/blink/web_tests/fast/peerconnection/poc-123067.html b/third_party/blink/web_tests/fast/peerconnection/poc-123067.html
new file mode 100644
index 0000000000..ff169f1d1e
--- /dev/null
+++ b/third_party/blink/web_tests/fast/peerconnection/poc-123067.html
@@ -0,0 +1,71 @@
+<!DOCTYPE html>
+<html>
+
+  <head>
+    <script src="../../resources/testharness.js"></script>
+    <script src="../../resources/testharnessreport.js"></script>
+    <script src="../../resources/gc.js"></script>
+  </head>
+  <body>
+  <script>
+    'use strict';
+  promise_test(async t => {
+    const var_caller_1 = new RTCPeerConnection();
+    const var_callee_1 = new RTCPeerConnection();
+    var_caller_1.addTransceiver('audio');
+    const var_prom_1 = new Promise(resolve => {
+      var_caller_1.onicecandidate = e => resolve(e.candidate);
+    });
+    await var_caller_1.setLocalDescription(await var_caller_1.createOffer());
+    await var_callee_1.setRemoteDescription(var_caller_1.localDescription);
+    const candidate = await var_prom_1;
+    var arrProm = [];
+    gc();
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.setLocalDescription().then(() => {
+    })
+    var_callee_1.addIceCandidate(candidate).then(() => {
+    })
+    await Promise.all(arrProm);
+  }, 'Running this script does not cause an UAF');
+  </script>
+</head>
+
+<body></body>
+
+</html>
diff --git a/third_party/blink/web_tests/http/tests/streams/chromium/underlying-sink-base-type-getter.html b/third_party/blink/web_tests/http/tests/streams/chromium/underlying-sink-base-type-getter.html
new file mode 100644
index 0000000000..fbbc26b08e
--- /dev/null
+++ b/third_party/blink/web_tests/http/tests/streams/chromium/underlying-sink-base-type-getter.html
@@ -0,0 +1,57 @@
+<!DOCTYPE html>
+<meta charset="utf-8">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script>
+'use strict';
+
+test(t => {
+  Object.defineProperty(Object.prototype, 'type',
+                        {
+                          configurable: true,
+                          get() {
+                            throw Error();
+                          }
+                        });
+  t.add_cleanup(() => {
+    delete Object.prototype.type;
+  });
+  const generator = new MediaStreamTrackGenerator('video');
+  // The WritableStream is created lazily, so access it to trigger creation.
+  generator.writable.getWriter();
+}, 'a throwing getter on Object.prototype.type should not interfere with ' +
+     'native writable stream creation');
+
+test(t => {
+  Object.defineProperty(Object.prototype, 'type',
+                        {
+                          configurable: true,
+                          get() {
+                            this.start(0x414141);
+                          }
+                        });
+  t.add_cleanup(() => {
+    delete Object.prototype.type;
+  });
+  const generator = new MediaStreamTrackGenerator('video');
+  generator.writable.getWriter();
+}, 'a getter that calls start() with a number on Object.prototype.type ' +
+     'should not interfere with native writable stream creation');
+
+test(t => {
+  Object.defineProperty(Object.prototype, 'type',
+                        {
+                          configurable: true,
+                          get() {
+                            this.start({});
+                          }
+                        });
+  t.add_cleanup(() => {
+    delete Object.prototype.type;
+  });
+  const generator = new MediaStreamTrackGenerator('video');
+  generator.writable.getWriter();
+}, 'a getter that calls start() with an object on Object.prototype.type ' +
+     'should not interfere with native writable stream creation');
+
+</script>
diff --git a/third_party/blink/web_tests/webaudio/AudioParam/exponential-ramp-crash-1253746.html b/third_party/blink/web_tests/webaudio/AudioParam/exponential-ramp-crash-1253746.html
new file mode 100644
index 0000000000..85397c5cc6
--- /dev/null
+++ b/third_party/blink/web_tests/webaudio/AudioParam/exponential-ramp-crash-1253746.html
@@ -0,0 +1,39 @@
+<!DOCTYPE html>
+<html>
+<head>
+  <title>
+    Test if a corner case crashes the exponential ramp.
+  </title>
+  <script src="../../resources/testharness.js"></script>
+  <script src="../../resources/testharnessreport.js"></script>
+</head>
+<body>
+  <script>
+    const t = async_test('exponential-ramp-crash');
+
+    const onload = () => {
+      const context = new OfflineAudioContext(2, 441000, 44100);
+      const source = new ConstantSourceNode(context);
+      const delay_node = context.createDelay(30);
+      delay_node.connect(context.destination);
+      // The time overlap between 4.1s and 4s caused a crash in M95:
+      // https://crbug.com/1253746
+      delay_node.delayTime.exponentialRampToValueAtTime(2, 4.1);
+      delay_node.delayTime.cancelAndHoldAtTime(4);
+      context.oncomplete = t.step_func_done(() => {
+        // The |delay_node.delayTime| value should be zero because it does not
+        // have the previous anchor value. Based on the specification, if the
+        // beginning of an expoential ramp is zero, the resulting value falls
+        // into zero. In this case, there was no value point before the
+        // exponential ramp, and having no value point is treated as a
+        // default value, which is zero for |delayTime|.
+        assert_equals(delay_node.delayTime.value, 0);
+        assert_equals(context.state, 'closed');
+      });
+      context.startRendering();
+    };
+
+    window.addEventListener('load', t.step_func(onload));
+  </script>
+</body>
+</html>
diff --git a/tools/metrics/histograms/enums.xml b/tools/metrics/histograms/enums.xml
index e6f55d6ca1..808a241114 100644
--- a/tools/metrics/histograms/enums.xml
+++ b/tools/metrics/histograms/enums.xml
@@ -7143,6 +7143,7 @@ Called by update_bad_message_reasons.py.-->
   <int value="240" label="WCI_INVALID_FULLSCREEN_OPTIONS"/>
   <int value="241" label="PAYMENTS_WITHOUT_PERMISSION"/>
   <int value="242" label="WEB_BUNDLE_INVALID_NAVIGATION_URL"/>
+  <int value="254" label="RFH_CREATE_CHILD_FRAME_SANDBOX_FLAGS"/>
 </enum>
 
 <enum name="BadMessageReasonExtensions">
diff --git a/ui/base/resource/resource_bundle.cc b/ui/base/resource/resource_bundle.cc
index 1032f1e903..3f0110f0ee 100644
--- a/ui/base/resource/resource_bundle.cc
+++ b/ui/base/resource/resource_bundle.cc
@@ -379,7 +379,7 @@ base::FilePath ResourceBundle::GetLocaleFilePath(
 #else
   if (base::PathService::Get(base::DIR_ASSETS, &locale_file_path)) {
     locale_file_path =
-        locale_file_path.AppendASCII(app_locale + kPakFileExtension);
+        locale_file_path.AppendASCII(std::string("locales/") + app_locale + kPakFileExtension);
   }
 #endif
 
diff --git a/ui/ozone/common/BUILD.gn b/ui/ozone/common/BUILD.gn
index 59c8b17465..267f0c37ba 100644
--- a/ui/ozone/common/BUILD.gn
+++ b/ui/ozone/common/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("//build/config/ozone.gni")
 import("//build/config/ui.gni")
+import("//build/config/ohos/config.gni")
 
 assert(use_ozone)
 
@@ -26,6 +27,10 @@ source_set("common") {
     "//ui/ozone:ozone_base",
   ]
 
+  if (product_name == "rk3568") {
+    defines = [ "GL_RK3568" ]
+  }
+
   deps = [
     "//ui/gfx/ipc/color",
     "//ui/gl",
diff --git a/ui/ozone/common/egl_util.cc b/ui/ozone/common/egl_util.cc
index 7eda22ffbb..5c5a416cfc 100644
--- a/ui/ozone/common/egl_util.cc
+++ b/ui/ozone/common/egl_util.cc
@@ -37,8 +37,13 @@ const base::FilePath::CharType kDefaultGlesSoname[] =
 #elif defined(OS_OHOS)
 const base::FilePath::CharType kDefaultEglSoname[] =
     FILE_PATH_LITERAL("libEGL.so");
+#if defined(GL_RK3568)
+const base::FilePath::CharType kDefaultGlesSoname[] =
+    FILE_PATH_LITERAL("libGLESv2.so");
+#else
 const base::FilePath::CharType kDefaultGlesSoname[] =
     FILE_PATH_LITERAL("libGLES_mali.so");
+#endif
 #else
 const base::FilePath::CharType kDefaultEglSoname[] =
     FILE_PATH_LITERAL("libEGL.so.1");
diff --git a/ui/views/bubble/bubble_dialog_model_host.cc b/ui/views/bubble/bubble_dialog_model_host.cc
index 09dd241428..9aac59bc08 100644
--- a/ui/views/bubble/bubble_dialog_model_host.cc
+++ b/ui/views/bubble/bubble_dialog_model_host.cc
@@ -56,9 +56,8 @@ class CheckboxControl : public Checkbox {
       : label_line_height_(label_line_height) {
     auto* layout = SetLayoutManager(std::make_unique<BoxLayout>());
     layout->set_between_child_spacing(LayoutProvider::Get()->GetDistanceMetric(
-        views::DISTANCE_RELATED_LABEL_HORIZONTAL));
-    layout->set_cross_axis_alignment(
-        views::BoxLayout::CrossAxisAlignment::kStart);
+        DISTANCE_RELATED_LABEL_HORIZONTAL));
+    layout->set_cross_axis_alignment(BoxLayout::CrossAxisAlignment::kStart);
 
     SetAssociatedLabel(label.get());
 
@@ -254,8 +253,8 @@ BubbleDialogModelHost::BubbleDialogModelHost(
   set_close_on_deactivate(model_->close_on_deactivate(GetPassKey()));
 
   set_fixed_width(LayoutProvider::Get()->GetDistanceMetric(
-      anchor_view ? views::DISTANCE_BUBBLE_PREFERRED_WIDTH
-                  : views::DISTANCE_MODAL_DIALOG_PREFERRED_WIDTH));
+      anchor_view ? DISTANCE_BUBBLE_PREFERRED_WIDTH
+                  : DISTANCE_MODAL_DIALOG_PREFERRED_WIDTH));
 
   AddInitialFields();
 }
@@ -464,17 +463,19 @@ void BubbleDialogModelHost::AddOrUpdateCombobox(
   combobox->SetCallback(base::BindRepeating(
       [](ui::DialogModelCombobox* model_field,
          base::PassKey<DialogModelHost> pass_key, Combobox* combobox) {
-        // TODO(pbos): This should be a subscription through the Combobox
-        // directly, but Combobox right now doesn't support listening to
-        // selected-index changes.
-        model_field->OnSelectedIndexChanged(pass_key,
-                                            combobox->GetSelectedIndex());
         model_field->OnPerformAction(pass_key);
       },
       model_field, GetPassKey(), combobox.get()));
 
-  // TODO(pbos): Add subscription to combobox selected-index changes.
   combobox->SetSelectedIndex(model_field->selected_index());
+  property_changed_subscriptions_.push_back(
+      combobox->AddSelectedIndexChangedCallback(base::BindRepeating(
+          [](ui::DialogModelCombobox* model_field,
+             base::PassKey<DialogModelHost> pass_key, Combobox* combobox) {
+            model_field->OnSelectedIndexChanged(pass_key,
+                                                combobox->GetSelectedIndex());
+          },
+          model_field, GetPassKey(), combobox.get())));
   const gfx::FontList& font_list = combobox->GetFontList();
   AddViewForLabelAndField(model_field, model_field->label(GetPassKey()),
                           std::move(combobox), font_list);
diff --git a/ui/views/controls/combobox/combobox.cc b/ui/views/controls/combobox/combobox.cc
index 8fd0088e02..c25a7c5e57 100644
--- a/ui/views/controls/combobox/combobox.cc
+++ b/ui/views/controls/combobox/combobox.cc
@@ -281,6 +281,7 @@ const gfx::FontList& Combobox::GetFontList() const {
 void Combobox::SetSelectedIndex(int index) {
   if (selected_index_ == index)
     return;
+  // TODO(pbos): Add (D)CHECKs to validate the selected index.
   selected_index_ = index;
   if (size_to_largest_label_) {
     OnPropertyChanged(&selected_index_, kPropertyEffectsPaint);
@@ -290,6 +291,11 @@ void Combobox::SetSelectedIndex(int index) {
   }
 }
 
+base::CallbackListSubscription Combobox::AddSelectedIndexChangedCallback(
+    views::PropertyChangedCallback callback) {
+  return AddPropertyChangedCallback(&selected_index_, std::move(callback));
+}
+
 bool Combobox::SelectValue(const std::u16string& value) {
   for (int i = 0; i < GetModel()->GetItemCount(); ++i) {
     if (value == GetModel()->GetItemAt(i)) {
@@ -430,9 +436,11 @@ bool Combobox::OnKeyPressed(const ui::KeyEvent& e) {
   // TODO(oshima): handle IME.
   DCHECK_EQ(e.type(), ui::ET_KEY_PRESSED);
 
+  // TODO(pbos): Do we need to handle selected_index_ == -1 for unselected here?
+  // Ditto on handling an empty model?
   DCHECK_GE(selected_index_, 0);
   DCHECK_LT(selected_index_, GetModel()->GetItemCount());
-  if (selected_index_ < 0 || selected_index_ > GetModel()->GetItemCount())
+  if (selected_index_ < 0 || selected_index_ >= GetModel()->GetItemCount())
     SetSelectedIndex(0);
 
   bool show_menu = false;
@@ -618,10 +626,13 @@ void Combobox::PaintIconAndText(gfx::Canvas* canvas) {
 
   // Draw the text.
   SkColor text_color = GetTextColorForEnableState(*this, GetEnabled());
-  if (selected_index_ < 0 || selected_index_ > GetModel()->GetItemCount()) {
-    NOTREACHED();
+  // TODO(pbos): Do we need to handle selected_index_ == -1 for unselected here?
+  // Ditto on handling an empty model?
+  DCHECK_GE(selected_index_, 0);
+  DCHECK_LT(selected_index_, GetModel()->GetItemCount());
+  if (selected_index_ < 0 || selected_index_ >= GetModel()->GetItemCount())
     SetSelectedIndex(0);
-  }
+
   std::u16string text = GetModel()->GetItemAt(selected_index_);
 
   int disclosure_arrow_offset = width() - kComboboxArrowContainerWidth;
diff --git a/ui/views/controls/combobox/combobox.h b/ui/views/controls/combobox/combobox.h
index 303b9e5d9a..2dccca063e 100644
--- a/ui/views/controls/combobox/combobox.h
+++ b/ui/views/controls/combobox/combobox.h
@@ -71,6 +71,8 @@ class VIEWS_EXPORT Combobox : public View,
   // Gets/Sets the selected index.
   int GetSelectedIndex() const { return selected_index_; }
   void SetSelectedIndex(int index);
+  base::CallbackListSubscription AddSelectedIndexChangedCallback(
+      views::PropertyChangedCallback callback) WARN_UNUSED_RESULT;
 
   // Looks for the first occurrence of |value| in |model()|. If found, selects
   // the found index and returns true. Otherwise simply noops and returns false.
