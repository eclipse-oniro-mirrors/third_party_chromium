diff --git a/BUILD.gn b/BUILD.gn
index 059d93a124858..77a1f2289eb9c 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -103,12 +103,11 @@ group("gn_all") {
   # ifdef ohos_nweb_ex
   if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
     deps += [
-      "//ohos_browser_shell",
-      "//ohos_nweb_ex/browser_service_ex",
-      "//ohos_nweb_hap",
+    "//ohos_nweb_ex/browser_service",
+    "//ohos_nweb_hap",
     ]
   }
-  # endif 
+  # endif
 
   if (!is_component_build) {
     deps += [ "//third_party/abseil-cpp:absl_tests" ]
diff --git a/DEPS b/DEPS
index 9bc5bbe9fe0df..e226c296edd8d 100644
--- a/DEPS
+++ b/DEPS
@@ -289,7 +289,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling devtools-frontend
   # and whatever else without interference from each other.
-  'devtools_frontend_revision': '02d384884a4f26dffbaf79d14129a34f3f04d460',
+  'devtools_frontend_revision': '48195593291718160b196157c24a0147cb006773',
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling libprotobuf-mutator
   # and whatever else without interference from each other.
diff --git a/base/BUILD.gn b/base/BUILD.gn
index 9d9900844e538..976a11718185f 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -192,6 +192,7 @@ if (is_ohos) {
       "hilog",
       "utils.z",
       "eventhandler.z",
+      "hitrace_meter",
     ]
 
     include_dirs = ohos_src_includes
@@ -356,6 +357,8 @@ component("base") {
     "files/memory_mapped_file.cc",
     "files/memory_mapped_file.h",
     "files/platform_file.h",
+    "files/safe_base_name.cc",
+    "files/safe_base_name.h",
     "files/scoped_file.cc",
     "files/scoped_file.h",
     "files/scoped_temp_dir.cc",
@@ -2397,6 +2400,17 @@ component("base") {
       ]
     }
 
+    if (is_ohos) {
+      sources += [
+        "trace_event/trace_event_ohos.cc",
+      ]
+      if (enable_ohos_bytrace) {
+        defines += [
+          "ENABLE_OHOS_BYTRACE",
+        ]
+      }
+    }
+
     if (use_perfetto_client_library) {
       sources -= [ "trace_event/builtin_categories.cc" ]
     }
@@ -2976,6 +2990,7 @@ if (build_base_unittests) {
       "files/important_file_writer_cleaner_unittest.cc",
       "files/important_file_writer_unittest.cc",
       "files/memory_mapped_file_unittest.cc",
+      "files/safe_base_name_unittest.cc",
       "files/scoped_temp_dir_unittest.cc",
       "functional/identity_unittest.cc",
       "functional/invoke_unittest.cc",
diff --git a/base/files/file_path.cc b/base/files/file_path.cc
index d1575fcde9e7b..84817584a1a95 100644
--- a/base/files/file_path.cc
+++ b/base/files/file_path.cc
@@ -8,6 +8,7 @@
 #include <algorithm>
 
 #include "base/check_op.h"
+#include "base/files/safe_base_name.h"
 #include "base/macros.h"
 #include "base/pickle.h"
 #include "base/strings/strcat.h"
@@ -530,6 +531,10 @@ FilePath FilePath::Append(const FilePath& component) const {
   return Append(component.value());
 }
 
+FilePath FilePath::Append(const SafeBaseName& component) const {
+  return Append(component.path().value());
+}
+
 FilePath FilePath::AppendASCII(StringPiece component) const {
   DCHECK(base::IsStringASCII(component));
 #if defined(OS_WIN)
diff --git a/base/files/file_path.h b/base/files/file_path.h
index f32b7c24ba342..d0001f9d28eda 100644
--- a/base/files/file_path.h
+++ b/base/files/file_path.h
@@ -143,6 +143,7 @@
 
 namespace base {
 
+class SafeBaseName;
 class Pickle;
 class PickleIterator;
 
@@ -325,6 +326,7 @@ class BASE_EXPORT FilePath {
   // it is an error to pass an absolute path.
   FilePath Append(StringPieceType component) const WARN_UNUSED_RESULT;
   FilePath Append(const FilePath& component) const WARN_UNUSED_RESULT;
+  FilePath Append(const SafeBaseName& component) const WARN_UNUSED_RESULT;
 
   // Although Windows StringType is std::wstring, since the encoding it uses for
   // paths is well defined, it can handle ASCII path components as well.
diff --git a/base/files/file_path_unittest.cc b/base/files/file_path_unittest.cc
index 7af5f223c1297..242a6c2af7772 100644
--- a/base/files/file_path_unittest.cc
+++ b/base/files/file_path_unittest.cc
@@ -7,6 +7,7 @@
 #include <sstream>
 
 #include "base/files/file_path.h"
+#include "base/files/safe_base_name.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
@@ -1197,6 +1198,18 @@ TEST_F(FilePathTest, AppendWithNUL) {
 #endif
 }
 
+TEST_F(FilePathTest, AppendBaseName) {
+  FilePath dir(FPL("foo"));
+  auto file(SafeBaseName::Create(FPL("bar.txt")));
+  EXPECT_TRUE(file);
+
+#if defined(FILE_PATH_USES_WIN_SEPARATORS)
+  EXPECT_EQ(dir.Append(*file), FilePath(FPL("foo\\bar.txt")));
+#else
+  EXPECT_EQ(dir.Append(*file), FilePath(FPL("foo/bar.txt")));
+#endif
+}
+
 TEST_F(FilePathTest, ReferencesParentWithNUL) {
   // Assert FPS() works.
   ASSERT_EQ(3U, FPS("..\0").length());
diff --git a/base/files/safe_base_name.cc b/base/files/safe_base_name.cc
new file mode 100644
index 0000000000000..e98d7c2090060
--- /dev/null
+++ b/base/files/safe_base_name.cc
@@ -0,0 +1,33 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/files/safe_base_name.h"
+
+namespace base {
+
+// static
+absl::optional<SafeBaseName> SafeBaseName::Create(const FilePath& path) {
+  auto basename = path.BaseName();
+
+  if (!basename.IsAbsolute() && !basename.ReferencesParent() &&
+      !basename.EndsWithSeparator()) {
+    return absl::make_optional(SafeBaseName(basename));
+  }
+
+  return absl::nullopt;
+}
+
+// static
+absl::optional<SafeBaseName> SafeBaseName::Create(
+    FilePath::StringPieceType path) {
+  return Create(FilePath(path));
+}
+
+SafeBaseName::SafeBaseName(const FilePath& path) : path_(path) {}
+
+bool SafeBaseName::operator==(const SafeBaseName& that) const {
+  return path_ == that.path_;
+}
+
+}  // namespace base
\ No newline at end of file
diff --git a/base/files/safe_base_name.h b/base/files/safe_base_name.h
new file mode 100644
index 0000000000000..2517e4222130c
--- /dev/null
+++ b/base/files/safe_base_name.h
@@ -0,0 +1,43 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_FILES_SAFE_BASE_NAME_H_
+#define BASE_FILES_SAFE_BASE_NAME_H_
+
+#include "base/files/file_path.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+namespace base {
+
+// Represents the last path component of a FilePath object, either a file or a
+// directory. This type does not allow absolute paths or references to parent
+// directories and is considered safe to be passed over IPC. See
+// FilePath::BaseName().
+// Usage examples:
+// absl::optional<SafeBaseName> a
+//     (SafeBaseName::Create(FILE_PATH_LITERAL("file.txt")));
+// FilePath dir(FILE_PATH_LITERAL("foo")); dir.Append(*a);
+class BASE_EXPORT SafeBaseName {
+ public:
+  // TODO(crbug.com/1269986): Change to only be exposed to Mojo.
+  SafeBaseName() = default;
+
+  // Factory method that returns a valid SafeBaseName or absl::nullopt.
+  static absl::optional<SafeBaseName> Create(const FilePath&);
+
+  // Same as above, but takes a StringPieceType for convenience.
+  static absl::optional<SafeBaseName> Create(FilePath::StringPieceType);
+  const FilePath& path() const { return path_; }
+
+  bool operator==(const SafeBaseName& that) const;
+
+ private:
+  // Constructs a new SafeBaseName from the given FilePath.
+  explicit SafeBaseName(const FilePath&);
+  FilePath path_;
+};
+
+}  // namespace base
+
+#endif  // BASE_FILES_SAFE_BASE_NAME_H_
diff --git a/base/files/safe_base_name_unittest.cc b/base/files/safe_base_name_unittest.cc
new file mode 100644
index 0000000000000..d2043c7b20b9d
--- /dev/null
+++ b/base/files/safe_base_name_unittest.cc
@@ -0,0 +1,79 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/files/safe_base_name.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace base {
+
+TEST(SafeBaseNameTest, Basic) {
+  absl::optional<SafeBaseName> basename(SafeBaseName::Create(FilePath()));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_TRUE(basename->path().empty());
+
+  absl::optional<SafeBaseName> basename2(
+      SafeBaseName::Create(FILE_PATH_LITERAL("bar")));
+  EXPECT_TRUE(basename2);
+  EXPECT_EQ(basename2->path(), FilePath(FILE_PATH_LITERAL("bar")));
+}
+
+#if defined(FILE_PATH_USES_WIN_SEPARATORS)
+TEST(SafeBaseNameTest, WinRoot) {
+  absl::optional<SafeBaseName> basename(
+      SafeBaseName::Create(FILE_PATH_LITERAL("C:\\foo\\bar")));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL("bar")));
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("C:\\"));
+  EXPECT_FALSE(basename.has_value());
+}
+#else
+TEST(SafeBaseNameTest, Root) {
+  absl::optional<SafeBaseName> basename(
+      SafeBaseName::Create(FilePath(FILE_PATH_LITERAL("/"))));
+  EXPECT_FALSE(basename.has_value());
+}
+#endif  // FILE_PATH_USES_WIN_SEPARATORS
+
+TEST(SafeBaseNameTest, Separators) {
+  absl::optional<SafeBaseName> basename(
+      SafeBaseName::Create(FILE_PATH_LITERAL("/foo/bar")));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL("bar")));
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("/a/b/c/"));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL("c")));
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("/a/b/c/."));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL(".")));
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("/a/b/c/.."));
+  EXPECT_FALSE(basename.has_value());
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("a/b/c"));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL("c")));
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("a/b/."));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL(".")));
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("a/b/.."));
+  EXPECT_FALSE(basename.has_value());
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("a/../"));
+  EXPECT_FALSE(basename.has_value());
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("a/.."));
+  EXPECT_FALSE(basename.has_value());
+
+  basename = SafeBaseName::Create(FILE_PATH_LITERAL("../bar"));
+  EXPECT_TRUE(basename.has_value());
+  EXPECT_EQ(basename->path(), FilePath(FILE_PATH_LITERAL("bar")));
+}
+
+}  // namespace base
\ No newline at end of file
diff --git a/base/logging.cc b/base/logging.cc
index 8326bc2c63f84..e84dad02bd0bb 100644
--- a/base/logging.cc
+++ b/base/logging.cc
@@ -815,7 +815,7 @@ LogMessage::~LogMessage() {
         break;
     }
     const char kOHOSLogTag[] = "chromium";
-    HiLogPrintOHOS(LOG_APP, priority, 0, kOHOSLogTag, str_newline.c_str());
+    HiLogPrintOHOS(LOG_CORE, priority, 0xD004500, kOHOSLogTag, str_newline.c_str());
 #elif defined(OS_FUCHSIA)
     fx_log_severity_t severity = FX_LOG_INFO;
     switch (severity_) {
diff --git a/base/message_loop/message_pump_ohos.cc b/base/message_loop/message_pump_ohos.cc
index 25a245d9231c4..a66d0f969305f 100644
--- a/base/message_loop/message_pump_ohos.cc
+++ b/base/message_loop/message_pump_ohos.cc
@@ -18,6 +18,9 @@
 #include "base/notreached.h"
 #include "base/run_loop.h"
 #include "build/build_config.h"
+#if defined(__MUSL__)
+#include <sys/timerfd.h>
+#endif
 
 #ifndef __NR_timerfd_create
 #error "Unable to find syscall for __NR_timerfd_create"
@@ -26,6 +29,7 @@
 #ifndef TFD_TIMER_ABSTIME
 #define TFD_TIMER_ABSTIME (1 << 0)
 #endif
+#define OHOS_TIMER_MONOTONIC 0
 
 namespace base {
 
@@ -65,24 +69,21 @@ class EventHandlerFileDescriptorListener : public OHOS::AppExecFwk::FileDescript
   int delayed_fd_;
 };
 
-// See sys/timerfd.h
-int timerfd_create(int clockid, int flags) {
+int OhosTimerFdCreate(int clockid, int flags) {
+#if defined(__MUSL__)
+  return timerfd_create(clockid, flags);
+#else
   return syscall(__NR_timerfd_create, clockid, flags);
+#endif
 }
 
-// See sys/timerfd.h
-int timerfd_settime(int ufc,
-                    int flags,
+int OhosTimerfdSettime(int ufc,
                     const struct itimerspec* utmr,
                     struct itimerspec* otmr) {
 #if defined(__MUSL__)
-#if defined(__aarch64__)
-  return syscall(__NR_timerfd_settime, ufc, flags, utmr, otmr);
-#else
-  return syscall(__NR_timerfd_settime32, ufc, flags, utmr, otmr);
-#endif
+  return timerfd_settime(ufc, TFD_TIMER_ABSTIME, utmr, otmr);
 #else
-  return syscall(__NR_timerfd_settime, ufc, flags, utmr, otmr);
+  return syscall(__NR_timerfd_settime, ufc, TFD_TIMER_ABSTIME, utmr, otmr);
 #endif
 }
 
@@ -100,7 +101,7 @@ MessagePumpForUI::MessagePumpForUI() {
   // include timerfd.h. See comments above on __NR_timerfd_create. It looks like
   // they're just aliases to O_NONBLOCK and O_CLOEXEC anyways, so this should be
   // fine.
-  delayed_fd_ = timerfd_create(CLOCK_MONOTONIC, O_NONBLOCK | O_CLOEXEC);
+  delayed_fd_ = OhosTimerFdCreate(CLOCK_MONOTONIC, O_NONBLOCK | O_CLOEXEC);
   CHECK_NE(delayed_fd_, -1);
 
   ohos_event_handler_ = OHOS::AppExecFwk::EventHandler::Current();
@@ -275,8 +276,7 @@ void MessagePumpForUI::ScheduleDelayedWork(const TimeTicks& delayed_work_time) {
   ts.it_interval.tv_nsec = 0;
   ts.it_value.tv_sec = nanos / TimeTicks::kNanosecondsPerSecond;
   ts.it_value.tv_nsec = nanos % TimeTicks::kNanosecondsPerSecond;
-
-  int ret = timerfd_settime(delayed_fd_, TFD_TIMER_ABSTIME, &ts, nullptr);
+  int ret = OhosTimerfdSettime(delayed_fd_, &ts, nullptr);
   DPCHECK(ret >= 0);
 }
 
diff --git a/base/task/sequence_manager/thread_controller.cc b/base/task/sequence_manager/thread_controller.cc
index f108d559bdf6c..b6818afc55561 100644
--- a/base/task/sequence_manager/thread_controller.cc
+++ b/base/task/sequence_manager/thread_controller.cc
@@ -126,10 +126,11 @@ void ThreadController::RunLevelTracker::RunLevel::UpdateState(State new_state) {
     return;
 
   // Change of state.
-  if (is_active)
+  if (is_active) {
     TRACE_EVENT_BEGIN0("base", "ThreadController active");
-  else
+  } else {
     TRACE_EVENT_END0("base", "ThreadController active");
+  }
 
   if (trace_observer_for_testing_) {
     if (is_active)
diff --git a/base/trace_event/common/trace_event_common.h b/base/trace_event/common/trace_event_common.h
index 9b6783bb3535c..fb17c948be8d9 100644
--- a/base/trace_event/common/trace_event_common.h
+++ b/base/trace_event/common/trace_event_common.h
@@ -195,6 +195,7 @@
 // Normally we'd use BUILDFLAG(USE_PERFETTO_CLIENT_LIBRARY) for this, but
 // because v8 includes trace_event_common.h directly (in non-Perfetto mode), we
 // can't depend on any other header files here.
+
 #if defined(BASE_USE_PERFETTO_CLIENT_LIBRARY)
 ////////////////////////////////////////////////////////////////////////////////
 // Perfetto trace macros
@@ -270,6 +271,85 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
 }  // namespace perfetto
 
 #else  // !defined(BASE_USE_PERFETTO_CLIENT_LIBRARY)
+
+// Notes regarding the following definitions:
+// New values can be added and propagated to third party libraries, but existing
+// definitions must never be changed, because third party libraries may use old
+// definitions.
+
+// Phase indicates the nature of an event entry. E.g. part of a begin/end pair.
+#define TRACE_EVENT_PHASE_BEGIN ('B')
+#define TRACE_EVENT_PHASE_END ('E')
+#define TRACE_EVENT_PHASE_COMPLETE ('X')
+#define TRACE_EVENT_PHASE_INSTANT ('I')
+#define TRACE_EVENT_PHASE_ASYNC_BEGIN ('S')
+#define TRACE_EVENT_PHASE_ASYNC_STEP_INTO ('T')
+#define TRACE_EVENT_PHASE_ASYNC_STEP_PAST ('p')
+#define TRACE_EVENT_PHASE_ASYNC_END ('F')
+#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN ('b')
+#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_END ('e')
+#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT ('n')
+#define TRACE_EVENT_PHASE_FLOW_BEGIN ('s')
+#define TRACE_EVENT_PHASE_FLOW_STEP ('t')
+#define TRACE_EVENT_PHASE_FLOW_END ('f')
+#define TRACE_EVENT_PHASE_METADATA ('M')
+#define TRACE_EVENT_PHASE_COUNTER ('C')
+#define TRACE_EVENT_PHASE_SAMPLE ('P')
+#define TRACE_EVENT_PHASE_CREATE_OBJECT ('N')
+#define TRACE_EVENT_PHASE_SNAPSHOT_OBJECT ('O')
+#define TRACE_EVENT_PHASE_DELETE_OBJECT ('D')
+#define TRACE_EVENT_PHASE_MEMORY_DUMP ('v')
+#define TRACE_EVENT_PHASE_MARK ('R')
+#define TRACE_EVENT_PHASE_CLOCK_SYNC ('c')
+#define TRACE_EVENT_PHASE_ENTER_CONTEXT ('(')
+#define TRACE_EVENT_PHASE_LEAVE_CONTEXT (')')
+
+// Flags for changing the behavior of TRACE_EVENT_API_ADD_TRACE_EVENT.
+#define TRACE_EVENT_FLAG_NONE (static_cast<unsigned int>(0))
+#define TRACE_EVENT_FLAG_COPY (static_cast<unsigned int>(1 << 0))
+#define TRACE_EVENT_FLAG_HAS_ID (static_cast<unsigned int>(1 << 1))
+#define TRACE_EVENT_FLAG_SCOPE_OFFSET (static_cast<unsigned int>(1 << 2))
+#define TRACE_EVENT_FLAG_SCOPE_EXTRA (static_cast<unsigned int>(1 << 3))
+#define TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP (static_cast<unsigned int>(1 << 4))
+#define TRACE_EVENT_FLAG_ASYNC_TTS (static_cast<unsigned int>(1 << 5))
+#define TRACE_EVENT_FLAG_BIND_TO_ENCLOSING (static_cast<unsigned int>(1 << 6))
+#define TRACE_EVENT_FLAG_FLOW_IN (static_cast<unsigned int>(1 << 7))
+#define TRACE_EVENT_FLAG_FLOW_OUT (static_cast<unsigned int>(1 << 8))
+#define TRACE_EVENT_FLAG_HAS_CONTEXT_ID (static_cast<unsigned int>(1 << 9))
+#define TRACE_EVENT_FLAG_HAS_PROCESS_ID (static_cast<unsigned int>(1 << 10))
+#define TRACE_EVENT_FLAG_HAS_LOCAL_ID (static_cast<unsigned int>(1 << 11))
+#define TRACE_EVENT_FLAG_HAS_GLOBAL_ID (static_cast<unsigned int>(1 << 12))
+// TODO(eseckler): Remove once we have native support for typed proto events in
+// TRACE_EVENT macros.
+#define TRACE_EVENT_FLAG_TYPED_PROTO_ARGS (static_cast<unsigned int>(1 << 15))
+#define TRACE_EVENT_FLAG_JAVA_STRING_LITERALS \
+  (static_cast<unsigned int>(1 << 16))
+
+#define TRACE_EVENT_FLAG_SCOPE_MASK                          \
+  (static_cast<unsigned int>(TRACE_EVENT_FLAG_SCOPE_OFFSET | \
+                             TRACE_EVENT_FLAG_SCOPE_EXTRA))
+
+// Type values for identifying types in the TraceValue union.
+#define TRACE_VALUE_TYPE_BOOL (static_cast<unsigned char>(1))
+#define TRACE_VALUE_TYPE_UINT (static_cast<unsigned char>(2))
+#define TRACE_VALUE_TYPE_INT (static_cast<unsigned char>(3))
+#define TRACE_VALUE_TYPE_DOUBLE (static_cast<unsigned char>(4))
+#define TRACE_VALUE_TYPE_POINTER (static_cast<unsigned char>(5))
+#define TRACE_VALUE_TYPE_STRING (static_cast<unsigned char>(6))
+#define TRACE_VALUE_TYPE_COPY_STRING (static_cast<unsigned char>(7))
+#define TRACE_VALUE_TYPE_CONVERTABLE (static_cast<unsigned char>(8))
+#define TRACE_VALUE_TYPE_PROTO (static_cast<unsigned char>(9))
+
+// Enum reflecting the scope of an INSTANT event. Must fit within
+// TRACE_EVENT_FLAG_SCOPE_MASK.
+#define TRACE_EVENT_SCOPE_GLOBAL (static_cast<unsigned char>(0 << 2))
+#define TRACE_EVENT_SCOPE_PROCESS (static_cast<unsigned char>(1 << 2))
+#define TRACE_EVENT_SCOPE_THREAD (static_cast<unsigned char>(2 << 2))
+
+#define TRACE_EVENT_SCOPE_NAME_GLOBAL ('g')
+#define TRACE_EVENT_SCOPE_NAME_PROCESS ('p')
+#define TRACE_EVENT_SCOPE_NAME_THREAD ('t')
+
 ////////////////////////////////////////////////////////////////////////////////
 // Legacy trace macros
 
@@ -293,26 +373,104 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
 // enabled, then this does nothing.
 // - category and name strings must have application lifetime (statics or
 //   literals). They may not include " chars.
+
+#if defined(OS_OHOS)
+#include "base/trace_event/trace_arguments.h"
+#include "base/trace_event/trace_event_ohos.h"
+
+template <class ARG1_TYPE>
+std::string GetStringFromArgs(const char* name,
+                                     const char* arg1_name,
+                                     ARG1_TYPE&& arg1_val) {
+  if (IsBytraceEnable()) {
+    std::string str(name);
+    base::trace_event::TraceArguments args(arg1_name,
+                                           std::forward<ARG1_TYPE>(arg1_val));
+    str += " | ";
+    str += arg1_name;
+    str += "=";
+    args.values()[0].AppendAsString(args.types()[0], &str);
+    return str;
+  }
+  return "";
+}
+
+template <class ARG1_TYPE, class ARG2_TYPE>
+std::string GetStringFromArgs(const char* name,
+                              const char* arg1_name,
+                              ARG1_TYPE&& arg1_val,
+                              const char* arg2_name,
+                              ARG2_TYPE&& arg2_val) {
+  if (IsBytraceEnable()) {
+    std::string str(name);
+    base::trace_event::TraceArguments args(
+        arg1_name, std::forward<ARG1_TYPE>(arg1_val), arg2_name,
+        std::forward<ARG2_TYPE>(arg2_val));
+    str += " | ";
+    str += arg1_name;
+    str += "=";
+    args.values()[0].AppendAsString(args.types()[0], &str);
+    str += " | ";
+    str += arg2_name;
+    str += "=";
+    args.values()[1].AppendAsString(args.types()[1], &str);
+    return str;
+  }
+  return "";
+}
+#endif
+
+#if defined(OS_OHOS)
+#define TRACE_EVENT0(category_group, name) \
+  (void)(category_group);                  \
+  BYTRACE_SCOPED(name);
+#define TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
+  TRACE_EVENT0(category_group, GetStringFromArgs(name, arg1_name, arg1_val));
+#define TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name,  \
+                     arg2_val)                                              \
+  TRACE_EVENT0(category_group, GetStringFromArgs(name, arg1_name, arg1_val, \
+                                                 arg2_name, arg2_val));
+#else
 #define TRACE_EVENT0(category_group, name)    \
   INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name)
+#define TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
+  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val)
+#define TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name,   \
+                     arg2_val)                                               \
+  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val, \
+                                  arg2_name, arg2_val)
+#endif
+
+#if defined(OS_OHOS)
+#define TRACE_EVENT_WITH_FLOW0(category_group, name, bind_id, flow_flags) \
+  (void)(category_group);                                                 \
+  (void)(bind_id);                                                        \
+  (void)(flow_flags);                                                     \
+  BYTRACE_SCOPED(name);
+#define TRACE_EVENT_WITH_FLOW1(category_group, name, bind_id, flow_flags, \
+                               arg1_name, arg1_val)                       \
+  TRACE_EVENT_WITH_FLOW0(category_group,                                  \
+                         GetStringFromArgs(name, arg1_name, arg1_val),    \
+                         bind_id, flow_flags);
+#define TRACE_EVENT_WITH_FLOW2(category_group, name, bind_id, flow_flags, \
+                               arg1_name, arg1_val, arg2_name, arg2_val)  \
+  TRACE_EVENT_WITH_FLOW0(category_group,                                  \
+      GetStringFromArgs(name, arg1_name, arg1_val, arg2_name, arg2_val),  \
+                        bind_id, flow_flags);
+#else
 #define TRACE_EVENT_WITH_FLOW0(category_group, name, bind_id, flow_flags)  \
   INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id, \
                                             flow_flags)
-#define TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val)
 #define TRACE_EVENT_WITH_FLOW1(category_group, name, bind_id, flow_flags,  \
                                arg1_name, arg1_val)                        \
   INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id, \
                                             flow_flags, arg1_name, arg1_val)
-#define TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name,   \
-                     arg2_val)                                               \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val, \
-                                  arg2_name, arg2_val)
 #define TRACE_EVENT_WITH_FLOW2(category_group, name, bind_id, flow_flags,    \
                                arg1_name, arg1_val, arg2_name, arg2_val)     \
   INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id,   \
                                             flow_flags, arg1_name, arg1_val, \
                                             arg2_name, arg2_val)
+#endif
 
 // Records a single event called "name" immediately, with 0, 1 or 2
 // associated arguments. If the category is not enabled, then this
@@ -367,6 +525,18 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
 // does nothing.
 // - category and name strings must have application lifetime (statics or
 //   literals). They may not include " chars.
+#if defined(OS_OHOS)
+#define TRACE_EVENT_BEGIN0(category_group, name) \
+  (void)(category_group);                        \
+  StartBytrace(name)
+#define TRACE_EVENT_BEGIN1(category_group, name, arg1_name, arg1_val) \
+  TRACE_EVENT_BEGIN0(category_group,                                  \
+                     GetStringFromArgs(name, arg1_name, arg1_val))
+#define TRACE_EVENT_BEGIN2(category_group, name, arg1_name, arg1_val, \
+                           arg2_name, arg2_val)                       \
+  TRACE_EVENT_BEGIN0(category_group, GetStringFromArgs(name, arg1_name, \
+                     arg1_val, arg2_name, arg2_val))
+#else
 #define TRACE_EVENT_BEGIN0(category_group, name)                          \
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                            TRACE_EVENT_FLAG_NONE)
@@ -378,6 +548,21 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                            TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val,    \
                            arg2_name, arg2_val)
+#endif
+
+#if defined(OS_OHOS)
+#define TRACE_EVENT_BEGIN_WITH_FLAGS0(category_group, name, flags) \
+  (void)(flags);                                 \
+  TRACE_EVENT_BEGIN0(category_group, name)
+#define TRACE_EVENT_BEGIN_WITH_FLAGS1(category_group, name, flags, arg1_name, \
+                                      arg1_val)                               \
+  (void)(flags);                                 \
+  TRACE_EVENT_BEGIN1(category_group, name, arg1_name, arg1_name)
+#define TRACE_EVENT_COPY_BEGIN2(category_group, name, arg1_name, arg1_val, \
+                                arg2_name, arg2_val)                       \
+  TRACE_EVENT_BEGIN2(category_group, name, arg1_name, arg1_name,           \
+                     arg2_name, arg2_val)
+#else
 #define TRACE_EVENT_BEGIN_WITH_FLAGS0(category_group, name, flags) \
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, flags)
 #define TRACE_EVENT_BEGIN_WITH_FLAGS1(category_group, name, flags, arg1_name, \
@@ -389,6 +574,7 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name,  \
                            TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val,     \
                            arg2_name, arg2_val)
+#endif
 
 // Similar to TRACE_EVENT_BEGINx but with a custom |at| timestamp provided.
 // - |id| is used to match the _BEGIN event with the _END event.
@@ -423,6 +609,23 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
 // is not enabled, then this does nothing.
 // - category and name strings must have application lifetime (statics or
 //   literals). They may not include " chars.
+#if defined(OS_OHOS)
+#define TRACE_EVENT_END0(category_group, name) \
+  (void)(category_group);                      \
+  (void)(name);                                \
+  FinishBytrace()
+#define TRACE_EVENT_END1(category_group, name, arg1_name, arg1_val) \
+  (void)(arg1_name);                                                \
+  (void)(arg1_val);                                                 \
+  TRACE_EVENT_END0(category_group, name)
+#define TRACE_EVENT_END2(category_group, name, arg1_name, arg1_val, arg2_name, \
+                         arg2_val)                                             \
+  (void)(arg1_name);                                                           \
+  (void)(arg1_val);                                                            \
+  (void)(arg2_name);                                                           \
+  (void)(arg2_val);                                                            \
+  TRACE_EVENT_END0(category_group, name)
+#else
 #define TRACE_EVENT_END0(category_group, name)                          \
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
                            TRACE_EVENT_FLAG_NONE)
@@ -434,6 +637,26 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,        \
                            TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val,         \
                            arg2_name, arg2_val)
+#endif
+
+#if defined(OS_OHOS)
+#define TRACE_EVENT_END_WITH_FLAGS0(category_group, name, flags) \
+  (void)(flags);                                                 \
+  TRACE_EVENT_END0(category_group, name)
+#define TRACE_EVENT_END_WITH_FLAGS1(category_group, name, flags, arg1_name,  \
+                                    arg1_val)                                \
+  (void)(flags);                                                 \
+  (void)(arg1_name);                                             \
+  (void)(arg1_val);                                              \
+  TRACE_EVENT_END0(category_group, name)
+#define TRACE_EVENT_COPY_END2(category_group, name, arg1_name, arg1_val,  \
+                              arg2_name, arg2_val)                        \
+  (void)(arg1_name);                                                      \
+  (void)(arg1_val);                                                       \
+  (void)(arg2_name);                                                      \
+  (void)(arg2_val);                                                       \
+  TRACE_EVENT_END0(category_group, name)
+#else
 #define TRACE_EVENT_END_WITH_FLAGS0(category_group, name, flags) \
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, flags)
 #define TRACE_EVENT_END_WITH_FLAGS1(category_group, name, flags, arg1_name,    \
@@ -445,7 +668,22 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,  \
                            TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val,   \
                            arg2_name, arg2_val)
+#endif
 
+#if defined(OS_OHOS)
+#define TRACE_EVENT_MARK_WITH_TIMESTAMP0(category_group, name, timestamp) \
+  (void)(timestamp);                                                      \
+  TRACE_EVENT0(category_group, name);
+#define TRACE_EVENT_MARK_WITH_TIMESTAMP1(category_group, name, timestamp, \
+                                         arg1_name, arg1_val)             \
+  (void)(timestamp);                                                      \
+  TRACE_EVENT1(category_group, name, arg1_name, arg1_val);
+
+#define TRACE_EVENT_MARK_WITH_TIMESTAMP2(                                      \
+    category_group, name, timestamp, arg1_name, arg1_val, arg2_name, arg2_val) \
+  (void)(timestamp);                                                           \
+  TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name, arg2_val);
+#else
 #define TRACE_EVENT_MARK_WITH_TIMESTAMP0(category_group, name, timestamp) \
   INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                \
       TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,            \
@@ -462,7 +700,19 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                     \
       TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,                 \
       TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
+#endif
 
+#if defined(OS_OHOS)
+#define TRACE_EVENT_COPY_MARK(category_group, name)                      \
+  TRACE_EVENT0(category_group, name);
+
+#define TRACE_EVENT_COPY_MARK1(category_group, name, arg1_name, arg1_val) \
+  TRACE_EVENT1(category_group, name, arg1_name, arg1_val);
+
+#define TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP(category_group, name, timestamp) \
+  (void)(timestamp);                                                          \
+  TRACE_EVENT_COPY_MARK(category_group, name);
+#else
 #define TRACE_EVENT_COPY_MARK(category_group, name)                      \
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_MARK, category_group, name, \
                            TRACE_EVENT_FLAG_COPY)
@@ -475,6 +725,7 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                    \
       TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,                \
       TRACE_EVENT_FLAG_COPY)
+#endif
 
 // Similar to TRACE_EVENT_ENDx but with a custom |at| timestamp provided.
 // - |id| is used to match the _BEGIN event with the _END event.
@@ -509,6 +760,18 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
 // must be representable as a 32 bit integer.
 // - category and name strings must have application lifetime (statics or
 //   literals). They may not include " chars.
+#if defined(OS_OHOS)
+#define TRACE_COUNTER1(category_group, name, value)                         \
+  (void)(category_group);                                                   \
+  CountBytrace(name, value);
+#define TRACE_COUNTER_WITH_FLAG1(category_group, name, flag, value)         \
+  (void)(category_group);                                                   \
+  (void)(flag);                                                             \
+  CountBytrace(name, value);
+#define TRACE_COPY_COUNTER1(category_group, name, value)                    \
+  (void)(category_group);                                                   \
+  CountBytrace(name, static_cast<int>(value));
+#else
 #define TRACE_COUNTER1(category_group, name, value)                         \
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
                            TRACE_EVENT_FLAG_NONE, "value",                  \
@@ -520,6 +783,7 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
                            TRACE_EVENT_FLAG_COPY, "value",                  \
                            static_cast<int>(value))
+#endif
 
 // Records the values of a multi-parted counter called "name" immediately.
 // The UI will treat value1 and value2 as parts of a whole, displaying their
@@ -540,10 +804,16 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
                            static_cast<int>(value2_val))
 
 // Similar to TRACE_COUNTERx, but with a custom |timestamp| provided.
+#if defined(OS_OHOS)
+#define TRACE_COUNTER_WITH_TIMESTAMP1(category_group, name, timestamp, value) \
+  (void)(timestamp);                                                          \
+  TRACE_COUNTER1(category_group, name, value);
+#else
 #define TRACE_COUNTER_WITH_TIMESTAMP1(category_group, name, timestamp, value) \
   INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                    \
       TRACE_EVENT_PHASE_COUNTER, category_group, name, timestamp,             \
       TRACE_EVENT_FLAG_NONE, "value", static_cast<int>(value))
+#endif
 
 #define TRACE_COUNTER_WITH_TIMESTAMP2(category_group, name, timestamp,      \
                                       value1_name, value1_val, value2_name, \
@@ -1040,84 +1310,5 @@ ConvertTimestampToTraceTimeNs(const ::base::TimeTicks& ticks);
 // Macro for getting the real base::Time::Now() which can be overridden in
 // headless when VirtualTime is enabled.
 #define TRACE_TIME_NOW() INTERNAL_TRACE_TIME_NOW()
-
-// Notes regarding the following definitions:
-// New values can be added and propagated to third party libraries, but existing
-// definitions must never be changed, because third party libraries may use old
-// definitions.
-
-// Phase indicates the nature of an event entry. E.g. part of a begin/end pair.
-#define TRACE_EVENT_PHASE_BEGIN ('B')
-#define TRACE_EVENT_PHASE_END ('E')
-#define TRACE_EVENT_PHASE_COMPLETE ('X')
-#define TRACE_EVENT_PHASE_INSTANT ('I')
-#define TRACE_EVENT_PHASE_ASYNC_BEGIN ('S')
-#define TRACE_EVENT_PHASE_ASYNC_STEP_INTO ('T')
-#define TRACE_EVENT_PHASE_ASYNC_STEP_PAST ('p')
-#define TRACE_EVENT_PHASE_ASYNC_END ('F')
-#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN ('b')
-#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_END ('e')
-#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT ('n')
-#define TRACE_EVENT_PHASE_FLOW_BEGIN ('s')
-#define TRACE_EVENT_PHASE_FLOW_STEP ('t')
-#define TRACE_EVENT_PHASE_FLOW_END ('f')
-#define TRACE_EVENT_PHASE_METADATA ('M')
-#define TRACE_EVENT_PHASE_COUNTER ('C')
-#define TRACE_EVENT_PHASE_SAMPLE ('P')
-#define TRACE_EVENT_PHASE_CREATE_OBJECT ('N')
-#define TRACE_EVENT_PHASE_SNAPSHOT_OBJECT ('O')
-#define TRACE_EVENT_PHASE_DELETE_OBJECT ('D')
-#define TRACE_EVENT_PHASE_MEMORY_DUMP ('v')
-#define TRACE_EVENT_PHASE_MARK ('R')
-#define TRACE_EVENT_PHASE_CLOCK_SYNC ('c')
-#define TRACE_EVENT_PHASE_ENTER_CONTEXT ('(')
-#define TRACE_EVENT_PHASE_LEAVE_CONTEXT (')')
-
-// Flags for changing the behavior of TRACE_EVENT_API_ADD_TRACE_EVENT.
-#define TRACE_EVENT_FLAG_NONE (static_cast<unsigned int>(0))
-#define TRACE_EVENT_FLAG_COPY (static_cast<unsigned int>(1 << 0))
-#define TRACE_EVENT_FLAG_HAS_ID (static_cast<unsigned int>(1 << 1))
-#define TRACE_EVENT_FLAG_SCOPE_OFFSET (static_cast<unsigned int>(1 << 2))
-#define TRACE_EVENT_FLAG_SCOPE_EXTRA (static_cast<unsigned int>(1 << 3))
-#define TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP (static_cast<unsigned int>(1 << 4))
-#define TRACE_EVENT_FLAG_ASYNC_TTS (static_cast<unsigned int>(1 << 5))
-#define TRACE_EVENT_FLAG_BIND_TO_ENCLOSING (static_cast<unsigned int>(1 << 6))
-#define TRACE_EVENT_FLAG_FLOW_IN (static_cast<unsigned int>(1 << 7))
-#define TRACE_EVENT_FLAG_FLOW_OUT (static_cast<unsigned int>(1 << 8))
-#define TRACE_EVENT_FLAG_HAS_CONTEXT_ID (static_cast<unsigned int>(1 << 9))
-#define TRACE_EVENT_FLAG_HAS_PROCESS_ID (static_cast<unsigned int>(1 << 10))
-#define TRACE_EVENT_FLAG_HAS_LOCAL_ID (static_cast<unsigned int>(1 << 11))
-#define TRACE_EVENT_FLAG_HAS_GLOBAL_ID (static_cast<unsigned int>(1 << 12))
-// TODO(eseckler): Remove once we have native support for typed proto events in
-// TRACE_EVENT macros.
-#define TRACE_EVENT_FLAG_TYPED_PROTO_ARGS (static_cast<unsigned int>(1 << 15))
-#define TRACE_EVENT_FLAG_JAVA_STRING_LITERALS \
-  (static_cast<unsigned int>(1 << 16))
-
-#define TRACE_EVENT_FLAG_SCOPE_MASK                          \
-  (static_cast<unsigned int>(TRACE_EVENT_FLAG_SCOPE_OFFSET | \
-                             TRACE_EVENT_FLAG_SCOPE_EXTRA))
-
-// Type values for identifying types in the TraceValue union.
-#define TRACE_VALUE_TYPE_BOOL (static_cast<unsigned char>(1))
-#define TRACE_VALUE_TYPE_UINT (static_cast<unsigned char>(2))
-#define TRACE_VALUE_TYPE_INT (static_cast<unsigned char>(3))
-#define TRACE_VALUE_TYPE_DOUBLE (static_cast<unsigned char>(4))
-#define TRACE_VALUE_TYPE_POINTER (static_cast<unsigned char>(5))
-#define TRACE_VALUE_TYPE_STRING (static_cast<unsigned char>(6))
-#define TRACE_VALUE_TYPE_COPY_STRING (static_cast<unsigned char>(7))
-#define TRACE_VALUE_TYPE_CONVERTABLE (static_cast<unsigned char>(8))
-#define TRACE_VALUE_TYPE_PROTO (static_cast<unsigned char>(9))
-
-// Enum reflecting the scope of an INSTANT event. Must fit within
-// TRACE_EVENT_FLAG_SCOPE_MASK.
-#define TRACE_EVENT_SCOPE_GLOBAL (static_cast<unsigned char>(0 << 2))
-#define TRACE_EVENT_SCOPE_PROCESS (static_cast<unsigned char>(1 << 2))
-#define TRACE_EVENT_SCOPE_THREAD (static_cast<unsigned char>(2 << 2))
-
-#define TRACE_EVENT_SCOPE_NAME_GLOBAL ('g')
-#define TRACE_EVENT_SCOPE_NAME_PROCESS ('p')
-#define TRACE_EVENT_SCOPE_NAME_THREAD ('t')
-
 #endif  // !defined(BASE_USE_PERFETTO_CLIENT_LIBRARY)
 #endif  // BASE_TRACE_EVENT_COMMON_TRACE_EVENT_COMMON_H_
diff --git a/base/trace_event/trace_event_ohos.cc b/base/trace_event/trace_event_ohos.cc
new file mode 100644
index 0000000000000..220d1dc59c4d6
--- /dev/null
+++ b/base/trace_event/trace_event_ohos.cc
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "base/trace_event/trace_event_ohos.h"
+ 
+#include "base/logging.h"
+#include "hitrace_meter.h"
+ 
+bool IsBytraceEnable() {
+#if defined(ENABLE_OHOS_BYTRACE)
+  return true;
+#endif
+  return false;
+}
+ 
+BytraceArg GetArg(double i) {
+  BytraceArg arg;
+  arg.value.as_double = i;
+  arg.type = TYPE_NUMBER;
+  return arg;
+}
+ 
+BytraceArg GetArg(const char* i) {
+  BytraceArg arg;
+  arg.value.as_string = i;
+  arg.type = TYPE_STRING;
+  return arg;
+}
+ 
+std::string GetStringFromArg(const BytraceArg& arg) {
+  switch (arg.type) {
+    case TYPE_NUMBER: {
+      return std::to_string(arg.value.as_double);
+    }
+    case TYPE_STRING: {
+      return arg.value.as_string;
+    }
+    default: {
+      return "UnsupportArgType";
+    }
+  }
+}
+ 
+std::string GetStringWithArgs(const std::string& name) {
+  return name;
+}
+ 
+void StartBytrace(const std::string& value) {
+#if defined(ENABLE_OHOS_BYTRACE)
+  StartTrace(HITRACE_TAG_NWEB, value);
+#endif
+}
+ 
+void FinishBytrace() {
+#if defined(ENABLE_OHOS_BYTRACE)
+  FinishTrace(HITRACE_TAG_NWEB);
+#endif
+}
+ 
+void StartAsyncBytrace(const std::string& value, int32_t taskId) {
+#if defined(ENABLE_OHOS_BYTRACE)
+  StartAsyncTrace(HITRACE_TAG_NWEB, value, taskId);
+#endif
+}
+ 
+void FinishAsyncBytrace(const std::string& value, int32_t taskId) {
+#if defined(ENABLE_OHOS_BYTRACE)
+  FinishAsyncTrace(HITRACE_TAG_NWEB, value, taskId);
+#endif
+}
+
+void CountBytrace(const std::string& name, int64_t count) {
+#if defined(ENABLE_OHOS_BYTRACE)
+  CountTrace(HITRACE_TAG_NWEB, name, count);
+#endif  
+}
+ 
+ScopedBytrace::ScopedBytrace(const std::string& proc) : proc_(proc) {
+#if defined(ENABLE_OHOS_BYTRACE)
+  StartTrace(HITRACE_TAG_NWEB, proc_);
+#endif
+}
+ 
+ScopedBytrace::~ScopedBytrace() {
+#if defined(ENABLE_OHOS_BYTRACE)
+  FinishTrace(HITRACE_TAG_NWEB);
+#endif
+}
diff --git a/base/trace_event/trace_event_ohos.h b/base/trace_event/trace_event_ohos.h
new file mode 100644
index 0000000000000..b46f5b85a53ab
--- /dev/null
+++ b/base/trace_event/trace_event_ohos.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef BASE_TRACE_EVENT_TRACE_EVENT_OHOS_H
+#define BASE_TRACE_EVENT_TRACE_EVENT_OHOS_H
+ 
+#include <string>
+#include <utility>
+ 
+union BytraceArgValue {
+  double as_double;
+  const char* as_string;
+};
+ 
+enum BytraceArgType {
+  TYPE_NUMBER,
+  TYPE_STRING,
+  TYPE_INVALID,
+};
+ 
+struct BytraceArg {
+  BytraceArgValue value;
+  BytraceArgType type;
+};
+ 
+bool IsBytraceEnable();
+BytraceArg GetArg(double i);
+BytraceArg GetArg(const char* i);
+std::string GetStringFromArg(const BytraceArg& arg);
+std::string GetStringWithArgs(const std::string& name);
+ 
+template <class ARG1_TYPE>
+std::string GetStringWithArgs(const std::string& name,
+                              const char* arg1_name,
+                              ARG1_TYPE&& arg1_val) {
+  if (IsBytraceEnable()) {
+    BytraceArg arg1 = GetArg(std::forward<ARG1_TYPE>(arg1_val));
+    return name + " | " + arg1_name + "=" + GetStringFromArg(arg1);
+  }
+  return "";
+}
+ 
+template <class ARG1_TYPE, class ARG2_TYPE>
+std::string GetStringWithArgs(const std::string& name,
+                              const char* arg1_name,
+                              ARG1_TYPE&& arg1_val,
+                              const char* arg2_name,
+                              ARG2_TYPE&& arg2_val) {
+  if (IsBytraceEnable()) {
+    BytraceArg arg1 = GetArg(std::forward<ARG1_TYPE>(arg1_val));
+    BytraceArg arg2 = GetArg(std::forward<ARG2_TYPE>(arg2_val));
+    return name + " | " + arg1_name + "=" + GetStringFromArg(arg1) + " | " +
+           arg2_name + "=" + GetStringFromArg(arg2);
+  }
+  return "";
+}
+  
+void StartBytrace(const std::string& value);
+void FinishBytrace();
+void StartAsyncBytrace(const std::string& value, int32_t taskId);
+void FinishAsyncBytrace(const std::string& value, int32_t taskId);
+void CountBytrace(const std::string& name, int64_t count);
+ 
+class ScopedBytrace {
+ public:
+  ScopedBytrace(const std::string& proc);
+  ~ScopedBytrace();
+ 
+ private:
+  std::string proc_;
+};
+ 
+#define OHOS_BY_TRACE_CONNENCT(a, b) a##b
+#define OHOS_BY_TRACE_NAME2(a, b) OHOS_BY_TRACE_CONNENCT(a, b)
+#define OHOS_BY_TRACE_NAME(a) OHOS_BY_TRACE_NAME2(a, __LINE__)
+ 
+#define BYTRACE_SCOPED(name, ...)            \
+  ScopedBytrace OHOS_BY_TRACE_NAME(bytrace)( \
+      GetStringWithArgs(name, ##__VA_ARGS__))
+ 
+#endif  // BASE_TRACE_EVENT_TRACE_EVENT_OHOS_H_
diff --git a/build/config/BUILD.gn b/build/config/BUILD.gn
index 56f458aba4cfe..4b3aa6e1125e1 100644
--- a/build/config/BUILD.gn
+++ b/build/config/BUILD.gn
@@ -123,13 +123,13 @@ config("ohos_nweb_ex_def_main") {
     defines = ohos_nweb_ex_defines_main
   }
 }
- 
+
 config("ohos_nweb_ex_def_blink") {
   if (defined(ohos_nweb_ex_config_name) && ohos_nweb_ex_config_name != "") {
     defines = ohos_nweb_ex_defines_blink_core
   }
 }
- 
+
 config("ohos_nweb_ex_def_other") {
   if (defined(ohos_nweb_ex_config_name) && ohos_nweb_ex_config_name != "") {
     defines = ohos_nweb_ex_defines_other
@@ -332,7 +332,8 @@ config("executable_config") {
       "//build/config/ios:ios_dynamic_flags",
       "//build/config/ios:ios_executable_flags",
     ]
-  } else if (is_linux || is_chromeos || is_android || current_os == "aix" || is_ohos) {
+  } else if (is_linux || is_chromeos || is_android || current_os == "aix" ||
+             is_ohos) {
     configs += [ "//build/config/gcc:executable_config" ]
     if (is_chromecast) {
       configs += [ "//build/config/chromecast:executable_config" ]
diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
index a7aa11cf3af05..500356ba09f44 100644
--- a/build/config/BUILDCONFIG.gn
+++ b/build/config/BUILDCONFIG.gn
@@ -50,7 +50,7 @@
 declare_args() {
   ohos_nweb_ex_config_name = ""
 }
- 
+
 if (ohos_nweb_ex_config_name != "") {
   import("$ohos_nweb_ex_config_name")
 }  #endif  // OHOS_NWEB_EX
@@ -398,8 +398,7 @@ if (is_debug) {
 #ifdef OHOS_NWEB_EX
 if (ohos_nweb_ex_config_name != "") {
   default_compiler_configs += [ "//build/config:ohos_nweb_ex_def_main" ]
-}
-# endif //OHOS_NWEB_EX
+} #endif //OHOS_NWEB_EX
 
 # Static libraries and source sets use only the compiler ones.
 set_defaults("static_library") {
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index af07fe80667ff..77be3c6f3f6d1 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -1521,6 +1521,8 @@ config("default_warnings") {
         "-Wno-error=macro-redefined",
         "-Wno-error=implicit-function-declaration",
         "-Wno-error=misleading-indentation",
+        "-Wno-error=psabi",
+        "-Wno-error=non-c-typedef-for-linkage",
       ]
     } else {
       cflags += [
diff --git a/build/config/gclient_args.gni b/build/config/gclient_args.gni
index e5dd90b8bb609..bdd393ddd0ae0 100644
--- a/build/config/gclient_args.gni
+++ b/build/config/gclient_args.gni
@@ -1,8 +1,8 @@
 # Generated from 'DEPS'
 build_with_chromium = true
-checkout_android = false
+checkout_android = true
 checkout_android_prebuilts_build_tools = false
-checkout_android_native_support = false
+checkout_android_native_support = true
 checkout_fuchsia_for_arm64_host = false
 checkout_google_benchmark = false
 checkout_ios_webkit = false
@@ -10,4 +10,4 @@ checkout_nacl = true
 checkout_openxr = false
 checkout_rts_model = false
 cros_boards = ""
-cros_boards_with_qemu_images = ""
\ No newline at end of file
+cros_boards_with_qemu_images = ""
diff --git a/build/config/ohos/BUILD.gn b/build/config/ohos/BUILD.gn
index 7461d2b0f77e7..bd0cfb17b51f3 100644
--- a/build/config/ohos/BUILD.gn
+++ b/build/config/ohos/BUILD.gn
@@ -91,7 +91,7 @@ config("compiler") {
   if (use_musl) {
     cflags += [ "--target=$abi_target" ]
     include_dirs = [
-      "$ohos_toolchain_root/include/c++/v1",
+      "$ohos_toolchain_root/include/libcxx-ohos/include/c++/v1",
     ]
     ldflags += [ "--target=$abi_target" ]
   } else {
@@ -136,8 +136,8 @@ config("runtime_library") {
     if (current_cpu == "arm") {
       ldflags += [ "-L" + rebase_path("$ohos_sysroot/usr/lib/arm-linux-ohos", root_build_dir) ]
       ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/arm-linux-ohos/c++", root_build_dir) ]
-      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohos", root_build_dir) ]
-      libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohos/libclang_rt.builtins.a"
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/clang/current/lib/arm-linux-ohos", root_build_dir) ]
+      libclang_rt_file = "$ohos_toolchain_root/lib/clang/current/lib/arm-linux-ohos/libclang_rt.builtins.a"
     }
 
     if (current_cpu == "arm64") {
@@ -145,8 +145,8 @@ config("runtime_library") {
       ldflags += [ "-Wl,--hash-style=gnu" ]
       ldflags += [ "-L" + rebase_path("$ohos_sysroot/usr/lib/aarch64-linux-ohos", root_build_dir) ]
       ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/aarch64-linux-ohos/c++", root_build_dir) ]
-      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/aarch64-linux-ohos", root_build_dir) ]
-      libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/aarch64-linux-ohos/libclang_rt.builtins.a"
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib/clang/current/lib/aarch64-linux-ohos", root_build_dir) ]
+      libclang_rt_file = "$ohos_toolchain_root/lib/clang/current/lib/aarch64-linux-ohos/libclang_rt.builtins.a"
     }
 
     libs += [
diff --git a/build/config/ohos/config.gni b/build/config/ohos/config.gni
index a29757adeedd9..88ac1b1389c7d 100644
--- a/build/config/ohos/config.gni
+++ b/build/config/ohos/config.gni
@@ -12,6 +12,9 @@ if (is_ohos) {
 
   declare_args() {
     use_ohos_sdk_sysroot = false
+
+    # enable ohos bytrace, false by default
+    enable_ohos_bytrace = true
   }
 
   declare_args() {
@@ -73,26 +76,24 @@ if (is_ohos) {
       "$ohos_build_root/foundation/bundlemanager/bundle_framework/interfaces/innerkits/libeventhandler/include",
 
       "$ohos_build_root/foundation/appexecfwk/standard/interfaces/innerkits/libeventhandler/include",
-      "$ohos_build_root/utils/native/base/include",
       "$ohos_build_root/base/hiviewdfx/hilog/interfaces/native/innerkits/include",
       "$ohos_build_root/foundation/graphic/graphic_2d/interfaces/inner_api/common",
       "$ohos_build_root/drivers/peripheral/display/interfaces/include",
       "$ohos_build_root/foundation/graphic/graphic_2d/utils/buffer_handle/export",
-      "$ohos_build_root/foundation/multimedia/media_standard/interfaces/innerkits/native/media/include",
-      "$ohos_build_root/foundation/multimedia/media_standard/interfaces/inner_api/native",
+      "$ohos_build_root/foundation/multimedia/player_framework/interfaces/inner_api/native",
       "$ohos_build_root/drivers/peripheral/base",
       "$ohos_build_root/foundation/graphic/graphic_2d/interfaces/inner_api/surface",
       "$ohos_build_root/foundation/graphic/surface/interfaces/kits",
       "$ohos_build_root/foundation/communication/ipc/interfaces/innerkits/ipc_core/include",
-      "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_controller/include",
-      "$ohos_build_root/base/miscservices/inputmethod/services/include",
-      "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_ability/include",
-      "$ohos_build_root/utils/native/base/include",
+      "$ohos_build_root/base/inputmethod/imf/frameworks/inputmethod_controller/include",
+      "$ohos_build_root/base/inputmethod/imf/services/include",
+      "$ohos_build_root/base/inputmethod/imf/frameworks/inputmethod_ability/include",
+      "$ohos_build_root/commonlibrary/c_utils/base/include",
       "$ohos_build_root/foundation/multimodalinput/input/interfaces/native/innerkits/event/include",
       "$ohos_build_root/base/location/utils/include",
       "$ohos_build_root/base/location/interfaces/innerkits/locator_standard/include",
       "$ohos_build_root/base/location/location_common/common/include",
-      "$ohos_build_root/foundation/distributedschedule/samgr/interfaces/innerkits/samgr_proxy/include",
+      "$ohos_build_root/foundation/systemabilitymgr/samgr/interfaces/innerkits/samgr_proxy/include",
       "$ohos_build_root/utils/system/safwk/native/include",
       "$ohos_build_root/foundation/aafwk/standard/interfaces/innerkits/base/include",
       "$ohos_build_root/foundation/aafwk/standard/interfaces/innerkits/want/include/ohos/aafwk/content",
@@ -110,27 +111,29 @@ if (is_ohos) {
       "$ohos_build_root/base/location/interfaces/inner_api/include",
       "$ohos_build_root/base/location/services/utils/include",
       "$ohos_build_root/base/location/services/location_locator/callback/include",
+      "$ohos_build_root/base/hiviewdfx/hitrace/interfaces/native/innerkits/include/hitrace_meter",
+      "$ohos_build_root/base/hiviewdfx/hisysevent/interfaces/native/innerkits/hisysevent/include/",
     ]
 
     if (use_musl) {
       if (current_cpu == "arm") {
-        ohos_libs_dir =
-            [ "$ohos_build_root/out/rk3568/packages/phone/system/lib" ]
+        ohos_libs_root = "$ohos_build_root/out/rk3568/packages/phone/system/lib"
       } else if (current_cpu == "arm64") {
-        ohos_libs_dir =
-            [ "$ohos_build_root/out/rk3568/packages/phone/system/lib64" ]
+        ohos_libs_root = "$ohos_build_root/out/rk3568/packages/phone/system/lib64"
       }
     } else {
       if (current_cpu == "arm") {
-        ohos_libs_dir = [
-          "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib",
-        ]
+          ohos_libs_root = "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib"
       } else if (current_cpu == "arm64") {
-        ohos_libs_dir = [
-          "$ohos_build_root/out/ohos-arm64-release/packages/phone/system/lib64",
-        ]
+          ohos_libs_root = "$ohos_build_root/out/ohos-arm64-release/packages/phone/system/lib64"
       }
     }
+
+    ohos_libs_dir = [
+      "$ohos_libs_root",
+      "$ohos_libs_root/chipset-pub-sdk",
+      "$ohos_libs_root/platformsdk",
+    ]
   } else {
     if (use_musl) {
       ohos_build_root = "//ohos_ndk"
@@ -184,6 +187,8 @@ if (is_ohos) {
       "$ohos_build_root/includes/json",
       "$ohos_build_root/includes/appexecfwk",
       "$ohos_build_root/includes/ohos_adapter",
+      "$ohos_build_root/includes/hitrace_meter",
+      "$ohos_build_root/includes/hisysevent",
     ]
 
     if (current_cpu == "arm") {
diff --git a/build/config/sanitizers/BUILD.gn b/build/config/sanitizers/BUILD.gn
index f90b3318ea627..166e8adf5995d 100644
--- a/build/config/sanitizers/BUILD.gn
+++ b/build/config/sanitizers/BUILD.gn
@@ -609,3 +609,23 @@ config("not_fuzzed") {
     }
   }
 }
+
+config("cfi_config") {
+  if (is_ohos) {
+    _cfi_blocklist_path = "//tools/cfi/ignores.txt"
+
+    cflags = [
+      "-flto=thin",
+      "-fvisibility=default",
+      "-fsanitize=cfi-icall",
+      "-fsanitize-cfi-icall-generalize-pointers",
+      "-fsanitize-blacklist=" + rebase_path(_cfi_blocklist_path, root_build_dir),
+    ]
+
+    ldflags = [
+      "-flto=thin",
+      "-fsanitize=cfi-icall",
+      "-fsanitize-cfi-icall-generalize-pointers",
+    ]
+  }
+}
diff --git a/cc/trees/layer_tree_host.cc b/cc/trees/layer_tree_host.cc
index 3e6161e2c79e0..001a944de5226 100644
--- a/cc/trees/layer_tree_host.cc
+++ b/cc/trees/layer_tree_host.cc
@@ -73,6 +73,9 @@
 #include "ui/gfx/geometry/size_conversions.h"
 #include "ui/gfx/geometry/vector2d_conversions.h"
 #include "ui/gfx/presentation_feedback.h"
+#if defined(OS_OHOS)
+#include "cef/libcef/common/soc_perf_util.h"
+#endif
 
 namespace {
 static base::AtomicSequenceNumber s_layer_tree_host_sequence_number;
@@ -690,6 +693,11 @@ void LayerTreeHost::ApplyPageScaleDeltaFromImplSide(float page_scale_delta) {
   SetPageScaleFromImplSide(page_scale);
 }
 
+void LayerTreeHost::SetPinchSmoothMode(bool isEnable)
+{
+  proxy_->SetPinchSmoothMode(isEnable);
+}
+
 void LayerTreeHost::SetVisible(bool visible) {
   if (visible_ == visible)
     return;
@@ -1479,6 +1487,9 @@ Layer* LayerTreeHost::LayerById(int id) const {
 bool LayerTreeHost::PaintContent(const LayerList& update_layer_list) {
   base::AutoReset<bool> painting(&in_paint_layer_contents_, true);
   bool did_paint_content = false;
+#if defined(OS_OHOS)
+  soc_perf::layer_num = update_layer_list.size();
+#endif
   for (const auto& layer : update_layer_list) {
     did_paint_content |= layer->Update();
   }
diff --git a/cc/trees/layer_tree_host.h b/cc/trees/layer_tree_host.h
index ec44f47b6d5ba..3973b733e86cd 100644
--- a/cc/trees/layer_tree_host.h
+++ b/cc/trees/layer_tree_host.h
@@ -208,6 +208,7 @@ class CC_EXPORT LayerTreeHost : public MutatorHostClient {
   // to make it visible before it will attempt to start producing output.
   void SetVisible(bool visible);
   bool IsVisible() const;
+  void SetPinchSmoothMode(bool isEnable);
 
   // Called in response to a LayerTreeFrameSink request made to the client
   // using LayerTreeHostClient::RequestNewLayerTreeFrameSink. The client will
diff --git a/cc/trees/proxy.h b/cc/trees/proxy.h
index 44c40243afcf9..75171da13f288 100644
--- a/cc/trees/proxy.h
+++ b/cc/trees/proxy.h
@@ -43,6 +43,7 @@ class CC_EXPORT Proxy {
   virtual void ReleaseLayerTreeFrameSink() = 0;
 
   virtual void SetVisible(bool visible) = 0;
+  virtual void SetPinchSmoothMode(bool isEnable) = 0;
 
   virtual void SetNeedsAnimate() = 0;
   virtual void SetNeedsUpdateLayers() = 0;
diff --git a/cc/trees/proxy_impl.cc b/cc/trees/proxy_impl.cc
index aa091df7780ee..3ade670146d3d 100644
--- a/cc/trees/proxy_impl.cc
+++ b/cc/trees/proxy_impl.cc
@@ -207,6 +207,11 @@ void ProxyImpl::SetVisibleOnImpl(bool visible) {
   scheduler_->SetVisible(visible);
 }
 
+void ProxyImpl::SetPinchSmoothModeOnImpl(bool isEnable) {
+  DCHECK(IsImplThread());
+  pinch_smooth_ = isEnable;
+}
+
 void ProxyImpl::ReleaseLayerTreeFrameSinkOnImpl(CompletionEvent* completion) {
   DCHECK(IsImplThread());
 
@@ -367,8 +372,11 @@ void ProxyImpl::SetNeedsPrepareTilesOnImplThread() {
 }
 
 void ProxyImpl::SetNeedsCommitOnImplThread() {
-  TRACE_EVENT0("cc", "ProxyImpl::SetNeedsCommitOnImplThread");
   DCHECK(IsImplThread());
+  if ((pinch_smooth_) && (host_impl_->IsPinchGestureActive())) {
+    TRACE_EVENT0("cc", "ProxyImpl::SetNeedsCommitOnImplThread pinch smooth");
+    return;
+  }
   scheduler_->SetNeedsBeginMainFrame();
 }
 
@@ -709,6 +717,10 @@ void ProxyImpl::ScheduledActionBeginLayerTreeFrameSinkCreation() {
 void ProxyImpl::ScheduledActionPrepareTiles() {
   TRACE_EVENT0("cc", "ProxyImpl::ScheduledActionPrepareTiles");
   DCHECK(IsImplThread());
+  if ((pinch_smooth_) && (host_impl_->IsPinchGestureActive())) {
+    TRACE_EVENT0("cc", "ProxyImpl::ScheduledActionPrepareTiles pinch smooth");
+    return;
+  }
   host_impl_->PrepareTiles();
 }
 
diff --git a/cc/trees/proxy_impl.h b/cc/trees/proxy_impl.h
index 05eb84ed3ebdd..e4c84107fcea1 100644
--- a/cc/trees/proxy_impl.h
+++ b/cc/trees/proxy_impl.h
@@ -59,6 +59,7 @@ class CC_EXPORT ProxyImpl : public LayerTreeHostImplClient,
       base::TimeTicks main_thread_start_time,
       std::vector<std::unique_ptr<SwapPromise>> swap_promises);
   void SetVisibleOnImpl(bool visible);
+  void SetPinchSmoothModeOnImpl(bool isEnable);
   void ReleaseLayerTreeFrameSinkOnImpl(CompletionEvent* completion);
   void FinishGLOnImpl(CompletionEvent* completion);
   void NotifyReadyToCommitOnImpl(CompletionEvent* completion,
@@ -180,6 +181,8 @@ class CC_EXPORT ProxyImpl : public LayerTreeHostImplClient,
 
   bool inside_draw_;
 
+  bool pinch_smooth_ = false;
+
   bool send_compositor_frame_ack_;
 
   JankInjector jank_injector_;
diff --git a/cc/trees/proxy_main.cc b/cc/trees/proxy_main.cc
index 6f1e341a7303c..d27f0a1456910 100644
--- a/cc/trees/proxy_main.cc
+++ b/cc/trees/proxy_main.cc
@@ -124,7 +124,6 @@ void ProxyMain::BeginMainFrame(
   DCHECK_EQ(NO_PIPELINE_STAGE, current_pipeline_stage_);
 
   base::TimeTicks begin_main_frame_start_time = base::TimeTicks::Now();
-
   benchmark_instrumentation::ScopedBeginFrameTask begin_frame_task(
       benchmark_instrumentation::kDoBeginFrame,
       begin_main_frame_state->begin_frame_args.frame_id.sequence_number);
@@ -425,6 +424,12 @@ void ProxyMain::SetVisible(bool visible) {
                                 base::Unretained(proxy_impl_.get()), visible));
 }
 
+void ProxyMain::SetPinchSmoothMode(bool isEnable) {
+  TRACE_EVENT1("cc", "ProxyMain::SetPinchSmoothMode", "isEnable", isEnable);
+  ImplThreadTaskRunner()->PostTask(
+      FROM_HERE, base::BindOnce(&ProxyImpl::SetPinchSmoothModeOnImpl,
+                                base::Unretained(proxy_impl_.get()), isEnable));
+}
 void ProxyMain::SetNeedsAnimate() {
   DCHECK(IsMainThread());
   if (SendCommitRequestToImplThreadIfNeeded(ANIMATE_PIPELINE_STAGE)) {
diff --git a/cc/trees/proxy_main.h b/cc/trees/proxy_main.h
index 186de9d07b6e7..b96b05c22a175 100644
--- a/cc/trees/proxy_main.h
+++ b/cc/trees/proxy_main.h
@@ -80,6 +80,7 @@ class CC_EXPORT ProxyMain : public Proxy {
   void SetLayerTreeFrameSink(
       LayerTreeFrameSink* layer_tree_frame_sink) override;
   void SetVisible(bool visible) override;
+  void SetPinchSmoothMode(bool isEnable) override;
   void SetNeedsAnimate() override;
   void SetNeedsUpdateLayers() override;
   void SetNeedsCommit() override;
@@ -144,7 +145,6 @@ class CC_EXPORT ProxyMain : public Proxy {
   // Set when the Proxy is started using Proxy::Start() and reset when it is
   // stopped using Proxy::Stop().
   bool started_;
-
   // defer_main_frame_update_ will also cause commits to be deferred, regardless
   // of the setting for defer_commits_.
   bool defer_main_frame_update_;
diff --git a/cc/trees/single_thread_proxy.cc b/cc/trees/single_thread_proxy.cc
index 447a6efb019cf..dbe39e745e2fe 100644
--- a/cc/trees/single_thread_proxy.cc
+++ b/cc/trees/single_thread_proxy.cc
@@ -118,6 +118,11 @@ void SingleThreadProxy::SetVisible(bool visible) {
     scheduler_on_impl_thread_->SetVisible(host_impl_->visible());
 }
 
+void SingleThreadProxy::SetPinchSmoothMode(bool isEnable)
+{
+  return;
+}
+
 void SingleThreadProxy::RequestNewLayerTreeFrameSink() {
   DCHECK(task_runner_provider_->IsMainThread());
   layer_tree_frame_sink_creation_callback_.Cancel();
diff --git a/cc/trees/single_thread_proxy.h b/cc/trees/single_thread_proxy.h
index 246df6800cb28..a332b260da1c5 100644
--- a/cc/trees/single_thread_proxy.h
+++ b/cc/trees/single_thread_proxy.h
@@ -48,6 +48,7 @@ class CC_EXPORT SingleThreadProxy : public Proxy,
       LayerTreeFrameSink* layer_tree_frame_sink) override;
   void ReleaseLayerTreeFrameSink() override;
   void SetVisible(bool visible) override;
+  void SetPinchSmoothMode(bool isEnable) override;
   void SetNeedsAnimate() override;
   void SetNeedsUpdateLayers() override;
   void SetNeedsCommit() override;
diff --git a/cef/BUILD.gn b/cef/BUILD.gn
index 0abd6cd0686dd..ce378795f1c9a 100644
--- a/cef/BUILD.gn
+++ b/cef/BUILD.gn
@@ -410,6 +410,8 @@ static_library("libcef_static") {
     "libcef/browser/alloy/alloy_browser_host_impl.h",
     "libcef/browser/alloy/alloy_browser_main.cc",
     "libcef/browser/alloy/alloy_browser_main.h",
+    "libcef/browser/alloy/alloy_client_cert_lookup_table.cc",
+    "libcef/browser/alloy/alloy_client_cert_lookup_table.h",
     "libcef/browser/alloy/browser_platform_delegate_alloy.cc",
     "libcef/browser/alloy/browser_platform_delegate_alloy.h",
     "libcef/browser/alloy/chrome_browser_process_alloy.cc",
@@ -598,6 +600,8 @@ static_library("libcef_static") {
     "libcef/browser/net_service/resource_request_handler_wrapper.h",
     "libcef/browser/net_service/response_filter_wrapper.cc",
     "libcef/browser/net_service/response_filter_wrapper.h",
+    "libcef/browser/net_service/restrict_cookie_manager.cc",
+    "libcef/browser/net_service/restrict_cookie_manager.h",
     "libcef/browser/net_service/stream_reader_url_loader.cc",
     "libcef/browser/net_service/stream_reader_url_loader.h",
     "libcef/browser/net_service/url_loader_factory_getter.cc",
@@ -850,6 +854,8 @@ static_library("libcef_static") {
     "libcef/common/javascript/oh_gin_javascript_bridge_errors.cc",
     "libcef/common/javascript/oh_gin_javascript_bridge_value.h",
     "libcef/common/javascript/oh_gin_javascript_bridge_value.cc",
+    "libcef/common/soc_perf_util.h",
+    "libcef/common/soc_perf_util.cc",
     "libcef/renderer/javascript/oh_gin_javascript_bridge_dispatcher.h",
     "libcef/renderer/javascript/oh_gin_javascript_bridge_dispatcher.cc",
     "libcef/renderer/javascript/oh_gin_javascript_bridge_object.h",
@@ -989,6 +995,10 @@ static_library("libcef_static") {
     "//v8",
   ]
 
+  if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
+    deps += [ "//ohos_nweb_ex/overrides/cef" ]
+  }
+
   if (safe_browsing_mode != 0) {
     deps += [
       "//components/safe_browsing/core/db:test_database_manager"
@@ -1341,6 +1351,7 @@ config("libcef_dll_wrapper_config") {
 
 # libcef_dll_wrapper target.
 static_library("libcef_dll_wrapper") {
+  configs += [ "//build/config/sanitizers:cfi_config" ]
   sources = includes_common +
             gypi_paths.autogen_cpp_includes +
             gypi_paths2.includes_capi +
@@ -1700,6 +1711,7 @@ if (is_mac) {
   }
 } else {
   shared_library("libweb_engine") {
+    configs += [ "//build/config/sanitizers:cfi_config" ]
     sources = includes_common +
               gypi_paths.autogen_cpp_includes +
               gypi_paths2.includes_capi +
diff --git a/cef/cef_paths.gypi b/cef/cef_paths.gypi
index 65dff606c946e..e670c964caf18 100644
--- a/cef/cef_paths.gypi
+++ b/cef/cef_paths.gypi
@@ -8,7 +8,7 @@
 # by hand. See the translator.README.txt file in the tools directory for
 # more information.
 #
-# $hash=6877e69cfc3e737c9e7d4d00f15ea2f54b920548$
+# $hash=6a1c80139f8a8e0c57947fdea15bb43ebf38bb3a$
 #
 
 {
@@ -452,6 +452,8 @@
       'libcef_dll/ctocpp/server_handler_ctocpp.h',
       'libcef_dll/ctocpp/set_cookie_callback_ctocpp.cc',
       'libcef_dll/ctocpp/set_cookie_callback_ctocpp.h',
+      'libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.cc',
+      'libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.h',
       'libcef_dll/cpptoc/stream_reader_cpptoc.cc',
       'libcef_dll/cpptoc/stream_reader_cpptoc.h',
       'libcef_dll/cpptoc/stream_writer_cpptoc.cc',
@@ -782,6 +784,8 @@
       'libcef_dll/cpptoc/server_handler_cpptoc.h',
       'libcef_dll/cpptoc/set_cookie_callback_cpptoc.cc',
       'libcef_dll/cpptoc/set_cookie_callback_cpptoc.h',
+      'libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.cc',
+      'libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.h',
       'libcef_dll/ctocpp/stream_reader_ctocpp.cc',
       'libcef_dll/ctocpp/stream_reader_ctocpp.h',
       'libcef_dll/ctocpp/stream_writer_ctocpp.cc',
diff --git a/cef/include/capi/cef_browser_capi.h b/cef/include/capi/cef_browser_capi.h
index cb0c862369a17..7e116c76ac1b0 100644
--- a/cef/include/capi/cef_browser_capi.h
+++ b/cef/include/capi/cef_browser_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=c7e8c9198b6035c7a1a9e587bb5f1e14ec06c424$
+// $hash=c249481057088a3aae444f478f168880c5bb02c8$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_BROWSER_CAPI_H_
@@ -58,6 +58,7 @@ extern "C" {
 struct _cef_browser_host_t;
 struct _cef_client_t;
 struct _cef_java_script_result_callback_t;
+struct _cef_store_web_archive_result_callback_t;
 
 ///
 // Structure used to represent a browser window. When used in the browser
@@ -135,6 +136,13 @@ typedef struct _cef_browser_t {
   ///
   void(CEF_CALLBACK* reload_original_url)(struct _cef_browser_t* self);
 
+  ///
+  // Set user agent for current page.
+  ///
+  void(CEF_CALLBACK* set_browser_user_agent_string)(
+      struct _cef_browser_t* self,
+      const cef_string_t* user_agent);
+
   ///
   // Stop loading the page.
   ///
@@ -499,7 +507,8 @@ typedef struct _cef_browser_host_t {
                            const cef_string_t* searchText,
                            int forward,
                            int matchCase,
-                           int findNext);
+                           int findNext,
+                           int newSession);
 
   ///
   // Cancel all searches that are currently going on.
@@ -655,6 +664,12 @@ typedef struct _cef_browser_host_t {
   void(CEF_CALLBACK* notify_screen_info_changed)(
       struct _cef_browser_host_t* self);
 
+  ///
+  // Set the virtual pixel ratio
+  ///
+  void(CEF_CALLBACK* set_virtual_pixel_ratio)(struct _cef_browser_host_t* self,
+                                              float ratio);
+
   ///
   // Invalidate the view. The browser will call cef_render_handler_t::OnPaint
   // asynchronously. This function is only used when window rendering is
@@ -797,12 +812,62 @@ typedef struct _cef_browser_host_t {
       const cef_string_t* object_name,
       cef_string_list_t method_list);
 
+  ///
+  // Saves the current view as a web archive.
+  ///
+  void(CEF_CALLBACK* store_web_archive)(
+      struct _cef_browser_host_t* self,
+      const cef_string_t* base_name,
+      int auto_name,
+      struct _cef_store_web_archive_result_callback_t* callback);
+
   ///
   // Gets the title for the current page.
   ///
   // The resulting string must be freed by calling cef_string_userfree_free().
   cef_string_userfree_t(CEF_CALLBACK* title)(struct _cef_browser_host_t* self);
 
+  ///
+  // Create a message channel, which include two message ports.
+  ///
+  void(CEF_CALLBACK* create_web_message_ports)(struct _cef_browser_host_t* self,
+                                               cef_string_list_t ports);
+
+  ///
+  // Posts a MessageEvent to the main frame.
+  ///
+  void(CEF_CALLBACK* post_web_message)(struct _cef_browser_host_t* self,
+                                       cef_string_t* message,
+                                       cef_string_list_t ports,
+                                       cef_string_t* targetUri);
+
+  ///
+  // Close the web message port.
+  ///
+  void(CEF_CALLBACK* close_port)(struct _cef_browser_host_t* self,
+                                 cef_string_t* port_handle);
+
+  ///
+  // Destroy all web message ports.
+  ///
+  void(CEF_CALLBACK* destroy_all_web_message_ports)(
+      struct _cef_browser_host_t* self);
+
+  ///
+  // Post a message to the port.
+  ///
+  void(CEF_CALLBACK* post_port_message)(struct _cef_browser_host_t* self,
+                                        cef_string_t* port_handle,
+                                        cef_string_t* data);
+
+  ///
+  // Set the callback of the port.
+  ///
+  void(CEF_CALLBACK* set_port_message_callback)(
+      struct _cef_browser_host_t* self,
+      cef_string_t* port_handle,
+      struct _cef_java_script_result_callback_t* callback);
+
   ///
   // Gets the latest hitdata
   ///
@@ -1143,6 +1208,25 @@ typedef struct _cef_java_script_result_callback_t {
       const cef_string_t* result);
 } cef_java_script_result_callback_t;
 
+///
+// Structure to implement to be notified of asynchronous completion via
+// cef_browser_host_tBase::store_web_archive().
+///
+typedef struct _cef_store_web_archive_result_callback_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // Method that will be called upon completion. |result| will either be the
+  // filename under which the file was saved, or NULL if saving the file failed.
+  ///
+  void(CEF_CALLBACK* on_store_web_archive_done)(
+      struct _cef_store_web_archive_result_callback_t* self,
+      const cef_string_t* result);
+} cef_store_web_archive_result_callback_t;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/cef/include/capi/cef_cookie_capi.h b/cef/include/capi/cef_cookie_capi.h
index 86a809cd43fbf..fe865a0831b00 100644
--- a/cef/include/capi/cef_cookie_capi.h
+++ b/cef/include/capi/cef_cookie_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=f56fb7f36efbc915453237ce10712eb49e436b00$
+// $hash=76bce0d14b3cfcc4afb47d59936e4f2e0932566b$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_COOKIE_CAPI_H_
@@ -75,6 +75,20 @@ typedef struct _cef_cookie_manager_t {
       struct _cef_cookie_manager_t* self,
       int accept);
 
+  ///
+  // Gets whether cookies of third parties are allowed to be set. Returns false
+  // (0) if can't.
+  ///
+  int(CEF_CALLBACK* is_third_party_cookie_allowed)(
+      struct _cef_cookie_manager_t* self);
+
+  ///
+  // Set whether cookies of third parties are allowed to be set.
+  ///
+  void(CEF_CALLBACK* put_accept_third_party_cookie_enabled)(
+      struct _cef_cookie_manager_t* self,
+      int accept);
+
   ///
   // Get whether this cookie manager can accpet and send cookies for file scheme
   // URL. Returns false (0) if can't.
diff --git a/cef/include/capi/cef_data_base_capi.h b/cef/include/capi/cef_data_base_capi.h
index e276ce87c91c1..31f65bb52d3de 100644
--- a/cef/include/capi/cef_data_base_capi.h
+++ b/cef/include/capi/cef_data_base_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=ec6ed1e2d5ec96630f13da6fa95395d1147ec032$
+// $hash=d2a63576b59c75e748b5a725af9a4337414c82b9$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_DATA_BASE_CAPI_H_
@@ -81,6 +81,48 @@ typedef struct _cef_data_base_t {
   void(CEF_CALLBACK *get_http_auth_credentials)(
       struct _cef_data_base_t *self, const cef_string_t *host,
       const cef_string_t *realm, cef_string_list_t username_password);
+
+  ///
+  // gets whether the instance holds the specified permissions for the specified
+  // source.
+  ///
+  int(CEF_CALLBACK *exist_permission_by_origin)(struct _cef_data_base_t *self,
+                                                const cef_string_t *origin,
+                                                int type);
+
+  ///
+  // get specifies permission type result by origin.
+  ///
+  int(CEF_CALLBACK *get_permission_result_by_origin)(
+      struct _cef_data_base_t *self, const cef_string_t *origin, int type,
+      int *result);
+
+  ///
+  // set specifies permission type by origin.
+  ///
+  void(CEF_CALLBACK *set_permission_by_origin)(struct _cef_data_base_t *self,
+                                               const cef_string_t *origin,
+                                               int type, int result);
+
+  ///
+  // delete specifies permission type by origin.
+  ///
+  void(CEF_CALLBACK *clear_permission_by_origin)(struct _cef_data_base_t *self,
+                                                 const cef_string_t *origin,
+                                                 int type);
+
+  ///
+  // delete all specifies permission type.
+  ///
+  void(CEF_CALLBACK *clear_all_permission)(struct _cef_data_base_t *self,
+                                           int type);
+
+  ///
+  // obtains all origins of a specified permission type.
+  ///
+  void(CEF_CALLBACK *get_origins_by_permission)(struct _cef_data_base_t *self,
+                                                int type,
+                                                cef_string_list_t origins);
 } cef_data_base_t;
 
 ///
diff --git a/cef/include/capi/cef_render_handler_capi.h b/cef/include/capi/cef_render_handler_capi.h
index 0bbd5a9528f1b..6a390f26a7750 100644
--- a/cef/include/capi/cef_render_handler_capi.h
+++ b/cef/include/capi/cef_render_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=abc9692a81344244c2936c37b1a2d1bcd7bf697a$
+// $hash=50df1cb9393d36c975aecddb2775ada0d8b9eeec$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_RENDER_HANDLER_CAPI_H_
@@ -63,36 +63,34 @@ typedef struct _cef_render_handler_t {
   // Return the handler for accessibility notifications. If no handler is
   // provided the default implementation will be used.
   ///
-  struct _cef_accessibility_handler_t*(CEF_CALLBACK* get_accessibility_handler)(
-      struct _cef_render_handler_t* self);
+  struct _cef_accessibility_handler_t *(
+      CEF_CALLBACK *get_accessibility_handler)(
+      struct _cef_render_handler_t *self);
 
   ///
   // Called to retrieve the root window rectangle in screen coordinates. Return
   // true (1) if the rectangle was provided. If this function returns false (0)
   // the rectangle from GetViewRect will be used.
   ///
-  int(CEF_CALLBACK* get_root_screen_rect)(struct _cef_render_handler_t* self,
-                                          struct _cef_browser_t* browser,
-                                          cef_rect_t* rect);
+  int(CEF_CALLBACK *get_root_screen_rect)(struct _cef_render_handler_t *self,
+                                          struct _cef_browser_t *browser,
+                                          cef_rect_t *rect);
 
   ///
   // Called to retrieve the view rectangle which is relative to screen
   // coordinates. This function must always provide a non-NULL rectangle.
   ///
-  void(CEF_CALLBACK* get_view_rect)(struct _cef_render_handler_t* self,
-                                    struct _cef_browser_t* browser,
-                                    cef_rect_t* rect);
+  void(CEF_CALLBACK *get_view_rect)(struct _cef_render_handler_t *self,
+                                    struct _cef_browser_t *browser,
+                                    cef_rect_t *rect);
 
   ///
   // Called to retrieve the translation from view coordinates to actual screen
   // coordinates. Return true (1) if the screen coordinates were provided.
   ///
-  int(CEF_CALLBACK* get_screen_point)(struct _cef_render_handler_t* self,
-                                      struct _cef_browser_t* browser,
-                                      int viewX,
-                                      int viewY,
-                                      int* screenX,
-                                      int* screenY);
+  int(CEF_CALLBACK *get_screen_point)(struct _cef_render_handler_t *self,
+                                      struct _cef_browser_t *browser, int viewX,
+                                      int viewY, int *screenX, int *screenY);
 
   ///
   // Called to allow the client to fill in the CefScreenInfo object with
@@ -103,25 +101,24 @@ typedef struct _cef_render_handler_t {
   // will be used. If the rectangle is still NULL or invalid popups may not be
   // drawn correctly.
   ///
-  int(CEF_CALLBACK* get_screen_info)(struct _cef_render_handler_t* self,
-                                     struct _cef_browser_t* browser,
-                                     struct _cef_screen_info_t* screen_info);
+  int(CEF_CALLBACK *get_screen_info)(struct _cef_render_handler_t *self,
+                                     struct _cef_browser_t *browser,
+                                     struct _cef_screen_info_t *screen_info);
 
   ///
   // Called when the browser wants to show or hide the popup widget. The popup
   // should be shown if |show| is true (1) and hidden if |show| is false (0).
   ///
-  void(CEF_CALLBACK* on_popup_show)(struct _cef_render_handler_t* self,
-                                    struct _cef_browser_t* browser,
-                                    int show);
+  void(CEF_CALLBACK *on_popup_show)(struct _cef_render_handler_t *self,
+                                    struct _cef_browser_t *browser, int show);
 
   ///
   // Called when the browser wants to move or resize the popup widget. |rect|
   // contains the new location and size in view coordinates.
   ///
-  void(CEF_CALLBACK* on_popup_size)(struct _cef_render_handler_t* self,
-                                    struct _cef_browser_t* browser,
-                                    const cef_rect_t* rect);
+  void(CEF_CALLBACK *on_popup_size)(struct _cef_render_handler_t *self,
+                                    struct _cef_browser_t *browser,
+                                    const cef_rect_t *rect);
 
   ///
   // Called when an element should be painted. Pixel values passed to this
@@ -134,14 +131,12 @@ typedef struct _cef_render_handler_t {
   // upper-left origin. This function is only called when
   // cef_window_tInfo::shared_texture_enabled is set to false (0).
   ///
-  void(CEF_CALLBACK* on_paint)(struct _cef_render_handler_t* self,
-                               struct _cef_browser_t* browser,
+  void(CEF_CALLBACK *on_paint)(struct _cef_render_handler_t *self,
+                               struct _cef_browser_t *browser,
                                cef_paint_element_type_t type,
                                size_t dirtyRectsCount,
-                               cef_rect_t const* dirtyRects,
-                               const void* buffer,
-                               int width,
-                               int height);
+                               cef_rect_t const *dirtyRects, const void *buffer,
+                               int width, int height);
 
   ///
   // Called when an element has been rendered to the shared texture handle.
@@ -152,31 +147,39 @@ typedef struct _cef_render_handler_t {
   // This function is only called when cef_window_tInfo::shared_texture_enabled
   // is set to true (1), and is currently only supported on Windows.
   ///
-  void(CEF_CALLBACK* on_accelerated_paint)(struct _cef_render_handler_t* self,
-                                           struct _cef_browser_t* browser,
+  void(CEF_CALLBACK *on_accelerated_paint)(struct _cef_render_handler_t *self,
+                                           struct _cef_browser_t *browser,
                                            cef_paint_element_type_t type,
                                            size_t dirtyRectsCount,
-                                           cef_rect_t const* dirtyRects,
-                                           void* shared_handle);
+                                           cef_rect_t const *dirtyRects,
+                                           void *shared_handle);
 
   ///
   // Called to retrieve the size of the touch handle for the specified
   // |orientation|.
   ///
-  void(CEF_CALLBACK* get_touch_handle_size)(
-      struct _cef_render_handler_t* self,
-      struct _cef_browser_t* browser,
-      cef_horizontal_alignment_t orientation,
-      cef_size_t* size);
+  void(CEF_CALLBACK *get_touch_handle_size)(
+      struct _cef_render_handler_t *self, struct _cef_browser_t *browser,
+      cef_horizontal_alignment_t orientation, cef_size_t *size);
 
   ///
   // Called when touch handle state is updated. The client is responsible for
   // rendering the touch handles.
   ///
-  void(CEF_CALLBACK* on_touch_handle_state_changed)(
-      struct _cef_render_handler_t* self,
-      struct _cef_browser_t* browser,
-      const struct _cef_touch_handle_state_t* state);
+  void(CEF_CALLBACK *on_touch_handle_state_changed)(
+      struct _cef_render_handler_t *self, struct _cef_browser_t *browser,
+      const struct _cef_touch_handle_state_t *state);
+
+  ///
+  // Called when touch selection is updated. The client is responsible for
+  // rendering the touch handles.
+  ///
+  void(CEF_CALLBACK *on_touch_selection_changed)(
+      struct _cef_render_handler_t *self,
+      const struct _cef_touch_handle_state_t *insert_handle,
+      const struct _cef_touch_handle_state_t *start_selection_handle,
+      const struct _cef_touch_handle_state_t *end_selection_handle,
+      int need_report);
 
   ///
   // Called when the user starts dragging content in the web view. Contextual
@@ -192,76 +195,68 @@ typedef struct _cef_render_handler_t {
   // synchronously or asynchronously to inform the web view that the drag
   // operation has ended.
   ///
-  int(CEF_CALLBACK* start_dragging)(struct _cef_render_handler_t* self,
-                                    struct _cef_browser_t* browser,
-                                    struct _cef_drag_data_t* drag_data,
+  int(CEF_CALLBACK *start_dragging)(struct _cef_render_handler_t *self,
+                                    struct _cef_browser_t *browser,
+                                    struct _cef_drag_data_t *drag_data,
                                     cef_drag_operations_mask_t allowed_ops,
-                                    int x,
-                                    int y);
+                                    int x, int y);
 
   ///
   // Called when the web view wants to update the mouse cursor during a drag &
   // drop operation. |operation| describes the allowed operation (none, move,
   // copy, link).
   ///
-  void(CEF_CALLBACK* update_drag_cursor)(struct _cef_render_handler_t* self,
-                                         struct _cef_browser_t* browser,
+  void(CEF_CALLBACK *update_drag_cursor)(struct _cef_render_handler_t *self,
+                                         struct _cef_browser_t *browser,
                                          cef_drag_operations_mask_t operation);
 
   ///
   // Called when the scroll offset has changed.
   ///
-  void(CEF_CALLBACK* on_scroll_offset_changed)(
-      struct _cef_render_handler_t* self,
-      struct _cef_browser_t* browser,
-      double x,
-      double y);
+  void(CEF_CALLBACK *on_scroll_offset_changed)(
+      struct _cef_render_handler_t *self, struct _cef_browser_t *browser,
+      double x, double y);
 
   ///
   // Called when the RootLayer has changed.
   ///
-  void(CEF_CALLBACK* on_root_layer_changed)(struct _cef_render_handler_t* self,
-                                            struct _cef_browser_t* browser,
-                                            int height,
-                                            int width);
+  void(CEF_CALLBACK *on_root_layer_changed)(struct _cef_render_handler_t *self,
+                                            struct _cef_browser_t *browser,
+                                            int height, int width);
 
   ///
   // Called when the IME composition range has changed. |selected_range| is the
   // range of characters that have been selected. |character_bounds| is the
   // bounds of each character in view coordinates.
   ///
-  void(CEF_CALLBACK* on_ime_composition_range_changed)(
-      struct _cef_render_handler_t* self,
-      struct _cef_browser_t* browser,
-      const cef_range_t* selected_range,
-      size_t character_boundsCount,
-      cef_rect_t const* character_bounds);
+  void(CEF_CALLBACK *on_ime_composition_range_changed)(
+      struct _cef_render_handler_t *self, struct _cef_browser_t *browser,
+      const cef_range_t *selected_range, size_t character_boundsCount,
+      cef_rect_t const *character_bounds);
 
   ///
   // Called when text selection has changed for the specified |browser|.
   // |selected_text| is the currently selected text and |selected_range| is the
   // character range.
   ///
-  void(CEF_CALLBACK* on_text_selection_changed)(
-      struct _cef_render_handler_t* self,
-      struct _cef_browser_t* browser,
-      const cef_string_t* selected_text,
-      const cef_range_t* selected_range);
+  void(CEF_CALLBACK *on_text_selection_changed)(
+      struct _cef_render_handler_t *self, struct _cef_browser_t *browser,
+      const cef_string_t *selected_text, const cef_range_t *selected_range);
 
   ///
   // Called when an on-screen keyboard should be shown or hidden for the
   // specified |browser|. |input_mode| specifies what kind of keyboard should be
   // opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
-  // for this browser should be hidden.
+  // for this browser should be hidden. |show_keyboard| specifies whether to
+  // display the keyboard.
   ///
-  void(CEF_CALLBACK* on_virtual_keyboard_requested)(
-      struct _cef_render_handler_t* self,
-      struct _cef_browser_t* browser,
-      cef_text_input_mode_t input_mode);
+  void(CEF_CALLBACK *on_virtual_keyboard_requested)(
+      struct _cef_render_handler_t *self, struct _cef_browser_t *browser,
+      cef_text_input_mode_t input_mode, int show_keyboard);
 } cef_render_handler_t;
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif  // CEF_INCLUDE_CAPI_CEF_RENDER_HANDLER_CAPI_H_
+#endif // CEF_INCLUDE_CAPI_CEF_RENDER_HANDLER_CAPI_H_
diff --git a/cef/include/capi/cef_request_callback_capi.h b/cef/include/capi/cef_request_callback_capi.h
index 3799fb2d0d79c..cdb26d6c48955 100644
--- a/cef/include/capi/cef_request_callback_capi.h
+++ b/cef/include/capi/cef_request_callback_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=830a1e8ef0e0910fde07c4f4c4fb7df7f8d74a66$
+// $hash=87deb54b1cc60045b67b415f836d350e273815a6$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_REQUEST_CALLBACK_CAPI_H_
@@ -67,6 +67,37 @@ typedef struct _cef_request_callback_t {
   void(CEF_CALLBACK* cancel)(struct _cef_request_callback_t* self);
 } cef_request_callback_t;
 
+///
+// Callback structure used to select a client certificate for authentication.
+///
+typedef struct _cef_select_client_certificate_callback_t {
+  ///
+  // Base structure.
+  ///
+  cef_base_ref_counted_t base;
+
+  ///
+  // Chooses the specified certificate for client certificate authentication.
+  // NULL value means that no client certificate should be used.
+  ///
+  void(CEF_CALLBACK* select)(
+      struct _cef_select_client_certificate_callback_t* self,
+      const cef_string_t* private_key_file,
+      const cef_string_t* cert_chain_file);
+
+  ///
+  // Cancel the select cert request.
+  ///
+  void(CEF_CALLBACK* cancel)(
+      struct _cef_select_client_certificate_callback_t* self);
+
+  ///
+  // Ignore the select cert request.
+  ///
+  void(CEF_CALLBACK* ignore)(
+      struct _cef_select_client_certificate_callback_t* self);
+} cef_select_client_certificate_callback_t;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/cef/include/capi/cef_request_context_capi.h b/cef/include/capi/cef_request_context_capi.h
index 008aaa7f4ad98..1573ed8dca8bb 100644
--- a/cef/include/capi/cef_request_context_capi.h
+++ b/cef/include/capi/cef_request_context_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=b1a351be3e37d34c8e7ad3d30481d59d955102f4$
+// $hash=efa12915f3f8c71175ef5c4e1a12f5add78a5306$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_REQUEST_CONTEXT_CAPI_H_
@@ -265,6 +265,16 @@ typedef struct _cef_request_context_t {
       struct _cef_request_context_t* self,
       struct _cef_completion_callback_t* callback);
 
+  ///
+  // Clears the client authentication certificate Cache that were added as part
+  // of handling cef_request_handler_t::on_select_client_certificate(). If
+  // |callback| is non-NULL it will be executed on the UI thread after
+  // completion.
+  ///
+  void(CEF_CALLBACK* clear_client_authentication_cache)(
+      struct _cef_request_context_t* self,
+      struct _cef_completion_callback_t* callback);
+
   ///
   // Clears all active and idle connections that Chromium currently has. This is
   // only recommended if you have released all other CEF objects but don't yet
diff --git a/cef/include/capi/cef_request_handler_capi.h b/cef/include/capi/cef_request_handler_capi.h
index bf623801b2819..c29fdc17fc721 100644
--- a/cef/include/capi/cef_request_handler_capi.h
+++ b/cef/include/capi/cef_request_handler_capi.h
@@ -33,7 +33,7 @@
 // by hand. See the translator.README.txt file in the tools directory for
 // more information.
 //
-// $hash=f71942c55763a057642cb4b23a212d9c858db6a0$
+// $hash=169dac800825b0344d083e3b8054eb08bc29f88d$
 //
 
 #ifndef CEF_INCLUDE_CAPI_CEF_REQUEST_HANDLER_CAPI_H_
@@ -54,24 +54,6 @@
 extern "C" {
 #endif
 
-///
-// Callback structure used to select a client certificate for authentication.
-///
-typedef struct _cef_select_client_certificate_callback_t {
-  ///
-  // Base structure.
-  ///
-  cef_base_ref_counted_t base;
-
-  ///
-  // Chooses the specified certificate for client certificate authentication.
-  // NULL value means that no client certificate should be used.
-  ///
-  void(CEF_CALLBACK* select)(
-      struct _cef_select_client_certificate_callback_t* self,
-      struct _cef_x509certificate_t* cert);
-} cef_select_client_certificate_callback_t;
-
 ///
 // Implement this structure to handle events related to browser requests. The
 // functions of this structure will be called on the thread indicated.
@@ -225,6 +207,8 @@ typedef struct _cef_request_handler_t {
       int isProxy,
       const cef_string_t* host,
       int port,
+      cef_string_list_t key_types,
+      cef_string_list_t principals,
       size_t certificatesCount,
       struct _cef_x509certificate_t* const* certificates,
       struct _cef_select_client_certificate_callback_t* callback);
diff --git a/cef/include/cef_api_hash.h b/cef/include/cef_api_hash.h
index 012e3376c70ea..61a0ff70e693a 100644
--- a/cef/include/cef_api_hash.h
+++ b/cef/include/cef_api_hash.h
@@ -42,15 +42,15 @@
 // way that may cause binary incompatibility with other builds. The universal
 // hash value will change if any platform is affected whereas the platform hash
 // values will change only if that particular platform is affected.
-#define CEF_API_HASH_UNIVERSAL "4d742811e4dc7cc4871c9641fcf22685337736c5"
+#define CEF_API_HASH_UNIVERSAL "84ce2db602d929e8d2065fdc5f4a1399bc6fb527"
 #if defined(OS_WIN)
-#define CEF_API_HASH_PLATFORM "653e3a03bb1a05545ae7a42e8782e2fc57745831"
+#define CEF_API_HASH_PLATFORM "084f5bf9db33bb0989eeb7092913aabaa29a3124"
 #elif defined(OS_MAC)
-#define CEF_API_HASH_PLATFORM "3463f005e66e2c13eed489c5c7b81b13d346a719"
+#define CEF_API_HASH_PLATFORM "6489389854e2295039d26fc62fb8e66ff10e1c58"
 #elif defined(OS_LINUX)
-#define CEF_API_HASH_PLATFORM "0b8cfe1d67c0ae1b70f0fca7eb1430a3a4e571da"
+#define CEF_API_HASH_PLATFORM "9a253beedf72545a0ac1075e1b05856c370a5f88"
 #elif defined(OS_OHOS)
-#define CEF_API_HASH_PLATFORM "0b8cfe1d67c0ae1b70f0fca7eb1430a3a4e571da"
+#define CEF_API_HASH_PLATFORM "9a253beedf72545a0ac1075e1b05856c370a5f88"
 #endif
 
 #ifdef __cplusplus
diff --git a/cef/include/cef_browser.h b/cef/include/cef_browser.h
index f9e8055c98c67..66da5d701b759 100644
--- a/cef/include/cef_browser.h
+++ b/cef/include/cef_browser.h
@@ -53,6 +53,7 @@
 class CefBrowserHost;
 class CefClient;
 class CefJavaScriptResultCallback;
+class CefStoreWebArchiveResultCallback;
 
 ///
 // Class used to represent a browser window. When used in the browser process
@@ -137,6 +138,12 @@ class CefBrowser : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void ReloadOriginalUrl() = 0;
 
+  ///
+  // Set user agent for current page.
+  ///
+  /*--cef()--*/
+  virtual void SetBrowserUserAgentString(const CefString& user_agent) = 0;
+
   /* ---------- ohos nweb_ex add end --------- */
 
   ///
@@ -534,7 +541,8 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
                     const CefString& searchText,
                     bool forward,
                     bool matchCase,
-                    bool findNext) = 0;
+                    bool findNext,
+                    bool newSession) = 0;
 
   ///
   // Cancel all searches that are currently going on.
@@ -691,6 +699,12 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void NotifyScreenInfoChanged() = 0;
 
+  ///
+  // Set the virtual pixel ratio
+  ///
+  /*--cef()--*/
+  virtual void SetVirtualPixelRatio(float ratio) = 0;
+
   ///
   // Invalidate the view. The browser will call CefRenderHandler::OnPaint
   // asynchronously. This method is only used when window rendering is
@@ -827,6 +841,15 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   /*--cef(optional_param=method_list)--*/
   virtual void UnregisterArkJSfunction(const CefString& object_name, const std::vector<CefString>& method_list) = 0;
 
+  ///
+  // Saves the current view as a web archive.
+  ///
+  /*--cef()--*/
+  virtual void StoreWebArchive(
+      const CefString& base_name,
+      bool auto_name,
+      CefRefPtr<CefStoreWebArchiveResultCallback> callback) = 0;
+
   /* ---------- ohos webview add end --------- */
 
   ///
@@ -835,6 +858,42 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual CefString Title() = 0;
 
+  ///
+  // Create a message channel, which include two message ports.
+  ///
+  /*--cef()--*/
+  virtual void CreateWebMessagePorts(std::vector<CefString>& ports) = 0;
+
+  ///
+  // Posts a MessageEvent to the main frame.
+  ///
+  /*--cef()--*/
+  virtual void PostWebMessage(CefString& message, std::vector<CefString>& ports, CefString& targetUri) = 0;
+
+  ///
+  // Close the web message port.
+  ///
+  /*--cef()--*/
+  virtual void ClosePort(CefString& port_handle) = 0;
+
+  ///
+  // Destroy all web message ports.
+  ///
+  /*--cef()--*/
+  virtual void DestroyAllWebMessagePorts() = 0;
+
+  ///
+  // Post a message to the port.
+  ///
+  /*--cef()--*/
+  virtual void PostPortMessage(CefString& port_handle, CefString& data) = 0;
+
+  ///
+  // Set the callback of the port.
+  ///
+  /*--cef()--*/
+  virtual void SetPortMessageCallback(CefString& port_handle, CefRefPtr<CefJavaScriptResultCallback> callback) = 0;
+
   ///
   // Gets the latest hitdata
   ///
@@ -1141,4 +1200,22 @@ class CefJavaScriptResultCallback : public virtual CefBaseRefCounted {
   virtual void OnJavaScriptExeResult(const CefString& result) = 0;
 };
 
+/* ---------- ohos webview add begin --------- */
+///
+// Interface to implement to be notified of asynchronous completion via
+// CefBrowserHostBase::StoreWebArchive().
+///
+/*--cef(source=client)--*/
+class CefStoreWebArchiveResultCallback : public virtual CefBaseRefCounted {
+ public:
+  ///
+  // Method that will be called upon completion. |result| will either be the
+  // filename under which the file was saved, or empty if saving the file
+  // failed.
+  ///
+  /*--cef(optional_param=result)--*/
+  virtual void OnStoreWebArchiveDone(const CefString& result) = 0;
+};
+/* ---------- ohos webview add end --------- */
+
 #endif  // CEF_INCLUDE_CEF_BROWSER_H_
diff --git a/cef/include/cef_cookie.h b/cef/include/cef_cookie.h
index 8eb3beea39ddb..33cd9807aa2c8 100644
--- a/cef/include/cef_cookie.h
+++ b/cef/include/cef_cookie.h
@@ -85,6 +85,19 @@ class CefCookieManager : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void PutAcceptCookieEnabled(bool accept) = 0;
 
+  ///
+  // Gets whether cookies of third parties are allowed to be set. Returns false if
+  // can't.
+  ///
+  /*--cef()--*/
+  virtual bool IsThirdPartyCookieAllowed() = 0;
+
+  ///
+  // Set whether cookies of third parties are allowed to be set.
+  ///
+  /*--cef()--*/
+  virtual void PutAcceptThirdPartyCookieEnabled(bool accept) = 0;
+
   ///
   // Get whether this cookie manager can accpet and send cookies for file scheme URL.
   // Returns false if can't.
diff --git a/cef/include/cef_data_base.h b/cef/include/cef_data_base.h
index 5f628e66a3a8e..38b228f964359 100644
--- a/cef/include/cef_data_base.h
+++ b/cef/include/cef_data_base.h
@@ -47,7 +47,7 @@
 /*--cef(source=library,no_debugct_check)--*/
 class CefDataBase : public virtual CefBaseRefCounted {
  public:
- ///
+  ///
   // Returns the global data base instance.
   ///
   /*--cef()--*/
@@ -78,6 +78,42 @@ class CefDataBase : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void GetHttpAuthCredentials(const CefString& host, const CefString& realm,
     std::vector<CefString>& username_password) = 0;
+
+  ///
+  // gets whether the instance holds the specified permissions for the specified source.
+  ///
+  /*--cef()--*/
+  virtual bool ExistPermissionByOrigin(const CefString& origin, int type) = 0;
+
+  ///
+  // get specifies permission type result by origin.
+  ///
+  /*--cef()--*/
+  virtual bool GetPermissionResultByOrigin(const CefString& origin, int type, bool& result) = 0;
+
+  ///
+  // set specifies permission type by origin.
+  ///
+  /*--cef()--*/
+  virtual void SetPermissionByOrigin(const CefString& origin, int type, bool result) = 0;
+
+  ///
+  // delete specifies permission type by origin.
+  ///
+  /*--cef()--*/
+  virtual void ClearPermissionByOrigin(const CefString& origin, int type) = 0;
+
+  ///
+  // delete all specifies permission type.
+  ///
+  /*--cef()--*/
+  virtual void ClearAllPermission(int type) = 0;
+
+  ///
+  // obtains all origins of a specified permission type.
+  ///
+  /*--cef()--*/
+  virtual void GetOriginsByPermission(int type, std::vector<CefString>& origins) = 0;
 };
 
-#endif  // CEF_INCLUDE_CEF_DATA_BASE_H_
\ No newline at end of file
+#endif  // CEF_INCLUDE_CEF_DATA_BASE_H_
diff --git a/cef/include/cef_render_handler.h b/cef/include/cef_render_handler.h
index 22c41245a96b6..3c616ad45c849 100644
--- a/cef/include/cef_render_handler.h
+++ b/cef/include/cef_render_handler.h
@@ -178,6 +178,16 @@ class CefRenderHandler : public virtual CefBaseRefCounted {
   virtual void OnTouchHandleStateChanged(CefRefPtr<CefBrowser> browser,
                                          const CefTouchHandleState& state) {}
 
+  ///
+  // Called when touch selection is updated. The client is responsible for
+  // rendering the touch handles.
+  ///
+  /*--cef()--*/
+  virtual void OnTouchSelectionChanged(const CefTouchHandleState& insert_handle,
+                                       const CefTouchHandleState& start_selection_handle,
+                                       const CefTouchHandleState& end_selection_handle,
+                                       bool need_report) {}
+
   ///
   // Called when the user starts dragging content in the web view. Contextual
   // information about the dragged content is supplied by |drag_data|.
@@ -251,11 +261,13 @@ class CefRenderHandler : public virtual CefBaseRefCounted {
   // Called when an on-screen keyboard should be shown or hidden for the
   // specified |browser|. |input_mode| specifies what kind of keyboard
   // should be opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any
-  // existing keyboard for this browser should be hidden.
+  // existing keyboard for this browser should be hidden. |show_keyboard|
+  // specifies whether to display the keyboard.
   ///
   /*--cef()--*/
   virtual void OnVirtualKeyboardRequested(CefRefPtr<CefBrowser> browser,
-                                          TextInputMode input_mode) {}
+                                          TextInputMode input_mode,
+                                          bool show_keyboard) {}
 };
 
 #endif  // CEF_INCLUDE_CEF_RENDER_HANDLER_H_
diff --git a/cef/include/cef_request_callback.h b/cef/include/cef_request_callback.h
index 68094de2f5916..6a5dc9e7fac9c 100644
--- a/cef/include/cef_request_callback.h
+++ b/cef/include/cef_request_callback.h
@@ -60,4 +60,29 @@ class CefRequestCallback : public virtual CefBaseRefCounted {
   virtual void Cancel() = 0;
 };
 
+///
+// Callback interface used to select a client certificate for authentication.
+///
+/*--cef(source=library)--*/
+class CefSelectClientCertificateCallback : public virtual CefBaseRefCounted {
+ public:
+  ///
+  // Chooses the specified certificate for client certificate authentication.
+  // NULL value means that no client certificate should be used.
+  ///
+  /*--cef(optional_param=cert)--*/
+  virtual void Select(const CefString& private_key_file, const CefString& cert_chain_file) = 0;
+
+  ///
+  // Cancel the select cert request.
+  ///
+  /*--cef()--*/
+  virtual void Cancel() = 0;
+
+  ///
+  // Ignore the select cert request.
+  ///
+  /*--cef()--*/
+  virtual void Ignore() = 0;
+};
 #endif  // CEF_INCLUDE_CEF_REQUEST_CALLBACK_H_
diff --git a/cef/include/cef_request_context.h b/cef/include/cef_request_context.h
index 204d3c492412c..55490ec2885a7 100644
--- a/cef/include/cef_request_context.h
+++ b/cef/include/cef_request_context.h
@@ -276,6 +276,16 @@ class CefRequestContext : public virtual CefBaseRefCounted {
   virtual void ClearHttpAuthCredentials(
       CefRefPtr<CefCompletionCallback> callback) = 0;
 
+  ///
+  // Clears the client authentication certificate Cache that were added
+  // as part of handling CefRequestHandler::OnSelectClientCertificate().
+  // If |callback| is non-NULL it will be executed on the UI thread after
+  // completion.
+  ///
+  /*--cef(optional_param=callback)--*/
+  virtual void ClearClientAuthenticationCache(
+      CefRefPtr<CefCompletionCallback> callback) = 0;
+
   ///
   // Clears all active and idle connections that Chromium currently has.
   // This is only recommended if you have released all other CEF objects but
diff --git a/cef/include/cef_request_handler.h b/cef/include/cef_request_handler.h
index c255057f91e0b..5646c08753d4e 100644
--- a/cef/include/cef_request_handler.h
+++ b/cef/include/cef_request_handler.h
@@ -50,20 +50,6 @@
 #include "include/cef_ssl_info.h"
 #include "include/cef_x509_certificate.h"
 
-///
-// Callback interface used to select a client certificate for authentication.
-///
-/*--cef(source=library)--*/
-class CefSelectClientCertificateCallback : public virtual CefBaseRefCounted {
- public:
-  ///
-  // Chooses the specified certificate for client certificate authentication.
-  // NULL value means that no client certificate should be used.
-  ///
-  /*--cef(optional_param=cert)--*/
-  virtual void Select(CefRefPtr<CefX509Certificate> cert) = 0;
-};
-
 ///
 // Implement this interface to handle events related to browser requests. The
 // methods of this class will be called on the thread indicated.
@@ -223,6 +209,8 @@ class CefRequestHandler : public virtual CefBaseRefCounted {
       bool isProxy,
       const CefString& host,
       int port,
+      const std::vector<CefString>& key_types,
+      const std::vector<CefString>& principals,
       const X509CertificateList& certificates,
       CefRefPtr<CefSelectClientCertificateCallback> callback) {
     return false;
diff --git a/cef/include/internal/cef_types.h b/cef/include/internal/cef_types.h
index e788e57040a41..f1dbe98874e5a 100644
--- a/cef/include/internal/cef_types.h
+++ b/cef/include/internal/cef_types.h
@@ -90,8 +90,6 @@ typedef uint32 cef_color_t;
 extern "C" {
 #endif
 
-#define DEFAULT_SCALE 50
-
 ///
 // Log severity levels.
 ///
@@ -713,6 +711,8 @@ typedef struct _cef_browser_settings_t {
   bool supports_multi_touch_zoom;
   cef_state_t initialize_at_minimum_page_scale;
   bool viewport_meta_enabled;
+  bool user_gesture_required;
+  bool pinch_smooth_mode;
   /* ohos webview end */
 } cef_browser_settings_t;
 
@@ -1748,6 +1748,7 @@ typedef enum {
   // Custom menu items originating from the renderer process. For example,
   // plugin placeholder menu items.
   MENU_ID_CUSTOM_FIRST = 220,
+  MENU_ID_IMAGE_COPY = 221,
   MENU_ID_CUSTOM_LAST = 250,
 
   // All user-defined menu IDs should come between MENU_ID_USER_FIRST and
@@ -1975,6 +1976,10 @@ typedef enum {
   ///
   CM_MEDIATYPE_AUDIO,
   ///
+  // A canvas node is selected.
+  ///
+  CM_MEDIATYPE_CANVAS,
+  ///
   // A file node is selected.
   ///
   CM_MEDIATYPE_FILE,
@@ -2025,6 +2030,7 @@ typedef enum {
   QM_EDITFLAG_CAN_CUT = 1 << 1,
   QM_EDITFLAG_CAN_COPY = 1 << 2,
   QM_EDITFLAG_CAN_PASTE = 1 << 3,
+  QM_EDITFLAG_CAN_SELECT_ALL = 1 << 4,
 } cef_quick_menu_edit_state_flags_t;
 
 ///
@@ -2902,6 +2908,11 @@ typedef enum {
   // Align the text's right edge with that of its display area.
   ///
   CEF_HORIZONTAL_ALIGNMENT_RIGHT,
+
+  ///
+  // Undefined align.
+  ///
+  CEF_HORIZONTAL_ALIGNMENT_UNDEFINED,
 } cef_horizontal_alignment_t;
 
 ///
@@ -3316,6 +3327,7 @@ typedef enum {
   CEF_THS_FLAG_ORIENTATION = 1 << 1,
   CEF_THS_FLAG_ORIGIN = 1 << 2,
   CEF_THS_FLAG_ALPHA = 1 << 3,
+  CEF_THS_FLAG_EDGE_HEIGHT = 1 << 4,
 } cef_touch_handle_state_flags_t;
 
 typedef struct _cef_touch_handle_state_t {
@@ -3351,6 +3363,11 @@ typedef struct _cef_touch_handle_state_t {
   // Alpha state. Only set if |flags| contains CEF_THS_FLAG_ALPHA.
   ///
   float alpha;
+
+  ///
+  // Edge height state. Only set if |flags| contains CEF_THS_FLAG_EDGE_HEIGHT.
+  ///
+  float edge_height;
 } cef_touch_handle_state_t;
 
 #ifdef __cplusplus
diff --git a/cef/include/internal/cef_types_wrappers.h b/cef/include/internal/cef_types_wrappers.h
index 933cbad342fcd..773ca4c7cf603 100644
--- a/cef/include/internal/cef_types_wrappers.h
+++ b/cef/include/internal/cef_types_wrappers.h
@@ -748,6 +748,8 @@ struct CefBrowserSettingsTraits {
     target->supports_multi_touch_zoom = src->supports_multi_touch_zoom;
     target->initialize_at_minimum_page_scale = src->initialize_at_minimum_page_scale;
     target->viewport_meta_enabled = src->viewport_meta_enabled;
+    target->user_gesture_required = src->user_gesture_required;
+    target->pinch_smooth_mode = src->pinch_smooth_mode;
     /* ohos webview end */
   }
 };
diff --git a/cef/libcef/browser/alloy/alloy_browser_host_impl.cc b/cef/libcef/browser/alloy/alloy_browser_host_impl.cc
index 15e2aa724e0dd..3d58b7bb885be 100644
--- a/cef/libcef/browser/alloy/alloy_browser_host_impl.cc
+++ b/cef/libcef/browser/alloy/alloy_browser_host_impl.cc
@@ -469,17 +469,18 @@ void AlloyBrowserHostImpl::Find(int identifier,
                                 const CefString& searchText,
                                 bool forward,
                                 bool matchCase,
-                                bool findNext) {
+                                bool findNext,
+                                bool newSession) {
   if (!CEF_CURRENTLY_ON_UIT()) {
-    CEF_POST_TASK(CEF_UIT,
-                  base::BindOnce(&AlloyBrowserHostImpl::Find, this, identifier,
-                                 searchText, forward, matchCase, findNext));
+    CEF_POST_TASK(CEF_UIT, base::BindOnce(&AlloyBrowserHostImpl::Find, this,
+                                          identifier, searchText, forward,
+                                          matchCase, findNext, newSession));
     return;
   }
 
   if (platform_delegate_) {
     platform_delegate_->Find(identifier, searchText, forward, matchCase,
-                             findNext);
+                             findNext, newSession);
   }
 }
 
@@ -1231,8 +1232,18 @@ bool AlloyBrowserHostImpl::TakeFocus(content::WebContents* source,
 bool AlloyBrowserHostImpl::HandleContextMenu(
     content::RenderFrameHost* render_frame_host,
     const content::ContextMenuParams& params) {
-  // notice: now only report kImage.
-  if (params.media_type == blink::mojom::ContextMenuDataMediaType::kImage) {
+  // This bool value is only used for touch insert handle quick menu.
+  auto rvh = web_contents()->GetRenderViewHost();
+  CefRenderWidgetHostViewOSR* view =
+    static_cast<CefRenderWidgetHostViewOSR*>(rvh->GetWidget()->GetView());
+  touch_insert_handle_menu_show_ = true;
+  if (view && view->NeedPopupInsertTouchHandleQuickMenu()) {
+    return false;
+  }
+
+  // notice: now only report kImage and link.
+  if (params.media_type == blink::mojom::ContextMenuDataMediaType::kImage ||
+      !params.link_url.is_empty() || !params.unfiltered_link_url.is_empty()) {
     if (!menu_manager_.get() && platform_delegate_) {
       menu_manager_.reset(
           new CefMenuManager(this, platform_delegate_->CreateMenuRunner()));
diff --git a/cef/libcef/browser/alloy/alloy_browser_host_impl.h b/cef/libcef/browser/alloy/alloy_browser_host_impl.h
index 9c035a2051102..c4592c97fbff8 100644
--- a/cef/libcef/browser/alloy/alloy_browser_host_impl.h
+++ b/cef/libcef/browser/alloy/alloy_browser_host_impl.h
@@ -102,7 +102,8 @@ class AlloyBrowserHostImpl : public CefBrowserHostBase,
             const CefString& searchText,
             bool forward,
             bool matchCase,
-            bool findNext) override;
+            bool findNext,
+            bool newSession) override;
   void StopFinding(bool clearSelection) override;
   void ShowDevTools(const CefWindowInfo& windowInfo,
                     CefRefPtr<CefClient> client,
@@ -209,6 +210,10 @@ class AlloyBrowserHostImpl : public CefBrowserHostBase,
 
   /* ohos webview begin */
   void SetBackgroundColor(int color) override;
+  void SetTouchInsertHandleMenuShow(bool show) {
+    touch_insert_handle_menu_show_ = show;
+  }
+  bool GetTouchInsertHandleMenuShow() { return touch_insert_handle_menu_show_; }
   /* ohos webview end */
 
   // content::WebContentsDelegate methods.
@@ -392,6 +397,8 @@ class AlloyBrowserHostImpl : public CefBrowserHostBase,
   base::OneShotTimer recently_audible_timer_;
 
   int base_background_color_ = 0xffffffff;
+
+  bool touch_insert_handle_menu_show_ = false;
 };
 
 #endif  // CEF_LIBCEF_BROWSER_ALLOY_ALLOY_BROWSER_HOST_IMPL_H_
diff --git a/cef/libcef/browser/alloy/alloy_client_cert_identity.h b/cef/libcef/browser/alloy/alloy_client_cert_identity.h
new file mode 100644
index 0000000000000..1749d2327d22f
--- /dev/null
+++ b/cef/libcef/browser/alloy/alloy_client_cert_identity.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef CEF_LIBCEF_BROWSER_ALLOY_ALLOY_CLIENT_CERT_IDENTITY_H_
+#define CEF_LIBCEF_BROWSER_ALLOY_ALLOY_CLIENT_CERT_IDENTITY_H_
+#pragma once
+
+#include <string>
+
+#include "net/ssl/client_cert_identity.h"
+#include "net/ssl/ssl_private_key.h"
+
+// Simple ClientCertIdentity implementation.
+// Note: this implementation of AcquirePrivateKey will always call the callback
+// synchronously.
+class ClientCertIdentityOhos : public net::ClientCertIdentity {
+ public:
+  ClientCertIdentityOhos(
+  scoped_refptr<net::X509Certificate> cert,
+  scoped_refptr<net::SSLPrivateKey> key)
+  : net::ClientCertIdentity(std::move(cert)), key_(std::move(key)) {}
+
+  ~ClientCertIdentityOhos() override {}
+
+  // ClientCertIdentity implementation:
+  void AcquirePrivateKey(base::OnceCallback<void(scoped_refptr<net::SSLPrivateKey>)>
+                             private_key_callback) override {};
+
+ private:
+  scoped_refptr<net::SSLPrivateKey> key_;
+};
+
+#endif // CEF_LIBCEF_BROWSER_ALLOY_ALLOY_CLIENT_CERT_IDENTITY_H_
\ No newline at end of file
diff --git a/cef/libcef/browser/alloy/alloy_client_cert_lookup_table.cc b/cef/libcef/browser/alloy/alloy_client_cert_lookup_table.cc
new file mode 100644
index 0000000000000..b20445cc3bce0
--- /dev/null
+++ b/cef/libcef/browser/alloy/alloy_client_cert_lookup_table.cc
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "libcef/browser/alloy/alloy_client_cert_lookup_table.h"
+
+#include "base/logging.h"
+
+std::map<std::string, AlloyCert> AlloyClientCertLookupTable::certs_;
+std::set<std::string> AlloyClientCertLookupTable::denieds_;
+
+void AlloyClientCertLookupTable::Clear() {
+  certs_.clear();
+  denieds_.clear();
+}
+
+bool AlloyClientCertLookupTable::IsDenied(const std::string& host, int port) {
+  std::string host_port = HostAndPort(host, port);
+  auto it = denieds_.find(host_port);
+  if (it != denieds_.end()) {
+    return true;
+  }
+  return false;
+}
+
+void AlloyClientCertLookupTable::Allow(const std::string& host, int port,
+    const std::string& private_key,
+    const std::string& cert_chain) {
+  std::string host_port = HostAndPort(host, port);
+  AlloyCert cert(private_key, cert_chain);
+  certs_[host_port] = cert;
+  denieds_.erase(host_port);
+}
+
+void AlloyClientCertLookupTable::Deny(const std::string& host, int port) {
+  std::string host_port = HostAndPort(host, port);
+  certs_.erase(host_port);
+  denieds_.insert(host_port);
+}
+
+bool AlloyClientCertLookupTable::GetCertData(const std::string& host, int port,
+    AlloyCert& cert) {
+  std::string host_port = HostAndPort(host, port);
+  auto it = certs_.find(host_port);
+  if (it != certs_.end()) {
+    cert = (*it).second;
+    return true;
+  }
+  return false;
+}
+
+std::string AlloyClientCertLookupTable::HostAndPort(const std::string& host, int port) {
+  return host + ":" + std::to_string(port);
+}
+
diff --git a/cef/libcef/browser/alloy/alloy_client_cert_lookup_table.h b/cef/libcef/browser/alloy/alloy_client_cert_lookup_table.h
new file mode 100644
index 0000000000000..b6fdcf9e846a3
--- /dev/null
+++ b/cef/libcef/browser/alloy/alloy_client_cert_lookup_table.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CEF_LIBCEF_BROWSER_ALLOY_ALLOY_CLIENT_CERT_LOOKUP_TABLE_H_
+#define CEF_LIBCEF_BROWSER_ALLOY_ALLOY_CLIENT_CERT_LOOKUP_TABLE_H_
+#pragma once
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "include/cef_base.h"
+
+class AlloyCert {
+ public:
+  AlloyCert(const std::string& private_key, const std::string& cert_chain)
+    : private_key_(private_key), cert_chain_(cert_chain) {}
+
+  AlloyCert() {}
+
+  ~AlloyCert() = default;
+
+  std::string private_key_;
+
+  std::string cert_chain_;
+};
+
+class AlloyClientCertLookupTable : public virtual CefBaseRefCounted {
+ public:
+  AlloyClientCertLookupTable() {}
+
+  ~AlloyClientCertLookupTable() = default;
+
+  static void Clear();
+
+  static void Allow(const std::string& host, int port, const std::string& private_key,
+    const std::string& cert_chain);
+
+  static void Deny(const std::string& host, int port);
+
+  static bool GetCertData(const std::string& host, int port, AlloyCert& cert);
+
+  static bool IsDenied(const std::string& host, int port);
+
+  static std::string HostAndPort(const std::string& host, int port);
+
+ private:
+  static std::map<std::string, AlloyCert> certs_;
+  static std::set<std::string> denieds_;
+
+  IMPLEMENT_REFCOUNTING(AlloyClientCertLookupTable);
+  DISALLOW_COPY_AND_ASSIGN(AlloyClientCertLookupTable);
+};
+
+#endif
diff --git a/cef/libcef/browser/alloy/alloy_content_browser_client.cc b/cef/libcef/browser/alloy/alloy_content_browser_client.cc
index 69fde6cece1d5..718dcf2cee245 100644
--- a/cef/libcef/browser/alloy/alloy_content_browser_client.cc
+++ b/cef/libcef/browser/alloy/alloy_content_browser_client.cc
@@ -6,11 +6,15 @@
 
 #include <algorithm>
 #include <utility>
+#include <vector>
 
 #include "include/cef_version.h"
 #include "libcef/browser/alloy/alloy_browser_context.h"
 #include "libcef/browser/alloy/alloy_browser_host_impl.h"
 #include "libcef/browser/alloy/alloy_browser_main.h"
+#include "libcef/browser/alloy/alloy_client_cert_lookup_table.h"
+#include "libcef/browser/alloy/alloy_client_cert_identity.h"
+#include "libcef/browser/alloy/alloy_ssl_platform_key.h"
 #include "libcef/browser/alloy/alloy_web_contents_view_delegate.h"
 #include "libcef/browser/browser_context.h"
 #include "libcef/browser/browser_info.h"
@@ -28,6 +32,7 @@
 #include "libcef/browser/net_service/login_delegate.h"
 #include "libcef/browser/net_service/proxy_url_loader_factory.h"
 #include "libcef/browser/net_service/resource_request_handler_wrapper.h"
+#include "libcef/browser/net_service/restrict_cookie_manager.h"
 #include "libcef/browser/plugins/plugin_service_filter.h"
 #include "libcef/browser/prefs/renderer_prefs.h"
 #include "libcef/browser/speech_recognition_manager_delegate.h"
@@ -46,7 +51,9 @@
 #include "base/base_switches.h"
 #include "base/command_line.h"
 #include "base/files/file_path.h"
+#include "base/files/file_util.h"
 #include "base/json/json_reader.h"
+#include "base/logging.h"
 #include "base/path_service.h"
 #include "base/stl_util.h"
 #include "base/threading/thread_restrictions.h"
@@ -84,6 +91,7 @@
 #include "content/public/browser/browser_ppapi_host.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/client_certificate_delegate.h"
+#include "content/public/browser/file_url_loader.h"
 #include "content/public/browser/navigation_handle.h"
 #include "content/public/browser/overlay_window.h"
 #include "content/public/browser/page_navigator.h"
@@ -93,6 +101,7 @@
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/render_widget_host.h"
 #include "content/public/browser/render_widget_host_view.h"
+#include "content/public/browser/shared_cors_origin_access_list.h"
 #include "content/public/browser/storage_partition.h"
 #include "content/public/browser/web_ui_url_loader_factory.h"
 #include "content/public/common/content_switches.h"
@@ -124,6 +133,7 @@
 #include "third_party/blink/public/mojom/insecure_input/insecure_input_service.mojom.h"
 #include "third_party/blink/public/mojom/prerender/prerender.mojom.h"
 #include "third_party/blink/public/web/web_window_features.h"
+#include "third_party/boringssl/src/include/openssl/evp.h"
 #include "third_party/widevine/cdm/buildflags.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/resource/resource_bundle.h"
@@ -161,6 +171,18 @@
 #endif
 
 namespace {
+void TransferVector(const std::vector<std::string>& source,
+                         std::vector<CefString>& target) {
+  if (!target.empty())
+    target.clear();
+
+  if (!source.empty()) {
+    std::vector<std::string>::const_iterator it = source.begin();
+    for (; it != source.end(); ++it) {
+      target.push_back(*it);
+    }
+  }
+}
 
 class CefQuotaCallbackImpl : public CefRequestCallback {
  public:
@@ -267,48 +289,177 @@ class CefSelectClientCertificateCallbackImpl
     : public CefSelectClientCertificateCallback {
  public:
   explicit CefSelectClientCertificateCallbackImpl(
-      std::unique_ptr<content::ClientCertificateDelegate> delegate)
-      : delegate_(std::move(delegate)) {}
+      std::unique_ptr<content::ClientCertificateDelegate> delegate, const std::string& host, int port)
+      : delegate_(std::move(delegate)) , host_(host), port_(port) {}
 
   ~CefSelectClientCertificateCallbackImpl() {
     // If Select has not been called, call it with NULL to continue without any
     // client certificate.
     if (delegate_)
-      DoSelect(nullptr);
+      DoCancel();
   }
 
-  void Select(CefRefPtr<CefX509Certificate> cert) override {
-    if (delegate_)
-      DoSelect(cert);
+  void Select(const CefString& private_key_file, const CefString& cert_chain_file) override {
+    if (delegate_) {
+       DoSelect(private_key_file, cert_chain_file);
+    }
+  }
+
+  void Cancel() override {
+    if (delegate_) {
+       DoCancel();
+    }
   }
 
+  void Ignore() override {
+    if (delegate_) {
+      DoIgnore();
+    }
+ }
+
  private:
-  void DoSelect(CefRefPtr<CefX509Certificate> cert) {
+  void DoCancel() {
     if (CEF_CURRENTLY_ON_UIT()) {
-      RunNow(std::move(delegate_), cert);
+      RunCancelNow(std::move(delegate_), host_, port_);
     } else {
       CEF_POST_TASK(
           CEF_UIT,
-          base::BindOnce(&CefSelectClientCertificateCallbackImpl::RunNow,
-                         std::move(delegate_), cert));
+          base::BindOnce(&CefSelectClientCertificateCallbackImpl::RunCancelNow,
+              std::move(delegate_), host_, port_));
     }
   }
 
-  static void RunNow(
-      std::unique_ptr<content::ClientCertificateDelegate> delegate,
-      CefRefPtr<CefX509Certificate> cert) {
+  void DoIgnore() {
+    if (CEF_CURRENTLY_ON_UIT()) {
+      RunIgnoreNow(std::move(delegate_), host_, port_);
+    } else {
+      CEF_POST_TASK(
+          CEF_UIT,
+          base::BindOnce(&CefSelectClientCertificateCallbackImpl::RunIgnoreNow,
+              std::move(delegate_), host_, port_));
+    }
+  }
+
+  void DoSelect(const std::string& private_key_file, const std::string& cert_chain_file) {
+    if (CEF_CURRENTLY_ON_UIT()) {
+      RunSelectNow(std::move(delegate_), private_key_file, cert_chain_file, host_, port_);
+    } else {
+      CEF_POST_TASK(
+          CEF_UIT,
+          base::BindOnce(&CefSelectClientCertificateCallbackImpl::RunSelectNow,
+             std::move(delegate_), private_key_file, cert_chain_file, host_, port_));
+    }
+  }
+
+  static void RunCancelNow(std::unique_ptr<content::ClientCertificateDelegate> delegate,
+      const std::string& host, int port) {
+    LOG(INFO) << "CefSelectClientCertificateCallbackImpl::RunCancelNow";
     CEF_REQUIRE_UIT();
+    AlloyClientCertLookupTable::Deny(host, port);
+    delegate->ContinueWithCertificate(nullptr, nullptr);
+  }
 
-    if (cert) {
-      CefX509CertificateImpl* certImpl =
-          static_cast<CefX509CertificateImpl*>(cert.get());
-      certImpl->AcquirePrivateKey(base::BindOnce(
-          &CefSelectClientCertificateCallbackImpl::RunWithPrivateKey,
-          std::move(delegate), cert));
+  static void RunIgnoreNow(std::unique_ptr<content::ClientCertificateDelegate> delegate,
+      const std::string& host, int port) {
+    LOG(INFO) << "CefSelectClientCertificateCallbackImpl::RunIgnoreNow";
+    CEF_REQUIRE_UIT();
+    delegate->ContinueWithCertificate(nullptr, nullptr);
+  }
+
+  static scoped_refptr<net::SSLPrivateKey> WrapOpenSSLPrivateKey(
+      bssl::UniquePtr<EVP_PKEY> key) {
+    if (!key)
+      return nullptr;
+
+    return base::MakeRefCounted<net::ThreadedSSLPrivateKey>(
+        std::make_unique<SSLPlatformKey>(std::move(key)),
+        net::GetSSLPlatformKeyTaskRunner());
+  }
+
+  static net::ClientCertIdentityList ClientCertIdentityListFromCertificateList(
+      const net::CertificateList& certs) {
+    net::ClientCertIdentityList result;
+    for (const auto& cert : certs) {
+      result.push_back(std::make_unique<ClientCertIdentityOhos>(cert, nullptr));
+    }
+
+    return result;
+  }
+
+  static void AcquirePrivateKey(std::unique_ptr<content::ClientCertificateDelegate> delegate,
+        CefRefPtr<CefX509Certificate> cert, const std::string& private_key_file, std::string& pkcs8) {
+    CBS cbs;
+    CBS_init(&cbs, reinterpret_cast<const uint8_t*>(pkcs8.data()), pkcs8.size());
+    bssl::UniquePtr<EVP_PKEY> pkey(EVP_parse_private_key(&cbs));
+    if (!pkey || CBS_len(&cbs) != 0) {
+      LOG(ERROR) << "AcquirePrivateKey: EVP parse private key failed, pkey = " << pkey << ", CBS length = " << CBS_len(&cbs);
       return;
     }
 
-    delegate->ContinueWithCertificate(nullptr, nullptr);
+    scoped_refptr<net::SSLPrivateKey> ssl_private_key = WrapOpenSSLPrivateKey(std::move(pkey));
+    if (!ssl_private_key) {
+      LOG(ERROR) << "AcquirePrivateKey: ssl private key parse failed";
+      return;
+    }
+
+    RunWithPrivateKey(std::move(delegate), cert, ssl_private_key);
+  }
+
+  static void RunSelectNow(std::unique_ptr<content::ClientCertificateDelegate> delegate,
+      const std::string& private_key_file, const std::string& cert_chain_file,
+      const std::string& host, int port) {
+    LOG(INFO) << "CefSelectClientCertificateCallbackImpl::RunSelectNow";
+    CEF_REQUIRE_UIT();
+
+    // Client certificate file read
+    std::string cert_data;
+    base::FilePath src_root_cert;
+    base::PathService::Get(base::DIR_SOURCE_ROOT, &src_root_cert);
+    if (!base::ReadFileToString(src_root_cert.AppendASCII(cert_chain_file), &cert_data)) {
+      LOG(ERROR) << "RunSelectNow: read cert file to string failed";
+      return;
+    }
+
+    // Convert the client certificates file to X509
+    net::CertificateList certsList =
+        net::X509Certificate::CreateCertificateListFromBytes(
+            cert_data.data(), cert_data.size(),
+            net::X509Certificate::FORMAT_AUTO);
+    if (certsList.empty()) {
+      LOG(ERROR) << "RunSelectNow: certs list is empty";
+      return;
+    }
+
+    auto client_certs = ClientCertIdentityListFromCertificateList(certsList);
+    CefRequestHandler::X509CertificateList certs;
+    for (net::ClientCertIdentityList::iterator iter = client_certs.begin();
+        iter != client_certs.end(); iter++) {
+      certs.push_back(new CefX509CertificateImpl(std::move(*iter)));
+    }
+
+    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> intermediates;
+    for (size_t i = 1; i < certsList.size(); ++i) {
+      intermediates.push_back(bssl::UpRef(certsList[i]->cert_buffer()));
+    }
+
+    scoped_refptr<net::X509Certificate> cert_X509(net::X509Certificate::CreateFromBuffer(
+      bssl::UpRef(certsList[0]->cert_buffer()), std::move(intermediates)));
+
+    // Save the converted X509 format certificate
+    CefX509CertificateImpl* certImpl = static_cast<CefX509CertificateImpl*>(certs[0].get());
+    certImpl->setClientCert(cert_X509);
+
+    // Private key file read
+    std::string prikey_data;
+    base::FilePath src_root_prikey;
+    base::PathService::Get(base::DIR_SOURCE_ROOT, &src_root_prikey);
+    if (!base::ReadFileToString(src_root_prikey.AppendASCII(private_key_file), &prikey_data)) {
+      LOG(ERROR) << "RunSelectNow: private key file to string failed";
+      return;
+    }
+
+    AcquirePrivateKey(std::move(delegate), certs[0], private_key_file, prikey_data);
+    return;
   }
 
   static void RunWithPrivateKey(
@@ -328,6 +479,8 @@ class CefSelectClientCertificateCallbackImpl
   }
 
   std::unique_ptr<content::ClientCertificateDelegate> delegate_;
+  std::string host_;
+  int port_;
 
   IMPLEMENT_REFCOUNTING(CefSelectClientCertificateCallbackImpl);
   DISALLOW_COPY_AND_ASSIGN(CefSelectClientCertificateCallbackImpl);
@@ -904,6 +1057,15 @@ base::OnceClosure AlloyContentBrowserClient::SelectClientCertificate(
     net::ClientCertIdentityList client_certs,
     std::unique_ptr<content::ClientCertificateDelegate> delegate) {
   CEF_REQUIRE_UIT();
+  LOG(INFO) << "AlloyContentBrowserClient::SelectClientCertificate";
+  std::string host = cert_request_info->host_and_port.host();
+  int port = cert_request_info->host_and_port.port();
+
+  if (AlloyClientCertLookupTable::IsDenied(host, port)) {
+    LOG(INFO) << "AlloyContentBrowserClient::SelectClientCertificate is denied";
+    delegate->ContinueWithCertificate(nullptr, nullptr);
+    return base::OnceClosure();
+  }
 
   CefRefPtr<CefRequestHandler> handler;
   CefRefPtr<AlloyBrowserHostImpl> browser =
@@ -915,6 +1077,7 @@ base::OnceClosure AlloyContentBrowserClient::SelectClientCertificate(
   }
 
   if (!handler.get()) {
+    LOG(ERROR) << "AlloyContentBrowserClient::SelectClientCertificate get handler failed.";
     delegate->ContinueWithCertificate(nullptr, nullptr);
     return base::OnceClosure();
   }
@@ -925,17 +1088,35 @@ base::OnceClosure AlloyContentBrowserClient::SelectClientCertificate(
     certs.push_back(new CefX509CertificateImpl(std::move(*iter)));
   }
 
+  std::vector<std::string> key_types;
+  for (size_t i = 0; i < cert_request_info->cert_key_types.size(); ++i) {
+    switch (cert_request_info->cert_key_types[i]) {
+      case net::CLIENT_CERT_RSA_SIGN:
+        key_types.push_back("RSA");
+        break;
+      case net::CLIENT_CERT_ECDSA_SIGN:
+        key_types.push_back("ECDSA");
+        break;
+      default:
+        break;
+    }
+  }
+  std::vector<CefString> key_types_cef;
+  TransferVector(key_types, key_types_cef);
+  std::vector<CefString> cert_authorities_cef;
+  TransferVector(cert_request_info->cert_authorities, cert_authorities_cef);
+
   CefRefPtr<CefSelectClientCertificateCallbackImpl> callbackImpl(
-      new CefSelectClientCertificateCallbackImpl(std::move(delegate)));
+      new CefSelectClientCertificateCallbackImpl(std::move(delegate), host, port));
 
   bool proceed = handler->OnSelectClientCertificate(
       browser.get(), cert_request_info->is_proxy,
-      cert_request_info->host_and_port.host(),
-      cert_request_info->host_and_port.port(), certs, callbackImpl.get());
+      host, port,
+      key_types_cef,
+      cert_authorities_cef,
+      certs, callbackImpl.get());
+  LOG(INFO) << "AlloyContentBrowserClient::SelectClientCertificate end: prceed = " << proceed;
 
-  if (!proceed && !certs.empty()) {
-    callbackImpl->Select(certs[0]);
-  }
   return base::OnceClosure();
 }
 
@@ -1123,6 +1304,23 @@ void AlloyContentBrowserClient::RegisterNonNetworkSubresourceURLLoaderFactories(
     int render_process_id,
     int render_frame_id,
     NonNetworkURLLoaderFactoryMap* factories) {
+  content::RenderFrameHost* frame_host =
+      content::RenderFrameHost::FromID(render_process_id, render_frame_id);
+  content::WebContents* web_contents =
+      content::WebContents::FromRenderFrameHost(frame_host);
+  if (!web_contents)
+    return;
+
+#if defined(OS_OHOS)
+  auto browser_context = web_contents->GetBrowserContext();
+  if (!browser_context) {
+    return;
+  }
+
+  factories->emplace(url::kFileScheme, content::CreateFileURLLoaderFactory(browser_context->GetPath(),
+    content::BrowserContext::GetSharedCorsOriginAccessList(browser_context)));
+#endif
+
   if (!extensions::ExtensionsEnabled())
     return;
 
@@ -1131,13 +1329,6 @@ void AlloyContentBrowserClient::RegisterNonNetworkSubresourceURLLoaderFactories(
   if (factory)
     factories->emplace(extensions::kExtensionScheme, std::move(factory));
 
-  content::RenderFrameHost* frame_host =
-      content::RenderFrameHost::FromID(render_process_id, render_frame_id);
-  content::WebContents* web_contents =
-      content::WebContents::FromRenderFrameHost(frame_host);
-  if (!web_contents)
-    return;
-
   extensions::CefExtensionWebContentsObserver* web_observer =
       extensions::CefExtensionWebContentsObserver::FromWebContents(
           web_contents);
@@ -1225,9 +1416,7 @@ void AlloyContentBrowserClient::ConfigureNetworkContextParams(
 
   base::FilePath cache_path;
   if (base::PathService::Get(base::DIR_CACHE, &cache_path)) {
-    if (cef_context->ShouldPersistSessionCookies()) {
-      network_context_params->cookie_path = cache_path.Append(base::FilePath("cookie.db"));
-    }
+    network_context_params->cookie_path = cache_path.Append(base::FilePath("cookie.db"));
     network_context_params->persist_session_cookies = cef_context->ShouldPersistSessionCookies();
     network_context_params->restore_old_session_cookies = cef_context->ShouldRestoreOldSessionCookies();
     network_context_params->http_cache_enabled = true;
@@ -1261,6 +1450,18 @@ void AlloyContentBrowserClient::ConfigureNetworkContextParams(
   network_context_params->require_network_isolation_key = false;
 }
 
+base::FilePath AlloyContentBrowserClient::GetShaderDiskCacheDirectory() {
+  base::FilePath cache_path;
+  base::PathService::Get(base::DIR_CACHE, &cache_path);
+  return cache_path.Append(FILE_PATH_LITERAL("ShaderCache"));
+}
+
+base::FilePath AlloyContentBrowserClient::GetGrShaderDiskCacheDirectory() {
+  base::FilePath cache_path;
+  base::PathService::Get(base::DIR_CACHE, &cache_path);
+  return cache_path.Append(FILE_PATH_LITERAL("GrShaderCache"));
+}
+
 // The sandbox may block read/write access from the NetworkService to
 // directories that are not returned by this method.
 std::vector<base::FilePath>
@@ -1472,6 +1673,43 @@ bool AlloyContentBrowserClient::ShouldLockProcessToSite(
     const GURL& effective_url) {
   return false;
 }
+
+uint32_t AlloyContentBrowserClient::GetWebSocketOptions(content::RenderFrameHost* frame) {
+  uint32_t options = network::mojom::kWebSocketOptionNone;
+
+  bool global_cookie_policy = net_service::NetHelpers::IsAllowAcceptCookies();
+  bool third_party_cookie_policy = net_service::NetHelpers::IsThirdPartyCookieAllowed();
+  if (!global_cookie_policy) {
+    options |= network::mojom::kWebSocketOptionBlockAllCookies;
+  } else if (!third_party_cookie_policy) {
+    options |= network::mojom::kWebSocketOptionBlockThirdPartyCookies;
+  }
+  return options;
+}
+
+bool AlloyContentBrowserClient::WillCreateRestrictedCookieManager(
+      network::mojom::RestrictedCookieManagerRole role,
+      content::BrowserContext* browser_context,
+      const url::Origin& origin,
+      const net::IsolationInfo& isolation_info,
+      bool is_service_worker,
+      int process_id,
+      int routing_id,
+      mojo::PendingReceiver<network::mojom::RestrictedCookieManager>* receiver) {
+  mojo::PendingReceiver<network::mojom::RestrictedCookieManager> orig_receiver =
+      std::move(*receiver);
+
+  mojo::PendingRemote<network::mojom::RestrictedCookieManager>
+      target_rcm_remote;
+  *receiver = target_rcm_remote.InitWithNewPipeAndPassReceiver();
+
+  ProxyingRestrictedCookieManager::CreateAndBind(
+      std::move(target_rcm_remote), is_service_worker, process_id, routing_id,
+      std::move(orig_receiver));
+
+  return false;  // only made a proxy, still need the actual impl to be made.
+}
+
 #endif
 
 CefRefPtr<CefRequestContextImpl> AlloyContentBrowserClient::request_context()
diff --git a/cef/libcef/browser/alloy/alloy_content_browser_client.h b/cef/libcef/browser/alloy/alloy_content_browser_client.h
index 1238da6a484f0..e292d4f9d28fc 100644
--- a/cef/libcef/browser/alloy/alloy_content_browser_client.h
+++ b/cef/libcef/browser/alloy/alloy_content_browser_client.h
@@ -227,8 +227,21 @@ class AlloyContentBrowserClient : public content::ContentBrowserClient {
   bool ShouldLockProcessToSite(
       content::BrowserContext* browser_context,
       const GURL& effective_url) override;
+  uint32_t GetWebSocketOptions(content::RenderFrameHost* frame) override;
+  bool WillCreateRestrictedCookieManager(
+      network::mojom::RestrictedCookieManagerRole role,
+      content::BrowserContext* browser_context,
+      const url::Origin& origin,
+      const net::IsolationInfo& isolation_info,
+      bool is_service_worker,
+      int process_id,
+      int routing_id,
+      mojo::PendingReceiver<network::mojom::RestrictedCookieManager>* receiver) override;
 #endif
 
+  base::FilePath GetShaderDiskCacheDirectory() override;
+  base::FilePath GetGrShaderDiskCacheDirectory() override;
+
   CefRefPtr<CefRequestContextImpl> request_context() const;
   CefDevToolsDelegate* devtools_delegate() const;
 
diff --git a/cef/libcef/browser/alloy/alloy_ssl_platform_key.h b/cef/libcef/browser/alloy/alloy_ssl_platform_key.h
new file mode 100644
index 0000000000000..b5f3e9814b30a
--- /dev/null
+++ b/cef/libcef/browser/alloy/alloy_ssl_platform_key.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef CEF_LIBCEF_BROWSER_ALLOY_ALLOY_SSL_PLATFORM_KEY_
+#define CEF_LIBCEF_BROWSER_ALLOY_ALLOY_SSL_PLATFORM_KEY_
+#pragma once
+
+#include "include/cef_request_handler.h"
+
+#include "crypto/rsa_private_key.h"
+#include "net/ssl/threaded_ssl_private_key.h"
+#include "net/base/net_errors.h"
+#include "net/ssl/ssl_platform_key_util.h"
+#include "third_party/boringssl/src/include/openssl/digest.h"
+#include "third_party/boringssl/src/include/openssl/ec.h"
+#include "third_party/boringssl/src/include/openssl/evp.h"
+#include "third_party/boringssl/src/include/openssl/rsa.h"
+#include "third_party/boringssl/src/include/openssl/ssl.h"
+
+class SSLPlatformKey : public net::ThreadedSSLPrivateKey::Delegate {
+ public:
+  explicit SSLPlatformKey(bssl::UniquePtr<EVP_PKEY> key)
+      : key_(std::move(key)) {}
+
+  SSLPlatformKey(const SSLPlatformKey&) = delete;
+  SSLPlatformKey& operator=(const SSLPlatformKey&) = delete;
+
+  ~SSLPlatformKey() override = default;
+
+  std::string GetProviderName() override { return "EVP_PKEY"; }
+
+  std::vector<uint16_t> GetAlgorithmPreferences() override {
+    return net::SSLPrivateKey::DefaultAlgorithmPreferences(EVP_PKEY_id(key_.get()),
+                                                      true /* supports PSS */);
+  }
+
+  net::Error Sign(uint16_t algorithm,
+             base::span<const uint8_t> input,
+             std::vector<uint8_t>* signature) override {
+    bssl::ScopedEVP_MD_CTX ctx;
+    EVP_PKEY_CTX* pctx;
+
+    if (!EVP_DigestSignInit(ctx.get(), &pctx,
+                            SSL_get_signature_algorithm_digest(algorithm),
+                            nullptr, key_.get())) {
+        LOG(ERROR) << "Sign: EVP digest sign init failed";
+        return net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
+    }
+
+    if (SSL_is_signature_algorithm_rsa_pss(algorithm)) {
+      if (!EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) ||
+          !EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx, -1 /* hash length */)) {
+        LOG(ERROR) << "Sign: EVP pkey ctx set rsa padding failed";
+        return net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
+      }
+    }
+
+    size_t sig_len = 0;
+    if (!EVP_DigestSign(ctx.get(), nullptr, &sig_len, input.data(),
+                        input.size())) {
+        LOG(ERROR) << "Sign: EVP digest sign failed";
+        return net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
+    }
+
+    signature->resize(sig_len);
+    if (!EVP_DigestSign(ctx.get(), signature->data(), &sig_len, input.data(),
+                        input.size())) {
+        LOG(ERROR) << "Sign: resize EVP digest sign failed";
+        return net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
+    }
+    signature->resize(sig_len);
+
+    return net::OK;
+  }
+
+ private:
+  bssl::UniquePtr<EVP_PKEY> key_;
+};
+
+#endif // CEF_LIBCEF_BROWSER_ALLOY_ALLOY_SSL_PLATFORM_KEY_
\ No newline at end of file
diff --git a/cef/libcef/browser/alloy/browser_platform_delegate_alloy.cc b/cef/libcef/browser/alloy/browser_platform_delegate_alloy.cc
index 099cfbec282e8..0dbd4d1e97ad0 100644
--- a/cef/libcef/browser/alloy/browser_platform_delegate_alloy.cc
+++ b/cef/libcef/browser/alloy/browser_platform_delegate_alloy.cc
@@ -400,7 +400,8 @@ void CefBrowserPlatformDelegateAlloy::Find(int identifier,
                                            const CefString& searchText,
                                            bool forward,
                                            bool matchCase,
-                                           bool findNext) {
+                                           bool findNext,
+                                           bool newSession) {
   if (!web_contents_)
     return;
 
@@ -416,6 +417,9 @@ void CefBrowserPlatformDelegateAlloy::Find(int identifier,
   options->forward = forward;
   options->match_case = matchCase;
   options->find_match = findNext;
+#ifdef OS_OHOS
+  options->new_session = newSession;
+#endif
   web_contents_->Find(identifier, searchText, std::move(options));
 }
 
diff --git a/cef/libcef/browser/alloy/browser_platform_delegate_alloy.h b/cef/libcef/browser/alloy/browser_platform_delegate_alloy.h
index 8622f73c5106f..f96c44b6e05a3 100644
--- a/cef/libcef/browser/alloy/browser_platform_delegate_alloy.h
+++ b/cef/libcef/browser/alloy/browser_platform_delegate_alloy.h
@@ -57,7 +57,8 @@ class CefBrowserPlatformDelegateAlloy : public CefBrowserPlatformDelegate {
             const CefString& searchText,
             bool forward,
             bool matchCase,
-            bool findNext) override;
+            bool findNext,
+            bool newSession) override;
   void StopFinding(bool clearSelection) override;
 
  protected:
diff --git a/cef/libcef/browser/browser_context.cc b/cef/libcef/browser/browser_context.cc
index 2d3ad2e27a411..bf9f2b116fa95 100644
--- a/cef/libcef/browser/browser_context.cc
+++ b/cef/libcef/browser/browser_context.cc
@@ -18,6 +18,7 @@
 #include "base/lazy_instance.h"
 #include "base/logging.h"
 #include "base/no_destructor.h"
+#include "base/path_service.h"
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "chrome/browser/profiles/profile.h"
@@ -183,7 +184,7 @@ CefBrowserContext::~CefBrowserContext() {
 }
 
 void CefBrowserContext::Initialize() {
-  cache_path_ = base::FilePath(CefString(&settings_.cache_path));
+  base::PathService::Get(base::DIR_CACHE, &cache_path_);
 
   if (!cache_path_.empty())
     g_manager.Get().SetImplPath(this, cache_path_);
diff --git a/cef/libcef/browser/browser_host_base.cc b/cef/libcef/browser/browser_host_base.cc
index 9d2837d88ddea..b621152030a95 100644
--- a/cef/libcef/browser/browser_host_base.cc
+++ b/cef/libcef/browser/browser_host_base.cc
@@ -28,6 +28,10 @@
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/download_manager.h"
 #include "content/public/browser/download_request_utils.h"
+#if defined(OS_OHOS)
+#include "content/public/browser/message_port_provider.h"
+#include "third_party/blink/public/common/messaging/web_message_port.h"
+#endif
 #include "content/public/browser/navigation_entry.h"
 #include "ui/gfx/image/image_skia.h"
 #include "ui/gl/nweb_native_window_tracker.h"
@@ -39,6 +43,9 @@
 #include "content/browser/web_contents/web_contents_impl.h"
 
 #if defined(OS_OHOS)
+#include "base/files/file_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/common/mhtml_generation_params.h"
 #include "libcef/browser/javascript/oh_javascript_injector.h"
 #endif
 
@@ -80,6 +87,36 @@ class WebContentsUserDataAdapter : public base::SupportsUserData::Data {
   CefRefPtr<CefBrowserHostBase> browser_;
 };
 
+#if defined(OS_OHOS)
+const std::string WEB_ARCHIVE_EXTENSION = ".mht";
+
+CefString GenerateArchiveAutoNamePath(const GURL& url,
+                                      const CefString& base_name) {
+  if (!url.is_empty()) {
+    std::string file_name = url.ExtractFileName();
+    if (file_name.empty()) {
+      file_name = "index";
+    }
+
+    std::string test_name =
+        base_name.ToString() + file_name + WEB_ARCHIVE_EXTENSION;
+
+    if (!base::PathExists(base::FilePath(test_name))) {
+      return test_name;
+    }
+
+    for (int i = 0; i < 100; ++i) {
+      test_name = base_name.ToString() + file_name + "-" +
+                  base::NumberToString(i) + WEB_ARCHIVE_EXTENSION;
+      if (!base::PathExists(base::FilePath(test_name))) {
+        return test_name;
+      }
+    }
+  }
+  return "";
+}
+#endif  // OS_OHOS
+
 }  // namespace
 
 using namespace NWEB;
@@ -181,7 +218,12 @@ CefBrowserHostBase::CefBrowserHostBase(
       platform_delegate_(std::move(platform_delegate)),
       browser_info_(browser_info),
       request_context_(request_context),
+#ifdef OS_OHOS
+      is_views_hosted_(platform_delegate_->IsViewsHosted()),
+      weak_ptr_factory_(this) {
+#else
       is_views_hosted_(platform_delegate_->IsViewsHosted()) {
+#endif
   CEF_REQUIRE_UIT();
   DCHECK(!browser_info_->browser().get());
   browser_info_->SetBrowser(this);
@@ -480,6 +522,8 @@ void CefBrowserHostBase::UpdateBrowserSettings(
   settings_.initialize_at_minimum_page_scale =
       browser_settings.initialize_at_minimum_page_scale;
   settings_.viewport_meta_enabled = browser_settings.viewport_meta_enabled;
+  settings_.user_gesture_required = browser_settings.user_gesture_required;
+  settings_.pinch_smooth_mode = browser_settings.pinch_smooth_mode;
 }
 
 void CefBrowserHostBase::SetWebPreferences(
@@ -780,6 +824,70 @@ void CefBrowserHostBase::ReloadOriginalUrl() {
     wc->GetController().Reload(content::ReloadType::ORIGINAL_REQUEST_URL, true);
   }
 }
+
+void CefBrowserHostBase::StoreWebArchiveInternal(
+    CefRefPtr<CefStoreWebArchiveResultCallback> callback,
+    const CefString& path) {
+  auto web_contents = GetWebContents();
+  if (!web_contents) {
+    callback->OnStoreWebArchiveDone("");
+    return;
+  }
+
+  web_contents->GenerateMHTML(
+      content::MHTMLGenerationParams(base::FilePath(path)),
+      base::BindOnce(
+          [](const CefString& path,
+             CefRefPtr<CefStoreWebArchiveResultCallback> callback,
+             int64 file_size) {
+            CEF_REQUIRE_UIT();
+            callback->OnStoreWebArchiveDone(file_size < 0 ? "" : path);
+          },
+          path, callback));
+}
+
+void CefBrowserHostBase::StoreWebArchive(
+    const CefString& base_name,
+    bool auto_name,
+    CefRefPtr<CefStoreWebArchiveResultCallback> callback) {
+  if (!CEF_CURRENTLY_ON_UIT()) {
+    CEF_POST_TASK(CEF_UIT,
+                  base::BindOnce(&CefBrowserHostBase::StoreWebArchive, this,
+                                 base_name, auto_name, callback));
+    return;
+  }
+
+  if (!callback)
+    return;
+
+  auto web_contents = GetWebContents();
+  if (!web_contents) {
+    callback->OnStoreWebArchiveDone("");
+    return;
+  }
+
+  if (auto_name) {
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN},
+        base::BindOnce(&GenerateArchiveAutoNamePath, web_contents->GetURL(),
+                       base_name),
+        base::BindOnce(&CefBrowserHostBase::StoreWebArchiveInternal,
+                       weak_ptr_factory_.GetWeakPtr(), std::move(callback)));
+  } else {
+    StoreWebArchiveInternal(std::move(callback), base_name);
+  }
+}
+
+void CefBrowserHostBase::SetBrowserUserAgentString(
+    const CefString& user_agent) {
+  auto callback = base::BindOnce(&CefBrowserHostBase::ReloadOriginalUrl, this);
+  if (!CEF_CURRENTLY_ON_UIT()) {
+    CEF_POST_TASK(CEF_UIT, std::move(callback));
+    return;
+  }
+  PutUserAgent(user_agent);
+}
 #endif  // OS_OHOS
 
 void CefBrowserHostBase::StopLoad() {
@@ -1229,6 +1337,230 @@ CefString CefBrowserHostBase::Title() {
   return "";
 }
 
+// in the std::map<std::pair<uint64_t, uint64_t>, std::pair<WebMessagePort, WebMessagePort>> portMap_;
+// first is the paif of port_handles.
+// second is the WebMessagePort of the pipe.
+#if defined(OS_OHOS)
+void CefBrowserHostBase::CreateWebMessagePorts(std::vector<CefString>& ports) {
+  auto web_contents = GetWebContents();
+  if (web_contents) {
+    std::vector<blink::WebMessagePort> portArr;
+    web_contents->CreateWebMessagePorts(portArr);
+    if (portArr.size() != 2) {
+      LOG(ERROR) <<"CreateWebMessagePorts size wrong";
+      return;
+    }
+    uint64_t pointer0 = reinterpret_cast<uint64_t>(&portArr[0]);
+    uint64_t pointer1 = reinterpret_cast<uint64_t>(&portArr[1]);
+    portMap_[std::make_pair(pointer0, pointer1)] = std::make_pair(std::move(portArr[0]), std::move(portArr[1]));
+    ports.emplace_back(std::to_string(pointer0));
+    ports.emplace_back(std::to_string(pointer1));
+  } else {
+    LOG(ERROR) <<"CreateWebMessagePorts web_contents its null";
+  }
+}
+
+// in the std::map<std::pair<uint64_t, uint64_t>, std::pair<WebMessagePort, WebMessagePort>> portMap_;
+// first is the paif of port_handles.
+// second is the WebMessagePort of the pipe.
+void CefBrowserHostBase::PostWebMessage(CefString& message, std::vector<CefString>& port_handles, CefString& targetUri) {
+  auto web_contents = GetWebContents();
+  if (!web_contents) {
+    LOG(ERROR) <<"PostWebMessage web_contents its null";
+    return;
+  }
+
+  std::string msg = message.empty() ? "" : message.ToString();
+  std::string uri = targetUri.empty() ? "" : targetUri.ToString();
+  // check whether the port is already send to html5.
+  for (CefString port : port_handles) {
+    auto found = postedPorts_.find(port.ToString());
+    if (found != postedPorts_.end()) {
+      LOG(ERROR) <<"This port has alrady send to h5, can not post again.";
+      return;
+    }
+  }
+
+  // find the WebMessagePort by port_handle, and send to html5
+  std::vector<blink::WebMessagePort> sendPorts;
+  for (CefString port : port_handles) {
+    LOG(INFO) <<"PostWebMessage port:" << port.ToString();
+    for(auto iter = portMap_.begin(); iter != portMap_.end(); ++iter) {
+      if (port.ToString().compare(std::to_string(iter->first.first)) == 0) {
+        postedPorts_.insert(port.ToString());
+        sendPorts.emplace_back(std::move(iter->second.first));
+      } else if(port.ToString().compare(std::to_string(iter->first.second)) == 0) {
+        postedPorts_.insert(port.ToString());
+        sendPorts.emplace_back(std::move(iter->second.second));
+      }
+    }
+  }
+
+  // send to html5 main frame
+  if (sendPorts.size() >= 1) {
+    web_contents->PostWebMessage(msg, sendPorts, uri);
+  }
+}
+
+// in the std::map<std::pair<uint64_t, uint64_t>, std::pair<WebMessagePort, WebMessagePort>> portMap_;
+// first is the paif of port_handles.
+// second is the WebMessagePort of the pipe.
+void CefBrowserHostBase::ClosePort(CefString& portHandle) {
+  LOG(INFO) <<"ClosePort ClosePort";
+  auto web_contents = GetWebContents();
+  if (!web_contents) {
+    LOG(ERROR) <<"ClosePort GetWebContents null";
+  }
+
+  // find port and close, then erase the item in map
+  blink::WebMessagePort port;
+  for(auto iter = portMap_.begin(); iter != portMap_.end(); ++iter) {
+    if (portHandle.ToString().compare(std::to_string(iter->first.first)) == 0) {
+      port = std::move(iter->second.first);
+      port.Close();
+      portMap_.erase(iter);
+      break;
+    } else if(portHandle.ToString().compare(std::to_string(iter->first.second)) == 0) {
+      port = std::move(iter->second.second);
+      port.Close();
+      portMap_.erase(iter);
+      break;
+    }
+  }
+
+  for(auto iter = receiverMap_.begin(); iter != receiverMap_.end(); ++iter) {
+    if (portHandle.ToString().compare(iter->first) == 0) {
+      receiverMap_.erase(iter);
+      break;
+    }
+  }
+
+  for(auto iter = runnerMap_.begin(); iter != runnerMap_.end(); ++iter) {
+    if (portHandle.ToString().compare(iter->first) == 0) {
+      runnerMap_.erase(iter);
+      break;
+    }
+  }
+  postedPorts_.erase(portHandle.ToString());
+  LOG(INFO) <<"ClosePort end";
+}
+
+void CefBrowserHostBase::PostPortMessage(CefString& portHandle, CefString& data) {
+  auto web_contents = GetWebContents();
+  if (!web_contents) {
+    LOG(ERROR) <<"GetWebContents null";
+    return;
+  }
+
+  std::u16string message(base::UTF8ToUTF16(data.ToString()));
+  // find the WebMessagePort in map
+  for(auto iter = portMap_.begin(); iter != portMap_.end(); ++iter) {
+    if (portHandle.ToString().compare(std::to_string(iter->first.first)) == 0) {
+      if (iter->second.first.CanPostMessage()) {
+        iter->second.first.PostMessage(blink::WebMessagePort::Message(message));
+      } else {
+        LOG(ERROR) <<"port can not post messsage";
+      }
+      break;
+    } else if(portHandle.ToString().compare(std::to_string(iter->first.second)) == 0) {
+      if (iter->second.second.CanPostMessage()) {
+        iter->second.second.PostMessage(blink::WebMessagePort::Message(message));
+      } else {
+        LOG(ERROR) <<"port can not post messsage";
+      }
+      break;
+    }
+  }
+}
+
+// in the std::map<std::pair<uint64_t, uint64_t>, std::pair<WebMessagePort, WebMessagePort>> portMap_;
+// first is the paif of port_handles.
+// second is the WebMessagePort of the pipe.
+void CefBrowserHostBase::SetPortMessageCallback(CefString& portHandle,
+      CefRefPtr<CefJavaScriptResultCallback> callback) {
+  auto web_contents = GetWebContents();
+  if (!web_contents) {
+    LOG(ERROR) <<"GetWebContents null";
+    return;
+  }
+
+  // get sequenced task runner
+  std::string pointer0 = portHandle.ToString();
+  scoped_refptr<base::SequencedTaskRunner> sequenced_task_runner_;
+  auto runner_it = runnerMap_.find(pointer0);
+  if (runner_it != runnerMap_.end()) {
+    sequenced_task_runner_ = runner_it->second;
+  } else {
+    sequenced_task_runner_ = base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()});
+  }
+
+  // get web message receiver instance
+  std::shared_ptr<WebMessageReceiverImpl> webMsgReceiver;
+  auto receive_it = receiverMap_.find(pointer0);
+  if (receive_it != receiverMap_.end()) {
+    webMsgReceiver = receive_it->second;
+  } else {
+    webMsgReceiver = std::make_shared<WebMessageReceiverImpl>();
+  }
+  webMsgReceiver->SetOnMessageCallback(callback);
+
+  // find the port set message callback
+  for(auto iter = portMap_.begin(); iter != portMap_.end(); ++iter) {
+    if (portHandle.ToString().compare(std::to_string(iter->first.first)) == 0) {
+      if (iter->second.first.HasReceiver()) {
+        iter->second.first.ClearReceiver();
+      }
+      iter->second.first.SetReceiver(webMsgReceiver.get(), sequenced_task_runner_);
+      break;
+    } else if(portHandle.ToString().compare(std::to_string(iter->first.second)) == 0) {
+      if (iter->second.second.HasReceiver()) {
+        iter->second.second.ClearReceiver();
+      }
+      iter->second.second.SetReceiver(webMsgReceiver.get(), sequenced_task_runner_);
+      break;
+    }
+  }
+
+  // save in map
+  runnerMap_[pointer0] = sequenced_task_runner_;
+  receiverMap_[pointer0] = webMsgReceiver;
+}
+
+void CefBrowserHostBase::DestroyAllWebMessagePorts() {
+  LOG(INFO) <<"clear all message ports";
+  portMap_.clear();
+  runnerMap_.clear();
+  receiverMap_.clear();
+  postedPorts_.clear();
+}
+
+WebMessageReceiverImpl::~WebMessageReceiverImpl()
+{
+  LOG(INFO) <<"WebMessageReceiverImpl destrory";
+}
+
+void WebMessageReceiverImpl::SetOnMessageCallback(CefRefPtr<CefJavaScriptResultCallback> callback)
+{
+  LOG(INFO) <<"WebMessageReceiverImpl::SetOnMessageCallback ";
+  callback_ = callback;
+}
+
+// this will receive message from html5
+bool WebMessageReceiverImpl::OnMessage(blink::WebMessagePort::Message message)
+{
+  LOG(INFO) << "OnMessage start";
+  // Pass the message on to the receiver.
+  if (callback_) {
+    LOG(INFO) << "OnMessage:" << message.data;
+    std::u16string data = message.data;
+    callback_->OnJavaScriptExeResult(base::UTF16ToUTF8(data));
+  } else {
+    LOG(ERROR) <<"u should set callback to receive message";
+  }
+  return true;
+}
+#endif
+
 void CefBrowserHostBase::GetHitData(int& type, CefString& extra_data) {
   type = cef_hit_data_.type;
   extra_data = cef_hit_data_.extra_data;
@@ -1237,9 +1569,18 @@ void CefBrowserHostBase::GetHitData(int& type, CefString& extra_data) {
 void CefBrowserHostBase::SetInitialScale(float scale) {
   auto frame = GetMainFrame();
   if (frame && frame->IsValid()) {
-    static_cast<CefFrameHostImpl*>(frame.get())->SetInitialScale(scale / DEFAULT_SCALE);
+    static_cast<CefFrameHostImpl*>(frame.get())->SetInitialScale(scale / (100 / virtual_pixel_ratio_));
   }
 }
+
+void CefBrowserHostBase::SetVirtualPixelRatio(float ratio) {
+  virtual_pixel_ratio_ = ratio;
+}
+
+float CefBrowserHostBase::GetVirtualPixelRatio() const {
+  return virtual_pixel_ratio_;
+}
+
 float CefBrowserHostBase::Scale() {
   auto web_contents = GetWebContents();
   if (web_contents) {
@@ -1297,8 +1638,13 @@ void CefBrowserHostBase::LoadWithDataAndBaseUrl(const CefString& baseUrl,
     loadUrlParams.base_url_for_data_url = GURL(url);
   }
 
+  loadUrlParams.load_type = content::NavigationController::LOAD_TYPE_DATA;
+  loadUrlParams.transition_type = ui::PAGE_TRANSITION_TYPED;
+  loadUrlParams.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;
+  loadUrlParams.can_load_local_resources = true;
   auto web_contents = GetWebContents();
   if (web_contents) {
+    LOG(INFO) << "load data with BaseUrl";
     web_contents->GetController().LoadURLWithParams(loadUrlParams);
   }
 }
diff --git a/cef/libcef/browser/browser_host_base.h b/cef/libcef/browser/browser_host_base.h
index e438e31ae214c..0913ef89a8499 100644
--- a/cef/libcef/browser/browser_host_base.h
+++ b/cef/libcef/browser/browser_host_base.h
@@ -6,6 +6,9 @@
 #ifndef CEF_LIBCEF_BROWSER_BROWSER_HOST_BASE_H_
 #define CEF_LIBCEF_BROWSER_BROWSER_HOST_BASE_H_
 #pragma once
+#include <map>
+#include <set>
+#include <unordered_map>
 
 #include "include/cef_browser.h"
 #include "include/cef_client.h"
@@ -97,6 +100,20 @@ struct CefBrowserCreateParams {
       extensions::mojom::ViewType::kInvalid;
 };
 
+class WebMessageReceiverImpl : public blink::WebMessagePort::MessageReceiver {
+ public:
+  WebMessageReceiverImpl() = default;
+  ~WebMessageReceiverImpl();
+
+  // WebMessagePort::MessageReceiver implementation:
+  bool OnMessage(blink::WebMessagePort::Message message) override;
+
+  void SetOnMessageCallback(CefRefPtr<CefJavaScriptResultCallback> callback);
+
+private:
+  CefRefPtr<CefJavaScriptResultCallback> callback_;
+};
+
 struct CefHitData {
   int type;
   CefString extra_data;
@@ -211,7 +228,12 @@ class CefBrowserHostBase : public CefBrowserHost,
       const std::vector<CefString>& method_list) override;
   void OnWebPreferencesChanged();
   void ReloadOriginalUrl() override;
+  void StoreWebArchive(
+      const CefString& base_name,
+      bool auto_name,
+      CefRefPtr<CefStoreWebArchiveResultCallback> callback) override;
   void GetImageForContextNode() override;
+  void SetBrowserUserAgentString(const CefString& user_agent) override;
   /* ohos webview end */
 #endif
 
@@ -242,9 +264,19 @@ class CefBrowserHostBase : public CefBrowserHost,
   CefRefPtr<CefBrowserPermissionRequestDelegate> GetPermissionRequestDelegate()
       override;
   CefRefPtr<CefGeolocationAcess> GetGeolocationPermissions() override;
+#if defined(OS_OHOS)
+  void CreateWebMessagePorts(std::vector<CefString>& ports) override;
+  void PostWebMessage(CefString& message, std::vector<CefString>& ports, CefString& targetUri) override;
+  void ClosePort(CefString& port_handle) override;
+  void PostPortMessage(CefString& port_handle, CefString& data) override;
+  void SetPortMessageCallback(CefString& port_handle, CefRefPtr<CefJavaScriptResultCallback> callback) override;
+  void DestroyAllWebMessagePorts() override;
+#endif
   CefString Title() override;
   void GetHitData(int& type, CefString& extra_data) override;
   void SetInitialScale(float scale) override;
+  void SetVirtualPixelRatio(float ratio) override;
+  float GetVirtualPixelRatio() const;
   int PageLoadProgress() override;
   float Scale() override;
   void LoadWithDataAndBaseUrl(const CefString& baseUrl,
@@ -400,6 +432,11 @@ class CefBrowserHostBase : public CefBrowserHost,
   std::unique_ptr<CefDevToolsManager> devtools_manager_;
 
  private:
+#if defined(OS_OHOS)
+  void StoreWebArchiveInternal(
+      CefRefPtr<CefStoreWebArchiveResultCallback> callback,
+      const CefString& path);
+#endif  // OS_OHOS
   bool UseLegacyGeolocationPermissionAPI();
   // GURL is supplied by the content layer as requesting frame.
   // Callback is supplied by the content layer, and is invoked with the result
@@ -408,6 +445,15 @@ class CefBrowserHostBase : public CefBrowserHost,
   // The first element in the list is always the currently pending request.
   std::list<OriginCallback> unhandled_geolocation_prompts_;
 
+#if defined(OS_OHOS)
+  using MessagePipe = std::pair<blink::WebMessagePort, blink::WebMessagePort>;
+  using PortHandle = std::pair<uint64_t, uint64_t>;
+  std::map<PortHandle, MessagePipe> portMap_;
+  std::set<std::string> postedPorts_;
+  std::unordered_map<std::string, scoped_refptr<base::SequencedTaskRunner>> runnerMap_;
+  std::unordered_map<std::string, std::shared_ptr<WebMessageReceiverImpl>> receiverMap_;
+#endif
+
   CefHitData cef_hit_data_;
   CefRefPtr<CefGeolocationAcess> geolocation_permissions_;
   std::unique_ptr<AlloyPermissionRequestHandler> permission_request_handler_;
@@ -417,6 +463,11 @@ class CefBrowserHostBase : public CefBrowserHost,
 
   cef_accelerated_widget_t widget_;
   bool is_web_debugging_access_ = false;
+  float virtual_pixel_ratio_ = 2.0;
+
+#if defined(OS_OHOS)
+  base::WeakPtrFactory<CefBrowserHostBase> weak_ptr_factory_;
+#endif  // OS_OHOS
 };
 
 #endif  // CEF_LIBCEF_BROWSER_BROWSER_HOST_BASE_H_
diff --git a/cef/libcef/browser/browser_platform_delegate.cc b/cef/libcef/browser/browser_platform_delegate.cc
index 646614c126e79..d9b6f414aaa08 100644
--- a/cef/libcef/browser/browser_platform_delegate.cc
+++ b/cef/libcef/browser/browser_platform_delegate.cc
@@ -384,7 +384,8 @@ void CefBrowserPlatformDelegate::Find(int identifier,
                                       const CefString& searchText,
                                       bool forward,
                                       bool matchCase,
-                                      bool findNext) {
+                                      bool findNext,
+                                      bool newSession) {
   NOTIMPLEMENTED();
 }
 
diff --git a/cef/libcef/browser/browser_platform_delegate.h b/cef/libcef/browser/browser_platform_delegate.h
index 938f40840ed4f..cfa205fde5ee5 100644
--- a/cef/libcef/browser/browser_platform_delegate.h
+++ b/cef/libcef/browser/browser_platform_delegate.h
@@ -352,7 +352,8 @@ class CefBrowserPlatformDelegate {
                     const CefString& searchText,
                     bool forward,
                     bool matchCase,
-                    bool findNext);
+                    bool findNext,
+                    bool newSession);
   virtual void StopFinding(bool clearSelection);
 
  protected:
diff --git a/cef/libcef/browser/chrome/chrome_browser_host_impl.cc b/cef/libcef/browser/chrome/chrome_browser_host_impl.cc
index 5c8bd8fc17202..5f4795e05e634 100644
--- a/cef/libcef/browser/chrome/chrome_browser_host_impl.cc
+++ b/cef/libcef/browser/chrome/chrome_browser_host_impl.cc
@@ -234,7 +234,8 @@ void ChromeBrowserHostImpl::Find(int identifier,
                                  const CefString& searchText,
                                  bool forward,
                                  bool matchCase,
-                                 bool findNext) {
+                                 bool findNext,
+                                 bool newSession) {
   NOTIMPLEMENTED();
 }
 
@@ -594,4 +595,4 @@ int ChromeBrowserHostImpl::GetCurrentTabIndex() const {
   return TabStripModel::kNoTab;
 }
 
-void ChromeBrowserHostImpl::SetBackgroundColor(int color) {}
\ No newline at end of file
+void ChromeBrowserHostImpl::SetBackgroundColor(int color) {}
diff --git a/cef/libcef/browser/chrome/chrome_browser_host_impl.h b/cef/libcef/browser/chrome/chrome_browser_host_impl.h
index c73499622ca01..9c0b829afaa32 100644
--- a/cef/libcef/browser/chrome/chrome_browser_host_impl.h
+++ b/cef/libcef/browser/chrome/chrome_browser_host_impl.h
@@ -82,7 +82,8 @@ class ChromeBrowserHostImpl : public CefBrowserHostBase {
             const CefString& searchText,
             bool forward,
             bool matchCase,
-            bool findNext) override;
+            bool findNext,
+            bool newSession) override;
   void StopFinding(bool clearSelection) override;
   void ShowDevTools(const CefWindowInfo& windowInfo,
                     CefRefPtr<CefClient> client,
diff --git a/cef/libcef/browser/net_database/cef_data_base_impl.cc b/cef/libcef/browser/net_database/cef_data_base_impl.cc
index aa90f983f8e8c..7c2794aa20d45 100644
--- a/cef/libcef/browser/net_database/cef_data_base_impl.cc
+++ b/cef/libcef/browser/net_database/cef_data_base_impl.cc
@@ -59,4 +59,92 @@ void CefDataBaseImpl::GetHttpAuthCredentials(const CefString& host, const CefStr
   databaseAdapter.GetHttpAuthCredentials(host, realm, result);
   TransferVector(result, username_password);
   return;
-}
\ No newline at end of file
+}
+
+static OHOS::NWeb::WebPermissionType TypeToWebPermissionType(int type)
+{
+  if (type == CefDataBaseImpl::CefPermissionType::GEOLOCATION_TYPE) {
+    return OHOS::NWeb::WebPermissionType::GEOLOCATION;
+  }
+  return OHOS::NWeb::WebPermissionType::NONE_TYPE;
+}
+
+bool CefDataBaseImpl::ExistPermissionByOrigin(const CefString& origin, int type)
+{
+  if (origin.empty()) {
+    return false;
+  }
+  OHOS::NWeb::WebPermissionType key = TypeToWebPermissionType(type);
+  if (key == OHOS::NWeb::WebPermissionType::NONE_TYPE) {
+    return false;
+  }
+  OHOS::NWeb::OhosWebPermissionDataBaseAdapter& databaseAdapter =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().GetWebPermissionDataBaseInstance();
+  return databaseAdapter.ExistPermissionByOrigin(origin, key);
+}
+
+bool CefDataBaseImpl::GetPermissionResultByOrigin(const CefString& origin, int type, bool& result)
+{
+  if (origin.empty()) {
+    return false;
+  }
+  OHOS::NWeb::WebPermissionType key = TypeToWebPermissionType(type);
+  if (key == OHOS::NWeb::WebPermissionType::NONE_TYPE) {
+    return false;
+  }
+  OHOS::NWeb::OhosWebPermissionDataBaseAdapter& databaseAdapter =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().GetWebPermissionDataBaseInstance();
+  return databaseAdapter.GetPermissionResultByOrigin(origin, key, result);
+}
+
+void CefDataBaseImpl::SetPermissionByOrigin(const CefString& origin, int type, bool result)
+{
+  if (origin.empty()) {
+    return;
+  }
+  OHOS::NWeb::WebPermissionType key = TypeToWebPermissionType(type);
+  if (key == OHOS::NWeb::WebPermissionType::NONE_TYPE) {
+    return;
+  }
+  OHOS::NWeb::OhosWebPermissionDataBaseAdapter& databaseAdapter =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().GetWebPermissionDataBaseInstance();
+  databaseAdapter.SetPermissionByOrigin(origin, key, result);
+}
+
+void CefDataBaseImpl::ClearPermissionByOrigin(const CefString& origin, int type)
+{
+  if (origin.empty()) {
+    return;
+  }
+  OHOS::NWeb::WebPermissionType key = TypeToWebPermissionType(type);
+  if (key == OHOS::NWeb::WebPermissionType::NONE_TYPE) {
+    return;
+  }
+  OHOS::NWeb::OhosWebPermissionDataBaseAdapter& databaseAdapter =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().GetWebPermissionDataBaseInstance();
+  databaseAdapter.ClearPermissionByOrigin(origin, key);
+}
+
+void CefDataBaseImpl::ClearAllPermission(int type)
+{
+  OHOS::NWeb::WebPermissionType key = TypeToWebPermissionType(type);
+  if (key == OHOS::NWeb::WebPermissionType::NONE_TYPE) {
+    return;
+  }
+  OHOS::NWeb::OhosWebPermissionDataBaseAdapter& databaseAdapter =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().GetWebPermissionDataBaseInstance();
+  databaseAdapter.ClearAllPermission(key);
+}
+
+void CefDataBaseImpl::GetOriginsByPermission(int type, std::vector<CefString>& origins)
+{
+  OHOS::NWeb::WebPermissionType key = TypeToWebPermissionType(type);
+  if (key == OHOS::NWeb::WebPermissionType::NONE_TYPE) {
+    return;
+  }
+  OHOS::NWeb::OhosWebPermissionDataBaseAdapter& databaseAdapter =
+    OHOS::NWeb::OhosAdapterHelper::GetInstance().GetWebPermissionDataBaseInstance();
+  std::vector<std::string> result;
+  databaseAdapter.GetOriginsByPermission(key, result);
+  TransferVector(result, origins);
+}
diff --git a/cef/libcef/browser/net_database/cef_data_base_impl.h b/cef/libcef/browser/net_database/cef_data_base_impl.h
index bd9a92c2fd0d0..c5c88a75a660b 100644
--- a/cef/libcef/browser/net_database/cef_data_base_impl.h
+++ b/cef/libcef/browser/net_database/cef_data_base_impl.h
@@ -10,6 +10,10 @@
 
 class CefDataBaseImpl : public CefDataBase {
  public:
+  enum CefPermissionType {
+    GEOLOCATION_TYPE
+  };
+  
   CefDataBaseImpl() = default;
 
   bool ExistHttpAuthCredentials() override;
@@ -22,6 +26,17 @@ class CefDataBaseImpl : public CefDataBase {
   void GetHttpAuthCredentials(const CefString& host, const CefString& realm,
     std::vector<CefString>& username_password) override;
 
+  bool ExistPermissionByOrigin(const CefString& origin, int type) override;
+
+  bool GetPermissionResultByOrigin(const CefString& origin, int type, bool& result) override;
+
+  void SetPermissionByOrigin(const CefString& origin, int type, bool result) override;
+
+  void ClearPermissionByOrigin(const CefString& origin, int type) override;
+
+  void ClearAllPermission(int type) override;
+
+  void GetOriginsByPermission(int type, std::vector<CefString>& origins) override;
  private:
   IMPLEMENT_REFCOUNTING(CefDataBaseImpl);
 
diff --git a/cef/libcef/browser/net_service/cookie_manager_impl.cc b/cef/libcef/browser/net_service/cookie_manager_impl.cc
index 38c4c9833a5d3..b3d76ca44947d 100644
--- a/cef/libcef/browser/net_service/cookie_manager_impl.cc
+++ b/cef/libcef/browser/net_service/cookie_manager_impl.cc
@@ -11,6 +11,7 @@
 #include "base/logging.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/storage_partition.h"
+#include "net_helpers.h"
 #include "services/network/public/mojom/cookie_manager.mojom.h"
 #include "url/gurl.h"
 
@@ -108,11 +109,27 @@ void CefCookieManagerImpl::Initialize(
 }
 
 bool CefCookieManagerImpl::IsAcceptCookieAllowed() {
-  return accept_cookies_;
+  return net_service::NetHelpers::IsAllowAcceptCookies();
 }
 
 void CefCookieManagerImpl::PutAcceptCookieEnabled(bool accept) {
-  accept_cookies_ = accept;
+  net_service::NetHelpers::accept_cookies = accept;
+}
+
+bool CefCookieManagerImpl::IsThirdPartyCookieAllowed() {
+  return net_service::NetHelpers::IsThirdPartyCookieAllowed();
+}
+
+void CefCookieManagerImpl::PutAcceptThirdPartyCookieEnabled(bool accept) {
+  if (!ValidContext()) {
+    StoreOrTriggerInitCallback(base::BindOnce(
+        base::IgnoreResult(&CefCookieManagerImpl::
+                               PutAcceptThirdPartyCookieEnabledInternal),
+        this, accept));
+    return;
+  }
+
+  PutAcceptThirdPartyCookieEnabledInternal(accept);
 }
 
 bool CefCookieManagerImpl::IsFileURLSchemeCookiesAllowed() {
@@ -216,6 +233,16 @@ bool CefCookieManagerImpl::FlushStore(
   return FlushStoreInternal(callback);
 }
 
+bool CefCookieManagerImpl::PutAcceptThirdPartyCookieEnabledInternal(bool accept) {
+  DCHECK(ValidContext());
+  auto browser_context = GetBrowserContext(browser_context_getter_);
+  if (!browser_context)
+    return false;
+  net_service::NetHelpers::third_party_cookies = accept;
+  GetCookieManager(browser_context)->BlockThirdPartyCookies(!accept);
+  return true;
+}
+
 void CefCookieManagerImpl::PutAcceptFileURLSchemeCookiesEnabledCompleted(
     bool allow,
     bool can_change_schemes) {
diff --git a/cef/libcef/browser/net_service/cookie_manager_impl.h b/cef/libcef/browser/net_service/cookie_manager_impl.h
index 55c544dbdc1e5..79b1088a30980 100644
--- a/cef/libcef/browser/net_service/cookie_manager_impl.h
+++ b/cef/libcef/browser/net_service/cookie_manager_impl.h
@@ -28,6 +28,8 @@ class CefCookieManagerImpl : public CefCookieManager {
   // CefCookieManager methods.
   bool IsAcceptCookieAllowed() override;
   void PutAcceptCookieEnabled(bool accept) override;
+  bool IsThirdPartyCookieAllowed() override;
+  void PutAcceptThirdPartyCookieEnabled(bool accept) override;
   bool IsFileURLSchemeCookiesAllowed() override;
   void PutAcceptFileURLSchemeCookiesEnabled(bool allow) override;
   bool VisitAllCookies(CefRefPtr<CefCookieVisitor> visitor) override;
@@ -44,6 +46,7 @@ class CefCookieManagerImpl : public CefCookieManager {
   bool FlushStore(CefRefPtr<CefCompletionCallback> callback) override;
 
  private:
+  bool PutAcceptThirdPartyCookieEnabledInternal(bool accept);
   void PutAcceptFileURLSchemeCookiesEnabledCompleted(bool allow, bool can_change_schemes);
   bool PutAcceptFileURLSchemeCookiesEnabledInternal(bool allow);
   bool VisitAllCookiesInternal(CefRefPtr<CefCookieVisitor> visitor);
@@ -81,7 +84,6 @@ class CefCookieManagerImpl : public CefCookieManager {
   CefBrowserContext::Getter browser_context_getter_;
 
   bool initialized_ = false;
-  std::atomic<bool> accept_cookies_ = true;
   std::atomic<bool> allow_file_scheme_cookies_ = false;
   std::vector<base::OnceClosure> init_callbacks_;
   base::Thread cookie_thread;
diff --git a/cef/libcef/browser/net_service/net_helpers.cc b/cef/libcef/browser/net_service/net_helpers.cc
index 056525bb27c4e..e5c3a6c13e132 100644
--- a/cef/libcef/browser/net_service/net_helpers.cc
+++ b/cef/libcef/browser/net_service/net_helpers.cc
@@ -30,6 +30,8 @@ int UpdateCacheLoadFlags(int load_flags, int cache_control_flags) {
 bool NetHelpers::allow_content_access = false;
 bool NetHelpers::allow_file_access = false;
 bool NetHelpers::is_network_blocked = false;
+bool NetHelpers::accept_cookies = true;
+bool NetHelpers::third_party_cookies = true;
 int NetHelpers::cache_mode = 0;
 
 bool NetHelpers::ShouldBlockContentUrls() {
@@ -40,6 +42,14 @@ bool NetHelpers::ShouldBlockFileUrls() {
   return !allow_file_access;
 }
 
+bool NetHelpers::IsAllowAcceptCookies() {
+  return accept_cookies;
+}
+
+bool NetHelpers::IsThirdPartyCookieAllowed() {
+  return third_party_cookies;
+}
+
 bool IsSpecialFileUrl(const GURL& url) {
   if (!url.is_valid() || !url.SchemeIsFile() || !url.has_path())
     return false;
diff --git a/cef/libcef/browser/net_service/net_helpers.h b/cef/libcef/browser/net_service/net_helpers.h
index c9ca95e737158..f2283769ec839 100644
--- a/cef/libcef/browser/net_service/net_helpers.h
+++ b/cef/libcef/browser/net_service/net_helpers.h
@@ -15,10 +15,14 @@ class NETHELPERS_EXPORT NetHelpers {
  public:
   static bool ShouldBlockContentUrls();
   static bool ShouldBlockFileUrls();
+  static bool IsAllowAcceptCookies();
+  static bool IsThirdPartyCookieAllowed();
 
   static bool allow_content_access;
   static bool allow_file_access;
   static bool is_network_blocked;
+  static bool accept_cookies;
+  static bool third_party_cookies;
   static int cache_mode;
 };
 
diff --git a/cef/libcef/browser/net_service/proxy_url_loader_factory.cc b/cef/libcef/browser/net_service/proxy_url_loader_factory.cc
index 470806ab660ec..9d59df9e63030 100644
--- a/cef/libcef/browser/net_service/proxy_url_loader_factory.cc
+++ b/cef/libcef/browser/net_service/proxy_url_loader_factory.cc
@@ -6,7 +6,6 @@
 #include "libcef/browser/net_service/proxy_url_loader_factory.h"
 
 #include "libcef/browser/context.h"
-#include "libcef/browser/net_service/net_helpers.h"
 #include "libcef/browser/origin_whitelist_impl.h"
 #include "libcef/browser/thread_util.h"
 #include "libcef/common/cef_switches.h"
@@ -1401,6 +1400,14 @@ void ProxyURLLoaderFactory::CreateLoaderAndStart(
         target_factory_clone.InitWithNewPipeAndPassReceiver());
   }
 
+  bool allCookiePolicy = NetHelpers::IsAllowAcceptCookies();
+  bool thirdPartyCookiePolicy = NetHelpers::IsThirdPartyCookieAllowed();
+  if (!allCookiePolicy) {
+    options |= network::mojom::kURLLoadOptionBlockAllCookies;
+  } else if (!thirdPartyCookiePolicy) {
+    options |= network::mojom::kURLLoadOptionBlockThirdPartyCookies;
+  }
+
   InterceptedRequest* req = new InterceptedRequest(
       this, request_id, options, request, traffic_annotation,
       std::move(receiver), std::move(client), std::move(target_factory_clone));
diff --git a/cef/libcef/browser/net_service/proxy_url_loader_factory.h b/cef/libcef/browser/net_service/proxy_url_loader_factory.h
index 5f26acd9ffcce..fcd126013bcca 100644
--- a/cef/libcef/browser/net_service/proxy_url_loader_factory.h
+++ b/cef/libcef/browser/net_service/proxy_url_loader_factory.h
@@ -7,6 +7,7 @@
 #define CEF_LIBCEF_BROWSER_NET_SERVICE_PROXY_URL_LOADER_FACTORY_H_
 
 #include "include/internal/cef_ptr.h"
+#include "libcef/browser/net_service/net_helpers.h"
 #include "libcef/browser/net_service/stream_reader_url_loader.h"
 
 #include "base/callback.h"
diff --git a/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc b/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc
index cdd7e55249ed2..9fba6a5a556e0 100644
--- a/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc
+++ b/cef/libcef/browser/net_service/resource_request_handler_wrapper.cc
@@ -29,6 +29,7 @@
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/web_contents.h"
 #include "net/base/load_flags.h"
+#include "net_helpers.h"
 #include "net/http/http_status_code.h"
 #include "third_party/blink/public/mojom/loader/resource_load_info.mojom-shared.h"
 #include "ui/base/page_transition_types.h"
@@ -467,9 +468,9 @@ class InterceptedRequestHandlerWrapper : public InterceptedRequestHandler {
                         network::ResourceRequest* request,
                         base::OnceClosure callback) {
     CEF_REQUIRE_IOT();
-
     if (!cookie_helper::IsCookieableScheme(request->url,
-                                           init_state_->cookieable_schemes_)) {
+                                           init_state_->cookieable_schemes_)
+                            || !net_service::NetHelpers::IsThirdPartyCookieAllowed()) {
       // The scheme does not support cookies.
       std::move(callback).Run();
       return;
@@ -919,7 +920,8 @@ class InterceptedRequestHandlerWrapper : public InterceptedRequestHandler {
     }
 
     if (!cookie_helper::IsCookieableScheme(request->url,
-                                           init_state_->cookieable_schemes_)) {
+                                           init_state_->cookieable_schemes_)
+                    || !net_service::NetHelpers::IsThirdPartyCookieAllowed()) {
       // The scheme does not support cookies.
       std::move(callback).Run();
       return;
diff --git a/cef/libcef/browser/net_service/restrict_cookie_manager.cc b/cef/libcef/browser/net_service/restrict_cookie_manager.cc
new file mode 100644
index 0000000000000..e27b614f8d7b9
--- /dev/null
+++ b/cef/libcef/browser/net_service/restrict_cookie_manager.cc
@@ -0,0 +1,194 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "libcef/browser/net_service/restrict_cookie_manager.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/memory/ptr_util.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "mojo/public/cpp/bindings/pending_remote.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "mojo/public/cpp/bindings/self_owned_receiver.h"
+#include "net_helpers.h"
+#include "url/gurl.h"
+
+class ProxyingRestrictedCookieManagerListener
+    : public network::mojom::CookieChangeListener {
+ public:
+  ProxyingRestrictedCookieManagerListener(
+      const GURL& url,
+      const net::SiteForCookies& site_for_cookies,
+      base::WeakPtr<ProxyingRestrictedCookieManager>
+          restricted_cookie_manager,
+      mojo::PendingRemote<network::mojom::CookieChangeListener> client_listener)
+      : url_(url),
+        site_for_cookies_(site_for_cookies),
+        restricted_cookie_manager_(restricted_cookie_manager),
+        client_listener_(std::move(client_listener)) {}
+
+  void OnCookieChange(const net::CookieChangeInfo& change) override {
+    if (restricted_cookie_manager_ &&
+        restricted_cookie_manager_->AllowCookies(url_, site_for_cookies_))
+      client_listener_->OnCookieChange(change);
+  }
+
+ private:
+  const GURL url_;
+  const net::SiteForCookies site_for_cookies_;
+  base::WeakPtr<ProxyingRestrictedCookieManager>
+      restricted_cookie_manager_;
+  mojo::Remote<network::mojom::CookieChangeListener> client_listener_;
+};
+
+// static
+void ProxyingRestrictedCookieManager::CreateAndBind(
+    mojo::PendingRemote<network::mojom::RestrictedCookieManager> underlying_rcm,
+    bool is_service_worker,
+    int process_id,
+    int frame_id,
+    mojo::PendingReceiver<network::mojom::RestrictedCookieManager> receiver) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  content::GetIOThreadTaskRunner({})->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &ProxyingRestrictedCookieManager::CreateAndBindOnIoThread,
+          std::move(underlying_rcm), is_service_worker, process_id, frame_id,
+          std::move(receiver)));
+}
+
+ProxyingRestrictedCookieManager::~ProxyingRestrictedCookieManager() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+}
+
+void ProxyingRestrictedCookieManager::GetAllForUrl(
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies,
+    const url::Origin& top_frame_origin,
+    network::mojom::CookieManagerGetOptionsPtr options,
+    GetAllForUrlCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  if (AllowCookies(url, site_for_cookies)) {
+    underlying_restricted_cookie_manager_->GetAllForUrl(
+        url, site_for_cookies, top_frame_origin, std::move(options),
+        std::move(callback));
+  } else {
+    std::move(callback).Run(std::vector<net::CookieWithAccessResult>());
+  }
+}
+
+void ProxyingRestrictedCookieManager::SetCanonicalCookie(
+    const net::CanonicalCookie& cookie,
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies,
+    const url::Origin& top_frame_origin,
+    SetCanonicalCookieCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  if (AllowCookies(url, site_for_cookies)) {
+    underlying_restricted_cookie_manager_->SetCanonicalCookie(
+        cookie, url, site_for_cookies, top_frame_origin, std::move(callback));
+  } else {
+    std::move(callback).Run(false);
+  }
+}
+
+void ProxyingRestrictedCookieManager::AddChangeListener(
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies,
+    const url::Origin& top_frame_origin,
+    mojo::PendingRemote<network::mojom::CookieChangeListener> listener,
+    AddChangeListenerCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  mojo::PendingRemote<network::mojom::CookieChangeListener>
+      proxy_listener_remote;
+  auto proxy_listener =
+      std::make_unique<ProxyingRestrictedCookieManagerListener>(
+          url, site_for_cookies, weak_factory_.GetWeakPtr(),
+          std::move(listener));
+
+  mojo::MakeSelfOwnedReceiver(
+      std::move(proxy_listener),
+      proxy_listener_remote.InitWithNewPipeAndPassReceiver());
+
+  underlying_restricted_cookie_manager_->AddChangeListener(
+      url, site_for_cookies, top_frame_origin, std::move(proxy_listener_remote),
+      std::move(callback));
+}
+
+void ProxyingRestrictedCookieManager::SetCookieFromString(
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies,
+    const url::Origin& top_frame_origin,
+    const std::string& cookie,
+    SetCookieFromStringCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  if (AllowCookies(url, site_for_cookies)) {
+    underlying_restricted_cookie_manager_->SetCookieFromString(
+        url, site_for_cookies, top_frame_origin, cookie, std::move(callback));
+  } else {
+    std::move(callback).Run();
+  }
+}
+
+void ProxyingRestrictedCookieManager::GetCookiesString(
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies,
+    const url::Origin& top_frame_origin,
+    GetCookiesStringCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  if (AllowCookies(url, site_for_cookies)) {
+    underlying_restricted_cookie_manager_->GetCookiesString(
+        url, site_for_cookies, top_frame_origin, std::move(callback));
+  } else {
+    std::move(callback).Run("");
+  }
+}
+
+void ProxyingRestrictedCookieManager::CookiesEnabledFor(
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies,
+    const url::Origin& top_frame_origin,
+    CookiesEnabledForCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  std::move(callback).Run(AllowCookies(url, site_for_cookies));
+}
+
+ProxyingRestrictedCookieManager::ProxyingRestrictedCookieManager(
+    mojo::PendingRemote<network::mojom::RestrictedCookieManager>
+        underlying_restricted_cookie_manager,
+    bool is_service_worker,
+    int process_id,
+    int frame_id)
+    : underlying_restricted_cookie_manager_(
+           std::move(underlying_restricted_cookie_manager)) {
+  is_service_worker_ = is_service_worker;
+  process_id_ = process_id;
+  frame_id_ = frame_id;
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+}
+
+// static
+void ProxyingRestrictedCookieManager::CreateAndBindOnIoThread(
+    mojo::PendingRemote<network::mojom::RestrictedCookieManager> underlying_rcm,
+    bool is_service_worker,
+    int process_id,
+    int frame_id,
+    mojo::PendingReceiver<network::mojom::RestrictedCookieManager> receiver) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  auto wrapper = base::WrapUnique(new ProxyingRestrictedCookieManager(
+      std::move(underlying_rcm), is_service_worker, process_id, frame_id));
+  mojo::MakeSelfOwnedReceiver(std::move(wrapper), std::move(receiver));
+}
+
+bool ProxyingRestrictedCookieManager::AllowCookies(
+    const GURL& url,
+    const net::SiteForCookies& site_for_cookies) const {
+  return net_service::NetHelpers::IsAllowAcceptCookies();
+}
diff --git a/cef/libcef/browser/net_service/restrict_cookie_manager.h b/cef/libcef/browser/net_service/restrict_cookie_manager.h
new file mode 100644
index 0000000000000..5dc1806473130
--- /dev/null
+++ b/cef/libcef/browser/net_service/restrict_cookie_manager.h
@@ -0,0 +1,102 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_BROWSER_NET_SERVICE_RESTRICT_COOKIE_MANAGER_H_
+#define CEF_LIBCEF_BROWSER_NET_SERVICE_RESTRICT_COOKIE_MANAGER_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "include/cef_cookie.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "services/network/public/mojom/restricted_cookie_manager.mojom.h"
+
+class GURL;
+
+// A RestrictedCookieManager which conditionally proxies to an underlying
+// RestrictedCookieManager, first consulting WebView's cookie settings.
+class ProxyingRestrictedCookieManager
+    : public network::mojom::RestrictedCookieManager {
+ public:
+  // Creates a ProxyingRestrictedCookieManager that lives on IO thread,
+  // binding it to handle communications from |receiver|. The requests will be
+  // delegated to |underlying_rcm|. The resulting object will be owned by the
+  // pipe corresponding to |request| and will in turn own |underlying_rcm|.
+  //
+  // Expects to be called on the UI thread.
+  static void CreateAndBind(
+      mojo::PendingRemote<network::mojom::RestrictedCookieManager>
+          underlying_rcm,
+      bool is_service_worker,
+      int process_id,
+      int frame_id,
+      mojo::PendingReceiver<network::mojom::RestrictedCookieManager> receiver);
+
+  ~ProxyingRestrictedCookieManager() override;
+
+  // network::mojom::RestrictedCookieManager interface:
+  void GetAllForUrl(const GURL& url,
+                    const net::SiteForCookies& site_for_cookies,
+                    const url::Origin& top_frame_origin,
+                    network::mojom::CookieManagerGetOptionsPtr options,
+                    GetAllForUrlCallback callback) override;
+  void SetCanonicalCookie(const net::CanonicalCookie& cookie,
+                          const GURL& url,
+                          const net::SiteForCookies& site_for_cookies,
+                          const url::Origin& top_frame_origin,
+                          SetCanonicalCookieCallback callback) override;
+  void AddChangeListener(
+      const GURL& url,
+      const net::SiteForCookies& site_for_cookies,
+      const url::Origin& top_frame_origin,
+      mojo::PendingRemote<network::mojom::CookieChangeListener> listener,
+      AddChangeListenerCallback callback) override;
+
+  void SetCookieFromString(const GURL& url,
+                           const net::SiteForCookies& site_for_cookies,
+                           const url::Origin& top_frame_origin,
+                           const std::string& cookie,
+                           SetCookieFromStringCallback callback) override;
+
+  void GetCookiesString(const GURL& url,
+                        const net::SiteForCookies& site_for_cookies,
+                        const url::Origin& top_frame_origin,
+                        GetCookiesStringCallback callback) override;
+
+  void CookiesEnabledFor(const GURL& url,
+                         const net::SiteForCookies& site_for_cookies,
+                         const url::Origin& top_frame_origin,
+                         CookiesEnabledForCallback callback) override;
+
+  bool AllowCookies(const GURL& url,
+                    const net::SiteForCookies& site_for_cookies) const;
+ private:
+  ProxyingRestrictedCookieManager(
+      mojo::PendingRemote<network::mojom::RestrictedCookieManager>
+          underlying_restricted_cookie_manager,
+      bool is_service_worker,
+      int process_id,
+      int frame_id);
+
+  static void CreateAndBindOnIoThread(
+      mojo::PendingRemote<network::mojom::RestrictedCookieManager>
+          underlying_rcm,
+      bool is_service_worker,
+      int process_id,
+      int frame_id,
+      mojo::PendingReceiver<network::mojom::RestrictedCookieManager> receiver);
+
+  mojo::Remote<network::mojom::RestrictedCookieManager>
+      underlying_restricted_cookie_manager_;
+  bool is_service_worker_;
+  int process_id_;
+  int frame_id_;
+
+  base::WeakPtrFactory<ProxyingRestrictedCookieManager> weak_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ProxyingRestrictedCookieManager);
+};
+
+#endif  // CEF_LIBCEF_BROWSER_NET_SERVICE_RESTRICT_COOKIE_MANAGER_H_
diff --git a/cef/libcef/browser/osr/render_widget_host_view_osr.cc b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
index 0510a80055694..535ca641773ab 100644
--- a/cef/libcef/browser/osr/render_widget_host_view_osr.cc
+++ b/cef/libcef/browser/osr/render_widget_host_view_osr.cc
@@ -1140,7 +1140,10 @@ void CefRenderWidgetHostViewOSR::OnScaleChanged(float old_page_scale_factor, flo
   if (browser_impl_.get()) {
     CefRefPtr<CefDisplayHandler> handler = browser_impl_->client()->GetDisplayHandler();
     CHECK(handler);
-    handler->OnScaleChanged(browser_impl_.get(), old_page_scale_factor * DEFAULT_SCALE, nwe_page_scale_factor * DEFAULT_SCALE);
+    float ratio = browser_impl_->GetVirtualPixelRatio();
+    handler->OnScaleChanged(browser_impl_.get(),
+                            old_page_scale_factor * (100 / ratio),
+                            nwe_page_scale_factor * (100 / ratio));
   }
 }
 
@@ -1556,9 +1559,10 @@ void CefRenderWidgetHostViewOSR::SendFocusEvent(bool focus) {
     widget->GotFocus();
     widget->SetActive(true);
   } else {
+#ifndef OS_OHOS
     if (browser_impl_.get())
       browser_impl_->CancelContextMenu();
-
+#endif
     if (selection_controller_client_) {
       selection_controller_client_->CloseQuickMenuAndHideHandles();
     }
@@ -1573,23 +1577,26 @@ void CefRenderWidgetHostViewOSR::OnUpdateTextInputStateCalled(
     content::RenderWidgetHostViewBase* updated_view,
     bool did_update_state) {
   const auto state = text_input_manager->GetTextInputState();
-  if (state && !state->show_ime_if_needed)
-    return;
+  if (state && !state->show_ime_if_needed) {
+    LOG(INFO) << "OnUpdateTextInputStateCalled no need to show ime";
+  }
 
   CefRenderHandler::TextInputMode mode = CEF_TEXT_INPUT_MODE_NONE;
+  bool show_keyboard = false;
   if (state && state->type != ui::TEXT_INPUT_TYPE_NONE) {
     static_assert(
         static_cast<int>(CEF_TEXT_INPUT_MODE_MAX) ==
             static_cast<int>(ui::TEXT_INPUT_MODE_MAX),
         "Enum values in cef_text_input_mode_t must match ui::TextInputMode");
     mode = static_cast<CefRenderHandler::TextInputMode>(state->mode);
+    show_keyboard = state->show_ime_if_needed;
   }
 
   CefRefPtr<CefRenderHandler> handler =
       browser_impl_->GetClient()->GetRenderHandler();
   CHECK(handler);
 
-  handler->OnVirtualKeyboardRequested(browser_impl_->GetBrowser(), mode);
+  handler->OnVirtualKeyboardRequested(browser_impl_->GetBrowser(), mode, show_keyboard);
 }
 
 void CefRenderWidgetHostViewOSR::ProcessAckedTouchEvent(
@@ -1710,6 +1717,29 @@ ui::TextInputType CefRenderWidgetHostViewOSR::GetTextInputType() {
   return ui::TEXT_INPUT_TYPE_NONE;
 }
 
+void CefRenderWidgetHostViewOSR::OnTouchSelectionChanged(
+  const CefTouchHandleState& insert_handle,
+  const CefTouchHandleState& start_selection_handle,
+  const CefTouchHandleState& end_selection_handle,
+  bool need_report) {
+  if (!browser_impl_) {
+    return;
+  }
+  CefRefPtr<CefRenderHandler> handler =
+    browser_impl_->client()->GetRenderHandler();
+  if (handler) {
+    handler->OnTouchSelectionChanged(
+      insert_handle, start_selection_handle, end_selection_handle, need_report);
+  }
+}
+
+bool CefRenderWidgetHostViewOSR::NeedPopupInsertTouchHandleQuickMenu() {
+  if (selection_controller_client_) {
+    selection_controller_client_->NeedPopupInsertTouchHandleQuickMenu();
+  }
+  return false;
+}
+
 void CefRenderWidgetHostViewOSR::SetFrameRate() {
   CefRefPtr<AlloyBrowserHostImpl> browser;
   if (parent_host_view_) {
diff --git a/cef/libcef/browser/osr/render_widget_host_view_osr.h b/cef/libcef/browser/osr/render_widget_host_view_osr.h
index aeca0fbfb9fae..ba70972b9472d 100644
--- a/cef/libcef/browser/osr/render_widget_host_view_osr.h
+++ b/cef/libcef/browser/osr/render_widget_host_view_osr.h
@@ -300,6 +300,12 @@ class CefRenderWidgetHostViewOSR
 
   ui::TextInputType GetTextInputType();
 
+  void OnTouchSelectionChanged(const CefTouchHandleState& insert_handle,
+                              const CefTouchHandleState& start_selection_handle,
+                              const CefTouchHandleState& end_selection_handle,
+                              bool need_report);
+  bool NeedPopupInsertTouchHandleQuickMenu();
+
  private:
   void SetFrameRate();
   bool SetDeviceScaleFactor();
diff --git a/cef/libcef/browser/osr/touch_handle_drawable_osr.cc b/cef/libcef/browser/osr/touch_handle_drawable_osr.cc
index 5c4b2b83ad234..d9659b6883854 100755
--- a/cef/libcef/browser/osr/touch_handle_drawable_osr.cc
+++ b/cef/libcef/browser/osr/touch_handle_drawable_osr.cc
@@ -17,7 +17,7 @@ namespace {
 
 // The distance by which a handle image is offset from the focal point (i.e.
 // text baseline) downwards.
-constexpr int kSelectionHandleVerticalVisualOffset = 2;
+constexpr int kSelectionHandleVerticalVisualOffset = 10;
 
 // The padding around the selection handle image can be used to extend the
 // handle so that touch events near the selection handle image are
@@ -53,30 +53,7 @@ void CefTouchHandleDrawableOSR::SetOrientation(
     return;
 
   orientation_ = orientation;
-
-  CefSize size;
-  auto browser = rwhv_->browser_impl();
-  auto handler = browser->GetClient()->GetRenderHandler();
-  handler->GetTouchHandleSize(
-      browser.get(), static_cast<cef_horizontal_alignment_t>(orientation_),
-      size);
-
-  const gfx::Size& image_size = gfx::Size(size.width, size.height);
-  int handle_width = image_size.width() + 2 * kSelectionHandlePadding;
-  int handle_height = image_size.height() + 2 * kSelectionHandlePadding;
-  relative_bounds_ =
-      gfx::RectF(-kSelectionHandlePadding,
-                 kSelectionHandleVerticalVisualOffset - kSelectionHandlePadding,
-                 handle_width, handle_height);
-
-  CefTouchHandleState touch_handle_state;
-  touch_handle_state.touch_handle_id = id_;
-  touch_handle_state.flags = CEF_THS_FLAG_ORIENTATION;
-  touch_handle_state.orientation =
-      static_cast<cef_horizontal_alignment_t>(orientation_);
-  touch_handle_state.mirror_vertical = mirror_vertical;
-  touch_handle_state.mirror_horizontal = mirror_horizontal;
-  TouchHandleStateChanged(touch_handle_state);
+  UpdateVisiableBounds();
 }
 
 void CefTouchHandleDrawableOSR::SetOrigin(const gfx::PointF& position) {
@@ -84,13 +61,6 @@ void CefTouchHandleDrawableOSR::SetOrigin(const gfx::PointF& position) {
     return;
 
   origin_position_ = position;
-
-  CefTouchHandleState touch_handle_state;
-  touch_handle_state.touch_handle_id = id_;
-  touch_handle_state.flags = CEF_THS_FLAG_ORIGIN;
-  touch_handle_state.origin = {static_cast<int>(std::round(position.x())),
-                               static_cast<int>(std::round(position.y()))};
-  TouchHandleStateChanged(touch_handle_state);
 }
 
 void CefTouchHandleDrawableOSR::SetAlpha(float alpha) {
@@ -98,29 +68,48 @@ void CefTouchHandleDrawableOSR::SetAlpha(float alpha) {
     return;
 
   alpha_ = alpha;
-
-  CefTouchHandleState touch_handle_state;
-  touch_handle_state.touch_handle_id = id_;
-  touch_handle_state.flags = CEF_THS_FLAG_ALPHA;
-  touch_handle_state.alpha = alpha_;
-  TouchHandleStateChanged(touch_handle_state);
 }
 
 gfx::RectF CefTouchHandleDrawableOSR::GetVisibleBounds() const {
   gfx::RectF bounds = relative_bounds_;
   bounds.Offset(origin_position_.x(), origin_position_.y());
-  // TODO: 91.0.4455.0 don't have gfx::InsetsF::TLBR
-//   bounds.Inset(gfx::InsetsF::TLBR(
-//       kSelectionHandlePadding,
-//       kSelectionHandlePadding + kSelectionHandleVerticalVisualOffset,
-//       kSelectionHandlePadding, kSelectionHandlePadding));
   return bounds;
 }
 
+void CefTouchHandleDrawableOSR::SetEdge(
+    const gfx::PointF& top, const gfx::PointF& bottom) {
+  edge_height_ = bottom.y() - top.y();
+
+  UpdateVisiableBounds();
+}
+
 float CefTouchHandleDrawableOSR::GetDrawableHorizontalPaddingRatio() const {
   return 0.0f;
 }
 
+void CefTouchHandleDrawableOSR::UpdateVisiableBounds() {
+  CefSize size;
+  auto browser = rwhv_->browser_impl();
+  auto handler = browser->GetClient()->GetRenderHandler();
+  handler->GetTouchHandleSize(
+      browser.get(), static_cast<cef_horizontal_alignment_t>(orientation_),
+      size);
+
+  const gfx::Size& image_size = gfx::Size(size.width, size.height);
+  int handle_width = image_size.width() + 2 * kSelectionHandlePadding;
+  int handle_height = image_size.height() + 2 * kSelectionHandlePadding;
+  if (orientation_ != ui::TouchHandleOrientation::LEFT) {
+    relative_bounds_ =
+      gfx::RectF(-kSelectionHandleVerticalVisualOffset, 0,
+                 handle_width, handle_height);
+  } else {
+    relative_bounds_ =
+      gfx::RectF(-kSelectionHandleVerticalVisualOffset,
+                 -edge_height_ - kSelectionHandleVerticalVisualOffset * 2,
+                 handle_width, handle_height);
+  }
+}
+
 void CefTouchHandleDrawableOSR::TouchHandleStateChanged(
     const CefTouchHandleState& state) {
   auto browser = rwhv_->browser_impl();
diff --git a/cef/libcef/browser/osr/touch_handle_drawable_osr.h b/cef/libcef/browser/osr/touch_handle_drawable_osr.h
index b80286912c84c..6634c4ec69489 100755
--- a/cef/libcef/browser/osr/touch_handle_drawable_osr.h
+++ b/cef/libcef/browser/osr/touch_handle_drawable_osr.h
@@ -34,9 +34,11 @@ class CefTouchHandleDrawableOSR : public ui::TouchHandleDrawable {
   void SetOrigin(const gfx::PointF& position) override;
   void SetAlpha(float alpha) override;
   gfx::RectF GetVisibleBounds() const override;
+  void SetEdge(const gfx::PointF& top, const gfx::PointF& bottom) override;
   float GetDrawableHorizontalPaddingRatio() const override;
 
   // Pass the current touch handle state to the CefRenderHandler.
+  void UpdateVisiableBounds();
   void TouchHandleStateChanged(const CefTouchHandleState& state);
 
   CefRenderWidgetHostViewOSR* rwhv_;
@@ -54,6 +56,9 @@ class CefTouchHandleDrawableOSR : public ui::TouchHandleDrawable {
 
   // Handle bounds relative to the focal position.
   gfx::RectF relative_bounds_ = gfx::RectF(0.0F, 0.0F, 24.0F, 24.0F);
+
+  // Handle line height
+  float edge_height_ = 0.f;
 };
 
 #endif
\ No newline at end of file
diff --git a/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc b/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc
index 09bab10e798bb..f9822b324e965 100755
--- a/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc
+++ b/cef/libcef/browser/osr/touch_selection_controller_client_osr.cc
@@ -29,7 +29,7 @@ constexpr int kQuickMenuDelayInMs = 100;
 
 constexpr cef_quick_menu_edit_state_flags_t kMenuCommands[] = {
     QM_EDITFLAG_CAN_ELLIPSIS, QM_EDITFLAG_CAN_CUT, QM_EDITFLAG_CAN_COPY,
-    QM_EDITFLAG_CAN_PASTE};
+    QM_EDITFLAG_CAN_PASTE, QM_EDITFLAG_CAN_SELECT_ALL};
 
 constexpr int kInvalidCommandId = -1;
 constexpr cef_event_flags_t kEmptyEventFlags =
@@ -89,6 +89,19 @@ class CefRunQuickMenuCallbackImpl : public CefRunQuickMenuCallback {
   IMPLEMENT_REFCOUNTING(CefRunQuickMenuCallbackImpl);
 };
 
+void ConvertTouchHandleState(
+    const std::unique_ptr<ui::TouchHandle>& handle,
+    CefTouchHandleState& state) {
+  if (handle == nullptr) {
+    state.enabled = 0;
+    return;
+  }
+
+  state.enabled = handle->GetEnabled();
+  state.origin = { handle->focus_bottom().x(), handle->focus_bottom().y()};
+  state.edge_height = handle->focus_bottom().y() - handle->focus_top().y();
+  state.alpha = handle->alpha();
+}
 }  // namespace
 
 CefTouchSelectionControllerClientOSR::CefTouchSelectionControllerClientOSR(
@@ -101,7 +114,7 @@ CefTouchSelectionControllerClientOSR::CefTouchSelectionControllerClientOSR(
           FROM_HERE,
           base::TimeDelta::FromMilliseconds(kQuickMenuDelayInMs),
           base::BindRepeating(
-              &CefTouchSelectionControllerClientOSR::ShowQuickMenu,
+              &CefTouchSelectionControllerClientOSR::RunQuickMenu,
               base::Unretained(this))),
       weak_ptr_factory_(this) {
   DCHECK(rwhv_);
@@ -243,6 +256,9 @@ void CefTouchSelectionControllerClientOSR::CloseQuickMenu() {
   if (auto handler = browser->client()->GetContextMenuHandler()) {
     handler->OnQuickMenuDismissed(browser.get(), browser->GetFocusedFrame());
   }
+  if (browser->web_contents()) {
+    browser->web_contents()->SetShowingContextMenu(false);
+  }
 }
 
 void CefTouchSelectionControllerClientOSR::ShowQuickMenu() {
@@ -256,8 +272,6 @@ void CefTouchSelectionControllerClientOSR::ShowQuickMenu() {
     auto client_bounds = gfx::RectF(rwhv_->GetViewBounds());
     origin.SetToMax(client_bounds.origin());
     bottom_right.SetToMin(client_bounds.bottom_right());
-    if (origin.x() > bottom_right.x() || origin.y() > bottom_right.y())
-      return;
 
     gfx::Vector2dF diagonal = bottom_right - origin;
     gfx::SizeF size(diagonal.x(), diagonal.y());
@@ -286,6 +300,10 @@ void CefTouchSelectionControllerClientOSR::ShowQuickMenu() {
             callbackImpl)) {
       callbackImpl->Disconnect();
       CloseQuickMenu();
+    } else {
+      if (browser->web_contents()) {
+        browser->web_contents()->SetShowingContextMenu(true);
+      }
     }
   }
 }
@@ -362,6 +380,25 @@ void CefTouchSelectionControllerClientOSR::InternalClient::
   }
 }
 
+void CefTouchSelectionControllerClientOSR::NotifyTouchSelectionChanged(bool need_report) {
+  ui::TouchSelectionController* controller = GetTouchSelectionController();
+  if (rwhv_ && controller) {
+    CefTouchHandleState insert_handle;
+    CefTouchHandleState start_selection_handle;
+    CefTouchHandleState end_selection_handle;
+    ConvertTouchHandleState(controller->GetInsertHandle(),
+                            insert_handle);
+    ConvertTouchHandleState(controller->GetStartSelectionHandle(),
+                            start_selection_handle);
+    ConvertTouchHandleState(controller->GetEndSelectionHandle(),
+                            end_selection_handle);
+    rwhv_->OnTouchSelectionChanged(insert_handle,
+                                   start_selection_handle,
+                                   end_selection_handle,
+                                   need_report);
+  }
+}
+
 void CefTouchSelectionControllerClientOSR::OnSelectionEvent(
     ui::SelectionEventType event) {
   // This function (implicitly) uses active_menu_client_, so we don't go to the
@@ -369,32 +406,48 @@ void CefTouchSelectionControllerClientOSR::OnSelectionEvent(
   switch (event) {
     case ui::SELECTION_HANDLES_SHOWN:
       quick_menu_requested_ = true;
-      [[fallthrough]];
+      NotifyTouchSelectionChanged(false);
+      UpdateQuickMenu();
+      break;
     case ui::INSERTION_HANDLE_SHOWN:
+      if (rwhv_ && rwhv_->browser_impl()) {
+        quick_menu_requested_ =
+          rwhv_->browser_impl()->GetTouchInsertHandleMenuShow();
+        rwhv_->browser_impl()->SetTouchInsertHandleMenuShow(false);
+      }
+      NotifyTouchSelectionChanged(true);
       UpdateQuickMenu();
       break;
     case ui::SELECTION_HANDLES_CLEARED:
     case ui::INSERTION_HANDLE_CLEARED:
       quick_menu_requested_ = false;
+      NotifyTouchSelectionChanged(true);
       UpdateQuickMenu();
       break;
     case ui::SELECTION_HANDLE_DRAG_STARTED:
     case ui::INSERTION_HANDLE_DRAG_STARTED:
       handle_drag_in_progress_ = true;
-      UpdateQuickMenu();
       break;
     case ui::SELECTION_HANDLE_DRAG_STOPPED:
     case ui::INSERTION_HANDLE_DRAG_STOPPED:
       handle_drag_in_progress_ = false;
-      UpdateQuickMenu();
       break;
     case ui::SELECTION_HANDLES_MOVED:
+      if (!handle_drag_in_progress_) {
+        UpdateQuickMenu();
+      }
+      [[fallthrough]];
     case ui::INSERTION_HANDLE_MOVED:
-      UpdateQuickMenu();
+      NotifyTouchSelectionChanged(true);
       break;
     case ui::INSERTION_HANDLE_TAPPED:
       quick_menu_requested_ = !quick_menu_requested_;
-      UpdateQuickMenu();
+      if (quick_menu_requested_) {
+        UpdateQuickMenu();
+      } else {
+        CloseQuickMenu();
+        NotifyTouchSelectionChanged(true);
+      }
       break;
   }
 }
@@ -445,12 +498,22 @@ bool CefTouchSelectionControllerClientOSR::IsCommandIdEnabled(
       return readable && has_selection;
     case QM_EDITFLAG_CAN_PASTE: {
       std::u16string result;
+      bool can_paste = false;
       ui::DataTransferEndpoint data_dst = ui::DataTransferEndpoint(
-          ui::EndpointType::kDefault, /*notify_if_restricted=*/false);
+        ui::EndpointType::kDefault, /*notify_if_restricted=*/false);
       ui::Clipboard::GetForCurrentThread()->ReadText(
-          ui::ClipboardBuffer::kCopyPaste, &data_dst, &result);
-      return editable && !result.empty();
+      ui::ClipboardBuffer::kCopyPaste, &data_dst, &result);
+      if (rwhv_->GetTextInputType() == ui::TEXT_INPUT_TYPE_CONTENT_EDITABLE &&
+          result.empty()) {
+        can_paste = ui::Clipboard::GetForCurrentThread()->IsFormatAvailable(
+          ui::ClipboardFormatType::GetBitmapType(),
+          ui::ClipboardBuffer::kCopyPaste, &data_dst);
+      }
+      can_paste = can_paste ? can_paste : !result.empty();
+      return editable && can_paste;
     }
+    case QM_EDITFLAG_CAN_SELECT_ALL:
+      return editable || readable;
     default:
       return false;
   }
@@ -462,7 +525,8 @@ void CefTouchSelectionControllerClientOSR::ExecuteCommand(int command_id,
     return;
   }
 
-  if (command_id != QM_EDITFLAG_CAN_ELLIPSIS) {
+  if (command_id != QM_EDITFLAG_CAN_ELLIPSIS &&
+      command_id != QM_EDITFLAG_CAN_SELECT_ALL) {
     rwhv_->selection_controller()->HideAndDisallowShowingAutomatically();
   }
 
@@ -480,23 +544,32 @@ void CefTouchSelectionControllerClientOSR::ExecuteCommand(int command_id,
     }
   }
 
+  base::Optional<std::u16string> value;
   switch (command_id) {
     case QM_EDITFLAG_CAN_CUT:
       host_delegate->Cut();
       break;
     case QM_EDITFLAG_CAN_COPY:
       host_delegate->Copy();
+      host_delegate->ExecuteEditCommand("Unselect", value);
       break;
     case QM_EDITFLAG_CAN_PASTE:
       host_delegate->Paste();
       break;
+    case QM_EDITFLAG_CAN_SELECT_ALL:
+      host_delegate->SelectAll();
+      CloseQuickMenu();
+      ShowQuickMenu();
+      break;
     case QM_EDITFLAG_CAN_ELLIPSIS:
       CloseQuickMenu();
       RunContextMenu();
+      host_delegate->ExecuteEditCommand("Unselect", value);
       break;
     default:
       // Invalid command, do nothing.
       // Also reached when callback is destroyed/cancelled.
+      host_delegate->ExecuteEditCommand("Unselect", value);
       break;
   }
 }
@@ -515,11 +588,28 @@ void CefTouchSelectionControllerClientOSR::RunContextMenu() {
   rwhv_->selection_controller()->HideAndDisallowShowingAutomatically();
 }
 
+void CefTouchSelectionControllerClientOSR::RunQuickMenu() {
+  const gfx::RectF anchor_rect =
+      rwhv_->selection_controller()->GetVisibleRectBetweenBounds();
+  const gfx::PointF anchor_point =
+      gfx::PointF(anchor_rect.CenterPoint().x(), anchor_rect.y());
+  rwhv_->host()->ShowContextMenuAtPoint(gfx::ToRoundedPoint(anchor_point),
+                                        ui::MENU_SOURCE_TOUCH_EDIT_MENU);
+}
+
 bool CefTouchSelectionControllerClientOSR::ShouldShowQuickMenu() {
   return quick_menu_requested_ && !touch_down_ && !scroll_in_progress_ &&
-         !handle_drag_in_progress_ && IsQuickMenuAvailable();
+         IsQuickMenuAvailable();
 }
 
 std::u16string CefTouchSelectionControllerClientOSR::GetSelectedText() {
   return rwhv_->GetSelectedText();
+}
+
+bool CefTouchSelectionControllerClientOSR::NeedPopupInsertTouchHandleQuickMenu() {
+  if (ShouldShowQuickMenu()) {
+    ShowQuickMenu();
+    return true;
+  }
+  return false;
 }
\ No newline at end of file
diff --git a/cef/libcef/browser/osr/touch_selection_controller_client_osr.h b/cef/libcef/browser/osr/touch_selection_controller_client_osr.h
index f1b84b79515f3..9794cf9fc8ea0 100755
--- a/cef/libcef/browser/osr/touch_selection_controller_client_osr.h
+++ b/cef/libcef/browser/osr/touch_selection_controller_client_osr.h
@@ -81,6 +81,8 @@ class CefTouchSelectionControllerClientOSR
   void RemoveObserver(
       TouchSelectionControllerClientManager::Observer* observer) override;
 
+  bool NeedPopupInsertTouchHandleQuickMenu();
+
  private:
   class EnvEventObserver;
 
@@ -109,6 +111,8 @@ class CefTouchSelectionControllerClientOSR
   bool ShouldShowQuickMenu() override;
   std::u16string GetSelectedText() override;
 
+  void NotifyTouchSelectionChanged(bool need_report);
+  void RunQuickMenu();
   // Not owned, non-null for the lifetime of this object.
   CefRenderWidgetHostViewOSR* rwhv_;
 
diff --git a/cef/libcef/browser/permission/alloy_access_request.h b/cef/libcef/browser/permission/alloy_access_request.h
index 5342f0a3a44e3..905013f15b595 100644
--- a/cef/libcef/browser/permission/alloy_access_request.h
+++ b/cef/libcef/browser/permission/alloy_access_request.h
@@ -37,7 +37,7 @@ class AlloyAccessRequest : public CefAccessRequest {
   void ReportRequestResult(bool allowed) override;
 
  private:
-  const CefString& origin_;
+  CefString origin_;
   int resources_;
   cef_permission_callback_t callback_;
 
diff --git a/cef/libcef/browser/permission/alloy_geolocation_access.cc b/cef/libcef/browser/permission/alloy_geolocation_access.cc
index e45567a8c9093..73cf6c57a3641 100644
--- a/cef/libcef/browser/permission/alloy_geolocation_access.cc
+++ b/cef/libcef/browser/permission/alloy_geolocation_access.cc
@@ -5,18 +5,41 @@
 #include "libcef/browser/permission/alloy_geolocation_access.h"
 
 #include "base/logging.h"
+#include "libcef/browser/net_database/cef_data_base_impl.h"
 
 bool AlloyGeolocationAccess::ContainOrigin(const CefString& origin) {
-  return false;
+  auto dataBase = CefDataBase::GetGlobalDataBase();
+  if (dataBase == nullptr) {
+    return false;
+  }
+  return dataBase->ExistPermissionByOrigin(origin, CefDataBaseImpl::GEOLOCATION_TYPE);
 }
 
 bool AlloyGeolocationAccess::IsOriginAccessEnabled(const CefString& origin) {
-  return true;
+  auto dataBase = CefDataBase::GetGlobalDataBase();
+  if (dataBase == nullptr) {
+    return false;
+  }
+  bool result = false;
+  dataBase->GetPermissionResultByOrigin(origin, CefDataBaseImpl::GEOLOCATION_TYPE, result);
+  return result;
 }
 
-void AlloyGeolocationAccess::Enabled(const CefString& origin) {}
+void AlloyGeolocationAccess::Enabled(const CefString& origin) {
+  auto dataBase = CefDataBase::GetGlobalDataBase();
+  if (dataBase == nullptr) {
+    return;
+  }
+  dataBase->SetPermissionByOrigin(origin, CefDataBaseImpl::GEOLOCATION_TYPE, true);
+}
 
-void AlloyGeolocationAccess::Disabled(const CefString& origin) {}
+void AlloyGeolocationAccess::Disabled(const CefString& origin) {
+  auto dataBase = CefDataBase::GetGlobalDataBase();
+  if (dataBase == nullptr) {
+    return;
+  }
+  dataBase->SetPermissionByOrigin(origin, CefDataBaseImpl::GEOLOCATION_TYPE, false);
+}
 
 std::string AlloyGeolocationAccess::GetOriginKey(std::string& origin) {
   return pref_prefix_ + origin;
diff --git a/cef/libcef/browser/prefs/renderer_prefs.cc b/cef/libcef/browser/prefs/renderer_prefs.cc
index ef17292929816..730cfc5fa8073 100644
--- a/cef/libcef/browser/prefs/renderer_prefs.cc
+++ b/cef/libcef/browser/prefs/renderer_prefs.cc
@@ -323,7 +323,7 @@ void SetCefPrefs(const CefBrowserSettings& cef,
     web.fantasy_font_family_map[blink::web_pref::kCommonScript] =
         CefString(&cef.fantasy_font_family);
   }
-
+  web.pinch_smooth_mode = cef.pinch_smooth_mode;
   if (cef.default_font_size > 0)
     web.default_font_size = cef.default_font_size;
   if (cef.default_fixed_font_size > 0)
@@ -371,8 +371,13 @@ void SetCefPrefs(const CefBrowserSettings& cef,
   SET_STATE(cef.strict_mixed_content_checking,
             web.strict_mixed_content_checking);
   SET_STATE(cef.allow_mixed_content_upgrades, web.allow_mixed_content_upgrades);
-  SET_STATE(cef.initialize_at_minimum_page_scale, web.initialize_at_minimum_page_scale);
+  SET_STATE(cef.initialize_at_minimum_page_scale,
+            web.initialize_at_minimum_page_scale);
   web.viewport_meta_enabled = cef.viewport_meta_enabled;
+  web.autoplay_policy =
+      cef.user_gesture_required
+          ? blink::mojom::AutoplayPolicy::kUserGestureRequired
+          : blink::mojom::AutoplayPolicy::kNoUserGestureRequired;
   /* ohos webview end */
 }
 
diff --git a/cef/libcef/browser/request_context_impl.cc b/cef/libcef/browser/request_context_impl.cc
index 357e9a6c0b9d8..16db692116633 100644
--- a/cef/libcef/browser/request_context_impl.cc
+++ b/cef/libcef/browser/request_context_impl.cc
@@ -3,6 +3,7 @@
 // can be found in the LICENSE file.
 
 #include "libcef/browser/request_context_impl.h"
+#include "libcef/browser/alloy/alloy_client_cert_lookup_table.h"
 #include "libcef/browser/browser_context.h"
 #include "libcef/browser/context.h"
 #include "libcef/browser/thread_util.h"
@@ -18,6 +19,7 @@
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/plugin_service.h"
 #include "content/public/browser/ssl_host_state_delegate.h"
+#include "net/cert/cert_database.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/network/public/cpp/resolve_host_client_base.h"
@@ -55,6 +57,11 @@ const char* GetTypeString(base::Value::Type type) {
   return "UNKNOWN";
 }
 
+void NotifyClientCertificatesChanged() {
+  LOG(INFO) << "CefRequestContextImpl::NotifyClientCertificatesChanged";
+  net::CertDatabase::GetInstance()->NotifyObserversCertDBChanged();
+}
+
 // Helper for HostResolver::Resolve.
 struct ResolveHostHelperOld {
   explicit ResolveHostHelperOld(CefRefPtr<CefResolveCallback> callback)
@@ -523,6 +530,15 @@ void CefRequestContextImpl::ClearCertificateExceptions(
                      this, callback));
 }
 
+void CefRequestContextImpl::ClearClientAuthenticationCache(
+    CefRefPtr<CefCompletionCallback> callback) {
+  LOG(INFO) << "CefRequestContextImpl::ClearClientAuthenticationCache";
+  GetBrowserContext(
+      content::GetUIThreadTaskRunner({}),
+      base::BindOnce(&CefRequestContextImpl::ClearClientAuthenticationCacheInternal,
+                     this, callback));
+}
+
 void CefRequestContextImpl::ClearHttpAuthCredentials(
     CefRefPtr<CefCompletionCallback> callback) {
   GetBrowserContext(
@@ -751,6 +767,29 @@ void CefRequestContextImpl::ClearCertificateExceptionsInternal(
   }
 }
 
+void CefRequestContextImpl::ClearClientAuthenticationCacheInternal(
+    CefRefPtr<CefCompletionCallback> callback,
+    CefBrowserContext::Getter browser_context_getter) {
+  LOG(INFO) << "CefRequestContextImpl::ClearClientAuthenticationCacheInternal";
+  auto browser_context = browser_context_getter.Run();
+  if (!browser_context)
+    return;
+
+  AlloyClientCertLookupTable::Clear();
+
+  if (content::BrowserThread::CurrentlyOn(content::BrowserThread::IO)) {
+    NotifyClientCertificatesChanged();
+  } else {
+    content::GetIOThreadTaskRunner({})->PostTask(
+        FROM_HERE, base::BindOnce(&NotifyClientCertificatesChanged));
+  }
+
+  if (callback) {
+    CEF_POST_TASK(CEF_UIT,
+                  base::Bind(&CefCompletionCallback::OnComplete, callback));
+  }
+}
+
 void CefRequestContextImpl::ClearHttpAuthCredentialsInternal(
     CefRefPtr<CefCompletionCallback> callback,
     CefBrowserContext::Getter browser_context_getter) {
diff --git a/cef/libcef/browser/request_context_impl.h b/cef/libcef/browser/request_context_impl.h
index a997d2f847aea..2964225c2a091 100644
--- a/cef/libcef/browser/request_context_impl.h
+++ b/cef/libcef/browser/request_context_impl.h
@@ -80,6 +80,8 @@ class CefRequestContextImpl : public CefRequestContext {
                      CefString& error) override;
   void ClearCertificateExceptions(
       CefRefPtr<CefCompletionCallback> callback) override;
+  void ClearClientAuthenticationCache(
+      CefRefPtr<CefCompletionCallback> callback) override;
   void ClearHttpAuthCredentials(
       CefRefPtr<CefCompletionCallback> callback) override;
   void CloseAllConnections(CefRefPtr<CefCompletionCallback> callback) override;
@@ -155,6 +157,9 @@ class CefRequestContextImpl : public CefRequestContext {
   void ClearCertificateExceptionsInternal(
       CefRefPtr<CefCompletionCallback> callback,
       CefBrowserContext::Getter browser_context_getter);
+  void ClearClientAuthenticationCacheInternal(
+      CefRefPtr<CefCompletionCallback> callback,
+      CefBrowserContext::Getter browser_context_getter);
   void ClearHttpAuthCredentialsInternal(
       CefRefPtr<CefCompletionCallback> callback,
       CefBrowserContext::Getter browser_context_getter);
diff --git a/cef/libcef/browser/storage/web_storage_impl.cc b/cef/libcef/browser/storage/web_storage_impl.cc
index 0f963d489040d..1fedd7fee1496 100644
--- a/cef/libcef/browser/storage/web_storage_impl.cc
+++ b/cef/libcef/browser/storage/web_storage_impl.cc
@@ -250,7 +250,7 @@ void CefWebStorageImpl::GetOriginUsageAndQuotaInternal(
       base::BindOnce(&CefWebStorageImpl::CefGetOriginUsageOrQuotaCallbackImpl,
                      weak_factory_.GetWeakPtr(), callback, is_quota);
   CEF_POST_TASK(CEF_IOT,
-                base::BindOnce(&storage::QuotaManager::GetUsageAndQuota, GetQuotaManager(browser_context), 
+                base::BindOnce(&storage::QuotaManager::GetUsageAndQuota, GetQuotaManager(browser_context),
                 url::Origin::Create(GURL(origin.ToString16())),
                 blink::mojom::StorageType::kTemporary,
                 base::BindOnce(&CefWebStorageImpl::OnUsageAndQuotaObtained, this, std::move(ui_callback))));
@@ -312,7 +312,7 @@ void CefWebStorageImpl::GetOriginsCallbackImpl(
   std::vector<CefString> usages;
   std::vector<CefString> quotas;
   std::string res;
-  for (size_t i = 0; i < nums; i++) {
+  for (int32_t i = 0; i < nums; i++) {
     origins.push_back(CefString(origin[i]));
     res = std::to_string(usage[i]);
     usages.push_back(CefString(res));
diff --git a/cef/libcef/browser/x509_certificate_impl.h b/cef/libcef/browser/x509_certificate_impl.h
index f5c22250f6338..3499fc9d8dc9f 100644
--- a/cef/libcef/browser/x509_certificate_impl.h
+++ b/cef/libcef/browser/x509_certificate_impl.h
@@ -38,6 +38,10 @@ class CefX509CertificateImpl : public CefX509Certificate {
       base::OnceCallback<void(scoped_refptr<net::SSLPrivateKey>)>
           private_key_callback);
 
+  void setClientCert(scoped_refptr<net::X509Certificate> cert) {
+      cert_ = cert;
+  }
+
  private:
   void GetEncodedIssuerChain(IssuerChainBinaryList& chain, bool der);
 
diff --git a/cef/libcef/common/soc_perf_util.cc b/cef/libcef/common/soc_perf_util.cc
new file mode 100644
index 0000000000000..8cbad8b72ea73
--- /dev/null
+++ b/cef/libcef/common/soc_perf_util.cc
@@ -0,0 +1,32 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd.
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "soc_perf_util.h"
+
+#include "base/logging.h"
+#include "base/trace_event/common/trace_event_common.h"
+#include "ohos_adapter_helper.h"
+#include "soc_perf_client_adapter.h"
+
+namespace soc_perf {
+int video_layout_num = 0;
+int layer_num = 0;
+
+namespace {
+const int SOC_PERF_CONFIG_ID = 10020;
+const int MIN_LAYER_NUM = 50;
+const int MIN_VIDEO_LAYOUT_NUM = 1;
+}  // namespace
+
+void SocPerUtil::ApplySocConfig() {
+  TRACE_EVENT2("input", "SocPerUtil::ApplySocConfig", "layout_num",
+               video_layout_num, "layer_num", layer_num);
+  if (video_layout_num >= MIN_VIDEO_LAYOUT_NUM || layer_num >= MIN_LAYER_NUM) {
+    OHOS::NWeb::OhosAdapterHelper::GetInstance()
+        .CreateSocPerfClientAdapter()
+        ->ApplySocPerfConfigById(SOC_PERF_CONFIG_ID);
+  }
+}
+}  // namespace soc_perf
\ No newline at end of file
diff --git a/cef/libcef/common/soc_perf_util.h b/cef/libcef/common/soc_perf_util.h
new file mode 100644
index 0000000000000..e3667553d8b86
--- /dev/null
+++ b/cef/libcef/common/soc_perf_util.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd.
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_COMMON_SOC_PERF_UTIL_H_
+#define CEF_LIBCEF_COMMON_SOC_PERF_UTIL_H_
+
+namespace soc_perf {
+extern int video_layout_num;
+extern int layer_num;
+
+class SocPerUtil {
+ public:
+  static void ApplySocConfig();
+};
+
+}  // namespace soc_perf
+
+#endif  // CEF_LIBCEF_COMMON_SOC_PERF_UTIL_H_
\ No newline at end of file
diff --git a/cef/libcef/renderer/alloy/alloy_content_renderer_client.h b/cef/libcef/renderer/alloy/alloy_content_renderer_client.h
index 8add71c6b305c..426cca917abd5 100644
--- a/cef/libcef/renderer/alloy/alloy_content_renderer_client.h
+++ b/cef/libcef/renderer/alloy/alloy_content_renderer_client.h
@@ -72,6 +72,18 @@ class AlloyContentRendererClient
   // single-process mode. Blocks until cleanup is complete.
   void RunSingleProcessCleanup();
 
+#if defined(OHOS_NWEB_EX)
+  void PrepareErrorPage(content::RenderFrame* render_frame,
+                        const blink::WebURLError& error,
+                        const std::string& http_method,
+                        std::string* error_html) override;
+  void PrepareErrorPageForHttpStatusError(content::RenderFrame* render_frame,
+                                          const blink::WebURLError& error,
+                                          const std::string& http_method,
+                                          int http_status,
+                                          std::string* error_html) override;
+#endif  // defined(OHOS_NWEB_EX)
+
   // ContentRendererClient implementation.
   void PostIOThreadCreated(
       base::SingleThreadTaskRunner* io_thread_task_runner) override;
diff --git a/cef/libcef/renderer/browser_impl.h b/cef/libcef/renderer/browser_impl.h
index 2de16d67aef17..a4671afb58694 100644
--- a/cef/libcef/renderer/browser_impl.h
+++ b/cef/libcef/renderer/browser_impl.h
@@ -57,6 +57,7 @@ class CefBrowserImpl : public CefBrowser, public blink::WebViewObserver {
   void ReloadIgnoreCache() override;
 #if defined(OS_OHOS)
   void ReloadOriginalUrl() override;
+  void SetBrowserUserAgentString(const CefString& user_agent) override {}
 #endif
   void StopLoad() override;
   int GetIdentifier() override;
diff --git a/cef/libcef_dll/cpptoc/browser_cpptoc.cc b/cef/libcef_dll/cpptoc/browser_cpptoc.cc
index 2f6f6703739c0..b385546650d3b 100644
--- a/cef/libcef_dll/cpptoc/browser_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/browser_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=ca8fa2ae4f113048e5b941eaa0e1dbcfc7cc6a95$
+// $hash=b780301458a1d76fc7996e9d7459cdd8521f57e5$
 //
 
 #include "libcef_dll/cpptoc/browser_cpptoc.h"
@@ -199,6 +199,25 @@ void CEF_CALLBACK browser_reload_original_url(struct _cef_browser_t* self) {
   CefBrowserCppToC::Get(self)->ReloadOriginalUrl();
 }
 
+void CEF_CALLBACK
+browser_set_browser_user_agent_string(struct _cef_browser_t* self,
+                                      const cef_string_t* user_agent) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: user_agent; type: string_byref_const
+  DCHECK(user_agent);
+  if (!user_agent)
+    return;
+
+  // Execute
+  CefBrowserCppToC::Get(self)->SetBrowserUserAgentString(CefString(user_agent));
+}
+
 void CEF_CALLBACK browser_stop_load(struct _cef_browser_t* self) {
   shutdown_checker::AssertNotShutdown();
 
@@ -485,6 +504,8 @@ CefBrowserCppToC::CefBrowserCppToC() {
   GetStruct()->reload = browser_reload;
   GetStruct()->reload_ignore_cache = browser_reload_ignore_cache;
   GetStruct()->reload_original_url = browser_reload_original_url;
+  GetStruct()->set_browser_user_agent_string =
+      browser_set_browser_user_agent_string;
   GetStruct()->stop_load = browser_stop_load;
   GetStruct()->get_identifier = browser_get_identifier;
   GetStruct()->is_same = browser_is_same;
diff --git a/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc b/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
index 01b13eb5d46f0..30410de5da926 100644
--- a/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/browser_host_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=9aab494bb0a139672fa13a541a462e2e9967f0b7$
+// $hash=d05030d6acade0f0e617cca5f959ecac2d851813$
 //
 
 #include "libcef_dll/cpptoc/browser_host_cpptoc.h"
@@ -27,6 +27,7 @@
 #include "libcef_dll/ctocpp/navigation_entry_visitor_ctocpp.h"
 #include "libcef_dll/ctocpp/pdf_print_callback_ctocpp.h"
 #include "libcef_dll/ctocpp/run_file_dialog_callback_ctocpp.h"
+#include "libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.h"
 #include "libcef_dll/ctocpp/task_ctocpp.h"
 #include "libcef_dll/shutdown_checker.h"
 #include "libcef_dll/transfer_util.h"
@@ -450,7 +451,8 @@ void CEF_CALLBACK browser_host_find(struct _cef_browser_host_t* self,
                                     const cef_string_t* searchText,
                                     int forward,
                                     int matchCase,
-                                    int findNext) {
+                                    int findNext,
+                                    int newSession) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -466,7 +468,8 @@ void CEF_CALLBACK browser_host_find(struct _cef_browser_host_t* self,
   // Execute
   CefBrowserHostCppToC::Get(self)->Find(
       identifier, CefString(searchText), forward ? true : false,
-      matchCase ? true : false, findNext ? true : false);
+      matchCase ? true : false, findNext ? true : false,
+      newSession ? true : false);
 }
 
 void CEF_CALLBACK browser_host_stop_finding(struct _cef_browser_host_t* self,
@@ -739,6 +742,21 @@ browser_host_notify_screen_info_changed(struct _cef_browser_host_t* self) {
   CefBrowserHostCppToC::Get(self)->NotifyScreenInfoChanged();
 }
 
+void CEF_CALLBACK
+browser_host_set_virtual_pixel_ratio(struct _cef_browser_host_t* self,
+                                     float ratio) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->SetVirtualPixelRatio(ratio);
+}
+
 void CEF_CALLBACK browser_host_invalidate(struct _cef_browser_host_t* self,
                                           cef_paint_element_type_t type) {
   shutdown_checker::AssertNotShutdown();
@@ -1098,6 +1116,33 @@ browser_host_unregister_ark_jsfunction(struct _cef_browser_host_t* self,
       CefString(object_name), method_listList);
 }
 
+void CEF_CALLBACK browser_host_store_web_archive(
+    struct _cef_browser_host_t* self,
+    const cef_string_t* base_name,
+    int auto_name,
+    struct _cef_store_web_archive_result_callback_t* callback) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: base_name; type: string_byref_const
+  DCHECK(base_name);
+  if (!base_name)
+    return;
+  // Verify param: callback; type: refptr_diff
+  DCHECK(callback);
+  if (!callback)
+    return;
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->StoreWebArchive(
+      CefString(base_name), auto_name ? true : false,
+      CefStoreWebArchiveResultCallbackCToCpp::Wrap(callback));
+}
+
 cef_string_userfree_t CEF_CALLBACK
 browser_host_title(struct _cef_browser_host_t* self) {
   shutdown_checker::AssertNotShutdown();
@@ -1115,6 +1160,167 @@ browser_host_title(struct _cef_browser_host_t* self) {
   return _retval.DetachToUserFree();
 }
 
+void CEF_CALLBACK
+browser_host_create_web_message_ports(struct _cef_browser_host_t* self,
+                                      cef_string_list_t ports) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: ports; type: string_vec_byref
+  DCHECK(ports);
+  if (!ports)
+    return;
+
+  // Translate param: ports; type: string_vec_byref
+  std::vector<CefString> portsList;
+  transfer_string_list_contents(ports, portsList);
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->CreateWebMessagePorts(portsList);
+
+  // Restore param: ports; type: string_vec_byref
+  cef_string_list_clear(ports);
+  transfer_string_list_contents(portsList, ports);
+}
+
+void CEF_CALLBACK
+browser_host_post_web_message(struct _cef_browser_host_t* self,
+                              cef_string_t* message,
+                              cef_string_list_t ports,
+                              cef_string_t* targetUri) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: message; type: string_byref
+  DCHECK(message);
+  if (!message)
+    return;
+  // Verify param: ports; type: string_vec_byref
+  DCHECK(ports);
+  if (!ports)
+    return;
+  // Verify param: targetUri; type: string_byref
+  DCHECK(targetUri);
+  if (!targetUri)
+    return;
+
+  // Translate param: message; type: string_byref
+  CefString messageStr(message);
+  // Translate param: ports; type: string_vec_byref
+  std::vector<CefString> portsList;
+  transfer_string_list_contents(ports, portsList);
+  // Translate param: targetUri; type: string_byref
+  CefString targetUriStr(targetUri);
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->PostWebMessage(messageStr, portsList,
+                                                  targetUriStr);
+
+  // Restore param: ports; type: string_vec_byref
+  cef_string_list_clear(ports);
+  transfer_string_list_contents(portsList, ports);
+}
+
+void CEF_CALLBACK browser_host_close_port(struct _cef_browser_host_t* self,
+                                          cef_string_t* port_handle) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: port_handle; type: string_byref
+  DCHECK(port_handle);
+  if (!port_handle)
+    return;
+
+  // Translate param: port_handle; type: string_byref
+  CefString port_handleStr(port_handle);
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->ClosePort(port_handleStr);
+}
+
+void CEF_CALLBACK
+browser_host_destroy_all_web_message_ports(struct _cef_browser_host_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->DestroyAllWebMessagePorts();
+}
+
+void CEF_CALLBACK
+browser_host_post_port_message(struct _cef_browser_host_t* self,
+                               cef_string_t* port_handle,
+                               cef_string_t* data) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: port_handle; type: string_byref
+  DCHECK(port_handle);
+  if (!port_handle)
+    return;
+  // Verify param: data; type: string_byref
+  DCHECK(data);
+  if (!data)
+    return;
+
+  // Translate param: port_handle; type: string_byref
+  CefString port_handleStr(port_handle);
+  // Translate param: data; type: string_byref
+  CefString dataStr(data);
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->PostPortMessage(port_handleStr, dataStr);
+}
+
+void CEF_CALLBACK browser_host_set_port_message_callback(
+    struct _cef_browser_host_t* self,
+    cef_string_t* port_handle,
+    struct _cef_java_script_result_callback_t* callback) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: port_handle; type: string_byref
+  DCHECK(port_handle);
+  if (!port_handle)
+    return;
+  // Verify param: callback; type: refptr_diff
+  DCHECK(callback);
+  if (!callback)
+    return;
+
+  // Translate param: port_handle; type: string_byref
+  CefString port_handleStr(port_handle);
+
+  // Execute
+  CefBrowserHostCppToC::Get(self)->SetPortMessageCallback(
+      port_handleStr, CefJavaScriptResultCallbackCToCpp::Wrap(callback));
+}
+
 void CEF_CALLBACK browser_host_get_hit_data(struct _cef_browser_host_t* self,
                                             int* type,
                                             cef_string_t* extra_data) {
@@ -1736,6 +1942,7 @@ CefBrowserHostCppToC::CefBrowserHostCppToC() {
   GetStruct()->was_hidden = browser_host_was_hidden;
   GetStruct()->notify_screen_info_changed =
       browser_host_notify_screen_info_changed;
+  GetStruct()->set_virtual_pixel_ratio = browser_host_set_virtual_pixel_ratio;
   GetStruct()->invalidate = browser_host_invalidate;
   GetStruct()->send_external_begin_frame =
       browser_host_send_external_begin_frame;
@@ -1759,7 +1966,16 @@ CefBrowserHostCppToC::CefBrowserHostCppToC() {
   GetStruct()->register_ark_jsfunction = browser_host_register_ark_jsfunction;
   GetStruct()->unregister_ark_jsfunction =
       browser_host_unregister_ark_jsfunction;
+  GetStruct()->store_web_archive = browser_host_store_web_archive;
   GetStruct()->title = browser_host_title;
+  GetStruct()->create_web_message_ports = browser_host_create_web_message_ports;
+  GetStruct()->post_web_message = browser_host_post_web_message;
+  GetStruct()->close_port = browser_host_close_port;
+  GetStruct()->destroy_all_web_message_ports =
+      browser_host_destroy_all_web_message_ports;
+  GetStruct()->post_port_message = browser_host_post_port_message;
+  GetStruct()->set_port_message_callback =
+      browser_host_set_port_message_callback;
   GetStruct()->get_hit_data = browser_host_get_hit_data;
   GetStruct()->set_initial_scale = browser_host_set_initial_scale;
   GetStruct()->page_load_progress = browser_host_page_load_progress;
diff --git a/cef/libcef_dll/cpptoc/cookie_manager_cpptoc.cc b/cef/libcef_dll/cpptoc/cookie_manager_cpptoc.cc
index e5abda9d95dc5..c78c8f33be0c4 100644
--- a/cef/libcef_dll/cpptoc/cookie_manager_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/cookie_manager_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=de992f1be99ed2d831e840e60f8fb318ca433265$
+// $hash=e2ce6d109390673bbfa660a9a43b8f7ce2e3adf7$
 //
 
 #include "libcef_dll/cpptoc/cookie_manager_cpptoc.h"
@@ -20,8 +20,8 @@
 
 // GLOBAL FUNCTIONS - Body may be edited by hand.
 
-CEF_EXPORT cef_cookie_manager_t* cef_cookie_manager_get_global_manager(
-    cef_completion_callback_t* callback) {
+CEF_EXPORT cef_cookie_manager_t *
+cef_cookie_manager_get_global_manager(cef_completion_callback_t *callback) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   // Unverified params: callback
@@ -34,10 +34,10 @@ CEF_EXPORT cef_cookie_manager_t* cef_cookie_manager_get_global_manager(
   return CefCookieManagerCppToC::Wrap(_retval);
 }
 
-CEF_EXPORT int cef_cookie_manager_create_cef_cookie(
-    const cef_string_t* url,
-    const cef_string_t* value,
-    struct _cef_cookie_t* cef_cookie) {
+CEF_EXPORT int
+cef_cookie_manager_create_cef_cookie(const cef_string_t *url,
+                                     const cef_string_t *value,
+                                     struct _cef_cookie_t *cef_cookie) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   // Verify param: url; type: string_byref_const
@@ -75,7 +75,7 @@ namespace {
 // MEMBER FUNCTIONS - Body may be edited by hand.
 
 int CEF_CALLBACK
-cookie_manager_is_accept_cookie_allowed(struct _cef_cookie_manager_t* self) {
+cookie_manager_is_accept_cookie_allowed(struct _cef_cookie_manager_t *self) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -89,9 +89,8 @@ cookie_manager_is_accept_cookie_allowed(struct _cef_cookie_manager_t* self) {
   return _retval;
 }
 
-void CEF_CALLBACK
-cookie_manager_put_accept_cookie_enabled(struct _cef_cookie_manager_t* self,
-                                         int accept) {
+void CEF_CALLBACK cookie_manager_put_accept_cookie_enabled(
+    struct _cef_cookie_manager_t *self, int accept) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -103,8 +102,36 @@ cookie_manager_put_accept_cookie_enabled(struct _cef_cookie_manager_t* self,
                                                                    : false);
 }
 
+int CEF_CALLBACK cookie_manager_is_third_party_cookie_allowed(
+    struct _cef_cookie_manager_t *self) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+
+  // Execute
+  bool _retval = CefCookieManagerCppToC::Get(self)->IsThirdPartyCookieAllowed();
+
+  // Return type: bool
+  return _retval;
+}
+
+void CEF_CALLBACK cookie_manager_put_accept_third_party_cookie_enabled(
+    struct _cef_cookie_manager_t *self, int accept) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefCookieManagerCppToC::Get(self)->PutAcceptThirdPartyCookieEnabled(
+      accept ? true : false);
+}
+
 int CEF_CALLBACK cookie_manager_is_file_urlscheme_cookies_allowed(
-    struct _cef_cookie_manager_t* self) {
+    struct _cef_cookie_manager_t *self) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -120,8 +147,7 @@ int CEF_CALLBACK cookie_manager_is_file_urlscheme_cookies_allowed(
 }
 
 void CEF_CALLBACK cookie_manager_put_accept_file_urlscheme_cookies_enabled(
-    struct _cef_cookie_manager_t* self,
-    int allow) {
+    struct _cef_cookie_manager_t *self, int allow) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -133,9 +159,8 @@ void CEF_CALLBACK cookie_manager_put_accept_file_urlscheme_cookies_enabled(
       allow ? true : false);
 }
 
-int CEF_CALLBACK
-cookie_manager_visit_all_cookies(struct _cef_cookie_manager_t* self,
-                                 struct _cef_cookie_visitor_t* visitor) {
+int CEF_CALLBACK cookie_manager_visit_all_cookies(
+    struct _cef_cookie_manager_t *self, struct _cef_cookie_visitor_t *visitor) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -154,11 +179,9 @@ cookie_manager_visit_all_cookies(struct _cef_cookie_manager_t* self,
   return _retval;
 }
 
-int CEF_CALLBACK
-cookie_manager_visit_url_cookies(struct _cef_cookie_manager_t* self,
-                                 const cef_string_t* url,
-                                 int includeHttpOnly,
-                                 struct _cef_cookie_visitor_t* visitor) {
+int CEF_CALLBACK cookie_manager_visit_url_cookies(
+    struct _cef_cookie_manager_t *self, const cef_string_t *url,
+    int includeHttpOnly, struct _cef_cookie_visitor_t *visitor) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -182,11 +205,10 @@ cookie_manager_visit_url_cookies(struct _cef_cookie_manager_t* self,
   return _retval;
 }
 
-int CEF_CALLBACK
-cookie_manager_set_cookie(struct _cef_cookie_manager_t* self,
-                          const cef_string_t* url,
-                          const struct _cef_cookie_t* cookie,
-                          struct _cef_set_cookie_callback_t* callback) {
+int CEF_CALLBACK cookie_manager_set_cookie(
+    struct _cef_cookie_manager_t *self, const cef_string_t *url,
+    const struct _cef_cookie_t *cookie,
+    struct _cef_set_cookie_callback_t *callback) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -215,12 +237,10 @@ cookie_manager_set_cookie(struct _cef_cookie_manager_t* self,
   return _retval;
 }
 
-int CEF_CALLBACK
-cookie_manager_delete_cookies(struct _cef_cookie_manager_t* self,
-                              const cef_string_t* url,
-                              const cef_string_t* cookie_name,
-                              int is_session,
-                              struct _cef_delete_cookies_callback_t* callback) {
+int CEF_CALLBACK cookie_manager_delete_cookies(
+    struct _cef_cookie_manager_t *self, const cef_string_t *url,
+    const cef_string_t *cookie_name, int is_session,
+    struct _cef_delete_cookies_callback_t *callback) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -237,9 +257,8 @@ cookie_manager_delete_cookies(struct _cef_cookie_manager_t* self,
   return _retval;
 }
 
-int CEF_CALLBACK
-cookie_manager_flush_store(struct _cef_cookie_manager_t* self,
-                           cef_completion_callback_t* callback) {
+int CEF_CALLBACK cookie_manager_flush_store(
+    struct _cef_cookie_manager_t *self, cef_completion_callback_t *callback) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   DCHECK(self);
@@ -255,7 +274,7 @@ cookie_manager_flush_store(struct _cef_cookie_manager_t* self,
   return _retval;
 }
 
-}  // namespace
+} // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
 
@@ -264,6 +283,10 @@ CefCookieManagerCppToC::CefCookieManagerCppToC() {
       cookie_manager_is_accept_cookie_allowed;
   GetStruct()->put_accept_cookie_enabled =
       cookie_manager_put_accept_cookie_enabled;
+  GetStruct()->is_third_party_cookie_allowed =
+      cookie_manager_is_third_party_cookie_allowed;
+  GetStruct()->put_accept_third_party_cookie_enabled =
+      cookie_manager_put_accept_third_party_cookie_enabled;
   GetStruct()->is_file_urlscheme_cookies_allowed =
       cookie_manager_is_file_urlscheme_cookies_allowed;
   GetStruct()->put_accept_file_urlscheme_cookies_enabled =
@@ -280,17 +303,16 @@ CefCookieManagerCppToC::CefCookieManagerCppToC() {
 CefCookieManagerCppToC::~CefCookieManagerCppToC() {}
 
 template <>
-CefRefPtr<CefCookieManager> CefCppToCRefCounted<
-    CefCookieManagerCppToC,
-    CefCookieManager,
-    cef_cookie_manager_t>::UnwrapDerived(CefWrapperType type,
-                                         cef_cookie_manager_t* s) {
+CefRefPtr<CefCookieManager>
+CefCppToCRefCounted<CefCookieManagerCppToC, CefCookieManager,
+                    cef_cookie_manager_t>::UnwrapDerived(CefWrapperType type,
+                                                         cef_cookie_manager_t
+                                                             *s) {
   NOTREACHED() << "Unexpected class type: " << type;
   return nullptr;
 }
 
 template <>
-CefWrapperType CefCppToCRefCounted<CefCookieManagerCppToC,
-                                   CefCookieManager,
+CefWrapperType CefCppToCRefCounted<CefCookieManagerCppToC, CefCookieManager,
                                    cef_cookie_manager_t>::kWrapperType =
     WT_COOKIE_MANAGER;
diff --git a/cef/libcef_dll/cpptoc/data_base_cpptoc.cc b/cef/libcef_dll/cpptoc/data_base_cpptoc.cc
index 0b5bfe4d0edad..1f82426f6939f 100644
--- a/cef/libcef_dll/cpptoc/data_base_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/data_base_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=ab1b05a3df9cb6b15fd2dc5652d4664ec27d76c9$
+// $hash=5cc7dfcfeb969f00a01d13456464b2811bda3a85$
 //
 
 #include "libcef_dll/cpptoc/data_base_cpptoc.h"
@@ -123,6 +123,129 @@ void CEF_CALLBACK data_base_get_http_auth_credentials(
   transfer_string_list_contents(username_passwordList, username_password);
 }
 
+int CEF_CALLBACK data_base_exist_permission_by_origin(
+    struct _cef_data_base_t *self, const cef_string_t *origin, int type) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+  // Verify param: origin; type: string_byref_const
+  DCHECK(origin);
+  if (!origin)
+    return 0;
+
+  // Execute
+  bool _retval = CefDataBaseCppToC::Get(self)->ExistPermissionByOrigin(
+      CefString(origin), type);
+
+  // Return type: bool
+  return _retval;
+}
+
+int CEF_CALLBACK data_base_get_permission_result_by_origin(
+    struct _cef_data_base_t *self, const cef_string_t *origin, int type,
+    int *result) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return 0;
+  // Verify param: origin; type: string_byref_const
+  DCHECK(origin);
+  if (!origin)
+    return 0;
+  // Verify param: result; type: bool_byref
+  DCHECK(result);
+  if (!result)
+    return 0;
+
+  // Translate param: result; type: bool_byref
+  bool resultBool = (result && *result) ? true : false;
+
+  // Execute
+  bool _retval = CefDataBaseCppToC::Get(self)->GetPermissionResultByOrigin(
+      CefString(origin), type, resultBool);
+
+  // Restore param: result; type: bool_byref
+  if (result)
+    *result = resultBool ? true : false;
+
+  // Return type: bool
+  return _retval;
+}
+
+void CEF_CALLBACK data_base_set_permission_by_origin(
+    struct _cef_data_base_t *self, const cef_string_t *origin, int type,
+    int result) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: origin; type: string_byref_const
+  DCHECK(origin);
+  if (!origin)
+    return;
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->SetPermissionByOrigin(CefString(origin), type,
+                                                      result ? true : false);
+}
+
+void CEF_CALLBACK data_base_clear_permission_by_origin(
+    struct _cef_data_base_t *self, const cef_string_t *origin, int type) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: origin; type: string_byref_const
+  DCHECK(origin);
+  if (!origin)
+    return;
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->ClearPermissionByOrigin(CefString(origin),
+                                                        type);
+}
+
+void CEF_CALLBACK data_base_clear_all_permission(struct _cef_data_base_t *self,
+                                                 int type) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->ClearAllPermission(type);
+}
+
+void CEF_CALLBACK data_base_get_origins_by_permission(
+    struct _cef_data_base_t *self, int type, cef_string_list_t origins) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: origins; type: string_vec_byref
+  DCHECK(origins);
+  if (!origins)
+    return;
+
+  // Translate param: origins; type: string_vec_byref
+  std::vector<CefString> originsList;
+  transfer_string_list_contents(origins, originsList);
+
+  // Execute
+  CefDataBaseCppToC::Get(self)->GetOriginsByPermission(type, originsList);
+
+  // Restore param: origins; type: string_vec_byref
+  cef_string_list_clear(origins);
+  transfer_string_list_contents(originsList, origins);
+}
+
 } // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -135,6 +258,15 @@ CefDataBaseCppToC::CefDataBaseCppToC() {
   GetStruct()->save_http_auth_credentials =
       data_base_save_http_auth_credentials;
   GetStruct()->get_http_auth_credentials = data_base_get_http_auth_credentials;
+  GetStruct()->exist_permission_by_origin =
+      data_base_exist_permission_by_origin;
+  GetStruct()->get_permission_result_by_origin =
+      data_base_get_permission_result_by_origin;
+  GetStruct()->set_permission_by_origin = data_base_set_permission_by_origin;
+  GetStruct()->clear_permission_by_origin =
+      data_base_clear_permission_by_origin;
+  GetStruct()->clear_all_permission = data_base_clear_all_permission;
+  GetStruct()->get_origins_by_permission = data_base_get_origins_by_permission;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc b/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc
index 907f122ea0c5e..b968dcf830e27 100644
--- a/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/render_handler_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=6e8b89e48c680cb130518d3a39dfa9521045d828$
+// $hash=c83f5f49a5411a5071750e238c12e22bfa82c48a$
 //
 
 #include "libcef_dll/cpptoc/render_handler_cpptoc.h"
@@ -22,8 +22,8 @@ namespace {
 
 // MEMBER FUNCTIONS - Body may be edited by hand.
 
-cef_accessibility_handler_t* CEF_CALLBACK
-render_handler_get_accessibility_handler(struct _cef_render_handler_t* self) {
+cef_accessibility_handler_t *CEF_CALLBACK
+render_handler_get_accessibility_handler(struct _cef_render_handler_t *self) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -41,9 +41,8 @@ render_handler_get_accessibility_handler(struct _cef_render_handler_t* self) {
 }
 
 int CEF_CALLBACK
-render_handler_get_root_screen_rect(struct _cef_render_handler_t* self,
-                                    cef_browser_t* browser,
-                                    cef_rect_t* rect) {
+render_handler_get_root_screen_rect(struct _cef_render_handler_t *self,
+                                    cef_browser_t *browser, cef_rect_t *rect) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -76,9 +75,8 @@ render_handler_get_root_screen_rect(struct _cef_render_handler_t* self,
 }
 
 void CEF_CALLBACK
-render_handler_get_view_rect(struct _cef_render_handler_t* self,
-                             cef_browser_t* browser,
-                             cef_rect_t* rect) {
+render_handler_get_view_rect(struct _cef_render_handler_t *self,
+                             cef_browser_t *browser, cef_rect_t *rect) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -107,13 +105,9 @@ render_handler_get_view_rect(struct _cef_render_handler_t* self,
     *rect = rectVal;
 }
 
-int CEF_CALLBACK
-render_handler_get_screen_point(struct _cef_render_handler_t* self,
-                                cef_browser_t* browser,
-                                int viewX,
-                                int viewY,
-                                int* screenX,
-                                int* screenY) {
+int CEF_CALLBACK render_handler_get_screen_point(
+    struct _cef_render_handler_t *self, cef_browser_t *browser, int viewX,
+    int viewY, int *screenX, int *screenY) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -154,10 +148,9 @@ render_handler_get_screen_point(struct _cef_render_handler_t* self,
   return _retval;
 }
 
-int CEF_CALLBACK
-render_handler_get_screen_info(struct _cef_render_handler_t* self,
-                               cef_browser_t* browser,
-                               struct _cef_screen_info_t* screen_info) {
+int CEF_CALLBACK render_handler_get_screen_info(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    struct _cef_screen_info_t *screen_info) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -191,10 +184,8 @@ render_handler_get_screen_info(struct _cef_render_handler_t* self,
   return _retval;
 }
 
-void CEF_CALLBACK
-render_handler_on_popup_show(struct _cef_render_handler_t* self,
-                             cef_browser_t* browser,
-                             int show) {
+void CEF_CALLBACK render_handler_on_popup_show(
+    struct _cef_render_handler_t *self, cef_browser_t *browser, int show) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -213,9 +204,8 @@ render_handler_on_popup_show(struct _cef_render_handler_t* self,
 }
 
 void CEF_CALLBACK
-render_handler_on_popup_size(struct _cef_render_handler_t* self,
-                             cef_browser_t* browser,
-                             const cef_rect_t* rect) {
+render_handler_on_popup_size(struct _cef_render_handler_t *self,
+                             cef_browser_t *browser, const cef_rect_t *rect) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -240,14 +230,10 @@ render_handler_on_popup_size(struct _cef_render_handler_t* self,
       CefBrowserCToCpp::Wrap(browser), rectVal);
 }
 
-void CEF_CALLBACK render_handler_on_paint(struct _cef_render_handler_t* self,
-                                          cef_browser_t* browser,
-                                          cef_paint_element_type_t type,
-                                          size_t dirtyRectsCount,
-                                          cef_rect_t const* dirtyRects,
-                                          const void* buffer,
-                                          int width,
-                                          int height) {
+void CEF_CALLBACK render_handler_on_paint(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    cef_paint_element_type_t type, size_t dirtyRectsCount,
+    cef_rect_t const *dirtyRects, const void *buffer, int width, int height) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -283,13 +269,10 @@ void CEF_CALLBACK render_handler_on_paint(struct _cef_render_handler_t* self,
                                              width, height);
 }
 
-void CEF_CALLBACK
-render_handler_on_accelerated_paint(struct _cef_render_handler_t* self,
-                                    cef_browser_t* browser,
-                                    cef_paint_element_type_t type,
-                                    size_t dirtyRectsCount,
-                                    cef_rect_t const* dirtyRects,
-                                    void* shared_handle) {
+void CEF_CALLBACK render_handler_on_accelerated_paint(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    cef_paint_element_type_t type, size_t dirtyRectsCount,
+    cef_rect_t const *dirtyRects, void *shared_handle) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -324,11 +307,9 @@ render_handler_on_accelerated_paint(struct _cef_render_handler_t* self,
       CefBrowserCToCpp::Wrap(browser), type, dirtyRectsList, shared_handle);
 }
 
-void CEF_CALLBACK
-render_handler_get_touch_handle_size(struct _cef_render_handler_t* self,
-                                     cef_browser_t* browser,
-                                     cef_horizontal_alignment_t orientation,
-                                     cef_size_t* size) {
+void CEF_CALLBACK render_handler_get_touch_handle_size(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    cef_horizontal_alignment_t orientation, cef_size_t *size) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -358,9 +339,8 @@ render_handler_get_touch_handle_size(struct _cef_render_handler_t* self,
 }
 
 void CEF_CALLBACK render_handler_on_touch_handle_state_changed(
-    struct _cef_render_handler_t* self,
-    cef_browser_t* browser,
-    const struct _cef_touch_handle_state_t* state) {
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    const struct _cef_touch_handle_state_t *state) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -387,13 +367,55 @@ void CEF_CALLBACK render_handler_on_touch_handle_state_changed(
       CefBrowserCToCpp::Wrap(browser), stateObj);
 }
 
-int CEF_CALLBACK
-render_handler_start_dragging(struct _cef_render_handler_t* self,
-                              cef_browser_t* browser,
-                              cef_drag_data_t* drag_data,
-                              cef_drag_operations_mask_t allowed_ops,
-                              int x,
-                              int y) {
+void CEF_CALLBACK render_handler_on_touch_selection_changed(
+    struct _cef_render_handler_t *self,
+    const struct _cef_touch_handle_state_t *insert_handle,
+    const struct _cef_touch_handle_state_t *start_selection_handle,
+    const struct _cef_touch_handle_state_t *end_selection_handle,
+    int need_report) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Verify param: insert_handle; type: struct_byref_const
+  DCHECK(insert_handle);
+  if (!insert_handle)
+    return;
+  // Verify param: start_selection_handle; type: struct_byref_const
+  DCHECK(start_selection_handle);
+  if (!start_selection_handle)
+    return;
+  // Verify param: end_selection_handle; type: struct_byref_const
+  DCHECK(end_selection_handle);
+  if (!end_selection_handle)
+    return;
+
+  // Translate param: insert_handle; type: struct_byref_const
+  CefTouchHandleState insert_handleObj;
+  if (insert_handle)
+    insert_handleObj.Set(*insert_handle, false);
+  // Translate param: start_selection_handle; type: struct_byref_const
+  CefTouchHandleState start_selection_handleObj;
+  if (start_selection_handle)
+    start_selection_handleObj.Set(*start_selection_handle, false);
+  // Translate param: end_selection_handle; type: struct_byref_const
+  CefTouchHandleState end_selection_handleObj;
+  if (end_selection_handle)
+    end_selection_handleObj.Set(*end_selection_handle, false);
+
+  // Execute
+  CefRenderHandlerCppToC::Get(self)->OnTouchSelectionChanged(
+      insert_handleObj, start_selection_handleObj, end_selection_handleObj,
+      need_report ? true : false);
+}
+
+int CEF_CALLBACK render_handler_start_dragging(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    cef_drag_data_t *drag_data, cef_drag_operations_mask_t allowed_ops, int x,
+    int y) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -419,10 +441,9 @@ render_handler_start_dragging(struct _cef_render_handler_t* self,
   return _retval;
 }
 
-void CEF_CALLBACK
-render_handler_update_drag_cursor(struct _cef_render_handler_t* self,
-                                  cef_browser_t* browser,
-                                  cef_drag_operations_mask_t operation) {
+void CEF_CALLBACK render_handler_update_drag_cursor(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    cef_drag_operations_mask_t operation) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -440,11 +461,9 @@ render_handler_update_drag_cursor(struct _cef_render_handler_t* self,
       CefBrowserCToCpp::Wrap(browser), operation);
 }
 
-void CEF_CALLBACK
-render_handler_on_scroll_offset_changed(struct _cef_render_handler_t* self,
-                                        cef_browser_t* browser,
-                                        double x,
-                                        double y) {
+void CEF_CALLBACK render_handler_on_scroll_offset_changed(
+    struct _cef_render_handler_t *self, cef_browser_t *browser, double x,
+    double y) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -462,11 +481,9 @@ render_handler_on_scroll_offset_changed(struct _cef_render_handler_t* self,
       CefBrowserCToCpp::Wrap(browser), x, y);
 }
 
-void CEF_CALLBACK
-render_handler_on_root_layer_changed(struct _cef_render_handler_t* self,
-                                     cef_browser_t* browser,
-                                     int height,
-                                     int width) {
+void CEF_CALLBACK render_handler_on_root_layer_changed(
+    struct _cef_render_handler_t *self, cef_browser_t *browser, int height,
+    int width) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -485,11 +502,9 @@ render_handler_on_root_layer_changed(struct _cef_render_handler_t* self,
 }
 
 void CEF_CALLBACK render_handler_on_ime_composition_range_changed(
-    struct _cef_render_handler_t* self,
-    cef_browser_t* browser,
-    const cef_range_t* selected_range,
-    size_t character_boundsCount,
-    cef_rect_t const* character_bounds) {
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    const cef_range_t *selected_range, size_t character_boundsCount,
+    cef_rect_t const *character_bounds) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -526,11 +541,9 @@ void CEF_CALLBACK render_handler_on_ime_composition_range_changed(
       CefBrowserCToCpp::Wrap(browser), selected_rangeVal, character_boundsList);
 }
 
-void CEF_CALLBACK
-render_handler_on_text_selection_changed(struct _cef_render_handler_t* self,
-                                         cef_browser_t* browser,
-                                         const cef_string_t* selected_text,
-                                         const cef_range_t* selected_range) {
+void CEF_CALLBACK render_handler_on_text_selection_changed(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    const cef_string_t *selected_text, const cef_range_t *selected_range) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -553,10 +566,9 @@ render_handler_on_text_selection_changed(struct _cef_render_handler_t* self,
       selected_rangeVal);
 }
 
-void CEF_CALLBACK
-render_handler_on_virtual_keyboard_requested(struct _cef_render_handler_t* self,
-                                             cef_browser_t* browser,
-                                             cef_text_input_mode_t input_mode) {
+void CEF_CALLBACK render_handler_on_virtual_keyboard_requested(
+    struct _cef_render_handler_t *self, cef_browser_t *browser,
+    cef_text_input_mode_t input_mode, int show_keyboard) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -571,10 +583,11 @@ render_handler_on_virtual_keyboard_requested(struct _cef_render_handler_t* self,
 
   // Execute
   CefRenderHandlerCppToC::Get(self)->OnVirtualKeyboardRequested(
-      CefBrowserCToCpp::Wrap(browser), input_mode);
+      CefBrowserCToCpp::Wrap(browser), input_mode,
+      show_keyboard ? true : false);
 }
 
-}  // namespace
+} // namespace
 
 // CONSTRUCTOR - Do not edit by hand.
 
@@ -592,6 +605,8 @@ CefRenderHandlerCppToC::CefRenderHandlerCppToC() {
   GetStruct()->get_touch_handle_size = render_handler_get_touch_handle_size;
   GetStruct()->on_touch_handle_state_changed =
       render_handler_on_touch_handle_state_changed;
+  GetStruct()->on_touch_selection_changed =
+      render_handler_on_touch_selection_changed;
   GetStruct()->start_dragging = render_handler_start_dragging;
   GetStruct()->update_drag_cursor = render_handler_update_drag_cursor;
   GetStruct()->on_scroll_offset_changed =
@@ -612,17 +627,16 @@ CefRenderHandlerCppToC::~CefRenderHandlerCppToC() {
 }
 
 template <>
-CefRefPtr<CefRenderHandler> CefCppToCRefCounted<
-    CefRenderHandlerCppToC,
-    CefRenderHandler,
-    cef_render_handler_t>::UnwrapDerived(CefWrapperType type,
-                                         cef_render_handler_t* s) {
+CefRefPtr<CefRenderHandler>
+CefCppToCRefCounted<CefRenderHandlerCppToC, CefRenderHandler,
+                    cef_render_handler_t>::UnwrapDerived(CefWrapperType type,
+                                                         cef_render_handler_t
+                                                             *s) {
   NOTREACHED() << "Unexpected class type: " << type;
   return nullptr;
 }
 
 template <>
-CefWrapperType CefCppToCRefCounted<CefRenderHandlerCppToC,
-                                   CefRenderHandler,
+CefWrapperType CefCppToCRefCounted<CefRenderHandlerCppToC, CefRenderHandler,
                                    cef_render_handler_t>::kWrapperType =
     WT_RENDER_HANDLER;
diff --git a/cef/libcef_dll/cpptoc/request_context_cpptoc.cc b/cef/libcef_dll/cpptoc/request_context_cpptoc.cc
index d9ed11e960da7..709c073357f7f 100644
--- a/cef/libcef_dll/cpptoc/request_context_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/request_context_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=1c9faf9e6cc954e6750cbdb4dd0533659bdab68d$
+// $hash=7e01b6605f683bc0eedf94d2f9f5f0d2f2eefb9b$
 //
 
 #include "libcef_dll/cpptoc/request_context_cpptoc.h"
@@ -426,6 +426,21 @@ void CEF_CALLBACK request_context_clear_http_auth_credentials(
       CefCompletionCallbackCToCpp::Wrap(callback));
 }
 
+void CEF_CALLBACK request_context_clear_client_authentication_cache(
+    struct _cef_request_context_t* self,
+    cef_completion_callback_t* callback) {
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Unverified params: callback
+
+  // Execute
+  CefRequestContextCppToC::Get(self)->ClearClientAuthenticationCache(
+      CefCompletionCallbackCToCpp::Wrap(callback));
+}
+
 void CEF_CALLBACK
 request_context_close_all_connections(struct _cef_request_context_t* self,
                                       cef_completion_callback_t* callback) {
@@ -625,6 +640,8 @@ CefRequestContextCppToC::CefRequestContextCppToC() {
       request_context_clear_certificate_exceptions;
   GetStruct()->clear_http_auth_credentials =
       request_context_clear_http_auth_credentials;
+  GetStruct()->clear_client_authentication_cache =
+      request_context_clear_client_authentication_cache;
   GetStruct()->close_all_connections = request_context_close_all_connections;
   GetStruct()->resolve_host = request_context_resolve_host;
   GetStruct()->load_extension = request_context_load_extension;
diff --git a/cef/libcef_dll/cpptoc/request_handler_cpptoc.cc b/cef/libcef_dll/cpptoc/request_handler_cpptoc.cc
index 001faf062dcfd..e084c4679cb09 100644
--- a/cef/libcef_dll/cpptoc/request_handler_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/request_handler_cpptoc.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=d737e87912d409f23e7b078a6c7d56bed2a5df95$
+// $hash=98fc4aa339448e61acef741b88f7e96a39e69bea$
 //
 
 #include "libcef_dll/cpptoc/request_handler_cpptoc.h"
@@ -23,6 +23,7 @@
 #include "libcef_dll/ctocpp/sslinfo_ctocpp.h"
 #include "libcef_dll/ctocpp/x509certificate_ctocpp.h"
 #include "libcef_dll/shutdown_checker.h"
+#include "libcef_dll/transfer_util.h"
 
 namespace {
 
@@ -283,6 +284,8 @@ int CEF_CALLBACK request_handler_on_select_client_certificate(
     int isProxy,
     const cef_string_t* host,
     int port,
+    cef_string_list_t key_types,
+    cef_string_list_t principals,
     size_t certificatesCount,
     struct _cef_x509certificate_t* const* certificates,
     cef_select_client_certificate_callback_t* callback) {
@@ -301,6 +304,14 @@ int CEF_CALLBACK request_handler_on_select_client_certificate(
   DCHECK(host);
   if (!host)
     return 0;
+  // Verify param: key_types; type: string_vec_byref_const
+  DCHECK(key_types);
+  if (!key_types)
+    return 0;
+  // Verify param: principals; type: string_vec_byref_const
+  DCHECK(principals);
+  if (!principals)
+    return 0;
   // Verify param: certificates; type: refptr_vec_diff_byref_const
   DCHECK(certificatesCount == 0 || certificates);
   if (certificatesCount > 0 && !certificates)
@@ -310,6 +321,12 @@ int CEF_CALLBACK request_handler_on_select_client_certificate(
   if (!callback)
     return 0;
 
+  // Translate param: key_types; type: string_vec_byref_const
+  std::vector<CefString> key_typesList;
+  transfer_string_list_contents(key_types, key_typesList);
+  // Translate param: principals; type: string_vec_byref_const
+  std::vector<CefString> principalsList;
+  transfer_string_list_contents(principals, principalsList);
   // Translate param: certificates; type: refptr_vec_diff_byref_const
   std::vector<CefRefPtr<CefX509Certificate>> certificatesList;
   if (certificatesCount > 0) {
@@ -323,7 +340,7 @@ int CEF_CALLBACK request_handler_on_select_client_certificate(
   // Execute
   bool _retval = CefRequestHandlerCppToC::Get(self)->OnSelectClientCertificate(
       CefBrowserCToCpp::Wrap(browser), isProxy ? true : false, CefString(host),
-      port, certificatesList,
+      port, key_typesList, principalsList, certificatesList,
       CefSelectClientCertificateCallbackCToCpp::Wrap(callback));
 
   // Return type: bool
diff --git a/cef/libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.cc
new file mode 100644
index 0000000000000..6226e93809e3d
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.cc
@@ -0,0 +1,71 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=a3ef788b12af7c2ca8bc3d87c13626590891f74a$
+//
+
+#include "libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.h"
+#include "libcef_dll/shutdown_checker.h"
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK save_web_archive_result_callback_on_save_web_archive_done(
+    struct _cef_save_web_archive_result_callback_t* self,
+    const cef_string_t* result) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Unverified params: result
+
+  // Execute
+  CefSaveWebArchiveResultCallbackCppToC::Get(self)->OnSaveWebArchiveDone(
+      CefString(result));
+}
+
+}  // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefSaveWebArchiveResultCallbackCppToC::CefSaveWebArchiveResultCallbackCppToC() {
+  GetStruct()->on_save_web_archive_done =
+      save_web_archive_result_callback_on_save_web_archive_done;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefSaveWebArchiveResultCallbackCppToC::
+    ~CefSaveWebArchiveResultCallbackCppToC() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+CefRefPtr<CefSaveWebArchiveResultCallback>
+CefCppToCRefCounted<CefSaveWebArchiveResultCallbackCppToC,
+                    CefSaveWebArchiveResultCallback,
+                    cef_save_web_archive_result_callback_t>::
+    UnwrapDerived(CefWrapperType type,
+                  cef_save_web_archive_result_callback_t* s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType
+    CefCppToCRefCounted<CefSaveWebArchiveResultCallbackCppToC,
+                        CefSaveWebArchiveResultCallback,
+                        cef_save_web_archive_result_callback_t>::kWrapperType =
+        WT_SAVE_WEB_ARCHIVE_RESULT_CALLBACK;
diff --git a/cef/libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.h b/cef/libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.h
new file mode 100644
index 0000000000000..1bd0fd1374a68
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/save_web_archive_result_callback_cpptoc.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=cc54648b4be6f93659a4b6b438a60a7d6e07b4d0$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_SAVE_WEB_ARCHIVE_RESULT_CALLBACK_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_SAVE_WEB_ARCHIVE_RESULT_CALLBACK_CPPTOC_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_browser_capi.h"
+#include "include/capi/cef_client_capi.h"
+#include "include/cef_browser.h"
+#include "include/cef_client.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed wrapper-side only.
+class CefSaveWebArchiveResultCallbackCppToC
+    : public CefCppToCRefCounted<CefSaveWebArchiveResultCallbackCppToC,
+                                 CefSaveWebArchiveResultCallback,
+                                 cef_save_web_archive_result_callback_t> {
+ public:
+  CefSaveWebArchiveResultCallbackCppToC();
+  virtual ~CefSaveWebArchiveResultCallbackCppToC();
+};
+
+#endif  // CEF_LIBCEF_DLL_CPPTOC_SAVE_WEB_ARCHIVE_RESULT_CALLBACK_CPPTOC_H_
diff --git a/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.cc
index d14d94523a506..353d69c68b20f 100644
--- a/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.cc
+++ b/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.cc
@@ -9,11 +9,10 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=5017f5bece20966b0972418228301ef32e05f740$
+// $hash=d20b8b121892f6d2fe0f944c4447464ab6657feb$
 //
 
 #include "libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.h"
-#include "libcef_dll/cpptoc/x509certificate_cpptoc.h"
 #include "libcef_dll/shutdown_checker.h"
 
 namespace {
@@ -22,7 +21,8 @@ namespace {
 
 void CEF_CALLBACK select_client_certificate_callback_select(
     struct _cef_select_client_certificate_callback_t* self,
-    struct _cef_x509certificate_t* cert) {
+    const cef_string_t* private_key_file,
+    const cef_string_t* cert_chain_file) {
   shutdown_checker::AssertNotShutdown();
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
@@ -30,11 +30,46 @@ void CEF_CALLBACK select_client_certificate_callback_select(
   DCHECK(self);
   if (!self)
     return;
-  // Unverified params: cert
+  // Verify param: private_key_file; type: string_byref_const
+  DCHECK(private_key_file);
+  if (!private_key_file)
+    return;
+  // Verify param: cert_chain_file; type: string_byref_const
+  DCHECK(cert_chain_file);
+  if (!cert_chain_file)
+    return;
 
   // Execute
   CefSelectClientCertificateCallbackCppToC::Get(self)->Select(
-      CefX509CertificateCppToC::Unwrap(cert));
+      CefString(private_key_file), CefString(cert_chain_file));
+}
+
+void CEF_CALLBACK select_client_certificate_callback_cancel(
+    struct _cef_select_client_certificate_callback_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefSelectClientCertificateCallbackCppToC::Get(self)->Cancel();
+}
+
+void CEF_CALLBACK select_client_certificate_callback_ignore(
+    struct _cef_select_client_certificate_callback_t* self) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+
+  // Execute
+  CefSelectClientCertificateCallbackCppToC::Get(self)->Ignore();
 }
 
 }  // namespace
@@ -44,6 +79,8 @@ void CEF_CALLBACK select_client_certificate_callback_select(
 CefSelectClientCertificateCallbackCppToC::
     CefSelectClientCertificateCallbackCppToC() {
   GetStruct()->select = select_client_certificate_callback_select;
+  GetStruct()->cancel = select_client_certificate_callback_cancel;
+  GetStruct()->ignore = select_client_certificate_callback_ignore;
 }
 
 // DESTRUCTOR - Do not edit by hand.
diff --git a/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.h b/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.h
index 9905463d3e4e7..0669e57114698 100644
--- a/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.h
+++ b/cef/libcef_dll/cpptoc/select_client_certificate_callback_cpptoc.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=e397708024c85cf066c0b7b76f1fae74b3a3e4d6$
+// $hash=d1683893875612d3f4b2007cc246390dfba1ca6a$
 //
 
 #ifndef CEF_LIBCEF_DLL_CPPTOC_SELECT_CLIENT_CERTIFICATE_CALLBACK_CPPTOC_H_
@@ -20,8 +20,8 @@
 #error This file can be included DLL-side only
 #endif
 
-#include "include/capi/cef_request_handler_capi.h"
-#include "include/cef_request_handler.h"
+#include "include/capi/cef_request_callback_capi.h"
+#include "include/cef_request_callback.h"
 #include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
 
 // Wrap a C++ class with a C structure.
diff --git a/cef/libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.cc b/cef/libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.cc
new file mode 100644
index 0000000000000..4c69ff14accfb
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.cc
@@ -0,0 +1,72 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=63e0d5c68603a8478c9b8a638618c9b6554665cb$
+//
+
+#include "libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.h"
+#include "libcef_dll/shutdown_checker.h"
+
+namespace {
+
+// MEMBER FUNCTIONS - Body may be edited by hand.
+
+void CEF_CALLBACK store_web_archive_result_callback_on_store_web_archive_done(
+    struct _cef_store_web_archive_result_callback_t* self,
+    const cef_string_t* result) {
+  shutdown_checker::AssertNotShutdown();
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  DCHECK(self);
+  if (!self)
+    return;
+  // Unverified params: result
+
+  // Execute
+  CefStoreWebArchiveResultCallbackCppToC::Get(self)->OnStoreWebArchiveDone(
+      CefString(result));
+}
+
+}  // namespace
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefStoreWebArchiveResultCallbackCppToC::
+    CefStoreWebArchiveResultCallbackCppToC() {
+  GetStruct()->on_store_web_archive_done =
+      store_web_archive_result_callback_on_store_web_archive_done;
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefStoreWebArchiveResultCallbackCppToC::
+    ~CefStoreWebArchiveResultCallbackCppToC() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+CefRefPtr<CefStoreWebArchiveResultCallback>
+CefCppToCRefCounted<CefStoreWebArchiveResultCallbackCppToC,
+                    CefStoreWebArchiveResultCallback,
+                    cef_store_web_archive_result_callback_t>::
+    UnwrapDerived(CefWrapperType type,
+                  cef_store_web_archive_result_callback_t* s) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType
+    CefCppToCRefCounted<CefStoreWebArchiveResultCallbackCppToC,
+                        CefStoreWebArchiveResultCallback,
+                        cef_store_web_archive_result_callback_t>::kWrapperType =
+        WT_STORE_WEB_ARCHIVE_RESULT_CALLBACK;
diff --git a/cef/libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.h b/cef/libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.h
new file mode 100644
index 0000000000000..c80f743fff7ae
--- /dev/null
+++ b/cef/libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=1471041bc8e9230b7bef9e42aabaf441e641ab96$
+//
+
+#ifndef CEF_LIBCEF_DLL_CPPTOC_STORE_WEB_ARCHIVE_RESULT_CALLBACK_CPPTOC_H_
+#define CEF_LIBCEF_DLL_CPPTOC_STORE_WEB_ARCHIVE_RESULT_CALLBACK_CPPTOC_H_
+#pragma once
+
+#if !defined(WRAPPING_CEF_SHARED)
+#error This file can be included wrapper-side only
+#endif
+
+#include "include/capi/cef_browser_capi.h"
+#include "include/capi/cef_client_capi.h"
+#include "include/cef_browser.h"
+#include "include/cef_client.h"
+#include "libcef_dll/cpptoc/cpptoc_ref_counted.h"
+
+// Wrap a C++ class with a C structure.
+// This class may be instantiated and accessed wrapper-side only.
+class CefStoreWebArchiveResultCallbackCppToC
+    : public CefCppToCRefCounted<CefStoreWebArchiveResultCallbackCppToC,
+                                 CefStoreWebArchiveResultCallback,
+                                 cef_store_web_archive_result_callback_t> {
+ public:
+  CefStoreWebArchiveResultCallbackCppToC();
+  virtual ~CefStoreWebArchiveResultCallbackCppToC();
+};
+
+#endif  // CEF_LIBCEF_DLL_CPPTOC_STORE_WEB_ARCHIVE_RESULT_CALLBACK_CPPTOC_H_
diff --git a/cef/libcef_dll/ctocpp/browser_ctocpp.cc b/cef/libcef_dll/ctocpp/browser_ctocpp.cc
index 5da9863ef3342..61560088fb938 100644
--- a/cef/libcef_dll/ctocpp/browser_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/browser_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=220bf75cb17234a4207417a9b9808c449b84a75f$
+// $hash=217238b191b281dc7c1bb4abf8d4cbfbaf5444aa$
 //
 
 #include "libcef_dll/ctocpp/browser_ctocpp.h"
@@ -195,6 +195,25 @@ NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::ReloadOriginalUrl() {
   _struct->reload_original_url(_struct);
 }
 
+NO_SANITIZE("cfi-icall")
+void CefBrowserCToCpp::SetBrowserUserAgentString(const CefString& user_agent) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, set_browser_user_agent_string))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: user_agent; type: string_byref_const
+  DCHECK(!user_agent.empty());
+  if (user_agent.empty())
+    return;
+
+  // Execute
+  _struct->set_browser_user_agent_string(_struct, user_agent.GetStruct());
+}
+
 NO_SANITIZE("cfi-icall") void CefBrowserCToCpp::StopLoad() {
   shutdown_checker::AssertNotShutdown();
 
diff --git a/cef/libcef_dll/ctocpp/browser_ctocpp.h b/cef/libcef_dll/ctocpp/browser_ctocpp.h
index e35719950a18d..14a96d67fa90b 100644
--- a/cef/libcef_dll/ctocpp/browser_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/browser_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=916afe8b283c692464dd27c0e284c898e7f026bf$
+// $hash=621263303ff60f8f78a0905aab545ad6f464b754$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_BROWSER_CTOCPP_H_
@@ -48,6 +48,7 @@ class CefBrowserCToCpp
   void Reload() OVERRIDE;
   void ReloadIgnoreCache() OVERRIDE;
   void ReloadOriginalUrl() OVERRIDE;
+  void SetBrowserUserAgentString(const CefString& user_agent) OVERRIDE;
   void StopLoad() OVERRIDE;
   int GetIdentifier() OVERRIDE;
   bool IsSame(CefRefPtr<CefBrowser> that) OVERRIDE;
diff --git a/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc b/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
index 64a476694811a..4ce7c13f56971 100644
--- a/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/browser_host_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=40021309c151fae1441f8931dab8a08ff82bf2cf$
+// $hash=963dd3a80b249c6ef9a2e6e13025a2070f7c958a$
 //
 
 #include "libcef_dll/ctocpp/browser_host_ctocpp.h"
@@ -20,6 +20,7 @@
 #include "libcef_dll/cpptoc/navigation_entry_visitor_cpptoc.h"
 #include "libcef_dll/cpptoc/pdf_print_callback_cpptoc.h"
 #include "libcef_dll/cpptoc/run_file_dialog_callback_cpptoc.h"
+#include "libcef_dll/cpptoc/store_web_archive_result_callback_cpptoc.h"
 #include "libcef_dll/cpptoc/task_cpptoc.h"
 #include "libcef_dll/ctocpp/browser_ctocpp.h"
 #include "libcef_dll/ctocpp/dictionary_value_ctocpp.h"
@@ -409,7 +410,8 @@ void CefBrowserHostCToCpp::Find(int identifier,
                                 const CefString& searchText,
                                 bool forward,
                                 bool matchCase,
-                                bool findNext) {
+                                bool findNext,
+                                bool newSession) {
   shutdown_checker::AssertNotShutdown();
 
   cef_browser_host_t* _struct = GetStruct();
@@ -425,7 +427,7 @@ void CefBrowserHostCToCpp::Find(int identifier,
 
   // Execute
   _struct->find(_struct, identifier, searchText.GetStruct(), forward, matchCase,
-                findNext);
+                findNext, newSession);
 }
 
 NO_SANITIZE("cfi-icall")
@@ -682,6 +684,20 @@ NO_SANITIZE("cfi-icall") void CefBrowserHostCToCpp::NotifyScreenInfoChanged() {
   _struct->notify_screen_info_changed(_struct);
 }
 
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::SetVirtualPixelRatio(float ratio) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, set_virtual_pixel_ratio))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->set_virtual_pixel_ratio(_struct, ratio);
+}
+
 NO_SANITIZE("cfi-icall")
 void CefBrowserHostCToCpp::Invalidate(PaintElementType type) {
   shutdown_checker::AssertNotShutdown();
@@ -987,6 +1003,34 @@ void CefBrowserHostCToCpp::UnregisterArkJSfunction(
     cef_string_list_free(method_listList);
 }
 
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::StoreWebArchive(
+    const CefString& base_name,
+    bool auto_name,
+    CefRefPtr<CefStoreWebArchiveResultCallback> callback) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, store_web_archive))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: base_name; type: string_byref_const
+  DCHECK(!base_name.empty());
+  if (base_name.empty())
+    return;
+  // Verify param: callback; type: refptr_diff
+  DCHECK(callback.get());
+  if (!callback.get())
+    return;
+
+  // Execute
+  _struct->store_web_archive(
+      _struct, base_name.GetStruct(), auto_name,
+      CefStoreWebArchiveResultCallbackCppToC::Wrap(callback));
+}
+
 NO_SANITIZE("cfi-icall") CefString CefBrowserHostCToCpp::Title() {
   shutdown_checker::AssertNotShutdown();
 
@@ -1005,6 +1049,131 @@ NO_SANITIZE("cfi-icall") CefString CefBrowserHostCToCpp::Title() {
   return _retvalStr;
 }
 
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::CreateWebMessagePorts(
+    std::vector<CefString>& ports) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, create_web_message_ports))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Translate param: ports; type: string_vec_byref
+  cef_string_list_t portsList = cef_string_list_alloc();
+  DCHECK(portsList);
+  if (portsList)
+    transfer_string_list_contents(ports, portsList);
+
+  // Execute
+  _struct->create_web_message_ports(_struct, portsList);
+
+  // Restore param:ports; type: string_vec_byref
+  if (portsList) {
+    ports.clear();
+    transfer_string_list_contents(portsList, ports);
+    cef_string_list_free(portsList);
+  }
+}
+
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::PostWebMessage(CefString& message,
+                                          std::vector<CefString>& ports,
+                                          CefString& targetUri) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, post_web_message))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Translate param: ports; type: string_vec_byref
+  cef_string_list_t portsList = cef_string_list_alloc();
+  DCHECK(portsList);
+  if (portsList)
+    transfer_string_list_contents(ports, portsList);
+
+  // Execute
+  _struct->post_web_message(_struct, message.GetWritableStruct(), portsList,
+                            targetUri.GetWritableStruct());
+
+  // Restore param:ports; type: string_vec_byref
+  if (portsList) {
+    ports.clear();
+    transfer_string_list_contents(portsList, ports);
+    cef_string_list_free(portsList);
+  }
+}
+
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::ClosePort(CefString& port_handle) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, close_port))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->close_port(_struct, port_handle.GetWritableStruct());
+}
+
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::DestroyAllWebMessagePorts() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, destroy_all_web_message_ports))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->destroy_all_web_message_ports(_struct);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::PostPortMessage(CefString& port_handle,
+                                           CefString& data) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, post_port_message))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->post_port_message(_struct, port_handle.GetWritableStruct(),
+                             data.GetWritableStruct());
+}
+
+NO_SANITIZE("cfi-icall")
+void CefBrowserHostCToCpp::SetPortMessageCallback(
+    CefString& port_handle,
+    CefRefPtr<CefJavaScriptResultCallback> callback) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_browser_host_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, set_port_message_callback))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: callback; type: refptr_diff
+  DCHECK(callback.get());
+  if (!callback.get())
+    return;
+
+  // Execute
+  _struct->set_port_message_callback(
+      _struct, port_handle.GetWritableStruct(),
+      CefJavaScriptResultCallbackCppToC::Wrap(callback));
+}
+
 NO_SANITIZE("cfi-icall")
 void CefBrowserHostCToCpp::GetHitData(int& type, CefString& extra_data) {
   shutdown_checker::AssertNotShutdown();
diff --git a/cef/libcef_dll/ctocpp/browser_host_ctocpp.h b/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
index 96d928e453d48..b0b0950d4cedb 100644
--- a/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/browser_host_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=b923449230e8617d5e205097f08f7139d6548971$
+// $hash=638ed85cf0a5dd7a0d7a6868437bd8031f78c67f$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_BROWSER_HOST_CTOCPP_H_
@@ -69,7 +69,8 @@ class CefBrowserHostCToCpp : public CefCToCppRefCounted<CefBrowserHostCToCpp,
             const CefString& searchText,
             bool forward,
             bool matchCase,
-            bool findNext) OVERRIDE;
+            bool findNext,
+            bool newSession) OVERRIDE;
   void StopFinding(bool clearSelection) OVERRIDE;
   void ShowDevTools(const CefWindowInfo& windowInfo,
                     CefRefPtr<CefClient> client,
@@ -91,6 +92,7 @@ class CefBrowserHostCToCpp : public CefCToCppRefCounted<CefBrowserHostCToCpp,
   void WasResized() OVERRIDE;
   void WasHidden(bool hidden) OVERRIDE;
   void NotifyScreenInfoChanged() OVERRIDE;
+  void SetVirtualPixelRatio(float ratio) OVERRIDE;
   void Invalidate(PaintElementType type) OVERRIDE;
   void SendExternalBeginFrame() OVERRIDE;
   void SendKeyEvent(const CefKeyEvent& event) OVERRIDE;
@@ -118,7 +120,21 @@ class CefBrowserHostCToCpp : public CefCToCppRefCounted<CefBrowserHostCToCpp,
   void UnregisterArkJSfunction(
       const CefString& object_name,
       const std::vector<CefString>& method_list) OVERRIDE;
+  void StoreWebArchive(
+      const CefString& base_name,
+      bool auto_name,
+      CefRefPtr<CefStoreWebArchiveResultCallback> callback) OVERRIDE;
   CefString Title() OVERRIDE;
+  void CreateWebMessagePorts(std::vector<CefString>& ports) OVERRIDE;
+  void PostWebMessage(CefString& message,
+                      std::vector<CefString>& ports,
+                      CefString& targetUri) OVERRIDE;
+  void ClosePort(CefString& port_handle) OVERRIDE;
+  void DestroyAllWebMessagePorts() OVERRIDE;
+  void PostPortMessage(CefString& port_handle, CefString& data) OVERRIDE;
+  void SetPortMessageCallback(
+      CefString& port_handle,
+      CefRefPtr<CefJavaScriptResultCallback> callback) OVERRIDE;
   void GetHitData(int& type, CefString& extra_data) OVERRIDE;
   void SetInitialScale(float scale) OVERRIDE;
   int PageLoadProgress() OVERRIDE;
diff --git a/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.cc b/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.cc
index dc94d161fed46..9f8b8ea1acbea 100644
--- a/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=fc72d18dc6fecabfa6080413cf31ad31b1cfa958$
+// $hash=6e1bd6af22e730b6d6a12a7296414250bf415979$
 //
 
 #include "libcef_dll/ctocpp/cookie_manager_ctocpp.h"
@@ -28,7 +28,7 @@ CefRefPtr<CefCookieManager> CefCookieManager::GetGlobalManager(
   // Unverified params: callback
 
   // Execute
-  cef_cookie_manager_t* _retval = cef_cookie_manager_get_global_manager(
+  cef_cookie_manager_t *_retval = cef_cookie_manager_get_global_manager(
       CefCompletionCallbackCppToC::Wrap(callback));
 
   // Return type: refptr_same
@@ -36,9 +36,9 @@ CefRefPtr<CefCookieManager> CefCookieManager::GetGlobalManager(
 }
 
 NO_SANITIZE("cfi-icall")
-bool CefCookieManager::CreateCefCookie(const CefString& url,
-                                       const CefString& value,
-                                       CefCookie& cef_cookie) {
+bool CefCookieManager::CreateCefCookie(const CefString &url,
+                                       const CefString &value,
+                                       CefCookie &cef_cookie) {
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   // Verify param: url; type: string_byref_const
@@ -61,7 +61,7 @@ bool CefCookieManager::CreateCefCookie(const CefString& url,
 // VIRTUAL METHODS - Body may be edited by hand.
 
 NO_SANITIZE("cfi-icall") bool CefCookieManagerCToCpp::IsAcceptCookieAllowed() {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, is_accept_cookie_allowed))
     return false;
 
@@ -76,7 +76,7 @@ NO_SANITIZE("cfi-icall") bool CefCookieManagerCToCpp::IsAcceptCookieAllowed() {
 
 NO_SANITIZE("cfi-icall")
 void CefCookieManagerCToCpp::PutAcceptCookieEnabled(bool accept) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, put_accept_cookie_enabled))
     return;
 
@@ -86,9 +86,36 @@ void CefCookieManagerCToCpp::PutAcceptCookieEnabled(bool accept) {
   _struct->put_accept_cookie_enabled(_struct, accept);
 }
 
+NO_SANITIZE("cfi-icall")
+bool CefCookieManagerCToCpp::IsThirdPartyCookieAllowed() {
+  cef_cookie_manager_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, is_third_party_cookie_allowed))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  int _retval = _struct->is_third_party_cookie_allowed(_struct);
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
+NO_SANITIZE("cfi-icall")
+void CefCookieManagerCToCpp::PutAcceptThirdPartyCookieEnabled(bool accept) {
+  cef_cookie_manager_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, put_accept_third_party_cookie_enabled))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->put_accept_third_party_cookie_enabled(_struct, accept);
+}
+
 NO_SANITIZE("cfi-icall")
 bool CefCookieManagerCToCpp::IsFileURLSchemeCookiesAllowed() {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, is_file_urlscheme_cookies_allowed))
     return false;
 
@@ -103,7 +130,7 @@ bool CefCookieManagerCToCpp::IsFileURLSchemeCookiesAllowed() {
 
 NO_SANITIZE("cfi-icall")
 void CefCookieManagerCToCpp::PutAcceptFileURLSchemeCookiesEnabled(bool allow) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, put_accept_file_urlscheme_cookies_enabled))
     return;
 
@@ -116,7 +143,7 @@ void CefCookieManagerCToCpp::PutAcceptFileURLSchemeCookiesEnabled(bool allow) {
 NO_SANITIZE("cfi-icall")
 bool CefCookieManagerCToCpp::VisitAllCookies(
     CefRefPtr<CefCookieVisitor> visitor) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, visit_all_cookies))
     return false;
 
@@ -137,10 +164,9 @@ bool CefCookieManagerCToCpp::VisitAllCookies(
 
 NO_SANITIZE("cfi-icall")
 bool CefCookieManagerCToCpp::VisitUrlCookies(
-    const CefString& url,
-    bool includeHttpOnly,
+    const CefString &url, bool includeHttpOnly,
     CefRefPtr<CefCookieVisitor> visitor) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, visit_url_cookies))
     return false;
 
@@ -166,10 +192,9 @@ bool CefCookieManagerCToCpp::VisitUrlCookies(
 
 NO_SANITIZE("cfi-icall")
 bool CefCookieManagerCToCpp::SetCookie(
-    const CefString& url,
-    const CefCookie& cookie,
+    const CefString &url, const CefCookie &cookie,
     CefRefPtr<CefSetCookieCallback> callback) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, set_cookie))
     return false;
 
@@ -191,11 +216,9 @@ bool CefCookieManagerCToCpp::SetCookie(
 
 NO_SANITIZE("cfi-icall")
 bool CefCookieManagerCToCpp::DeleteCookies(
-    const CefString& url,
-    const CefString& cookie_name,
-    bool is_session,
+    const CefString &url, const CefString &cookie_name, bool is_session,
     CefRefPtr<CefDeleteCookiesCallback> callback) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, delete_cookies))
     return false;
 
@@ -215,7 +238,7 @@ bool CefCookieManagerCToCpp::DeleteCookies(
 NO_SANITIZE("cfi-icall")
 bool CefCookieManagerCToCpp::FlushStore(
     CefRefPtr<CefCompletionCallback> callback) {
-  cef_cookie_manager_t* _struct = GetStruct();
+  cef_cookie_manager_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, flush_store))
     return false;
 
@@ -240,17 +263,15 @@ CefCookieManagerCToCpp::CefCookieManagerCToCpp() {}
 CefCookieManagerCToCpp::~CefCookieManagerCToCpp() {}
 
 template <>
-cef_cookie_manager_t*
-CefCToCppRefCounted<CefCookieManagerCToCpp,
-                    CefCookieManager,
+cef_cookie_manager_t *
+CefCToCppRefCounted<CefCookieManagerCToCpp, CefCookieManager,
                     cef_cookie_manager_t>::UnwrapDerived(CefWrapperType type,
-                                                         CefCookieManager* c) {
+                                                         CefCookieManager *c) {
   NOTREACHED() << "Unexpected class type: " << type;
   return nullptr;
 }
 
 template <>
-CefWrapperType CefCToCppRefCounted<CefCookieManagerCToCpp,
-                                   CefCookieManager,
+CefWrapperType CefCToCppRefCounted<CefCookieManagerCToCpp, CefCookieManager,
                                    cef_cookie_manager_t>::kWrapperType =
     WT_COOKIE_MANAGER;
diff --git a/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.h b/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.h
index bbac3e21b5f37..34811444e1d09 100644
--- a/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/cookie_manager_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=72c7b7341d1fe0f7fc35b539d6a1cca430880423$
+// $hash=a94b064990f0b9801db58a115f3d54b0fc1f852c$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_COOKIE_MANAGER_CTOCPP_H_
@@ -27,30 +27,28 @@
 // Wrap a C structure with a C++ class.
 // This class may be instantiated and accessed wrapper-side only.
 class CefCookieManagerCToCpp
-    : public CefCToCppRefCounted<CefCookieManagerCToCpp,
-                                 CefCookieManager,
+    : public CefCToCppRefCounted<CefCookieManagerCToCpp, CefCookieManager,
                                  cef_cookie_manager_t> {
- public:
+public:
   CefCookieManagerCToCpp();
   virtual ~CefCookieManagerCToCpp();
 
   // CefCookieManager methods.
   bool IsAcceptCookieAllowed() OVERRIDE;
   void PutAcceptCookieEnabled(bool accept) OVERRIDE;
+  bool IsThirdPartyCookieAllowed() OVERRIDE;
+  void PutAcceptThirdPartyCookieEnabled(bool accept) OVERRIDE;
   bool IsFileURLSchemeCookiesAllowed() OVERRIDE;
   void PutAcceptFileURLSchemeCookiesEnabled(bool allow) OVERRIDE;
   bool VisitAllCookies(CefRefPtr<CefCookieVisitor> visitor) OVERRIDE;
-  bool VisitUrlCookies(const CefString& url,
-                       bool includeHttpOnly,
+  bool VisitUrlCookies(const CefString &url, bool includeHttpOnly,
                        CefRefPtr<CefCookieVisitor> visitor) OVERRIDE;
-  bool SetCookie(const CefString& url,
-                 const CefCookie& cookie,
+  bool SetCookie(const CefString &url, const CefCookie &cookie,
                  CefRefPtr<CefSetCookieCallback> callback) OVERRIDE;
-  bool DeleteCookies(const CefString& url,
-                     const CefString& cookie_name,
+  bool DeleteCookies(const CefString &url, const CefString &cookie_name,
                      bool is_session,
                      CefRefPtr<CefDeleteCookiesCallback> callback) OVERRIDE;
   bool FlushStore(CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
 };
 
-#endif  // CEF_LIBCEF_DLL_CTOCPP_COOKIE_MANAGER_CTOCPP_H_
+#endif // CEF_LIBCEF_DLL_CTOCPP_COOKIE_MANAGER_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/data_base_ctocpp.cc b/cef/libcef_dll/ctocpp/data_base_ctocpp.cc
index 7e58bbd44d83f..b590138461bd2 100644
--- a/cef/libcef_dll/ctocpp/data_base_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/data_base_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=53c2a75f715e09b94fad1d3b324886e59d428dcc$
+// $hash=3ab167d92ecbdc7c4c52483058038ed50a68231a$
 //
 
 #include "libcef_dll/ctocpp/data_base_ctocpp.h"
@@ -126,6 +126,129 @@ void CefDataBaseCToCpp::GetHttpAuthCredentials(
   }
 }
 
+NO_SANITIZE("cfi-icall")
+bool CefDataBaseCToCpp::ExistPermissionByOrigin(const CefString &origin,
+                                                int type) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, exist_permission_by_origin))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: origin; type: string_byref_const
+  DCHECK(!origin.empty());
+  if (origin.empty())
+    return false;
+
+  // Execute
+  int _retval =
+      _struct->exist_permission_by_origin(_struct, origin.GetStruct(), type);
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
+NO_SANITIZE("cfi-icall")
+bool CefDataBaseCToCpp::GetPermissionResultByOrigin(const CefString &origin,
+                                                    int type, bool &result) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_permission_result_by_origin))
+    return false;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: origin; type: string_byref_const
+  DCHECK(!origin.empty());
+  if (origin.empty())
+    return false;
+
+  // Translate param: result; type: bool_byref
+  int resultInt = result;
+
+  // Execute
+  int _retval = _struct->get_permission_result_by_origin(
+      _struct, origin.GetStruct(), type, &resultInt);
+
+  // Restore param:result; type: bool_byref
+  result = resultInt ? true : false;
+
+  // Return type: bool
+  return _retval ? true : false;
+}
+
+NO_SANITIZE("cfi-icall")
+void CefDataBaseCToCpp::SetPermissionByOrigin(const CefString &origin, int type,
+                                              bool result) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, set_permission_by_origin))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: origin; type: string_byref_const
+  DCHECK(!origin.empty());
+  if (origin.empty())
+    return;
+
+  // Execute
+  _struct->set_permission_by_origin(_struct, origin.GetStruct(), type, result);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefDataBaseCToCpp::ClearPermissionByOrigin(const CefString &origin,
+                                                int type) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, clear_permission_by_origin))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Verify param: origin; type: string_byref_const
+  DCHECK(!origin.empty());
+  if (origin.empty())
+    return;
+
+  // Execute
+  _struct->clear_permission_by_origin(_struct, origin.GetStruct(), type);
+}
+
+NO_SANITIZE("cfi-icall") void CefDataBaseCToCpp::ClearAllPermission(int type) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, clear_all_permission))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->clear_all_permission(_struct, type);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefDataBaseCToCpp::GetOriginsByPermission(
+    int type, std::vector<CefString> &origins) {
+  cef_data_base_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, get_origins_by_permission))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Translate param: origins; type: string_vec_byref
+  cef_string_list_t originsList = cef_string_list_alloc();
+  DCHECK(originsList);
+  if (originsList)
+    transfer_string_list_contents(origins, originsList);
+
+  // Execute
+  _struct->get_origins_by_permission(_struct, type, originsList);
+
+  // Restore param:origins; type: string_vec_byref
+  if (originsList) {
+    origins.clear();
+    transfer_string_list_contents(originsList, origins);
+    cef_string_list_free(originsList);
+  }
+}
+
 // CONSTRUCTOR - Do not edit by hand.
 
 CefDataBaseCToCpp::CefDataBaseCToCpp() {}
diff --git a/cef/libcef_dll/ctocpp/data_base_ctocpp.h b/cef/libcef_dll/ctocpp/data_base_ctocpp.h
index b2614a28e75c3..65f8618022baa 100644
--- a/cef/libcef_dll/ctocpp/data_base_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/data_base_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=e6ff148812bffbe2b08efcdda056642b77a392ca$
+// $hash=0ecd8a0ce002f2caf3fa75a6b70c903705f73572$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_DATA_BASE_CTOCPP_H_
@@ -43,6 +43,15 @@ public:
   void
   GetHttpAuthCredentials(const CefString &host, const CefString &realm,
                          std::vector<CefString> &username_password) OVERRIDE;
+  bool ExistPermissionByOrigin(const CefString &origin, int type) OVERRIDE;
+  bool GetPermissionResultByOrigin(const CefString &origin, int type,
+                                   bool &result) OVERRIDE;
+  void SetPermissionByOrigin(const CefString &origin, int type,
+                             bool result) OVERRIDE;
+  void ClearPermissionByOrigin(const CefString &origin, int type) OVERRIDE;
+  void ClearAllPermission(int type) OVERRIDE;
+  void GetOriginsByPermission(int type,
+                              std::vector<CefString> &origins) OVERRIDE;
 };
 
 #endif // CEF_LIBCEF_DLL_CTOCPP_DATA_BASE_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc b/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc
index cd3865ff3a864..ac2c4011307f3 100644
--- a/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/render_handler_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=99c2bfaa0dfb40df1c6aef46582bebb0350888b5$
+// $hash=4542e0e52791a8d283c997922779ab33d40ad54c$
 //
 
 #include "libcef_dll/ctocpp/render_handler_ctocpp.h"
@@ -25,14 +25,14 @@ CefRefPtr<
     CefAccessibilityHandler> CefRenderHandlerCToCpp::GetAccessibilityHandler() {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, get_accessibility_handler))
     return nullptr;
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   // Execute
-  cef_accessibility_handler_t* _retval =
+  cef_accessibility_handler_t *_retval =
       _struct->get_accessibility_handler(_struct);
 
   // Return type: refptr_same
@@ -41,10 +41,10 @@ CefRefPtr<
 
 NO_SANITIZE("cfi-icall")
 bool CefRenderHandlerCToCpp::GetRootScreenRect(CefRefPtr<CefBrowser> browser,
-                                               CefRect& rect) {
+                                               CefRect &rect) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, get_root_screen_rect))
     return false;
 
@@ -65,10 +65,10 @@ bool CefRenderHandlerCToCpp::GetRootScreenRect(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::GetViewRect(CefRefPtr<CefBrowser> browser,
-                                         CefRect& rect) {
+                                         CefRect &rect) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, get_view_rect))
     return;
 
@@ -85,13 +85,11 @@ void CefRenderHandlerCToCpp::GetViewRect(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 bool CefRenderHandlerCToCpp::GetScreenPoint(CefRefPtr<CefBrowser> browser,
-                                            int viewX,
-                                            int viewY,
-                                            int& screenX,
-                                            int& screenY) {
+                                            int viewX, int viewY, int &screenX,
+                                            int &screenY) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, get_screen_point))
     return false;
 
@@ -113,10 +111,10 @@ bool CefRenderHandlerCToCpp::GetScreenPoint(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 bool CefRenderHandlerCToCpp::GetScreenInfo(CefRefPtr<CefBrowser> browser,
-                                           CefScreenInfo& screen_info) {
+                                           CefScreenInfo &screen_info) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, get_screen_info))
     return false;
 
@@ -140,7 +138,7 @@ void CefRenderHandlerCToCpp::OnPopupShow(CefRefPtr<CefBrowser> browser,
                                          bool show) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_popup_show))
     return;
 
@@ -157,10 +155,10 @@ void CefRenderHandlerCToCpp::OnPopupShow(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnPopupSize(CefRefPtr<CefBrowser> browser,
-                                         const CefRect& rect) {
+                                         const CefRect &rect) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_popup_size))
     return;
 
@@ -178,13 +176,12 @@ void CefRenderHandlerCToCpp::OnPopupSize(CefRefPtr<CefBrowser> browser,
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnPaint(CefRefPtr<CefBrowser> browser,
                                      PaintElementType type,
-                                     const RectList& dirtyRects,
-                                     const void* buffer,
-                                     int width,
+                                     const RectList &dirtyRects,
+                                     const void *buffer, int width,
                                      int height) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_paint))
     return;
 
@@ -201,7 +198,7 @@ void CefRenderHandlerCToCpp::OnPaint(CefRefPtr<CefBrowser> browser,
 
   // Translate param: dirtyRects; type: simple_vec_byref_const
   const size_t dirtyRectsCount = dirtyRects.size();
-  cef_rect_t* dirtyRectsList = NULL;
+  cef_rect_t *dirtyRectsList = NULL;
   if (dirtyRectsCount > 0) {
     dirtyRectsList = new cef_rect_t[dirtyRectsCount];
     DCHECK(dirtyRectsList);
@@ -224,11 +221,11 @@ void CefRenderHandlerCToCpp::OnPaint(CefRefPtr<CefBrowser> browser,
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnAcceleratedPaint(CefRefPtr<CefBrowser> browser,
                                                 PaintElementType type,
-                                                const RectList& dirtyRects,
-                                                void* shared_handle) {
+                                                const RectList &dirtyRects,
+                                                void *shared_handle) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_accelerated_paint))
     return;
 
@@ -245,7 +242,7 @@ void CefRenderHandlerCToCpp::OnAcceleratedPaint(CefRefPtr<CefBrowser> browser,
 
   // Translate param: dirtyRects; type: simple_vec_byref_const
   const size_t dirtyRectsCount = dirtyRects.size();
-  cef_rect_t* dirtyRectsList = NULL;
+  cef_rect_t *dirtyRectsList = NULL;
   if (dirtyRectsCount > 0) {
     dirtyRectsList = new cef_rect_t[dirtyRectsCount];
     DCHECK(dirtyRectsList);
@@ -267,12 +264,11 @@ void CefRenderHandlerCToCpp::OnAcceleratedPaint(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::GetTouchHandleSize(
-    CefRefPtr<CefBrowser> browser,
-    cef_horizontal_alignment_t orientation,
-    CefSize& size) {
+    CefRefPtr<CefBrowser> browser, cef_horizontal_alignment_t orientation,
+    CefSize &size) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, get_touch_handle_size))
     return;
 
@@ -290,11 +286,10 @@ void CefRenderHandlerCToCpp::GetTouchHandleSize(
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnTouchHandleStateChanged(
-    CefRefPtr<CefBrowser> browser,
-    const CefTouchHandleState& state) {
+    CefRefPtr<CefBrowser> browser, const CefTouchHandleState &state) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_touch_handle_state_changed))
     return;
 
@@ -310,15 +305,33 @@ void CefRenderHandlerCToCpp::OnTouchHandleStateChanged(
       _struct, CefBrowserCppToC::Wrap(browser), &state);
 }
 
+NO_SANITIZE("cfi-icall")
+void CefRenderHandlerCToCpp::OnTouchSelectionChanged(
+    const CefTouchHandleState &insert_handle,
+    const CefTouchHandleState &start_selection_handle,
+    const CefTouchHandleState &end_selection_handle, bool need_report) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_render_handler_t *_struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_touch_selection_changed))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->on_touch_selection_changed(_struct, &insert_handle,
+                                      &start_selection_handle,
+                                      &end_selection_handle, need_report);
+}
+
 NO_SANITIZE("cfi-icall")
 bool CefRenderHandlerCToCpp::StartDragging(CefRefPtr<CefBrowser> browser,
                                            CefRefPtr<CefDragData> drag_data,
                                            DragOperationsMask allowed_ops,
-                                           int x,
-                                           int y) {
+                                           int x, int y) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, start_dragging))
     return false;
 
@@ -347,7 +360,7 @@ void CefRenderHandlerCToCpp::UpdateDragCursor(CefRefPtr<CefBrowser> browser,
                                               DragOperation operation) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, update_drag_cursor))
     return;
 
@@ -365,12 +378,10 @@ void CefRenderHandlerCToCpp::UpdateDragCursor(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnScrollOffsetChanged(
-    CefRefPtr<CefBrowser> browser,
-    double x,
-    double y) {
+    CefRefPtr<CefBrowser> browser, double x, double y) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_scroll_offset_changed))
     return;
 
@@ -388,11 +399,10 @@ void CefRenderHandlerCToCpp::OnScrollOffsetChanged(
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnRootLayerChanged(CefRefPtr<CefBrowser> browser,
-                                                int height,
-                                                int width) {
+                                                int height, int width) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_root_layer_changed))
     return;
 
@@ -410,12 +420,11 @@ void CefRenderHandlerCToCpp::OnRootLayerChanged(CefRefPtr<CefBrowser> browser,
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnImeCompositionRangeChanged(
-    CefRefPtr<CefBrowser> browser,
-    const CefRange& selected_range,
-    const RectList& character_bounds) {
+    CefRefPtr<CefBrowser> browser, const CefRange &selected_range,
+    const RectList &character_bounds) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_ime_composition_range_changed))
     return;
 
@@ -428,7 +437,7 @@ void CefRenderHandlerCToCpp::OnImeCompositionRangeChanged(
 
   // Translate param: character_bounds; type: simple_vec_byref_const
   const size_t character_boundsCount = character_bounds.size();
-  cef_rect_t* character_boundsList = NULL;
+  cef_rect_t *character_boundsList = NULL;
   if (character_boundsCount > 0) {
     character_boundsList = new cef_rect_t[character_boundsCount];
     DCHECK(character_boundsList);
@@ -451,12 +460,11 @@ void CefRenderHandlerCToCpp::OnImeCompositionRangeChanged(
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnTextSelectionChanged(
-    CefRefPtr<CefBrowser> browser,
-    const CefString& selected_text,
-    const CefRange& selected_range) {
+    CefRefPtr<CefBrowser> browser, const CefString &selected_text,
+    const CefRange &selected_range) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_text_selection_changed))
     return;
 
@@ -476,11 +484,11 @@ void CefRenderHandlerCToCpp::OnTextSelectionChanged(
 
 NO_SANITIZE("cfi-icall")
 void CefRenderHandlerCToCpp::OnVirtualKeyboardRequested(
-    CefRefPtr<CefBrowser> browser,
-    TextInputMode input_mode) {
+    CefRefPtr<CefBrowser> browser, TextInputMode input_mode,
+    bool show_keyboard) {
   shutdown_checker::AssertNotShutdown();
 
-  cef_render_handler_t* _struct = GetStruct();
+  cef_render_handler_t *_struct = GetStruct();
   if (CEF_MEMBER_MISSING(_struct, on_virtual_keyboard_requested))
     return;
 
@@ -493,7 +501,7 @@ void CefRenderHandlerCToCpp::OnVirtualKeyboardRequested(
 
   // Execute
   _struct->on_virtual_keyboard_requested(
-      _struct, CefBrowserCppToC::Wrap(browser), input_mode);
+      _struct, CefBrowserCppToC::Wrap(browser), input_mode, show_keyboard);
 }
 
 // CONSTRUCTOR - Do not edit by hand.
@@ -507,17 +515,15 @@ CefRenderHandlerCToCpp::~CefRenderHandlerCToCpp() {
 }
 
 template <>
-cef_render_handler_t*
-CefCToCppRefCounted<CefRenderHandlerCToCpp,
-                    CefRenderHandler,
+cef_render_handler_t *
+CefCToCppRefCounted<CefRenderHandlerCToCpp, CefRenderHandler,
                     cef_render_handler_t>::UnwrapDerived(CefWrapperType type,
-                                                         CefRenderHandler* c) {
+                                                         CefRenderHandler *c) {
   NOTREACHED() << "Unexpected class type: " << type;
   return nullptr;
 }
 
 template <>
-CefWrapperType CefCToCppRefCounted<CefRenderHandlerCToCpp,
-                                   CefRenderHandler,
+CefWrapperType CefCToCppRefCounted<CefRenderHandlerCToCpp, CefRenderHandler,
                                    cef_render_handler_t>::kWrapperType =
     WT_RENDER_HANDLER;
diff --git a/cef/libcef_dll/ctocpp/render_handler_ctocpp.h b/cef/libcef_dll/ctocpp/render_handler_ctocpp.h
index f299ceef1a7ac..781bb41575097 100644
--- a/cef/libcef_dll/ctocpp/render_handler_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/render_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=03e40f836e421eb3b4074b4c2efed287f4f39401$
+// $hash=f70633e6b53acb79709008ad6aaa692c77f7d136$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_RENDER_HANDLER_CTOCPP_H_
@@ -27,62 +27,56 @@
 // Wrap a C structure with a C++ class.
 // This class may be instantiated and accessed DLL-side only.
 class CefRenderHandlerCToCpp
-    : public CefCToCppRefCounted<CefRenderHandlerCToCpp,
-                                 CefRenderHandler,
+    : public CefCToCppRefCounted<CefRenderHandlerCToCpp, CefRenderHandler,
                                  cef_render_handler_t> {
- public:
+public:
   CefRenderHandlerCToCpp();
   virtual ~CefRenderHandlerCToCpp();
 
   // CefRenderHandler methods.
   CefRefPtr<CefAccessibilityHandler> GetAccessibilityHandler() override;
-  bool GetRootScreenRect(CefRefPtr<CefBrowser> browser, CefRect& rect) override;
-  void GetViewRect(CefRefPtr<CefBrowser> browser, CefRect& rect) override;
-  bool GetScreenPoint(CefRefPtr<CefBrowser> browser,
-                      int viewX,
-                      int viewY,
-                      int& screenX,
-                      int& screenY) override;
+  bool GetRootScreenRect(CefRefPtr<CefBrowser> browser, CefRect &rect) override;
+  void GetViewRect(CefRefPtr<CefBrowser> browser, CefRect &rect) override;
+  bool GetScreenPoint(CefRefPtr<CefBrowser> browser, int viewX, int viewY,
+                      int &screenX, int &screenY) override;
   bool GetScreenInfo(CefRefPtr<CefBrowser> browser,
-                     CefScreenInfo& screen_info) override;
+                     CefScreenInfo &screen_info) override;
   void OnPopupShow(CefRefPtr<CefBrowser> browser, bool show) override;
-  void OnPopupSize(CefRefPtr<CefBrowser> browser, const CefRect& rect) override;
-  void OnPaint(CefRefPtr<CefBrowser> browser,
-               PaintElementType type,
-               const RectList& dirtyRects,
-               const void* buffer,
-               int width,
+  void OnPopupSize(CefRefPtr<CefBrowser> browser, const CefRect &rect) override;
+  void OnPaint(CefRefPtr<CefBrowser> browser, PaintElementType type,
+               const RectList &dirtyRects, const void *buffer, int width,
                int height) override;
-  void OnAcceleratedPaint(CefRefPtr<CefBrowser> browser,
-                          PaintElementType type,
-                          const RectList& dirtyRects,
-                          void* shared_handle) override;
+  void OnAcceleratedPaint(CefRefPtr<CefBrowser> browser, PaintElementType type,
+                          const RectList &dirtyRects,
+                          void *shared_handle) override;
   void GetTouchHandleSize(CefRefPtr<CefBrowser> browser,
                           cef_horizontal_alignment_t orientation,
-                          CefSize& size) override;
+                          CefSize &size) override;
   void OnTouchHandleStateChanged(CefRefPtr<CefBrowser> browser,
-                                 const CefTouchHandleState& state) override;
+                                 const CefTouchHandleState &state) override;
+  void
+  OnTouchSelectionChanged(const CefTouchHandleState &insert_handle,
+                          const CefTouchHandleState &start_selection_handle,
+                          const CefTouchHandleState &end_selection_handle,
+                          bool need_report) override;
   bool StartDragging(CefRefPtr<CefBrowser> browser,
                      CefRefPtr<CefDragData> drag_data,
-                     DragOperationsMask allowed_ops,
-                     int x,
-                     int y) override;
+                     DragOperationsMask allowed_ops, int x, int y) override;
   void UpdateDragCursor(CefRefPtr<CefBrowser> browser,
                         DragOperation operation) override;
-  void OnScrollOffsetChanged(CefRefPtr<CefBrowser> browser,
-                             double x,
+  void OnScrollOffsetChanged(CefRefPtr<CefBrowser> browser, double x,
                              double y) override;
-  void OnRootLayerChanged(CefRefPtr<CefBrowser> browser,
-                          int height,
+  void OnRootLayerChanged(CefRefPtr<CefBrowser> browser, int height,
                           int width) override;
   void OnImeCompositionRangeChanged(CefRefPtr<CefBrowser> browser,
-                                    const CefRange& selected_range,
-                                    const RectList& character_bounds) override;
+                                    const CefRange &selected_range,
+                                    const RectList &character_bounds) override;
   void OnTextSelectionChanged(CefRefPtr<CefBrowser> browser,
-                              const CefString& selected_text,
-                              const CefRange& selected_range) override;
+                              const CefString &selected_text,
+                              const CefRange &selected_range) override;
   void OnVirtualKeyboardRequested(CefRefPtr<CefBrowser> browser,
-                                  TextInputMode input_mode) override;
+                                  TextInputMode input_mode,
+                                  bool show_keyboard) override;
 };
 
-#endif  // CEF_LIBCEF_DLL_CTOCPP_RENDER_HANDLER_CTOCPP_H_
+#endif // CEF_LIBCEF_DLL_CTOCPP_RENDER_HANDLER_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/request_context_ctocpp.cc b/cef/libcef_dll/ctocpp/request_context_ctocpp.cc
index ac22cd057ab40..5cd79458532d5 100644
--- a/cef/libcef_dll/ctocpp/request_context_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/request_context_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=e3ea60786acfb0510d510f00cc023f57baf00279$
+// $hash=598cc3427480337c8d4f0326ff919a7b9e2df7b3$
 //
 
 #include "libcef_dll/ctocpp/request_context_ctocpp.h"
@@ -408,6 +408,22 @@ void CefRequestContextCToCpp::ClearHttpAuthCredentials(
       _struct, CefCompletionCallbackCppToC::Wrap(callback));
 }
 
+NO_SANITIZE("cfi-icall")
+void CefRequestContextCToCpp::ClearClientAuthenticationCache(
+    CefRefPtr<CefCompletionCallback> callback) {
+  cef_request_context_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, clear_client_authentication_cache))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: callback
+
+  // Execute
+  _struct->clear_client_authentication_cache(
+      _struct, CefCompletionCallbackCppToC::Wrap(callback));
+}
+
 NO_SANITIZE("cfi-icall")
 void CefRequestContextCToCpp::CloseAllConnections(
     CefRefPtr<CefCompletionCallback> callback) {
diff --git a/cef/libcef_dll/ctocpp/request_context_ctocpp.h b/cef/libcef_dll/ctocpp/request_context_ctocpp.h
index 67d7a7714acde..f6b8bf30b5fd4 100644
--- a/cef/libcef_dll/ctocpp/request_context_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/request_context_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=8e0f90454e2018acc3d7297708d9835b1364e9a6$
+// $hash=be400ebb45c77f944ecf96738400e485fee2111c$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_REQUEST_CONTEXT_CTOCPP_H_
@@ -68,6 +68,8 @@ class CefRequestContextCToCpp
       CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
   void ClearHttpAuthCredentials(
       CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
+  void ClearClientAuthenticationCache(
+      CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
   void CloseAllConnections(CefRefPtr<CefCompletionCallback> callback) OVERRIDE;
   void ResolveHost(const CefString& origin,
                    CefRefPtr<CefResolveCallback> callback) OVERRIDE;
diff --git a/cef/libcef_dll/ctocpp/request_handler_ctocpp.cc b/cef/libcef_dll/ctocpp/request_handler_ctocpp.cc
index aaa756b9806b8..80883651b2881 100644
--- a/cef/libcef_dll/ctocpp/request_handler_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/request_handler_ctocpp.cc
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=5df945d13e76eb21611ae848d99505eaae5e7602$
+// $hash=8cdac6b506941fb0f68974c718f106a9a9f76ad6$
 //
 
 #include "libcef_dll/ctocpp/request_handler_ctocpp.h"
@@ -23,6 +23,7 @@
 #include "libcef_dll/cpptoc/x509certificate_cpptoc.h"
 #include "libcef_dll/ctocpp/resource_request_handler_ctocpp.h"
 #include "libcef_dll/shutdown_checker.h"
+#include "libcef_dll/transfer_util.h"
 
 // VIRTUAL METHODS - Body may be edited by hand.
 
@@ -277,6 +278,8 @@ bool CefRequestHandlerCToCpp::OnSelectClientCertificate(
     bool isProxy,
     const CefString& host,
     int port,
+    const std::vector<CefString>& key_types,
+    const std::vector<CefString>& principals,
     const X509CertificateList& certificates,
     CefRefPtr<CefSelectClientCertificateCallback> callback) {
   shutdown_checker::AssertNotShutdown();
@@ -300,6 +303,16 @@ bool CefRequestHandlerCToCpp::OnSelectClientCertificate(
   if (!callback.get())
     return false;
 
+  // Translate param: key_types; type: string_vec_byref_const
+  cef_string_list_t key_typesList = cef_string_list_alloc();
+  DCHECK(key_typesList);
+  if (key_typesList)
+    transfer_string_list_contents(key_types, key_typesList);
+  // Translate param: principals; type: string_vec_byref_const
+  cef_string_list_t principalsList = cef_string_list_alloc();
+  DCHECK(principalsList);
+  if (principalsList)
+    transfer_string_list_contents(principals, principalsList);
   // Translate param: certificates; type: refptr_vec_diff_byref_const
   const size_t certificatesCount = certificates.size();
   cef_x509certificate_t** certificatesList = NULL;
@@ -316,9 +329,15 @@ bool CefRequestHandlerCToCpp::OnSelectClientCertificate(
   // Execute
   int _retval = _struct->on_select_client_certificate(
       _struct, CefBrowserCppToC::Wrap(browser), isProxy, host.GetStruct(), port,
-      certificatesCount, certificatesList,
+      key_typesList, principalsList, certificatesCount, certificatesList,
       CefSelectClientCertificateCallbackCppToC::Wrap(callback));
 
+  // Restore param:key_types; type: string_vec_byref_const
+  if (key_typesList)
+    cef_string_list_free(key_typesList);
+  // Restore param:principals; type: string_vec_byref_const
+  if (principalsList)
+    cef_string_list_free(principalsList);
   // Restore param:certificates; type: refptr_vec_diff_byref_const
   if (certificatesList)
     delete[] certificatesList;
diff --git a/cef/libcef_dll/ctocpp/request_handler_ctocpp.h b/cef/libcef_dll/ctocpp/request_handler_ctocpp.h
index 32b5dac844034..3111ba0f27ed5 100644
--- a/cef/libcef_dll/ctocpp/request_handler_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/request_handler_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=dff7280d248bbc08733c6765a3ddfe5ae3978348$
+// $hash=012f58b9ab82579adf47394db6ec0d4652ea4486$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_REQUEST_HANDLER_CTOCPP_H_
@@ -20,6 +20,7 @@
 #error This file can be included DLL-side only
 #endif
 
+#include <vector>
 #include "include/capi/cef_request_handler_capi.h"
 #include "include/cef_request_handler.h"
 #include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
@@ -75,6 +76,8 @@ class CefRequestHandlerCToCpp
       bool isProxy,
       const CefString& host,
       int port,
+      const std::vector<CefString>& key_types,
+      const std::vector<CefString>& principals,
       const X509CertificateList& certificates,
       CefRefPtr<CefSelectClientCertificateCallback> callback) override;
   void OnPluginCrashed(CefRefPtr<CefBrowser> browser,
diff --git a/cef/libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.cc
new file mode 100644
index 0000000000000..1f74206bc55cd
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=7831635b2495318a47f9a16bbbbbb27510f381e5$
+//
+
+#include "libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.h"
+#include "libcef_dll/shutdown_checker.h"
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+void CefSaveWebArchiveResultCallbackCToCpp::OnSaveWebArchiveDone(
+    const CefString& result) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_save_web_archive_result_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_save_web_archive_done))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: result
+
+  // Execute
+  _struct->on_save_web_archive_done(_struct, result.GetStruct());
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefSaveWebArchiveResultCallbackCToCpp::CefSaveWebArchiveResultCallbackCToCpp() {
+}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefSaveWebArchiveResultCallbackCToCpp::
+    ~CefSaveWebArchiveResultCallbackCToCpp() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+cef_save_web_archive_result_callback_t*
+CefCToCppRefCounted<CefSaveWebArchiveResultCallbackCToCpp,
+                    CefSaveWebArchiveResultCallback,
+                    cef_save_web_archive_result_callback_t>::
+    UnwrapDerived(CefWrapperType type, CefSaveWebArchiveResultCallback* c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType
+    CefCToCppRefCounted<CefSaveWebArchiveResultCallbackCToCpp,
+                        CefSaveWebArchiveResultCallback,
+                        cef_save_web_archive_result_callback_t>::kWrapperType =
+        WT_SAVE_WEB_ARCHIVE_RESULT_CALLBACK;
diff --git a/cef/libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.h b/cef/libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.h
new file mode 100644
index 0000000000000..28e8c127a7522
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/save_web_archive_result_callback_ctocpp.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=b9a580e3465c6e32c1ab65c341a67a942758160c$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_SAVE_WEB_ARCHIVE_RESULT_CALLBACK_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_SAVE_WEB_ARCHIVE_RESULT_CALLBACK_CTOCPP_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include "include/capi/cef_browser_capi.h"
+#include "include/capi/cef_client_capi.h"
+#include "include/cef_browser.h"
+#include "include/cef_client.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed DLL-side only.
+class CefSaveWebArchiveResultCallbackCToCpp
+    : public CefCToCppRefCounted<CefSaveWebArchiveResultCallbackCToCpp,
+                                 CefSaveWebArchiveResultCallback,
+                                 cef_save_web_archive_result_callback_t> {
+ public:
+  CefSaveWebArchiveResultCallbackCToCpp();
+  virtual ~CefSaveWebArchiveResultCallbackCToCpp();
+
+  // CefSaveWebArchiveResultCallback methods.
+  void OnSaveWebArchiveDone(const CefString& result) override;
+};
+
+#endif  // CEF_LIBCEF_DLL_CTOCPP_SAVE_WEB_ARCHIVE_RESULT_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.cc
index 6d2ac0ee92db1..fda61b5069f30 100644
--- a/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.cc
+++ b/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.cc
@@ -9,18 +9,18 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=97852992a8406868d2b0dedf08a538a78b1cde9c$
+// $hash=f77cbb1874239eff164c3654befdc0f4fe81fed9$
 //
 
 #include "libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.h"
-#include "libcef_dll/ctocpp/x509certificate_ctocpp.h"
 #include "libcef_dll/shutdown_checker.h"
 
 // VIRTUAL METHODS - Body may be edited by hand.
 
 NO_SANITIZE("cfi-icall")
 void CefSelectClientCertificateCallbackCToCpp::Select(
-    CefRefPtr<CefX509Certificate> cert) {
+    const CefString& private_key_file,
+    const CefString& cert_chain_file) {
   shutdown_checker::AssertNotShutdown();
 
   cef_select_client_certificate_callback_t* _struct = GetStruct();
@@ -29,10 +29,46 @@ void CefSelectClientCertificateCallbackCToCpp::Select(
 
   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
-  // Unverified params: cert
+  // Verify param: private_key_file; type: string_byref_const
+  DCHECK(!private_key_file.empty());
+  if (private_key_file.empty())
+    return;
+  // Verify param: cert_chain_file; type: string_byref_const
+  DCHECK(!cert_chain_file.empty());
+  if (cert_chain_file.empty())
+    return;
+
+  // Execute
+  _struct->select(_struct, private_key_file.GetStruct(),
+                  cert_chain_file.GetStruct());
+}
+
+NO_SANITIZE("cfi-icall")
+void CefSelectClientCertificateCallbackCToCpp::Cancel() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_select_client_certificate_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, cancel))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Execute
+  _struct->cancel(_struct);
+}
+
+NO_SANITIZE("cfi-icall")
+void CefSelectClientCertificateCallbackCToCpp::Ignore() {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_select_client_certificate_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, ignore))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
 
   // Execute
-  _struct->select(_struct, CefX509CertificateCToCpp::Unwrap(cert));
+  _struct->ignore(_struct);
 }
 
 // CONSTRUCTOR - Do not edit by hand.
diff --git a/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.h b/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.h
index d3d36a9fcba0c..ce7f0171b2d36 100644
--- a/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.h
+++ b/cef/libcef_dll/ctocpp/select_client_certificate_callback_ctocpp.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=d18f32f1cb6917a6f6e83be4321e36aad309ea8b$
+// $hash=ac69adb2215c15868e5dc17162a0f0568776dd75$
 //
 
 #ifndef CEF_LIBCEF_DLL_CTOCPP_SELECT_CLIENT_CERTIFICATE_CALLBACK_CTOCPP_H_
@@ -20,8 +20,8 @@
 #error This file can be included wrapper-side only
 #endif
 
-#include "include/capi/cef_request_handler_capi.h"
-#include "include/cef_request_handler.h"
+#include "include/capi/cef_request_callback_capi.h"
+#include "include/cef_request_callback.h"
 #include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
 
 // Wrap a C structure with a C++ class.
@@ -35,7 +35,10 @@ class CefSelectClientCertificateCallbackCToCpp
   virtual ~CefSelectClientCertificateCallbackCToCpp();
 
   // CefSelectClientCertificateCallback methods.
-  void Select(CefRefPtr<CefX509Certificate> cert) OVERRIDE;
+  void Select(const CefString& private_key_file,
+              const CefString& cert_chain_file) OVERRIDE;
+  void Cancel() OVERRIDE;
+  void Ignore() OVERRIDE;
 };
 
 #endif  // CEF_LIBCEF_DLL_CTOCPP_SELECT_CLIENT_CERTIFICATE_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.cc b/cef/libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.cc
new file mode 100644
index 0000000000000..282357f875619
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=3ea3777da287fb256c81d7659000104b85d99c45$
+//
+
+#include "libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.h"
+#include "libcef_dll/shutdown_checker.h"
+
+// VIRTUAL METHODS - Body may be edited by hand.
+
+NO_SANITIZE("cfi-icall")
+void CefStoreWebArchiveResultCallbackCToCpp::OnStoreWebArchiveDone(
+    const CefString& result) {
+  shutdown_checker::AssertNotShutdown();
+
+  cef_store_web_archive_result_callback_t* _struct = GetStruct();
+  if (CEF_MEMBER_MISSING(_struct, on_store_web_archive_done))
+    return;
+
+  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
+
+  // Unverified params: result
+
+  // Execute
+  _struct->on_store_web_archive_done(_struct, result.GetStruct());
+}
+
+// CONSTRUCTOR - Do not edit by hand.
+
+CefStoreWebArchiveResultCallbackCToCpp::
+    CefStoreWebArchiveResultCallbackCToCpp() {}
+
+// DESTRUCTOR - Do not edit by hand.
+
+CefStoreWebArchiveResultCallbackCToCpp::
+    ~CefStoreWebArchiveResultCallbackCToCpp() {
+  shutdown_checker::AssertNotShutdown();
+}
+
+template <>
+cef_store_web_archive_result_callback_t*
+CefCToCppRefCounted<CefStoreWebArchiveResultCallbackCToCpp,
+                    CefStoreWebArchiveResultCallback,
+                    cef_store_web_archive_result_callback_t>::
+    UnwrapDerived(CefWrapperType type, CefStoreWebArchiveResultCallback* c) {
+  NOTREACHED() << "Unexpected class type: " << type;
+  return nullptr;
+}
+
+template <>
+CefWrapperType
+    CefCToCppRefCounted<CefStoreWebArchiveResultCallbackCToCpp,
+                        CefStoreWebArchiveResultCallback,
+                        cef_store_web_archive_result_callback_t>::kWrapperType =
+        WT_STORE_WEB_ARCHIVE_RESULT_CALLBACK;
diff --git a/cef/libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.h b/cef/libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.h
new file mode 100644
index 0000000000000..75369b7e2e97c
--- /dev/null
+++ b/cef/libcef_dll/ctocpp/store_web_archive_result_callback_ctocpp.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2022 The Chromium Embedded Framework Authors. All rights
+// reserved. Use of this source code is governed by a BSD-style license that
+// can be found in the LICENSE file.
+//
+// ---------------------------------------------------------------------------
+//
+// This file was generated by the CEF translator tool. If making changes by
+// hand only do so within the body of existing method and function
+// implementations. See the translator.README.txt file in the tools directory
+// for more information.
+//
+// $hash=ad8ad631ed5942baa7ae146fe31316d0952d3d36$
+//
+
+#ifndef CEF_LIBCEF_DLL_CTOCPP_STORE_WEB_ARCHIVE_RESULT_CALLBACK_CTOCPP_H_
+#define CEF_LIBCEF_DLL_CTOCPP_STORE_WEB_ARCHIVE_RESULT_CALLBACK_CTOCPP_H_
+#pragma once
+
+#if !defined(BUILDING_CEF_SHARED)
+#error This file can be included DLL-side only
+#endif
+
+#include "include/capi/cef_browser_capi.h"
+#include "include/capi/cef_client_capi.h"
+#include "include/cef_browser.h"
+#include "include/cef_client.h"
+#include "libcef_dll/ctocpp/ctocpp_ref_counted.h"
+
+// Wrap a C structure with a C++ class.
+// This class may be instantiated and accessed DLL-side only.
+class CefStoreWebArchiveResultCallbackCToCpp
+    : public CefCToCppRefCounted<CefStoreWebArchiveResultCallbackCToCpp,
+                                 CefStoreWebArchiveResultCallback,
+                                 cef_store_web_archive_result_callback_t> {
+ public:
+  CefStoreWebArchiveResultCallbackCToCpp();
+  virtual ~CefStoreWebArchiveResultCallbackCToCpp();
+
+  // CefStoreWebArchiveResultCallback methods.
+  void OnStoreWebArchiveDone(const CefString& result) override;
+};
+
+#endif  // CEF_LIBCEF_DLL_CTOCPP_STORE_WEB_ARCHIVE_RESULT_CALLBACK_CTOCPP_H_
diff --git a/cef/libcef_dll/wrapper_types.h b/cef/libcef_dll/wrapper_types.h
index de44445587d2f..c6f8b9a689d4c 100644
--- a/cef/libcef_dll/wrapper_types.h
+++ b/cef/libcef_dll/wrapper_types.h
@@ -9,7 +9,7 @@
 // implementations. See the translator.README.txt file in the tools directory
 // for more information.
 //
-// $hash=a1f17c16c7766c3e7268dd8878005cc144f58829$
+// $hash=fe662036b55f12c61d02dfbc8870ea4938f43a7d$
 //
 
 #ifndef CEF_LIBCEF_DLL_WRAPPER_TYPES_H_
@@ -138,6 +138,7 @@ enum CefWrapperType {
   WT_SERVER,
   WT_SERVER_HANDLER,
   WT_SET_COOKIE_CALLBACK,
+  WT_STORE_WEB_ARCHIVE_RESULT_CALLBACK,
   WT_STREAM_READER,
   WT_STREAM_WRITER,
   WT_STRING_VISITOR,
diff --git a/cef/tests/cefclient/browser/client_handler.cc b/cef/tests/cefclient/browser/client_handler.cc
index f7a666bbd6b33..14fd9ad85b17a 100644
--- a/cef/tests/cefclient/browser/client_handler.cc
+++ b/cef/tests/cefclient/browser/client_handler.cc
@@ -809,6 +809,8 @@ bool ClientHandler::OnSelectClientCertificate(
     bool isProxy,
     const CefString& host,
     int port,
+    const std::vector<CefString>& key_types,
+    const std::vector<CefString>& principals,
     const X509CertificateList& certificates,
     CefRefPtr<CefSelectClientCertificateCallback> callback) {
   CEF_REQUIRE_UI_THREAD();
diff --git a/cef/tests/cefclient/browser/client_handler.h b/cef/tests/cefclient/browser/client_handler.h
index 35dde3702e1af..6ae65495d0f1b 100644
--- a/cef/tests/cefclient/browser/client_handler.h
+++ b/cef/tests/cefclient/browser/client_handler.h
@@ -260,6 +260,8 @@ class ClientHandler : public CefClient,
       bool isProxy,
       const CefString& host,
       int port,
+      const std::vector<CefString>& key_types,
+      const std::vector<CefString>& principals,
       const X509CertificateList& certificates,
       CefRefPtr<CefSelectClientCertificateCallback> callback) OVERRIDE;
   void OnRenderProcessTerminated(CefRefPtr<CefBrowser> browser,
diff --git a/cef/tests/ceftests/os_rendering_unittest.cc b/cef/tests/ceftests/os_rendering_unittest.cc
index 92e5889bdf590..4b66fa267372c 100644
--- a/cef/tests/ceftests/os_rendering_unittest.cc
+++ b/cef/tests/ceftests/os_rendering_unittest.cc
@@ -1271,7 +1271,7 @@ class OSRTestHandler : public RoutingTestHandler,
   }
 
   void OnVirtualKeyboardRequested(CefRefPtr<CefBrowser> browser,
-                                  TextInputMode input_mode) override {
+                                  TextInputMode input_mode, bool show_keyboard) override {
     if (test_type_ == OSR_TEST_VIRTUAL_KEYBOARD && started()) {
       if (!got_virtual_keyboard_event_.isSet()) {
         got_virtual_keyboard_event_.yes();
diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
index b5e2d62d0cf92..40c431292f392 100644
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -1399,6 +1399,7 @@ android_library("chrome_test_java") {
     "//content/test/data/android/webshare-many.html",
     "//content/test/data/android/webshare-large.html",
     "//content/test/data/android/webshare-long.html",
+    "//content/test/data/android/webshare-separator.html",
     "//content/test/data/media/bear.webm",
     "//content/test/data/media/getusermedia.html",
     "//content/test/data/media/session/",
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/webshare/WebShareTest.java b/chrome/android/javatests/src/org/chromium/chrome/browser/webshare/WebShareTest.java
index afe782247aa23..2d269243e6a46 100644
--- a/chrome/android/javatests/src/org/chromium/chrome/browser/webshare/WebShareTest.java
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/webshare/WebShareTest.java
@@ -54,6 +54,8 @@ public class WebShareTest {
     private static final String TEST_FILE_OGG = "/content/test/data/android/webshare-ogg.html";
     private static final String TEST_FILE_MANY = "/content/test/data/android/webshare-many.html";
     private static final String TEST_FILE_LARGE = "/content/test/data/android/webshare-large.html";
+    private static final String TEST_FILE_SEPARATOR =
+            "/content/test/data/android/webshare-separator.html";
     private static final String TEST_LONG_TEXT = "/content/test/data/android/webshare-long.html";
 
     private EmbeddedTestServer mTestServer;
@@ -394,6 +396,22 @@ public class WebShareTest {
         verifyDeliveredCsvIntent(mReceivedIntent);
     }
 
+    /**
+     * Verify WebShare fails if share of file name '/' is called from a user gesture.
+     * @throws Exception
+     */
+    @Test
+    @MediumTest
+    @Feature({"WebShare"})
+    public void testWebShareSeparator() throws Exception {
+        sActivityTestRule.loadUrl(mTestServer.getURL(TEST_FILE_SEPARATOR));
+        // Click (instead of directly calling the JavaScript function) to simulate a user gesture.
+        TouchCommon.singleClickView(mTab.getView());
+        Assert.assertEquals("Fail: NotAllowedError: "
+                        + "Failed to execute 'share' on 'Navigator': Permission denied",
+                mUpdateWaiter.waitForUpdate());
+    }
+
     private static void verifyDeliveredIntent(Intent intent) {
         Assert.assertNotNull(intent);
         Assert.assertEquals(Intent.ACTION_SEND, intent.getAction());
diff --git a/chrome/app/settings_strings.grdp b/chrome/app/settings_strings.grdp
index cf925eb113e4f..dc700997c9992 100644
--- a/chrome/app/settings_strings.grdp
+++ b/chrome/app/settings_strings.grdp
@@ -1538,6 +1538,9 @@
   <message name="IDS_SETTINGS_MANAGE_CERTIFICATES_DESCRIPTION" desc="Secondary, continued explanation of how to manage SSL certificates and settings in Privacy options">
     Manage HTTPS/SSL certificates and settings
   </message>
+  <message name="IDS_SETTINGS_MANAGE" desc="Text displayed on a button, which when clicked opens the Extensions subpage for managing an extension">
+    Manage
+  </message>
   <message name="IDS_SETTINGS_SECURE_DNS" desc="Text for secure DNS toggle in Privacy options">
     Use secure DNS
   </message>
diff --git a/chrome/app/settings_strings_grdp/IDS_SETTINGS_MANAGE.png.sha1 b/chrome/app/settings_strings_grdp/IDS_SETTINGS_MANAGE.png.sha1
new file mode 100644
index 0000000000000..3022f7a01f9d2
--- /dev/null
+++ b/chrome/app/settings_strings_grdp/IDS_SETTINGS_MANAGE.png.sha1
@@ -0,0 +1 @@
+c56284f1ee244e37a4b5e0419aa4cd0e74f56822
\ No newline at end of file
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 054746e8cba22..bb0a50808c016 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3533,6 +3533,8 @@ static_library("browser") {
       "device_api/managed_configuration_api.h",
       "device_api/managed_configuration_api_factory.cc",
       "device_api/managed_configuration_api_factory.h",
+      "device_api/managed_configuration_service.cc",
+      "device_api/managed_configuration_service.h",
       "device_api/managed_configuration_store.cc",
       "device_api/managed_configuration_store.h",
       "device_identity/device_identity_provider.cc",
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index a99bc28830a3e..885c9b01ea8fb 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -60,6 +60,7 @@
 #include "chrome/browser/data_use_measurement/chrome_data_use_measurement.h"
 #include "chrome/browser/defaults.h"
 #include "chrome/browser/device_api/device_service_impl.h"
+#include "chrome/browser/device_api/managed_configuration_service.h"
 #include "chrome/browser/download/chrome_download_manager_delegate.h"
 #include "chrome/browser/download/download_prefs.h"
 #include "chrome/browser/enterprise/connectors/connectors_service.h"
@@ -5141,6 +5142,14 @@ void ChromeContentBrowserClient::CreateDeviceInfoService(
   DeviceServiceImpl::Create(render_frame_host, std::move(receiver));
 }
 
+void ChromeContentBrowserClient::CreateManagedConfigurationService(
+    content::RenderFrameHost* render_frame_host,
+    mojo::PendingReceiver<blink::mojom::ManagedConfigurationService> receiver) {
+  DCHECK(render_frame_host);
+  ManagedConfigurationServiceImpl::Create(render_frame_host,
+                                          std::move(receiver));
+}
+
 content::SerialDelegate* ChromeContentBrowserClient::GetSerialDelegate() {
   if (!serial_delegate_)
     serial_delegate_ = std::make_unique<ChromeSerialDelegate>();
@@ -5478,8 +5487,6 @@ bool ChromeContentBrowserClient::ShouldSandboxAudioService() {
   return IsAudioServiceSandboxEnabled();
 }
 
-
-
 void ChromeContentBrowserClient::LogWebFeatureForCurrentPage(
     content::RenderFrameHost* render_frame_host,
     blink::mojom::WebFeature feature) {
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index f1074fb9d9c06..b8ee3ffc903bc 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -543,6 +543,10 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void CreateDeviceInfoService(
       content::RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::DeviceAPIService> receiver) override;
+  void CreateManagedConfigurationService(
+      content::RenderFrameHost* render_frame_host,
+      mojo::PendingReceiver<blink::mojom::ManagedConfigurationService> receiver)
+      override;
   content::SerialDelegate* GetSerialDelegate() override;
   content::HidDelegate* GetHidDelegate() override;
   content::FontAccessDelegate* GetFontAccessDelegate() override;
diff --git a/chrome/browser/device_api/device_service_impl.cc b/chrome/browser/device_api/device_service_impl.cc
index cb5d7361e078d..cd20f91d9c4e7 100644
--- a/chrome/browser/device_api/device_service_impl.cc
+++ b/chrome/browser/device_api/device_service_impl.cc
@@ -6,7 +6,6 @@
 #include <memory>
 
 #include "chrome/browser/device_api/device_attribute_api.h"
-#include "chrome/browser/device_api/managed_configuration_api_factory.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/web_applications/components/policy/web_app_policy_constants.h"
 #include "chrome/common/chrome_features.h"
@@ -51,12 +50,9 @@ DeviceServiceImpl::DeviceServiceImpl(
       prefs::kWebAppInstallForceList,
       base::BindRepeating(&DeviceServiceImpl::OnForceInstallWebAppListChanged,
                           base::Unretained(this)));
-  managed_configuration_api()->AddObserver(origin(), this);
 }
 
-DeviceServiceImpl::~DeviceServiceImpl() {
-  managed_configuration_api()->RemoveObserver(origin(), this);
-}
+DeviceServiceImpl::~DeviceServiceImpl() = default;
 
 // static
 void DeviceServiceImpl::Create(
@@ -83,37 +79,6 @@ void DeviceServiceImpl::OnForceInstallWebAppListChanged() {
   }
 }
 
-ManagedConfigurationAPI* DeviceServiceImpl::managed_configuration_api() {
-  return ManagedConfigurationAPIFactory::GetForProfile(
-      Profile::FromBrowserContext(host_->GetBrowserContext()));
-}
-
-void DeviceServiceImpl::GetManagedConfiguration(
-    const std::vector<std::string>& keys,
-    GetManagedConfigurationCallback callback) {
-  managed_configuration_api()->GetOriginPolicyConfiguration(
-      origin(), keys,
-      base::BindOnce(
-          [](GetManagedConfigurationCallback callback,
-             std::unique_ptr<base::DictionaryValue> result) {
-            std::vector<std::pair<std::string, std::string>> items;
-            for (const auto& it : result->DictItems())
-              items.emplace_back(it.first, it.second.GetString());
-            std::move(callback).Run(
-                base::flat_map<std::string, std::string>(std::move(items)));
-          },
-          std::move(callback)));
-}
-
-void DeviceServiceImpl::SubscribeToManagedConfiguration(
-    mojo::PendingRemote<blink::mojom::ManagedConfigurationObserver> observer) {
-  configuration_subscription_.Bind(std::move(observer));
-}
-
-void DeviceServiceImpl::OnManagedConfigurationChanged() {
-  configuration_subscription_->OnConfigurationChanged();
-}
-
 void DeviceServiceImpl::GetDirectoryId(GetDirectoryIdCallback callback) {
   device_attribute_api::GetDirectoryId(std::move(callback));
 }
diff --git a/chrome/browser/device_api/device_service_impl.h b/chrome/browser/device_api/device_service_impl.h
index e4e92cba175d1..d3b1715c249bd 100644
--- a/chrome/browser/device_api/device_service_impl.h
+++ b/chrome/browser/device_api/device_service_impl.h
@@ -5,8 +5,6 @@
 #ifndef CHROME_BROWSER_DEVICE_API_DEVICE_SERVICE_IMPL_H_
 #define CHROME_BROWSER_DEVICE_API_DEVICE_SERVICE_IMPL_H_
 
-#include "base/scoped_observer.h"
-#include "chrome/browser/device_api/managed_configuration_api.h"
 #include "components/prefs/pref_change_registrar.h"
 #include "content/public/browser/frame_service_base.h"
 #include "third_party/blink/public/mojom/device/device.mojom.h"
@@ -18,8 +16,7 @@ class RenderFrameHost;
 // A browser-side mojo service, which corresponds to the navigator.managed Web
 // API. Available only to trusted web applications.
 class DeviceServiceImpl final
-    : public content::FrameServiceBase<blink::mojom::DeviceAPIService>,
-      public ManagedConfigurationAPI::Observer {
+    : public content::FrameServiceBase<blink::mojom::DeviceAPIService> {
  public:
   // Tries to attach this mojo service to |host| for trusted web applications.
   // Will dynamically disconnect if the trustness status is revoked.
@@ -32,12 +29,6 @@ class DeviceServiceImpl final
   ~DeviceServiceImpl() override;
 
   // blink::mojom::DeviceAPIService:
-  void GetManagedConfiguration(
-      const std::vector<std::string>& keys,
-      GetManagedConfigurationCallback callback) override;
-  void SubscribeToManagedConfiguration(
-      mojo::PendingRemote<blink::mojom::ManagedConfigurationObserver> observer)
-      override;
   void GetDirectoryId(GetDirectoryIdCallback callback) override;
   void GetHostname(GetHostnameCallback callback) override;
   void GetSerialNumber(GetSerialNumberCallback callback) override;
@@ -51,16 +42,8 @@ class DeviceServiceImpl final
 
   void OnForceInstallWebAppListChanged();
 
-  ManagedConfigurationAPI* managed_configuration_api();
-
-  // ManagedConfigurationAPI::Observer:
-  void OnManagedConfigurationChanged() override;
-
   content::RenderFrameHost* const host_;
   PrefChangeRegistrar pref_change_registrar_;
-
-  mojo::Remote<blink::mojom::ManagedConfigurationObserver>
-      configuration_subscription_;
 };
 
 #endif  // CHROME_BROWSER_DEVICE_API_DEVICE_SERVICE_IMPL_H_
diff --git a/chrome/browser/device_api/managed_configuration_api.cc b/chrome/browser/device_api/managed_configuration_api.cc
index fd93fa66f5fb0..5e6442750a945 100644
--- a/chrome/browser/device_api/managed_configuration_api.cc
+++ b/chrome/browser/device_api/managed_configuration_api.cc
@@ -4,12 +4,16 @@
 
 #include "chrome/browser/device_api/managed_configuration_api.h"
 
+#include <memory>
+#include <tuple>
+
 #include "base/bind.h"
 #include "base/callback.h"
 #include "base/containers/contains.h"
 #include "base/json/json_string_value_serializer.h"
 #include "base/task/post_task.h"
 #include "base/task/thread_pool.h"
+#include "base/values.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/device_api/managed_configuration_store.h"
 #include "chrome/browser/net/system_network_context_manager.h"
@@ -115,9 +119,7 @@ class ManagedConfigurationAPI::ManagedConfigurationDownloader {
 ManagedConfigurationAPI::ManagedConfigurationAPI(Profile* profile)
     : profile_(profile),
       stores_path_(
-          profile->GetPath().AppendASCII(kManagedConfigurationDirectoryName)),
-      backend_task_runner_(base::ThreadPool::CreateSequencedTaskRunner(
-          {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN})) {
+          profile->GetPath().AppendASCII(kManagedConfigurationDirectoryName)) {
   pref_change_registrar_ = std::make_unique<PrefChangeRegistrar>();
   pref_change_registrar_->Init(profile_->GetPrefs());
   pref_change_registrar_->Add(
@@ -142,23 +144,41 @@ void ManagedConfigurationAPI::GetOriginPolicyConfiguration(
     const url::Origin& origin,
     const std::vector<std::string>& keys,
     base::OnceCallback<void(std::unique_ptr<base::DictionaryValue>)> callback) {
-  backend_task_runner_->PostTaskAndReplyWithResult(
-      FROM_HERE,
-      base::BindOnce(&ManagedConfigurationAPI::GetConfigurationOnBackend,
-                     base::Unretained(this), origin, keys),
-      std::move(callback));
+  if (!CanHaveManagedStore(origin)) {
+    return std::move(callback).Run(std::make_unique<base::DictionaryValue>());
+  }
+
+  if (!base::Contains(store_map_, origin))
+    return std::move(callback).Run(nullptr);
+
+  store_map_[origin]
+      .AsyncCall(&ManagedConfigurationStore::Get)
+      .WithArgs(std::move(keys))
+      .Then(std::move(callback));
+}
+
+void ManagedConfigurationAPI::AddObserver(Observer* observer) {
+  url::Origin origin = observer->GetOrigin();
+  if (CanHaveManagedStore(origin)) {
+    MaybeCreateStoreForOrigin(origin);
+    observers_[origin].AddObserver(observer);
+  } else {
+    unmanaged_observers_.insert(observer);
+  }
 }
 
-void ManagedConfigurationAPI::AddObserver(const url::Origin& origin,
-                                          Observer* observer) {
-  // A configuration could potentially appear in the future, therefore create a
-  // store.
-  GetOrLoadStoreForOrigin(origin)->AddObserver(observer);
+void ManagedConfigurationAPI::RemoveObserver(Observer* observer) {
+  auto it = unmanaged_observers_.find(observer);
+  if (it != unmanaged_observers_.end()) {
+    unmanaged_observers_.erase(it);
+    return;
+  }
+
+  observers_[observer->GetOrigin()].RemoveObserver(observer);
 }
 
-void ManagedConfigurationAPI::RemoveObserver(const url::Origin& origin,
-                                             Observer* observer) {
-  GetOrLoadStoreForOrigin(origin)->RemoveObserver(observer);
+bool ManagedConfigurationAPI::CanHaveManagedStore(const url::Origin& origin) {
+  return base::Contains(managed_origins_, origin);
 }
 
 void ManagedConfigurationAPI::OnConfigurationPolicyChanged() {
@@ -193,38 +213,22 @@ void ManagedConfigurationAPI::OnConfigurationPolicyChanged() {
                                 std::string());
     }
   }
+
+  managed_origins_.swap(current_origins);
+  PromoteObservers();
 }
 
-ManagedConfigurationStore* ManagedConfigurationAPI::GetOrLoadStoreForOrigin(
+void ManagedConfigurationAPI::MaybeCreateStoreForOrigin(
     const url::Origin& origin) {
-  auto it = store_map_.find(origin);
-  if (it != store_map_.end())
-    return it->second.get();
+  if (base::Contains(store_map_, origin))
+    return;
+
   // Create the store now, and serve the cached policy until the PolicyService
   // sends updated values.
-  auto store = std::make_unique<ManagedConfigurationStore>(
-      backend_task_runner_, origin, GetStoreLocation(origin));
-  ManagedConfigurationStore* store_ptr = store.get();
-  store_map_[origin] = std::move(store);
-  return store_ptr;
-}
-
-std::unique_ptr<base::DictionaryValue>
-ManagedConfigurationAPI::GetConfigurationOnBackend(
-    const url::Origin& origin,
-    const std::vector<std::string>& keys) {
-  // If there was no policy set for this origin, there is no reason to create
-  // or load a store.
-  if (!base::Contains(store_map_, origin))
-    return nullptr;
-
-  LeveldbValueStore::ReadResult result = store_map_[origin]->Get(keys);
-  if (!result.status().ok())
-    return nullptr;
-
-  auto dict = std::make_unique<base::DictionaryValue>();
-  dict->Swap(&result.settings());
-  return dict;
+  store_map_[origin] = base::SequenceBound<ManagedConfigurationStore>(
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN}),
+      origin, GetStoreLocation(origin));
 }
 
 base::FilePath ManagedConfigurationAPI::GetStoreLocation(
@@ -311,15 +315,35 @@ void ManagedConfigurationAPI::ProcessDecodedConfiguration(
 void ManagedConfigurationAPI::PostStoreConfiguration(
     const url::Origin& origin,
     base::DictionaryValue configuration) {
-  // Safe to use unretained here, since we own the task runner.
-  backend_task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(&ManagedConfigurationAPI::StoreConfigurationOnBackend,
-                     base::Unretained(this), origin, std::move(configuration)));
+  MaybeCreateStoreForOrigin(origin);
+  store_map_[origin]
+      .AsyncCall(&ManagedConfigurationStore::SetCurrentPolicy)
+      .WithArgs(std::move(configuration))
+      .Then(base::BindOnce(
+          &ManagedConfigurationAPI::InformObserversIfConfigurationChanged,
+          weak_ptr_factory_.GetWeakPtr(), origin));
 }
 
-void ManagedConfigurationAPI::StoreConfigurationOnBackend(
+void ManagedConfigurationAPI::InformObserversIfConfigurationChanged(
     const url::Origin& origin,
-    base::DictionaryValue configuration) {
-  GetOrLoadStoreForOrigin(origin)->SetCurrentPolicy(configuration);
+    bool has_changed) {
+  if (!has_changed || !base::Contains(observers_, origin))
+    return;
+
+  for (auto& observer : observers_[origin]) {
+    observer.OnManagedConfigurationChanged();
+  }
+}
+
+void ManagedConfigurationAPI::PromoteObservers() {
+  for (auto it = unmanaged_observers_.begin();
+       it != unmanaged_observers_.end();) {
+    if (CanHaveManagedStore((*it)->GetOrigin())) {
+      auto* observer = *it;
+      it = unmanaged_observers_.erase(it);
+      AddObserver(observer);
+    } else {
+      ++it;
+    }
+  }
 }
diff --git a/chrome/browser/device_api/managed_configuration_api.h b/chrome/browser/device_api/managed_configuration_api.h
index 6e2e171a38f8e..cbea3ba941ecb 100644
--- a/chrome/browser/device_api/managed_configuration_api.h
+++ b/chrome/browser/device_api/managed_configuration_api.h
@@ -7,7 +7,8 @@
 
 #include "base/files/file_path.h"
 #include "base/memory/weak_ptr.h"
-#include "base/observer_list_types.h"
+#include "base/observer_list.h"
+#include "base/threading/sequence_bound.h"
 #include "base/values.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/prefs/pref_change_registrar.h"
@@ -29,6 +30,7 @@ class ManagedConfigurationAPI : public KeyedService {
   class Observer : public base::CheckedObserver {
    public:
     virtual void OnManagedConfigurationChanged() = 0;
+    virtual const url::Origin& GetOrigin() = 0;
   };
 
   static const char kOriginKey[];
@@ -48,8 +50,12 @@ class ManagedConfigurationAPI : public KeyedService {
       base::OnceCallback<void(std::unique_ptr<base::DictionaryValue>)>
           callback);
 
-  void AddObserver(const url::Origin& origin, Observer* observer);
-  void RemoveObserver(const url::Origin& origin, Observer* observer);
+  void AddObserver(Observer* observer);
+  void RemoveObserver(Observer* observer);
+
+  // Whether this application can have managed configuration set. essentially,
+  // this checks whether the application is managed.
+  bool CanHaveManagedStore(const url::Origin& origin);
 
  private:
   class ManagedConfigurationDownloader;
@@ -74,26 +80,34 @@ class ManagedConfigurationAPI : public KeyedService {
   // Sends an operation to set the configured value on FILE thread.
   void PostStoreConfiguration(const url::Origin& origin,
                               base::DictionaryValue configuration);
+  void InformObserversIfConfigurationChanged(const url::Origin& origin,
+                                             bool changed);
 
-  std::unique_ptr<base::DictionaryValue> GetConfigurationOnBackend(
-      const url::Origin& origin,
-      const std::vector<std::string>& keys);
-  void StoreConfigurationOnBackend(const url::Origin& origin,
-                                   base::DictionaryValue configuration);
-
-  ManagedConfigurationStore* GetOrLoadStoreForOrigin(const url::Origin& origin);
+  void MaybeCreateStoreForOrigin(const url::Origin& origin);
   base::FilePath GetStoreLocation(const url::Origin& origin);
 
+  // Assigns observers from |unmanaged_observers_| to a particular store if
+  // their origin has a configuration. There is no need to unassign those
+  // observers when the origin becomes unmanaged, since the managed data is
+  // cleared in the ManagedConfigurationStore, without destroying the actual
+  // store object.
+  void PromoteObservers();
+
   Profile* const profile_;
 
   const base::FilePath stores_path_;
-  std::map<url::Origin, std::unique_ptr<ManagedConfigurationStore>> store_map_;
+  std::map<url::Origin, base::SequenceBound<ManagedConfigurationStore>>
+      store_map_;
   // Stores current configuration downloading managers.
   std::map<url::Origin, std::unique_ptr<ManagedConfigurationDownloader>>
       downloaders_;
+  std::map<url::Origin, base::ObserverList<Observer>> observers_;
+
+  // Stores the list of orrigins which have a managed configuration(may not yet
+  // loaded).
+  std::set<url::Origin> managed_origins_;
 
-  // Blocking task runner for IO related tasks.
-  scoped_refptr<base::SequencedTaskRunner> backend_task_runner_;
+  std::set<Observer*> unmanaged_observers_;
 
   // Observes changes to WebAppInstallForceList.
   std::unique_ptr<PrefChangeRegistrar> pref_change_registrar_;
diff --git a/chrome/browser/device_api/managed_configuration_api_browsertest.cc b/chrome/browser/device_api/managed_configuration_api_browsertest.cc
index 09f52d302514f..f9b489b2ae3ba 100644
--- a/chrome/browser/device_api/managed_configuration_api_browsertest.cc
+++ b/chrome/browser/device_api/managed_configuration_api_browsertest.cc
@@ -7,6 +7,7 @@
 #include "chrome/browser/device_api/managed_configuration_api_factory.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser.h"
+#include "chrome/browser/web_applications/components/policy/web_app_policy_constants.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "components/prefs/pref_service.h"
@@ -78,6 +79,7 @@ bool DictValueEquals(std::unique_ptr<base::DictionaryValue> value,
       return false;
     actual.insert({entry.first, entry.second.GetString()});
   }
+
   return actual == expected;
 }
 
@@ -89,11 +91,11 @@ class ManagedConfigurationAPITest : public InProcessBrowserTest,
   void SetUpOnMainThread() override {
     InProcessBrowserTest::SetUpOnMainThread();
     origin_ = url::Origin::Create(GURL(kOrigin));
-    api()->AddObserver(origin_, this);
+    api()->AddObserver(this);
   }
 
   void TearDownOnMainThread() override {
-    api()->RemoveObserver(origin_, this);
+    api()->RemoveObserver(this);
     InProcessBrowserTest::TearDownOnMainThread();
   }
 
@@ -132,17 +134,23 @@ class ManagedConfigurationAPITest : public InProcessBrowserTest,
 
   std::unique_ptr<base::DictionaryValue> GetValues(
       const std::vector<std::string>& keys) {
+    updated_ = false;
     api()->GetOriginPolicyConfiguration(
         origin_, keys,
         base::BindOnce(&ManagedConfigurationAPITest::OnResultObtained,
                        base::Unretained(this)));
 
-    loop_get_ = std::make_unique<base::RunLoop>();
-    loop_get_->Run();
+    // We could receive a failure asynchrounously.
+    if (!updated_) {
+      loop_get_ = std::make_unique<base::RunLoop>();
+      loop_get_->Run();
+      updated_ = false;
+    }
     return std::move(result_);
   }
 
   void OnResultObtained(std::unique_ptr<base::DictionaryValue> result) {
+    updated_ = true;
     result_ = std::move(result);
     loop_get_->Quit();
   }
@@ -156,12 +164,14 @@ class ManagedConfigurationAPITest : public InProcessBrowserTest,
     }
   }
 
+  const url::Origin& GetOrigin() override { return origin(); }
+
   ManagedConfigurationAPI* api() {
     return ManagedConfigurationAPIFactory::GetForProfile(profile());
   }
 
   Profile* profile() { return browser()->profile(); }
-  url::Origin origin() { return origin_; }
+  const url::Origin& origin() { return origin_; }
 
  private:
   url::Origin origin_;
diff --git a/chrome/browser/device_api/managed_configuration_service.cc b/chrome/browser/device_api/managed_configuration_service.cc
new file mode 100644
index 0000000000000..9101cd1996bca
--- /dev/null
+++ b/chrome/browser/device_api/managed_configuration_service.cc
@@ -0,0 +1,71 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/device_api/managed_configuration_service.h"
+
+#include "chrome/browser/device_api/managed_configuration_api_factory.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_thread.h"
+
+// static
+void ManagedConfigurationServiceImpl::Create(
+    content::RenderFrameHost* host,
+    mojo::PendingReceiver<blink::mojom::ManagedConfigurationService> receiver) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // The object is bound to the lifetime of |host| and the mojo
+  // connection. See FrameServiceBase for details.
+  new ManagedConfigurationServiceImpl(host, std::move(receiver));
+}
+
+ManagedConfigurationServiceImpl::ManagedConfigurationServiceImpl(
+    content::RenderFrameHost* host,
+    mojo::PendingReceiver<blink::mojom::ManagedConfigurationService> receiver)
+    : FrameServiceBase(host, std::move(receiver)), host_(host) {
+  managed_configuration_api()->AddObserver(this);
+}
+
+ManagedConfigurationServiceImpl::~ManagedConfigurationServiceImpl() {
+  managed_configuration_api()->RemoveObserver(this);
+}
+
+void ManagedConfigurationServiceImpl::GetManagedConfiguration(
+    const std::vector<std::string>& keys,
+    GetManagedConfigurationCallback callback) {
+  managed_configuration_api()->GetOriginPolicyConfiguration(
+      origin(), keys,
+      base::BindOnce(
+          [](GetManagedConfigurationCallback callback,
+             std::unique_ptr<base::DictionaryValue> result) {
+            if (!result) {
+              return std::move(callback).Run(
+                  base::flat_map<std::string, std::string>());
+            }
+            std::vector<std::pair<std::string, std::string>> items;
+            for (const auto& it : result->DictItems())
+              items.emplace_back(it.first, it.second.GetString());
+            std::move(callback).Run(
+                base::flat_map<std::string, std::string>(std::move(items)));
+          },
+          std::move(callback)));
+}
+
+void ManagedConfigurationServiceImpl::SubscribeToManagedConfiguration(
+    mojo::PendingRemote<blink::mojom::ManagedConfigurationObserver> observer) {
+  configuration_subscription_.Bind(std::move(observer));
+}
+
+void ManagedConfigurationServiceImpl::OnManagedConfigurationChanged() {
+  configuration_subscription_->OnConfigurationChanged();
+}
+
+ManagedConfigurationAPI*
+ManagedConfigurationServiceImpl::managed_configuration_api() {
+  return ManagedConfigurationAPIFactory::GetForProfile(
+      Profile::FromBrowserContext(host_->GetBrowserContext()));
+}
+
+const url::Origin& ManagedConfigurationServiceImpl::GetOrigin() {
+  return origin();
+}
diff --git a/chrome/browser/device_api/managed_configuration_service.h b/chrome/browser/device_api/managed_configuration_service.h
new file mode 100644
index 0000000000000..aeb587865f602
--- /dev/null
+++ b/chrome/browser/device_api/managed_configuration_service.h
@@ -0,0 +1,53 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_DEVICE_API_MANAGED_CONFIGURATION_SERVICE_H_
+#define CHROME_BROWSER_DEVICE_API_MANAGED_CONFIGURATION_SERVICE_H_
+
+#include "chrome/browser/device_api/managed_configuration_api.h"
+#include "content/public/browser/frame_service_base.h"
+#include "third_party/blink/public/mojom/device/device.mojom.h"
+
+class ManagedConfigurationServiceImpl
+    : public content::FrameServiceBase<
+          blink::mojom::ManagedConfigurationService>,
+      public ManagedConfigurationAPI::Observer {
+ public:
+  static void Create(
+      content::RenderFrameHost* host,
+      mojo::PendingReceiver<blink::mojom::ManagedConfigurationService>
+          receiver);
+
+  ManagedConfigurationServiceImpl(const ManagedConfigurationServiceImpl&) =
+      delete;
+  ManagedConfigurationServiceImpl& operator=(
+      const ManagedConfigurationServiceImpl&) = delete;
+  ~ManagedConfigurationServiceImpl() override;
+
+ private:
+  ManagedConfigurationServiceImpl(
+      content::RenderFrameHost* host,
+      mojo::PendingReceiver<blink::mojom::ManagedConfigurationService>
+          receiver);
+  // blink::mojom::DeviceApiService:
+  void GetManagedConfiguration(
+      const std::vector<std::string>& keys,
+      GetManagedConfigurationCallback callback) override;
+  void SubscribeToManagedConfiguration(
+      mojo::PendingRemote<blink::mojom::ManagedConfigurationObserver> observer)
+      override;
+
+  ManagedConfigurationAPI* managed_configuration_api();
+
+  // ManagedConfigurationAPI::Observer:
+  void OnManagedConfigurationChanged() override;
+  const url::Origin& GetOrigin() override;
+
+  content::RenderFrameHost* const host_;
+
+  mojo::Remote<blink::mojom::ManagedConfigurationObserver>
+      configuration_subscription_;
+};
+
+#endif  // CHROME_BROWSER_DEVICE_API_MANAGED_CONFIGURATION_SERVICE_H_
diff --git a/chrome/browser/device_api/managed_configuration_store.cc b/chrome/browser/device_api/managed_configuration_store.cc
index cf01c0dd7f3c9..fdd0e618e08f7 100644
--- a/chrome/browser/device_api/managed_configuration_store.cc
+++ b/chrome/browser/device_api/managed_configuration_store.cc
@@ -4,44 +4,24 @@
 
 #include "chrome/browser/device_api/managed_configuration_store.h"
 
-ManagedConfigurationStore::ManagedConfigurationStore(
-    scoped_refptr<base::SequencedTaskRunner> backend_sequence,
-    const url::Origin& origin,
-    const base::FilePath& path)
-    : backend_sequence_(backend_sequence),
-      origin_(origin),
-      path_(path),
-      observers_(new base::ObserverListThreadSafe<
-                 ManagedConfigurationAPI::Observer>()) {}
+#include "base/logging.h"
 
-void ManagedConfigurationStore::InitializeOnBackend() {
+ManagedConfigurationStore::ManagedConfigurationStore(const url::Origin& origin,
+                                                     const base::FilePath& path)
+    : origin_(origin), path_(path) {}
+
+ManagedConfigurationStore::~ManagedConfigurationStore() = default;
+
+void ManagedConfigurationStore::Initialize() {
   // LeveldbValueStore can only be initialized on a blocking sequnece.
-  DCHECK(backend_sequence_->RunsTasksInCurrentSequence());
   store_ =
       std::make_unique<LeveldbValueStore>("OriginManagedConfiguration", path_);
 }
 
-ManagedConfigurationStore::~ManagedConfigurationStore() {
-  // Delete ValueStore on the FILE thread, since it can only operate on that
-  // thread.
-  backend_sequence_->DeleteSoon(FROM_HERE, std::move(store_));
-}
-
-void ManagedConfigurationStore::AddObserver(
-    ManagedConfigurationAPI::Observer* observer) {
-  observers_->AddObserver(observer);
-}
-
-void ManagedConfigurationStore::RemoveObserver(
-    ManagedConfigurationAPI::Observer* observer) {
-  observers_->RemoveObserver(observer);
-}
-
-void ManagedConfigurationStore::SetCurrentPolicy(
+bool ManagedConfigurationStore::SetCurrentPolicy(
     const base::DictionaryValue& current_configuration) {
-  DCHECK(backend_sequence_->RunsTasksInCurrentSequence());
   if (!store_)
-    InitializeOnBackend();
+    Initialize();
   // Get the previous policies stored in the database.
   base::DictionaryValue previous_policy;
   ValueStore::ReadResult read_result = store_->Get();
@@ -77,17 +57,18 @@ void ManagedConfigurationStore::SetCurrentPolicy(
     store_updated |= !result.changes().empty();
   }
 
-  if (!store_updated)
-    return;
-  observers_->Notify(
-      FROM_HERE,
-      &ManagedConfigurationAPI::Observer::OnManagedConfigurationChanged);
+  return store_updated;
 }
 
-ValueStore::ReadResult ManagedConfigurationStore::Get(
+std::unique_ptr<base::DictionaryValue> ManagedConfigurationStore::Get(
     const std::vector<std::string>& keys) {
-  DCHECK(backend_sequence_->RunsTasksInCurrentSequence());
   if (!store_)
-    InitializeOnBackend();
-  return store_->Get(keys);
+    Initialize();
+
+  auto result = store_->Get(keys);
+
+  if (!result.status().ok())
+    return nullptr;
+
+  return result.PassSettings();
 }
diff --git a/chrome/browser/device_api/managed_configuration_store.h b/chrome/browser/device_api/managed_configuration_store.h
index 17626b81f5acc..e90ac3def90b5 100644
--- a/chrome/browser/device_api/managed_configuration_store.h
+++ b/chrome/browser/device_api/managed_configuration_store.h
@@ -6,47 +6,35 @@
 #define CHROME_BROWSER_DEVICE_API_MANAGED_CONFIGURATION_STORE_H_
 
 #include "base/files/file_path.h"
-#include "base/observer_list_threadsafe.h"
-#include "chrome/browser/device_api/managed_configuration_api.h"
+#include "base/values.h"
 #include "extensions/browser/value_store/leveldb_value_store.h"
 #include "url/origin.h"
 
-namespace base {
-class SequencedTaskRunner;
-}
-
-// Class responsible for internal storage of the managed configuration. Adding
-// and removing observers is allowed on any thread, while setting/getting the
-// data is only allowed on the FILE thread.
+// Class responsible for internal storage of the managed configuration.
+// Setting/getting the data is a blocking operation and need to be run on a
+// thread that supports this.
 //
 // By itself, this class can be percieved as a handle to access levelDB database
 // stored at |path|.
 class ManagedConfigurationStore {
  public:
-  ManagedConfigurationStore(
-      scoped_refptr<base::SequencedTaskRunner> backend_sequence,
-      const url::Origin& origin,
-      const base::FilePath& path);
+  ManagedConfigurationStore(const url::Origin& origin,
+                            const base::FilePath& path);
   ~ManagedConfigurationStore();
 
-  // Initializes connection to the database. Must be called on
-  // |backend_sequence_|.
-  void InitializeOnBackend();
-
-  void AddObserver(ManagedConfigurationAPI::Observer* observer);
-  void RemoveObserver(ManagedConfigurationAPI::Observer* observer);
-
-  // Read/Write operations must be called on |backend_sequence_|.
-  void SetCurrentPolicy(const base::DictionaryValue& current_configuration);
-  ValueStore::ReadResult Get(const std::vector<std::string>& keys);
+  // Returns |true| if the new policy is different from the previously set
+  // policy.
+  bool SetCurrentPolicy(const base::DictionaryValue& current_configuration);
+  std::unique_ptr<base::DictionaryValue> Get(
+      const std::vector<std::string>& keys);
 
  private:
-  scoped_refptr<base::SequencedTaskRunner> backend_sequence_;
+  // Initializes connection to the database.
+  void Initialize();
+
   const url::Origin origin_;
   const base::FilePath path_;
   std::unique_ptr<ValueStore> store_;
-  scoped_refptr<base::ObserverListThreadSafe<ManagedConfigurationAPI::Observer>>
-      observers_;
 };
 
 #endif  // CHROME_BROWSER_DEVICE_API_MANAGED_CONFIGURATION_STORE_H_
diff --git a/chrome/browser/extensions/api/debugger/debugger_api.cc b/chrome/browser/extensions/api/debugger/debugger_api.cc
index 56e2a22db5ec6..c4b0efff6466d 100644
--- a/chrome/browser/extensions/api/debugger/debugger_api.cc
+++ b/chrome/browser/extensions/api/debugger/debugger_api.cc
@@ -40,6 +40,7 @@
 #include "components/security_interstitials/content/security_interstitial_tab_helper.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/devtools_agent_host.h"
+#include "content/public/browser/navigation_entry.h"
 #include "content/public/browser/notification_service.h"
 #include "content/public/browser/notification_source.h"
 #include "content/public/browser/render_process_host.h"
@@ -142,6 +143,12 @@ bool ExtensionMayAttachToWebContents(const Extension& extension,
                                profile, error)) {
     return false;
   }
+  if (web_contents.GetController().GetPendingEntry() &&
+      !ExtensionMayAttachToURL(
+          extension, web_contents.GetController().GetPendingEntry()->GetURL(),
+          profile, error)) {
+    return false;
+  }
 
   for (content::RenderFrameHost* rfh : web_contents.GetAllFrames()) {
     if (!ExtensionMayAttachToURL(extension, rfh->GetLastCommittedURL(), profile,
diff --git a/chrome/browser/extensions/api/sessions/sessions_api.cc b/chrome/browser/extensions/api/sessions/sessions_api.cc
index fa30a4353f0bf..2bee69bd73c24 100644
--- a/chrome/browser/extensions/api/sessions/sessions_api.cc
+++ b/chrome/browser/extensions/api/sessions/sessions_api.cc
@@ -17,6 +17,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "chrome/browser/extensions/api/sessions/session_id.h"
+#include "chrome/browser/extensions/api/tabs/tabs_constants.h"
 #include "chrome/browser/extensions/api/tabs/windows_util.h"
 #include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/extensions/window_controller.h"
@@ -568,6 +569,9 @@ ExtensionFunction::ResponseAction SessionsRestoreFunction::Run() {
   if (profile != profile->GetOriginalProfile())
     return RespondNow(Error(kRestoreInIncognitoError));
 
+  if (!ExtensionTabUtil::IsTabStripEditable())
+    return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
+    
   if (!params->session_id)
     return RespondNow(RestoreMostRecentlyClosed(browser));
 
diff --git a/chrome/browser/extensions/api/sessions/sessions_apitest.cc b/chrome/browser/extensions/api/sessions/sessions_apitest.cc
index d2ec2c89533ca..428150a6f236e 100644
--- a/chrome/browser/extensions/api/sessions/sessions_apitest.cc
+++ b/chrome/browser/extensions/api/sessions/sessions_apitest.cc
@@ -20,6 +20,7 @@
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/extensions/api/sessions/sessions_api.h"
 #include "chrome/browser/extensions/api/tabs/tabs_api.h"
+#include "chrome/browser/extensions/api/tabs/tabs_constants.h"
 #include "chrome/browser/extensions/extension_apitest.h"
 #include "chrome/browser/extensions/extension_function_test_utils.h"
 #include "chrome/browser/profiles/profile_manager.h"
@@ -27,6 +28,7 @@
 #include "chrome/common/chrome_paths.h"
 #include "chrome/common/chrome_switches.h"
 #include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/test_browser_window.h"
 #include "chrome/test/base/testing_browser_process.h"
 #include "components/sync/base/client_tag_hash.h"
 #include "components/sync/engine/data_type_activation_response.h"
@@ -347,6 +349,27 @@ IN_PROC_BROWSER_TEST_F(ExtensionSessionsTest, RestoreInIncognito) {
       "Can not restore sessions in incognito mode."));
 }
 
+IN_PROC_BROWSER_TEST_F(ExtensionSessionsTest, RestoreNonEditableTabstrip) {
+  CreateSessionModels();
+
+  // Set up a browser with a non-editable tabstrip, simulating one in the midst
+  // of a tab dragging session.
+  std::unique_ptr<TestBrowserWindow> browser_window =
+      std::make_unique<TestBrowserWindow>();
+  Browser::CreateParams params(browser()->profile(), true);
+  params.type = Browser::TYPE_NORMAL;
+  params.window = browser_window.get();
+  std::unique_ptr<Browser> browser =
+      std::unique_ptr<Browser>(Browser::Create(params));
+  browser_window->SetIsTabStripEditable(false);
+
+  EXPECT_TRUE(base::MatchPattern(
+      utils::RunFunctionAndReturnError(
+          CreateFunction<SessionsRestoreFunction>(true).get(), "[\"1\"]",
+          browser.get()),
+      tabs_constants::kTabStripNotEditableError));
+}
+
 IN_PROC_BROWSER_TEST_F(ExtensionSessionsTest, GetRecentlyClosedIncognito) {
   std::unique_ptr<base::ListValue> result(
       utils::ToList(utils::RunFunctionAndReturnSingleResult(
diff --git a/chrome/browser/extensions/api/tabs/tabs_api.cc b/chrome/browser/extensions/api/tabs/tabs_api.cc
index 525fbfe336424..d609279c7f1f1 100644
--- a/chrome/browser/extensions/api/tabs/tabs_api.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_api.cc
@@ -15,6 +15,7 @@
 #include "base/bind.h"
 #include "base/check_op.h"
 #include "base/command_line.h"
+#include "base/containers/contains.h"
 #include "base/location.h"
 #include "base/memory/ref_counted_memory.h"
 #include "base/memory/scoped_refptr.h"
@@ -711,10 +712,30 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
   }
   chrome::SelectNumberedTab(new_window, 0, {TabStripModel::GestureType::kNone});
 
-  if (focused)
+  if (focused) {
     new_window->window()->Show();
-  else
+  } else {
+    // The new window isn't supposed to be focused. Here, instead of showing an
+    // unfocused window on top (possible on some operating systems), we show
+    // the window and then bring the old focused window back on top.
+    // We still use ShowInactive() (instead of doing a Show() followed
+    // immediately by Deactivate()) because the process of showing the window is
+    // somewhat asynchronous. This causes the immediate Deactivate() call to not
+    // work.
+    BrowserList* const browser_list = BrowserList::GetInstance();
+    Browser* active_browser = browser_list->GetLastActive();
+    bool reset_active = false;
+    // Check if there's a currently-active window that should re-take focus.
+    // NOTE: This browser *may* be from another profile. We don't access any
+    // data from it.
+    if (active_browser && active_browser->window()->IsActive())
+      reset_active = true;
     new_window->window()->ShowInactive();
+    // NOTE: It's possible that showing the new browser synchronously caused
+    // the old one to close. Ensure it's still valid before activating it.
+    if (reset_active && base::Contains(*browser_list, active_browser))
+      active_browser->window()->Activate();
+  }
 
   // Lock the window fullscreen only after the new tab has been created
   // (otherwise the tabstrip is empty), and window()->show() has been called
diff --git a/chrome/browser/extensions/api/tabs/tabs_interactive_test.cc b/chrome/browser/extensions/api/tabs/tabs_interactive_test.cc
index 4d817eacf174b..a43f4a7bb635c 100644
--- a/chrome/browser/extensions/api/tabs/tabs_interactive_test.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_interactive_test.cc
@@ -4,6 +4,7 @@
 
 #include <stddef.h>
 
+#include "base/strings/stringprintf.h"
 #include "base/values.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -13,11 +14,20 @@
 #include "chrome/browser/extensions/extension_function_test_utils.h"
 #include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_list.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/interactive_test_utils.h"
+#include "chrome/test/base/ui_test_utils.h"
 #include "content/public/test/browser_test.h"
 #include "extensions/browser/api_test_utils.h"
 #include "extensions/common/extension_builder.h"
+#include "extensions/test/result_catcher.h"
+#include "extensions/test/test_extension_dir.h"
+#include "ui/views/test/widget_test.h"
+
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#include "ui/ozone/buildflags.h"
+#endif
 
 namespace extensions {
 
@@ -166,4 +176,112 @@ INSTANTIATE_TEST_SUITE_P(ServiceWorker,
                          NonPersistentExtensionTabsTest,
                          ::testing::Values(ContextType::kServiceWorker));
 
+using TabsApiInteractiveTest = ExtensionApiTest;
+
+// Tests that a window created with `focused: false` does not cover the focused
+// window. Regression test for https://crbug.com/1302159.
+IN_PROC_BROWSER_TEST_F(TabsApiInteractiveTest,
+                       OpeningAnUnfocusedWindowDoesntCoverTheFocusedWindow) {
+  ASSERT_TRUE(StartEmbeddedTestServer());
+
+  const GURL url1 = embedded_test_server()->GetURL("/title1.html");
+  const GURL url2 = embedded_test_server()->GetURL("/title2.html");
+
+  // Navigate to `url1` and ensure the browser is active.
+  {
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), url1));
+    ui_test_utils::BrowserActivationWaiter activation_waiter(browser());
+    browser()->window()->Activate();
+    activation_waiter.WaitForActivation();
+  }
+  ASSERT_TRUE(browser()->window()->IsActive());
+
+  // Create and load an extension that creates a new window with a tab at
+  // `url2` with `focused: false` and waits for the tab to complete loading.
+  static constexpr char kManifest[] =
+      R"({
+           "name": "Interactive Test",
+           "manifest_version": 3,
+           "version": "0.1",
+           "background": { "service_worker": "background.js" },
+           "permissions": ["tabs"]
+         })";
+  static constexpr char kBackgroundJs[] =
+      R"(chrome.test.runTests([
+           async function openUnfocusedWindow() {
+             const url = '%s';
+             const tabCreatedPromise = new Promise((resolve) => {
+               chrome.tabs.onUpdated.addListener(
+                   function listener(tabId, changeInfo, tab) {
+                     if (changeInfo.status === 'complete' &&
+                         tab.url === url) {
+                       chrome.tabs.onUpdated.removeListener(listener);
+                       resolve();
+                     }
+                   });
+             });
+             const win =
+                 await chrome.windows.create({focused: false, url: url});
+             chrome.test.assertFalse(win.focused);
+             await tabCreatedPromise;
+             chrome.test.succeed();
+           },
+         ]);)";
+
+  TestExtensionDir test_dir;
+  test_dir.WriteManifest(kManifest);
+  test_dir.WriteFile(FILE_PATH_LITERAL("background.js"),
+                     base::StringPrintf(kBackgroundJs, url2.spec().c_str()));
+
+  ResultCatcher result_catcher;
+  const Extension* extension = LoadExtension(test_dir.UnpackedPath());
+  ASSERT_TRUE(extension);
+  ASSERT_TRUE(result_catcher.GetNextResult()) << result_catcher.message();
+
+  // Now, verify the browsers. There should be exactly two browser windows (the
+  // original and the one created by the extension).
+  BrowserList* browser_list = BrowserList::GetInstance();
+  ASSERT_EQ(2u, browser_list->size());
+  ASSERT_TRUE(base::Contains(*browser_list, browser()));
+  // Find the new browser. Be flexible in case BrowserList's internal sort
+  // changes.
+  Browser* new_browser = browser_list->get(0) == browser()
+                             ? browser_list->get(1)
+                             : browser_list->get(0);
+  EXPECT_NE(new_browser, browser());
+
+  // The new browser should have a tab pointed to `url2`; we use this mostly as
+  // validation that setup went according to plan.
+  EXPECT_EQ(1, new_browser->tab_strip_model()->count());
+  EXPECT_EQ(url2, new_browser->tab_strip_model()
+                      ->GetActiveWebContents()
+                      ->GetLastCommittedURL());
+
+  bool check_window_active_state = true;
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(OZONE_PLATFORM_WAYLAND)
+  check_window_active_state = false;
+#endif
+#endif
+
+  // The new browser should be inactive, since it was created with
+  // `focused: false`. The old browser should remain active.
+  // This assertion fails on Wayland. This is possibly due to
+  // https://crbug.com/1280332, where bubbles are drawn on the same window,
+  // but that is yet to be confirmed.
+  if (check_window_active_state) {
+    EXPECT_FALSE(new_browser->window()->IsActive());
+    EXPECT_TRUE(browser()->window()->IsActive());
+  }
+
+  // The old browser (which retains focus) should be on top of the new browser.
+  // This currently fails because WidgetTest::IsWindowStackedAbove() doesn't
+  // work for different BrowserViews. While the functionality is currently
+  // correct, this means we don't have a good regression test for it.
+  // TODO(https://crbug.com/1302159): Fix this.
+  // EXPECT_TRUE(views::test::WidgetTest::IsWindowStackedAbove(
+  //     BrowserView::GetBrowserViewForBrowser(browser())->frame(),
+  //     BrowserView::GetBrowserViewForBrowser(new_browser)->frame()));
+}
+
 }  // namespace extensions
diff --git a/chrome/browser/extensions/extension_tab_util.cc b/chrome/browser/extensions/extension_tab_util.cc
index 3622b811fa78e..35e9eef02cfa3 100644
--- a/chrome/browser/extensions/extension_tab_util.cc
+++ b/chrome/browser/extensions/extension_tab_util.cc
@@ -971,4 +971,12 @@ api::tabs::TabStatus ExtensionTabUtil::GetLoadingStatus(WebContents* contents) {
   return api::tabs::TAB_STATUS_COMPLETE;
 }
 
+// static
+bool ExtensionTabUtil::IsTabStripEditable() {
+  for (auto* browser : *BrowserList::GetInstance())
+    if (browser && !browser->window()->IsTabStripEditable())
+      return false;
+  return true;
+}
+
 }  // namespace extensions
diff --git a/chrome/browser/extensions/extension_tab_util.h b/chrome/browser/extensions/extension_tab_util.h
index d2a8faaa0c473..6a74550721e50 100644
--- a/chrome/browser/extensions/extension_tab_util.h
+++ b/chrome/browser/extensions/extension_tab_util.h
@@ -253,6 +253,11 @@ class ExtensionTabUtil {
   // some non-const member functions of |contents|, but actually leaves it
   // unmodified.
   static api::tabs::TabStatus GetLoadingStatus(content::WebContents* contents);
+
+  // Check TabStripModel editability in every browser because a drag session
+  // could be running in another browser that reverts to the current browser. Or
+  // a drag could be mid-handoff if from one browser to another.
+  static bool IsTabStripEditable();
 };
 
 }  // namespace extensions
diff --git a/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.cc b/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.cc
index 3fd4d8f6f00e5..70c0c7c6792bd 100644
--- a/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.cc
+++ b/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.cc
@@ -21,6 +21,7 @@
 #include "chrome/browser/offline_pages/android/offline_page_bridge.h"
 #include "components/offline_pages/core/archive_manager.h"
 #include "components/offline_pages/core/model/offline_page_model_utils.h"
+#include "components/offline_pages/core/offline_page_archive_publisher.h"
 #include "components/offline_pages/core/offline_store_utils.h"
 
 namespace offline_pages {
@@ -203,4 +204,9 @@ int OfflinePageArchivePublisherImpl::Delegate::Remove(
   return Java_OfflinePageArchivePublisherBridge_remove(env, j_ids);
 }
 
+base::WeakPtr<OfflinePageArchivePublisher>
+OfflinePageArchivePublisherImpl::GetWeakPtr() {
+  return weak_ptr_factory_.GetWeakPtr();
+}
+
 }  // namespace offline_pages
diff --git a/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.h b/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.h
index 0740e4fe5e43b..2d914026253fe 100644
--- a/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.h
+++ b/chrome/browser/offline_pages/android/offline_page_archive_publisher_impl.h
@@ -8,11 +8,9 @@
 #include <cstdint>
 #include <string>
 
-#include "base/callback.h"
 #include "base/files/file_path.h"
 #include "components/offline_pages/core/offline_page_archive_publisher.h"
 #include "components/offline_pages/core/offline_page_item.h"
-#include "components/offline_pages/core/offline_page_types.h"
 
 namespace base {
 class SequencedTaskRunner;
@@ -58,9 +56,12 @@ class OfflinePageArchivePublisherImpl : public OfflinePageArchivePublisher {
   void UnpublishArchives(
       const std::vector<PublishedArchiveId>& publish_ids) const override;
 
+  base::WeakPtr<OfflinePageArchivePublisher> GetWeakPtr() override;
+
  private:
   ArchiveManager* archive_manager_;
   Delegate* delegate_;
+  base::WeakPtrFactory<OfflinePageArchivePublisher> weak_ptr_factory_{this};
 };
 
 }  // namespace offline_pages
diff --git a/chrome/browser/resources/settings/controls/extension_controlled_indicator.html b/chrome/browser/resources/settings/controls/extension_controlled_indicator.html
index 9dc58b49e097c..347a28e666d2b 100644
--- a/chrome/browser/resources/settings/controls/extension_controlled_indicator.html
+++ b/chrome/browser/resources/settings/controls/extension_controlled_indicator.html
@@ -11,6 +11,18 @@
     margin-inline-end: 16px;
   }
 
+  iron-icon[icon='cr:open-in-new'] {
+    fill: var(--text-color);
+    height: var(--cr-icon-size);
+    margin-inline-end: -10px;
+    margin-inline-start: 6px;
+    width: var(--cr-icon-size);
+  }
+
+  #disable {
+    margin-inline-start: 8px;
+  }
+
   /* Using ">" operator to ensure that this CSS rule will not accidentally
    * be applied to a search highlight span (which is inserted dynamically if
    * when search "hit" occurs within this element. */
@@ -20,7 +32,11 @@
   }
 </style>
 <img role="presentation" src="chrome://extension-icon/[[extensionId]]/20/1">
-<span inner-h-t-m-l="[[getLabel_(extensionId, extensionName)]]"></span>
+<span>[[getLabel_(extensionName)]]</span>
+<cr-button id="manage" on-click="onManageClick_">
+  $i18n{manage}
+  <iron-icon icon="cr:open-in-new"></iron-icon>
+</cr-button>
 <template is="dom-if" if="[[extensionCanBeDisabled]]" restamp>
-  <cr-button on-click="onDisableTap_">$i18n{disable}</cr-button>
+  <cr-button id="disable" on-click="onDisableClick_">$i18n{disable}</cr-button>
 </template>
diff --git a/chrome/browser/ui/tabs/tab_group_model.cc b/chrome/browser/ui/tabs/tab_group_model.cc
index cced26d1c6bf0..13199ec9ccc0f 100644
--- a/chrome/browser/ui/tabs/tab_group_model.cc
+++ b/chrome/browser/ui/tabs/tab_group_model.cc
@@ -24,6 +24,11 @@ TabGroupModel::~TabGroupModel() {}
 TabGroup* TabGroupModel::AddTabGroup(
     const tab_groups::TabGroupId& id,
     base::Optional<tab_groups::TabGroupVisualData> visual_data) {
+  // The tab group must not already exist - replacing the old group without
+  // first removing it would invalidate pointers to the old group and could
+  // easily UAF.
+  CHECK(!ContainsTabGroup(id));
+
   auto tab_group = std::make_unique<TabGroup>(
       controller_, id,
       visual_data.value_or(
diff --git a/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.cc b/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.cc
index 79c9ee5597641..e5833968c1bc1 100644
--- a/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.cc
+++ b/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.cc
@@ -18,7 +18,8 @@ CloseBubbleOnTabActivationHelper::CloseBubbleOnTabActivationHelper(
 }
 
 CloseBubbleOnTabActivationHelper::~CloseBubbleOnTabActivationHelper() {
-  browser_->tab_strip_model()->RemoveObserver(this);
+  if (browser_)
+    browser_->tab_strip_model()->RemoveObserver(this);
 }
 
 void CloseBubbleOnTabActivationHelper::OnTabStripModelChanged(
@@ -35,3 +36,10 @@ void CloseBubbleOnTabActivationHelper::OnTabStripModelChanged(
     owner_bubble_ = nullptr;
   }
 }
+
+void CloseBubbleOnTabActivationHelper::OnTabStripModelDestroyed(
+    TabStripModel* tab_strip_model) {
+  DCHECK(browser_);
+  browser_->tab_strip_model()->RemoveObserver(this);
+  browser_ = nullptr;
+}
diff --git a/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.h b/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.h
index 7fd05cefbd814..486b6d1c571c5 100644
--- a/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.h
+++ b/chrome/browser/ui/views/close_bubble_on_tab_activation_helper.h
@@ -30,6 +30,7 @@ class CloseBubbleOnTabActivationHelper : public TabStripModelObserver {
       TabStripModel* tab_strip_model,
       const TabStripModelChange& change,
       const TabStripSelectionChange& selection) override;
+  void OnTabStripModelDestroyed(TabStripModel* tab_strip_model) override;
 
  private:
   views::BubbleDialogDelegateView* owner_bubble_;  // weak, owns me.
diff --git a/chrome/browser/ui/views/drag_and_drop_interactive_uitest.cc b/chrome/browser/ui/views/drag_and_drop_interactive_uitest.cc
index 285766ebca795..18306f98f00f6 100644
--- a/chrome/browser/ui/views/drag_and_drop_interactive_uitest.cc
+++ b/chrome/browser/ui/views/drag_and_drop_interactive_uitest.cc
@@ -1526,4 +1526,76 @@ INSTANTIATE_TEST_SUITE_P(CrossSiteSubframe,
                          DragAndDropBrowserTest,
                          ::testing::Values(true));
 
+#if BUILDFLAG(IS_CHROMEOS_ASH)
+class DragAndDropBrowserTestNoParam : public InProcessBrowserTest {
+ protected:
+  void SimulateDragFromOmniboxToWebContents(base::OnceClosure quit) {
+    chrome::FocusLocationBar(browser());
+
+    BrowserView* browser_view =
+        BrowserView::GetBrowserViewForBrowser(browser());
+    OmniboxViewViews* omnibox_view =
+        browser_view->toolbar()->location_bar()->omnibox_view();
+
+    // Simulate mouse move to omnibox.
+    gfx::Point point;
+    views::View::ConvertPointToScreen(omnibox_view, &point);
+    EXPECT_TRUE(ui_controls::SendMouseMoveNotifyWhenDone(
+        point.x(), point.y(),
+        base::BindOnce(&DragAndDropBrowserTestNoParam::Step2,
+                       base::Unretained(this), std::move(quit))));
+  }
+
+  void Step2(base::OnceClosure quit) {
+    // Simulate mouse down.
+    EXPECT_TRUE(ui_controls::SendMouseEventsNotifyWhenDone(
+        ui_controls::LEFT, ui_controls::DOWN,
+        base::BindOnce(&DragAndDropBrowserTestNoParam::Step3,
+                       base::Unretained(this), std::move(quit))));
+  }
+
+  void Step3(base::OnceClosure quit) {
+    // Simulate mouse move to WebContents.
+    // Keep sending mouse move until the current tab is closed.
+    // After the current tab is closed, send mouse up to end drag and drop.
+    if (browser()->tab_strip_model()->count() == 1) {
+      EXPECT_TRUE(ui_controls::SendMouseEventsNotifyWhenDone(
+          ui_controls::LEFT, ui_controls::UP, std::move(quit)));
+      return;
+    }
+
+    gfx::Rect bounds = browser()
+                           ->tab_strip_model()
+                           ->GetActiveWebContents()
+                           ->GetContainerBounds();
+    EXPECT_TRUE(ui_controls::SendMouseMoveNotifyWhenDone(
+        bounds.CenterPoint().x(), bounds.CenterPoint().y(),
+        base::BindOnce(&DragAndDropBrowserTestNoParam::Step3,
+                       base::Unretained(this), std::move(quit))));
+  }
+};
+
+// https://crbug.com/1312505
+IN_PROC_BROWSER_TEST_F(DragAndDropBrowserTestNoParam, CloseTabDuringDrag) {
+  EXPECT_EQ(1, browser()->tab_strip_model()->count());
+  ui_test_utils::TabAddedWaiter wait_for_new_tab(browser());
+
+  // Create a new tab that closes itself on dragover event.
+  ASSERT_TRUE(ExecuteScript(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetMainFrame(),
+      "window.open('javascript:document.addEventListener("
+      "\"dragover\", () => {window.close(); })');"));
+
+  wait_for_new_tab.Wait();
+
+  EXPECT_EQ(2, browser()->tab_strip_model()->count());
+
+  base::RunLoop loop;
+  SimulateDragFromOmniboxToWebContents(loop.QuitClosure());
+  loop.Run();
+
+  EXPECT_EQ(1, browser()->tab_strip_model()->count());
+}
+#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+
 }  // namespace chrome
diff --git a/chrome/browser/ui/webui/chrome_url_data_manager_browsertest.cc b/chrome/browser/ui/webui/chrome_url_data_manager_browsertest.cc
index 9e60b66b68209..22018c97d51e3 100644
--- a/chrome/browser/ui/webui/chrome_url_data_manager_browsertest.cc
+++ b/chrome/browser/ui/webui/chrome_url_data_manager_browsertest.cc
@@ -292,7 +292,8 @@ static constexpr const char* const kChromeUrls[] = {
     "chrome://machine-learning-internals",
     "chrome://multidevice-setup",
     "chrome://network",
-    "chrome://oobe",
+    // TODO(crbug.com/1329058): Eliminate chrome://oobe/login
+    "chrome://oobe/login",
     "chrome://os-credits",
     "chrome://os-settings",
     "chrome://power",
diff --git a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index 948340f99e769..31057ad088196 100644
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -155,6 +155,7 @@
 #include "chrome/browser/ash/login/easy_unlock/easy_unlock_service.h"
 #include "chrome/browser/ash/login/easy_unlock/easy_unlock_service_factory.h"
 #include "chrome/browser/ash/login/login_pref_names.h"
+#include "chrome/browser/ash/profiles/profile_helper.h"
 #include "chrome/browser/ash/scanning/chrome_scanning_app_delegate.h"
 #include "chrome/browser/ash/scanning/scan_service.h"
 #include "chrome/browser/ash/scanning/scan_service_factory.h"
@@ -207,6 +208,7 @@
 #include "chrome/browser/ui/webui/nearby_internals/nearby_internals_ui.h"
 #include "chrome/browser/ui/webui/nearby_share/nearby_share_dialog_ui.h"
 #include "chrome/browser/ui/webui/settings/chromeos/os_settings_ui.h"
+#include "chrome/common/chrome_switches.h"
 #include "chromeos/components/camera_app_ui/camera_app_ui.h"
 #include "chromeos/components/camera_app_ui/url_constants.h"
 #include "chromeos/components/connectivity_diagnostics/connectivity_diagnostics_ui.h"
@@ -233,6 +235,7 @@
 #include "chromeos/services/multidevice_setup/public/mojom/multidevice_setup.mojom.h"
 #include "chromeos/services/network_health/public/mojom/network_diagnostics.mojom.h"
 #include "chromeos/services/network_health/public/mojom/network_health.mojom.h"
+#include "content/public/common/content_switches.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #endif
 
@@ -761,8 +764,18 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
     return &NewWebUI<chromeos::multidevice_setup::MultiDeviceSetupDialogUI>;
   if (url.host_piece() == chrome::kChromeUINetworkHost)
     return &NewWebUI<chromeos::NetworkUI>;
-  if (url.host_piece() == chrome::kChromeUIOobeHost)
-    return &NewWebUI<chromeos::OobeUI>;
+  if (url.host_piece() == chrome::kChromeUIOobeHost) {
+    // TODO(crbug.com/1329058): Eliminate chrome://oobe/login and fix OOBE tests
+    // running inside the session.
+    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+    bool is_running_test = command_line->HasSwitch(::switches::kTestName) ||
+                           command_line->HasSwitch(::switches::kTestType);
+    if (ash::ProfileHelper::IsSigninProfile(profile) ||
+        (url.path() == "/login" && is_running_test)) {
+      return &NewWebUI<chromeos::OobeUI>;
+    }
+    return nullptr;
+  }
   if (url.host_piece() == chrome::kChromeUIOSSettingsHost)
     return &NewWebUI<chromeos::settings::OSSettingsUI>;
   if (url.host_piece() == chrome::kChromeUIPowerHost)
diff --git a/chrome/browser/ui/webui/settings/chromeos/main_section.cc b/chrome/browser/ui/webui/settings/chromeos/main_section.cc
index e63667017f291..50819a4cc50b9 100644
--- a/chrome/browser/ui/webui/settings/chromeos/main_section.cc
+++ b/chrome/browser/ui/webui/settings/chromeos/main_section.cc
@@ -130,6 +130,7 @@ void MainSection::AddLoadTimeData(content::WebUIDataSource* html_source) {
       {"edit", IDS_SETTINGS_EDIT},
       {"extensionsLinkTooltip", IDS_SETTINGS_MENU_EXTENSIONS_LINK_TOOLTIP},
       {"learnMore", IDS_LEARN_MORE},
+      {"manage", IDS_SETTINGS_MANAGE},
       {"menu", IDS_MENU},
       {"menuButtonLabel", IDS_SETTINGS_MENU_BUTTON_LABEL},
       {"moreActions", IDS_SETTINGS_MORE_ACTIONS},
diff --git a/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc b/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
index c932e7ede0d51..06ca959450d49 100644
--- a/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
+++ b/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
@@ -153,6 +153,7 @@ void AddCommonStrings(content::WebUIDataSource* html_source, Profile* profile) {
     {"extensionsLinkTooltip", IDS_SETTINGS_MENU_EXTENSIONS_LINK_TOOLTIP},
     {"fonts", IDS_SETTINGS_FONTS},
     {"learnMore", IDS_LEARN_MORE},
+    {"manage", IDS_SETTINGS_MANAGE},
     {"menu", IDS_MENU},
     {"menuButtonLabel", IDS_SETTINGS_MENU_BUTTON_LABEL},
     {"moreActions", IDS_SETTINGS_MORE_ACTIONS},
diff --git a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc
index b56ce1f84260d..6a74b47e00967 100644
--- a/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc
+++ b/chrome/browser/ui/webui/tab_strip/tab_strip_ui_handler.cc
@@ -583,10 +583,11 @@ void TabStripUIHandler::HandleGroupTab(const base::ListValue* args) {
   int tab_id = args->GetList()[0].GetInt();
 
   int tab_index = -1;
-  bool got_tab = extensions::ExtensionTabUtil::GetTabById(
-      tab_id, browser_->profile(), /*include_incognito=*/true, nullptr, nullptr,
-      nullptr, &tab_index);
-  DCHECK(got_tab);
+  if (!extensions::ExtensionTabUtil::GetTabById(
+          tab_id, browser_->profile(), /*include_incognito=*/true, nullptr,
+          nullptr, nullptr, &tab_index)) {
+    return;
+  }
 
   const std::string group_id_string = args->GetList()[1].GetString();
   base::Optional<tab_groups::TabGroupId> group_id =
@@ -602,10 +603,11 @@ void TabStripUIHandler::HandleUngroupTab(const base::ListValue* args) {
   int tab_id = args->GetList()[0].GetInt();
 
   int tab_index = -1;
-  bool got_tab = extensions::ExtensionTabUtil::GetTabById(
-      tab_id, browser_->profile(), /*include_incognito=*/true, nullptr, nullptr,
-      nullptr, &tab_index);
-  DCHECK(got_tab);
+  if (!extensions::ExtensionTabUtil::GetTabById(
+          tab_id, browser_->profile(), /*include_incognito=*/true, nullptr,
+          nullptr, nullptr, &tab_index)) {
+    return;
+  }
 
   browser_->tab_strip_model()->RemoveFromGroup({tab_index});
 }
@@ -781,10 +783,11 @@ void TabStripUIHandler::HandleShowTabContextMenu(const base::ListValue* args) {
 
   Browser* browser = nullptr;
   int tab_index = -1;
-  const bool got_tab = extensions::ExtensionTabUtil::GetTabById(
-      tab_id, browser_->profile(), true /* include_incognito */, &browser,
-      nullptr, nullptr, &tab_index);
-  CHECK(got_tab);
+  if (!extensions::ExtensionTabUtil::GetTabById(
+          tab_id, browser_->profile(), true /* include_incognito */, &browser,
+          nullptr, nullptr, &tab_index)) {
+    return;
+  }
 
   if (browser != browser_) {
     // TODO(crbug.com/1141573): Investigate how a context menu is being opened
diff --git a/chrome/browser/webshare/BUILD.gn b/chrome/browser/webshare/BUILD.gn
index 5553a53506535..8e4486f6edb08 100644
--- a/chrome/browser/webshare/BUILD.gn
+++ b/chrome/browser/webshare/BUILD.gn
@@ -9,6 +9,8 @@ if (is_chromeos_ash || is_mac) {
     sources = [
       "prepare_directory_task.cc",
       "prepare_directory_task.h",
+      "prepare_subdirectory_task.cc",
+      "prepare_subdirectory_task.h",
       "store_file_task.cc",
       "store_file_task.h",
       "store_files_task.cc",
@@ -23,13 +25,6 @@ if (is_chromeos_ash || is_mac) {
       "//base",
       "//third_party/blink/public/common",
     ]
-
-    if (is_mac) {
-      sources += [
-        "prepare_subdirectory_task.cc",
-        "prepare_subdirectory_task.h",
-      ]
-    }
   }
 }
 
diff --git a/chrome/browser/webshare/chromeos/sharesheet_client.cc b/chrome/browser/webshare/chromeos/sharesheet_client.cc
index 8e1c10eb6754e..cbac64ca64819 100644
--- a/chrome/browser/webshare/chromeos/sharesheet_client.cc
+++ b/chrome/browser/webshare/chromeos/sharesheet_client.cc
@@ -10,6 +10,7 @@
 #include "base/callback_helpers.h"
 #include "base/feature_list.h"
 #include "base/files/file_path.h"
+#include "base/files/safe_base_name.h"
 #include "base/rand_util.h"
 #include "base/strings/string_piece.h"
 #include "base/strings/stringprintf.h"
@@ -22,9 +23,12 @@
 #include "chrome/browser/sharesheet/sharesheet_service_factory.h"
 #include "chrome/browser/visibility_timer_tab_helper.h"
 #include "chrome/browser/webshare/prepare_directory_task.h"
+#include "chrome/browser/webshare/prepare_subdirectory_task.h"
 #include "chrome/browser/webshare/share_service_impl.h"
 #include "chrome/browser/webshare/store_files_task.h"
 #include "chrome/common/chrome_features.h"
+#include "chrome/common/pref_names.h"
+#include "components/prefs/pref_service.h"
 #include "components/services/app_service/public/cpp/intent_util.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
@@ -39,19 +43,30 @@ namespace {
 constexpr base::FilePath::CharType kWebShareDirname[] =
     FILE_PATH_LITERAL(".WebShare");
 
-// We don't use |supplied_name| as it may contain special characters, and it may
-// not be unique. The suffix has been checked by
+constexpr char kDefaultShareName[] = "share";
+
+// Note that the suffix of |suggested_name| has been checked by
 // ShareServiceImpl::IsDangerousFilename().
-base::FilePath GenerateFileName(const base::FilePath& directory,
-                                const std::string& supplied_name) {
+base::FilePath GenerateFileName(content::WebContents* web_contents,
+                                const base::FilePath& directory,
+                                const base::SafeBaseName& suggested_name) {
   static unsigned counter = 0;
 
   ++counter;
+  std::string dirname = base::StringPrintf("share%u", counter);
+
+  Profile* profile =
+      Profile::FromBrowserContext(web_contents->GetBrowserContext());
+  std::string referrer_charset =
+      profile->GetPrefs()->GetString(prefs::kDefaultCharset);
 
-  size_t suffix_pos = supplied_name.find_last_of('.');
-  std::string filename = base::StringPrintf("share%u%s", counter,
-                                            supplied_name.c_str() + suffix_pos);
-  return directory.Append(filename);
+  base::FilePath filename =
+      net::GenerateFileName(web_contents->GetLastCommittedURL(),
+                            /*content_disposition=*/std::string(),
+                            referrer_charset, suggested_name.path().value(),
+                            /*mime_type=*/std::string(), kDefaultShareName);
+
+  return directory.Append(dirname).Append(filename);
 }
 
 blink::mojom::ShareError SharesheetResultToShareError(
@@ -64,6 +79,17 @@ blink::mojom::ShareError SharesheetResultToShareError(
   }
 }
 
+// Deletes immediate parent directories of specified |file_paths|, after waiting
+// |delay|.
+void ScheduleSharedFileDirectoryDeletion(std::vector<base::FilePath> file_paths,
+                                         base::TimeDelta delay) {
+  for (size_t i = 0; i < file_paths.size(); ++i)
+    file_paths[i] = file_paths[i].DirName();
+
+  webshare::PrepareDirectoryTask::ScheduleSharedFileDeletion(
+      std::move(file_paths), delay);
+}
+
 }  // namespace
 
 namespace webshare {
@@ -169,8 +195,27 @@ void SharesheetClient::OnPrepareDirectory(blink::mojom::ShareError error) {
 
   for (const auto& file : current_share_->files) {
     current_share_->content_types.push_back(file->blob->content_type);
-    current_share_->file_paths.push_back(
-        GenerateFileName(current_share_->directory, file->name));
+    current_share_->file_paths.push_back(GenerateFileName(
+        web_contents(), current_share_->directory, file->name));
+  }
+
+  current_share_->prepare_subdirectory_task =
+      std::make_unique<PrepareSubDirectoryTask>(
+          current_share_->file_paths,
+          base::BindOnce(&SharesheetClient::OnPrepareSubdirectory,
+                         weak_ptr_factory_.GetWeakPtr()));
+  current_share_->prepare_subdirectory_task->Start();
+}
+
+void SharesheetClient::OnPrepareSubdirectory(blink::mojom::ShareError error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (!current_share_.has_value())
+    return;
+
+  if (!web_contents() || error != blink::mojom::ShareError::OK) {
+    std::move(current_share_->callback).Run(error);
+    current_share_ = absl::nullopt;
+    return;
   }
 
   std::unique_ptr<StoreFilesTask> store_files_task =
@@ -191,8 +236,8 @@ void SharesheetClient::OnStoreFiles(blink::mojom::ShareError error) {
 
   if (!web_contents() || error != blink::mojom::ShareError::OK) {
     std::move(current_share_->callback).Run(error);
-    PrepareDirectoryTask::ScheduleSharedFileDeletion(
-        std::move(current_share_->file_paths), base::TimeDelta::FromMinutes(0));
+    ScheduleSharedFileDirectoryDeletion(std::move(current_share_->file_paths),
+                                        base::TimeDelta::FromMinutes(0));
     current_share_ = base::nullopt;
     return;
   }
@@ -209,7 +254,7 @@ void SharesheetClient::OnShowSharesheet(sharesheet::SharesheetResult result) {
     return;
 
   std::move(current_share_->callback).Run(SharesheetResultToShareError(result));
-  PrepareDirectoryTask::ScheduleSharedFileDeletion(
+  ScheduleSharedFileDirectoryDeletion(
       std::move(current_share_->file_paths),
       PrepareDirectoryTask::kSharedFileLifetime);
   current_share_ = base::nullopt;
diff --git a/chrome/browser/webshare/chromeos/sharesheet_client.h b/chrome/browser/webshare/chromeos/sharesheet_client.h
index afccf387e7bca..0e9732b7f4026 100644
--- a/chrome/browser/webshare/chromeos/sharesheet_client.h
+++ b/chrome/browser/webshare/chromeos/sharesheet_client.h
@@ -22,6 +22,7 @@ class WebContents;
 namespace webshare {
 
 class PrepareDirectoryTask;
+class PrepareSubDirectoryTask;
 
 // Chrome-OS implementation of navigator.share() sharing to
 // sharesheet::SharesheetService.
@@ -52,6 +53,8 @@ class SharesheetClient : public content::WebContentsObserver {
  private:
   void OnPrepareDirectory(blink::mojom::ShareError);
 
+  void OnPrepareSubdirectory(blink::mojom::ShareError);
+
   void OnStoreFiles(blink::mojom::ShareError);
 
   void OnShowSharesheet(sharesheet::SharesheetResult result);
@@ -85,6 +88,7 @@ class SharesheetClient : public content::WebContentsObserver {
     blink::mojom::ShareService::ShareCallback callback;
 
     std::unique_ptr<PrepareDirectoryTask> prepare_directory_task;
+    std::unique_ptr<PrepareSubDirectoryTask> prepare_subdirectory_task;
   };
 
   base::Optional<CurrentShare> current_share_;
diff --git a/chrome/browser/webshare/chromeos/sharesheet_client_browsertest.cc b/chrome/browser/webshare/chromeos/sharesheet_client_browsertest.cc
index 77119bad47989..6c275c4609f33 100644
--- a/chrome/browser/webshare/chromeos/sharesheet_client_browsertest.cc
+++ b/chrome/browser/webshare/chromeos/sharesheet_client_browsertest.cc
@@ -89,7 +89,7 @@ class SharesheetClientBrowserTest : public InProcessBrowserTest {
   base::test::ScopedFeatureList feature_list_;
 };
 
-IN_PROC_BROWSER_TEST_F(SharesheetClientBrowserTest, ShareTwoFiles) {
+IN_PROC_BROWSER_TEST_F(SharesheetClientBrowserTest, ShareMultipleFiles) {
   const std::string script = "share_multiple_files()";
   ASSERT_TRUE(embedded_test_server()->Start());
   ui_test_utils::NavigateToURL(browser(), GetAppUrl());
@@ -107,23 +107,28 @@ IN_PROC_BROWSER_TEST_F(SharesheetClientBrowserTest, ShareTwoFiles) {
 
         file_paths = std::move(in_file_paths);
 
-        EXPECT_EQ(content_types.size(), 2U);
+        EXPECT_EQ(content_types.size(), 3U);
         EXPECT_EQ(content_types[0], "audio/mpeg");
         EXPECT_EQ(content_types[1], "video/mp4");
+        EXPECT_EQ(content_types[2], "image/gif");
 
         std::move(close_callback).Run(sharesheet::SharesheetResult::kSuccess);
       }));
 
   EXPECT_EQ("share succeeded", content::EvalJs(contents, script));
-  EXPECT_EQ(file_paths.size(), 2U);
+  EXPECT_EQ(file_paths.size(), 3U);
 
   const base::FilePath my_files =
       file_manager::util::GetMyFilesFolderForProfile(browser()->profile());
-  EXPECT_EQ(file_paths[0], my_files.AppendASCII(".WebShare/share1.mp3"));
-  EXPECT_EQ(file_paths[1], my_files.AppendASCII(".WebShare/share2.mp4"));
+  EXPECT_EQ(file_paths[0],
+            my_files.AppendASCII(".WebShare/share1/sam.ple.mp3"));
+  EXPECT_EQ(file_paths[1], my_files.AppendASCII(".WebShare/share2/sample.mp4"));
+  EXPECT_EQ(file_paths[2],
+            my_files.AppendASCII(".WebShare/share3/sam_ple.gif"));
 
   CheckSize(file_paths[0], /*expected_size=*/345);
   CheckSize(file_paths[1], /*expected_size=*/67890);
+  CheckSize(file_paths[2], /*expected_size=*/1);
 }
 
 IN_PROC_BROWSER_TEST_F(SharesheetClientBrowserTest, RepeatedShare) {
diff --git a/chrome/browser/webshare/chromeos/sharesheet_client_unittest.cc b/chrome/browser/webshare/chromeos/sharesheet_client_unittest.cc
index d2055642de0ba..591b2e6e2d7bc 100644
--- a/chrome/browser/webshare/chromeos/sharesheet_client_unittest.cc
+++ b/chrome/browser/webshare/chromeos/sharesheet_client_unittest.cc
@@ -10,6 +10,7 @@
 #include "base/bind.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
+#include "base/files/safe_base_name.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/run_loop.h"
 #include "base/test/bind.h"
@@ -126,18 +127,20 @@ TEST_F(SharesheetClientUnitTest, DeleteAfterShare) {
   const base::FilePath my_files =
       file_manager::util::GetMyFilesFolderForProfile(profile());
   const base::FilePath first_file =
-      my_files.AppendASCII(".WebShare/share1.txt");
+      my_files.AppendASCII(".WebShare/share1/first.txt");
   const base::FilePath second_file =
-      my_files.AppendASCII(".WebShare/share2.txt");
+      my_files.AppendASCII(".WebShare/share2/second.txt");
 
   const std::string title = "Subject";
   const std::string text = "Message";
   const GURL share_url("https://example.com/");
   std::vector<blink::mojom::SharedFilePtr> files;
-  files.push_back(blink::mojom::SharedFile::New(
-      first_file.AsUTF8Unsafe(), blink::mojom::SerializedBlob::New()));
-  files.push_back(blink::mojom::SharedFile::New(
-      second_file.AsUTF8Unsafe(), blink::mojom::SerializedBlob::New()));
+  files.push_back(
+      blink::mojom::SharedFile::New(*base::SafeBaseName::Create(first_file),
+                                    blink::mojom::SerializedBlob::New()));
+  files.push_back(
+      blink::mojom::SharedFile::New(*base::SafeBaseName::Create(second_file),
+                                    blink::mojom::SerializedBlob::New()));
 
   base::RunLoop run_loop;
   blink::mojom::ShareError error = blink::mojom::ShareError::INTERNAL_ERROR;
diff --git a/chrome/browser/webshare/mac/sharing_service_operation.mm b/chrome/browser/webshare/mac/sharing_service_operation.mm
index 196e13e77abf1..0ab04e0d01fff 100644
--- a/chrome/browser/webshare/mac/sharing_service_operation.mm
+++ b/chrome/browser/webshare/mac/sharing_service_operation.mm
@@ -93,7 +93,9 @@ void SharingServiceOperation::OnPrepareDirectory(
   }
 
   for (const auto& file : shared_files_) {
-    std::string file_name = file->name;
+    // SafeBaseName protects against including paths in a file name.
+    std::string file_name = file->name.path().value();
+    DCHECK_EQ(file_name.find('/'), std::string::npos);
     base::i18n::ReplaceIllegalCharactersInPath(&file_name, '_');
     file_paths_.push_back(
         GenerateUniqueSubDirectory(directory_).Append(file_name));
diff --git a/chrome/browser/webshare/prepare_directory_task.cc b/chrome/browser/webshare/prepare_directory_task.cc
index 0a0ce7b12af2e..e4dd22a4e962e 100644
--- a/chrome/browser/webshare/prepare_directory_task.cc
+++ b/chrome/browser/webshare/prepare_directory_task.cc
@@ -26,7 +26,7 @@ void DeleteSharedFiles(std::vector<base::FilePath> file_paths) {
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::WILL_BLOCK);
   for (const base::FilePath& name : file_paths) {
-    base::DeleteFile(name);
+    base::DeletePathRecursively(name);
   }
 }
 
diff --git a/chrome/browser/webshare/share_service_impl.cc b/chrome/browser/webshare/share_service_impl.cc
index 34662478001ed..667509f2e6a2d 100644
--- a/chrome/browser/webshare/share_service_impl.cc
+++ b/chrome/browser/webshare/share_service_impl.cc
@@ -8,6 +8,7 @@
 #include <memory>
 
 #include "base/feature_list.h"
+#include "base/files/safe_base_name.h"
 #include "base/strings/string_piece.h"
 #include "base/strings/string_util.h"
 #include "build/chromeos_buildflags.h"
@@ -49,51 +50,52 @@ void ShareServiceImpl::Create(
 }
 
 // static
-bool ShareServiceImpl::IsDangerousFilename(base::StringPiece name) {
-  constexpr std::array<const char*, 39> kPermitted = {
-      ".bmp",    // image/bmp / image/x-ms-bmp
-      ".css",    // text/css
-      ".csv",    // text/csv / text/comma-separated-values
-      ".ehtml",  // text/html
-      ".flac",   // audio/flac
-      ".gif",    // image/gif
-      ".htm",    // text/html
-      ".html",   // text/html
-      ".ico",    // image/x-icon
-      ".jfif",   // image/jpeg
-      ".jpeg",   // image/jpeg
-      ".jpg",    // image/jpeg
-      ".m4a",    // audio/x-m4a
-      ".m4v",    // video/mp4
-      ".mp3",    // audio/mpeg audio/mp3
-      ".mp4",    // video/mp4
-      ".mpeg",   // video/mpeg
-      ".mpg",    // video/mpeg
-      ".oga",    // audio/ogg
-      ".ogg",    // audio/ogg
-      ".ogm",    // video/ogg
-      ".ogv",    // video/ogg
-      ".opus",   // audio/ogg
-      ".pjp",    // image/jpeg
-      ".pjpeg",  // image/jpeg
-      ".png",    // image/png
-      ".shtm",   // text/html
-      ".shtml",  // text/html
-      ".svg",    // image/svg+xml
-      ".svgz",   // image/svg+xml
-      ".text",   // text/plain
-      ".tif",    // image/tiff
-      ".tiff",   // image/tiff
-      ".txt",    // text/plain
-      ".wav",    // audio/wav
-      ".weba",   // audio/webm
-      ".webm",   // video/webm
-      ".webp",   // image/webp
-      ".xbm",    // image/x-xbitmap
+bool ShareServiceImpl::IsDangerousFilename(const base::FilePath& path) {
+  constexpr const base::FilePath::CharType* kPermitted[] = {
+      FILE_PATH_LITERAL(".bmp"),    // image/bmp / image/x-ms-bmp
+      FILE_PATH_LITERAL(".css"),    // text/css
+      FILE_PATH_LITERAL(".csv"),    // text/csv / text/comma-separated-values
+      FILE_PATH_LITERAL(".ehtml"),  // text/html
+      FILE_PATH_LITERAL(".flac"),   // audio/flac
+      FILE_PATH_LITERAL(".gif"),    // image/gif
+      FILE_PATH_LITERAL(".htm"),    // text/html
+      FILE_PATH_LITERAL(".html"),   // text/html
+      FILE_PATH_LITERAL(".ico"),    // image/x-icon
+      FILE_PATH_LITERAL(".jfif"),   // image/jpeg
+      FILE_PATH_LITERAL(".jpeg"),   // image/jpeg
+      FILE_PATH_LITERAL(".jpg"),    // image/jpeg
+      FILE_PATH_LITERAL(".m4a"),    // audio/x-m4a
+      FILE_PATH_LITERAL(".m4v"),    // video/mp4
+      FILE_PATH_LITERAL(".mp3"),    // audio/mpeg audio/mp3
+      FILE_PATH_LITERAL(".mp4"),    // video/mp4
+      FILE_PATH_LITERAL(".mpeg"),   // video/mpeg
+      FILE_PATH_LITERAL(".mpg"),    // video/mpeg
+      FILE_PATH_LITERAL(".oga"),    // audio/ogg
+      FILE_PATH_LITERAL(".ogg"),    // audio/ogg
+      FILE_PATH_LITERAL(".ogm"),    // video/ogg
+      FILE_PATH_LITERAL(".ogv"),    // video/ogg
+      FILE_PATH_LITERAL(".opus"),   // audio/ogg
+      FILE_PATH_LITERAL(".pjp"),    // image/jpeg
+      FILE_PATH_LITERAL(".pjpeg"),  // image/jpeg
+      FILE_PATH_LITERAL(".png"),    // image/png
+      FILE_PATH_LITERAL(".shtm"),   // text/html
+      FILE_PATH_LITERAL(".shtml"),  // text/html
+      FILE_PATH_LITERAL(".svg"),    // image/svg+xml
+      FILE_PATH_LITERAL(".svgz"),   // image/svg+xml
+      FILE_PATH_LITERAL(".text"),   // text/plain
+      FILE_PATH_LITERAL(".tif"),    // image/tiff
+      FILE_PATH_LITERAL(".tiff"),   // image/tiff
+      FILE_PATH_LITERAL(".txt"),    // text/plain
+      FILE_PATH_LITERAL(".wav"),    // audio/wav
+      FILE_PATH_LITERAL(".weba"),   // audio/webm
+      FILE_PATH_LITERAL(".webm"),   // video/webm
+      FILE_PATH_LITERAL(".webp"),   // image/webp
+      FILE_PATH_LITERAL(".xbm"),    // image/x-xbitmap
   };
 
-  for (const char* permitted : kPermitted) {
-    if (base::EndsWith(name, permitted, base::CompareCase::INSENSITIVE_ASCII))
+  for (const base::FilePath::CharType* permitted : kPermitted) {
+    if (base::EndsWith(path.value(), permitted,
+                       base::CompareCase::INSENSITIVE_ASCII))
       return false;
   }
   return true;
@@ -162,10 +164,11 @@ void ShareServiceImpl::Share(const std::string& title,
       return;
     }
 
-    if (IsDangerousFilename(file->name) ||
+    const base::FilePath& path = file->name.path();
+    if (IsDangerousFilename(path) ||
         IsDangerousMimeType(file->blob->content_type)) {
-      VLOG(1) << "File type is not supported: " << file->name
-              << " has mime type " << file->blob->content_type;
+      VLOG(1) << "File type is not supported: " << path << " has mime type "
+              << file->blob->content_type;
       std::move(callback).Run(blink::mojom::ShareError::PERMISSION_DENIED);
       return;
     }
diff --git a/chrome/browser/webshare/share_service_impl.h b/chrome/browser/webshare/share_service_impl.h
index 97104c92a6a3d..ce938ba372198 100644
--- a/chrome/browser/webshare/share_service_impl.h
+++ b/chrome/browser/webshare/share_service_impl.h
@@ -8,6 +8,7 @@
 #include <string>
 #include <vector>
 
+#include "base/files/file_path.h"
 #include "base/strings/string_piece.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -39,8 +40,8 @@ class ShareServiceImpl : public blink::mojom::ShareService,
       content::RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::ShareService> receiver);
 
-  static bool IsDangerousFilename(base::StringPiece);
-  static bool IsDangerousMimeType(base::StringPiece);
+  static bool IsDangerousFilename(const base::FilePath& path);
+  static bool IsDangerousMimeType(base::StringPiece content_type);
 
   // blink::mojom::ShareService:
   void Share(const std::string& title,
diff --git a/chrome/browser/webshare/share_service_unittest.cc b/chrome/browser/webshare/share_service_unittest.cc
index c93db538747f9..0e21ec116ae3e 100644
--- a/chrome/browser/webshare/share_service_unittest.cc
+++ b/chrome/browser/webshare/share_service_unittest.cc
@@ -6,6 +6,8 @@
 #include <string>
 #include <vector>
 
+#include "base/files/file_path.h"
+#include "base/files/safe_base_name.h"
 #include "base/guid.h"
 #include "base/run_loop.h"
 #include "base/test/bind.h"
@@ -72,7 +74,7 @@ class ShareServiceUnitTest : public ChromeRenderViewHostTestHarness {
   }
 #endif
 
-  ShareError ShareGeneratedFileData(const std::string& extension,
+  ShareError ShareGeneratedFileData(const base::FilePath::StringType& extension,
                                     const std::string& content_type,
                                     unsigned file_length = 100,
                                     unsigned file_count = 1) {
@@ -82,8 +84,13 @@ class ShareServiceUnitTest : public ChromeRenderViewHostTestHarness {
     std::vector<blink::mojom::SharedFilePtr> files;
     files.reserve(file_count);
     for (unsigned index = 0; index < file_count; ++index) {
-      const std::string name =
-          base::StringPrintf("share%d%s", index, extension.c_str());
+      const base::FilePath::StringType name = base::StringPrintf(
+#if defined(OS_WIN)
+          L"share%d%ls",
+#else
+          "share%d%s",
+#endif
+          index, extension.c_str());
       files.push_back(CreateSharedFile(name, content_type, file_length));
     }
 
@@ -99,10 +106,15 @@ class ShareServiceUnitTest : public ChromeRenderViewHostTestHarness {
     return result;
   }
 
+  bool IsDangerousFilename(base::FilePath::StringPieceType path) {
+    return ShareServiceImpl::IsDangerousFilename(base::FilePath(path));
+  }
+
  private:
-  blink::mojom::SharedFilePtr CreateSharedFile(const std::string& name,
-                                               const std::string& content_type,
-                                               unsigned file_length) {
+  blink::mojom::SharedFilePtr CreateSharedFile(
+      base::FilePath::StringPieceType name,
+      const std::string& content_type,
+      unsigned file_length) {
     const std::string uuid = base::GenerateGUID();
 
     auto blob = blink::mojom::SerializedBlob::New();
@@ -124,7 +136,8 @@ class ShareServiceUnitTest : public ChromeRenderViewHostTestHarness {
         base::BindLambdaForTesting([&run_loop]() { run_loop.Quit(); }));
 
     run_loop.Run();
-    return blink::mojom::SharedFile::New(name, std::move(blob));
+    return blink::mojom::SharedFile::New(*base::SafeBaseName::Create(name),
+                                         std::move(blob));
   }
 
   static std::unique_ptr<storage::BlobDataBuilder> CreateBuilder(
@@ -173,29 +186,30 @@ TEST_F(ShareServiceUnitTest, FileCount) {
     return;
 #endif
 
-  EXPECT_EQ(ShareError::OK, ShareGeneratedFileData(".txt", "text/plain", 1234,
-                                                   kMaxSharedFileCount));
+  EXPECT_EQ(ShareError::OK,
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"), "text/plain",
+                                   1234, kMaxSharedFileCount));
   EXPECT_EQ(ShareError::PERMISSION_DENIED,
-            ShareGeneratedFileData(".txt", "text/plain", 1234,
-                                   kMaxSharedFileCount + 1));
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"), "text/plain",
+                                   1234, kMaxSharedFileCount + 1));
 }
 
 TEST_F(ShareServiceUnitTest, DangerousFilename) {
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename(""));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("."));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("./"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename(".\\"));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL(".")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("./")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL(".\\")));
 
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("a.a"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("zzz.zzz"));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("a.a")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("zzz.zzz")));
 
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("a/a"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("zzz/zzz"));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("a/a")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("zzz/zzz")));
 
-  EXPECT_FALSE(ShareServiceImpl::IsDangerousFilename("1.XBM"));
-  EXPECT_FALSE(ShareServiceImpl::IsDangerousFilename("2.bMP"));
-  EXPECT_FALSE(ShareServiceImpl::IsDangerousFilename("3.Flac"));
-  EXPECT_FALSE(ShareServiceImpl::IsDangerousFilename("4.webM"));
+  EXPECT_FALSE(IsDangerousFilename(FILE_PATH_LITERAL("1.XBM")));
+  EXPECT_FALSE(IsDangerousFilename(FILE_PATH_LITERAL("2.bMP")));
+  EXPECT_FALSE(IsDangerousFilename(FILE_PATH_LITERAL("3.Flac")));
+  EXPECT_FALSE(IsDangerousFilename(FILE_PATH_LITERAL("4.webM")));
 }
 
 TEST_F(ShareServiceUnitTest, DangerousMimeType) {
@@ -218,10 +232,14 @@ TEST_F(ShareServiceUnitTest, Multimedia) {
     return;
 #endif
 
-  EXPECT_EQ(ShareError::OK, ShareGeneratedFileData(".bmp", "image/bmp"));
-  EXPECT_EQ(ShareError::OK, ShareGeneratedFileData(".xbm", "image/x-xbitmap"));
-  EXPECT_EQ(ShareError::OK, ShareGeneratedFileData(".flac", "audio/flac"));
-  EXPECT_EQ(ShareError::OK, ShareGeneratedFileData(".webm", "video/webm"));
+  EXPECT_EQ(ShareError::OK,
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".bmp"), "image/bmp"));
+  EXPECT_EQ(ShareError::OK, ShareGeneratedFileData(FILE_PATH_LITERAL(".xbm"),
+                                                   "image/x-xbitmap"));
+  EXPECT_EQ(ShareError::OK,
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".flac"), "audio/flac"));
+  EXPECT_EQ(ShareError::OK,
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".webm"), "video/webm"));
 }
 
 TEST_F(ShareServiceUnitTest, PortableDocumentFormat) {
@@ -232,20 +250,21 @@ TEST_F(ShareServiceUnitTest, PortableDocumentFormat) {
 
   // TODO(crbug.com/1006055): Support sharing of pdf files.
   // The URL will be checked using Safe Browsing.
-  EXPECT_EQ(ShareError::PERMISSION_DENIED,
-            ShareGeneratedFileData(".pdf", "application/pdf"));
+  EXPECT_EQ(
+      ShareError::PERMISSION_DENIED,
+      ShareGeneratedFileData(FILE_PATH_LITERAL(".pdf"), "application/pdf"));
 }
 
 #if defined(OS_WIN)
 TEST_F(ShareServiceUnitTest, ReservedNames) {
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("CON"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("PRN"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("AUX"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("NUL"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("COM1"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("COM9"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("LPT1"));
-  EXPECT_TRUE(ShareServiceImpl::IsDangerousFilename("LPT9"));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("CON")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("PRN")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("AUX")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("NUL")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("COM1")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("COM9")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("LPT1")));
+  EXPECT_TRUE(IsDangerousFilename(FILE_PATH_LITERAL("LPT9")));
 }
 #endif
 
@@ -253,30 +272,32 @@ TEST_F(ShareServiceUnitTest, ReservedNames) {
 // On Chrome OS, like Android, we prevent sharing of Android applications.
 TEST_F(ShareServiceUnitTest, AndroidPackage) {
   EXPECT_EQ(ShareError::PERMISSION_DENIED,
-            ShareGeneratedFileData(".apk", "text/plain"));
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".apk"), "text/plain"));
   EXPECT_EQ(ShareError::PERMISSION_DENIED,
-            ShareGeneratedFileData(".dex", "text/plain"));
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".dex"), "text/plain"));
   EXPECT_EQ(ShareError::PERMISSION_DENIED,
-            ShareGeneratedFileData(".txt", "vnd.android.package-archive"));
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"),
+                                   "vnd.android.package-archive"));
 }
 
 TEST_F(ShareServiceUnitTest, TotalBytes) {
   EXPECT_EQ(ShareError::OK,
-            ShareGeneratedFileData(".txt", "text/plain",
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"), "text/plain",
                                    kMaxSharedFileBytes / kMaxSharedFileCount,
                                    kMaxSharedFileCount));
   EXPECT_EQ(
       ShareError::PERMISSION_DENIED,
-      ShareGeneratedFileData(".txt", "text/plain",
+      ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"), "text/plain",
                              (kMaxSharedFileBytes / kMaxSharedFileCount) + 1,
                              kMaxSharedFileCount));
 }
 
 TEST_F(ShareServiceUnitTest, FileBytes) {
   EXPECT_EQ(ShareError::OK,
-            ShareGeneratedFileData(".txt", "text/plain", kMaxSharedFileBytes));
-  EXPECT_EQ(
-      ShareError::PERMISSION_DENIED,
-      ShareGeneratedFileData(".txt", "text/plain", kMaxSharedFileBytes + 1));
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"), "text/plain",
+                                   kMaxSharedFileBytes));
+  EXPECT_EQ(ShareError::PERMISSION_DENIED,
+            ShareGeneratedFileData(FILE_PATH_LITERAL(".txt"), "text/plain",
+                                   kMaxSharedFileBytes + 1));
 }
 #endif
diff --git a/chrome/browser/webshare/win/share_operation.cc b/chrome/browser/webshare/win/share_operation.cc
index 4c52230e05e07..7fa61b077e12f 100644
--- a/chrome/browser/webshare/win/share_operation.cc
+++ b/chrome/browser/webshare/win/share_operation.cc
@@ -408,7 +408,7 @@ void ShareOperation::Run(blink::mojom::ShareService::ShareCallback callback) {
         return;
       }
       if (FAILED(attachment_services->SetFileName(
-              base::UTF8ToWide(file->name).c_str()))) {
+              file->name.path().value().c_str()))) {
         Complete(blink::mojom::ShareError::INTERNAL_ERROR);
         return;
       }
@@ -537,7 +537,7 @@ bool ShareOperation::PutShareContentInDataPackage(IDataRequest* data_request) {
           content::BrowserContext::GetBlobStorageContext(
               web_contents()->GetBrowserContext()),
           file_bytes_shared, file->blob->uuid);
-      auto name_h = base::win::ScopedHString::Create(file->name);
+      auto name_h = base::win::ScopedHString::Create(file->name.path().value());
       auto raw_data_requested_callback =
           Callback<IStreamedFileDataRequestedHandler>(
               [operation](IOutputStream* stream) -> HRESULT {
diff --git a/chrome/browser/webshare/win/share_operation_unittest.cc b/chrome/browser/webshare/win/share_operation_unittest.cc
index 7b59ea38f3bb4..d3b9f67299fc3 100644
--- a/chrome/browser/webshare/win/share_operation_unittest.cc
+++ b/chrome/browser/webshare/win/share_operation_unittest.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/webshare/win/share_operation.h"
 
+#include "base/files/file_path.h"
 #include "base/guid.h"
 #include "base/run_loop.h"
 #include "base/synchronization/waitable_event.h"
@@ -146,9 +147,10 @@ class ShareOperationUnitTest : public ChromeRenderViewHostTestHarness {
     ASSERT_HRESULT_SUCCEEDED(closable_input_stream->Close());
   }
 
-  blink::mojom::SharedFilePtr CreateSharedFile(const std::string& name,
-                                               const std::string& content_type,
-                                               const std::string& contents) {
+  blink::mojom::SharedFilePtr CreateSharedFile(
+      base::FilePath::StringPieceType name,
+      const std::string& content_type,
+      const std::string& contents) {
     auto blob = blink::mojom::SerializedBlob::New();
     const std::string uuid = base::GenerateGUID();
     blob->uuid = uuid;
@@ -171,7 +173,8 @@ class ShareOperationUnitTest : public ChromeRenderViewHostTestHarness {
         }),
         base::BindLambdaForTesting([&run_loop]() { run_loop.Quit(); }));
     run_loop.Run();
-    return blink::mojom::SharedFile::New(name, std::move(blob));
+    return blink::mojom::SharedFile::New(*base::SafeBaseName::Create(name),
+                                         std::move(blob));
   }
 
   bool IsSupportedEnvironment() {
@@ -283,8 +286,8 @@ TEST_F(ShareOperationUnitTest, BasicFile) {
 
   base::RunLoop run_loop;
   std::vector<blink::mojom::SharedFilePtr> files;
-  files.push_back(
-      CreateSharedFile("MyFile.txt", "text/plain", "Contents of the file"));
+  files.push_back(CreateSharedFile(FILE_PATH_LITERAL("MyFile.txt"),
+                                   "text/plain", "Contents of the file"));
   ShareOperation operation{"shared title", "", GURL::EmptyGURL(),
                            std::move(files), web_contents()};
   operation.Run(
@@ -320,7 +323,7 @@ TEST_F(ShareOperationUnitTest, SingleFileAtSizeLimit) {
   base::RunLoop run_loop;
   std::vector<blink::mojom::SharedFilePtr> files;
   files.push_back(
-      CreateSharedFile("MyFile.txt", "text/plain",
+      CreateSharedFile(FILE_PATH_LITERAL("MyFile.txt"), "text/plain",
                        std::string(kMaxSharedFileBytesForTest, '*')));
   ShareOperation operation{"", "", GURL::EmptyGURL(), std::move(files),
                            web_contents()};
@@ -357,7 +360,7 @@ TEST_F(ShareOperationUnitTest, SingleFileLargerThanSizeLimit) {
   base::RunLoop run_loop;
   std::vector<blink::mojom::SharedFilePtr> files;
   files.push_back(
-      CreateSharedFile("MyFile.txt", "text/plain",
+      CreateSharedFile(FILE_PATH_LITERAL("MyFile.txt"), "text/plain",
                        std::string(kMaxSharedFileBytesForTest + 1, '*')));
   ShareOperation operation{"", "", GURL::EmptyGURL(), std::move(files),
                            web_contents()};
@@ -396,10 +399,10 @@ TEST_F(ShareOperationUnitTest, FilesTotallingSizeLimit) {
   base::RunLoop run_loop;
   std::vector<blink::mojom::SharedFilePtr> files;
   files.push_back(
-      CreateSharedFile("File1.txt", "text/plain",
+      CreateSharedFile(FILE_PATH_LITERAL("File1.txt"), "text/plain",
                        std::string(kMaxSharedFileBytesForTest / 2, '*')));
   files.push_back(
-      CreateSharedFile("File2.txt", "text/plain",
+      CreateSharedFile(FILE_PATH_LITERAL("File2.txt"), "text/plain",
                        std::string(kMaxSharedFileBytesForTest / 2, '*')));
   ShareOperation operation{"", "", GURL::EmptyGURL(), std::move(files),
                            web_contents()};
@@ -442,10 +445,10 @@ TEST_F(ShareOperationUnitTest, FilesTotallingLargerThanSizeLimit) {
   base::RunLoop run_loop;
   std::vector<blink::mojom::SharedFilePtr> files;
   files.push_back(
-      CreateSharedFile("File1.txt", "text/plain",
+      CreateSharedFile(FILE_PATH_LITERAL("File1.txt"), "text/plain",
                        std::string(kMaxSharedFileBytesForTest / 2, '*')));
   files.push_back(
-      CreateSharedFile("File2.txt", "text/plain",
+      CreateSharedFile(FILE_PATH_LITERAL("File2.txt"), "text/plain",
                        std::string((kMaxSharedFileBytesForTest / 2) + 1, '*')));
   ShareOperation operation{"", "", GURL::EmptyGURL(), std::move(files),
                            web_contents()};
diff --git a/chrome/chrome_paks.gni b/chrome/chrome_paks.gni
index fa26d2dc9d665..8fa81672ca64d 100644
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -128,6 +128,11 @@ template("chrome_extra_paks") {
       sources += invoker.additional_paks
     }
 
+    if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
+      sources += [ "$root_gen_dir/ohos_nweb_ex/overrides/ui/resources/ohos_nweb_ex_resources.pak" ]
+      deps += [ "//ohos_nweb_ex/overrides/ui/resources" ]
+    }
+
     if (!is_android) {
       # New paks should be added here by default.
       sources += [
diff --git a/chrome/chrome_repack_locales.gni b/chrome/chrome_repack_locales.gni
index b08eee1f789a7..029d8bf16878d 100644
--- a/chrome/chrome_repack_locales.gni
+++ b/chrome/chrome_repack_locales.gni
@@ -59,6 +59,11 @@ template("chrome_repack_locales") {
       deps += invoker.deps
     }
 
+    if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
+      source_patterns += [ "${root_gen_dir}/ohos_nweb_ex/overrides/ui/strings/ohos_nweb_ex_strings_" ]
+      deps += [ "//ohos_nweb_ex/overrides/ui/strings" ]
+    }
+
     # Omnibox resources are currently desktop-only, but this may change.
     if (!is_android) {
       source_patterns +=
diff --git a/chrome/test/data/extensions/api_test/debugger/background.js b/chrome/test/data/extensions/api_test/debugger/background.js
index 7675e92bdaae7..20406a281d426 100644
--- a/chrome/test/data/extensions/api_test/debugger/background.js
+++ b/chrome/test/data/extensions/api_test/debugger/background.js
@@ -132,13 +132,12 @@ chrome.test.getConfig(config => chrome.test.runTests([
 
       function onDetach(from, reason) {
         chrome.debugger.onDetach.removeListener(onDetach);
+        chrome.debugger.attach(
+          debuggee, protocolVersion, fail('Cannot access a chrome:// URL'));
         chrome.test.assertTrue(responded);
         chrome.test.assertEq(debuggee.tabId, from.tabId);
         chrome.test.assertEq("target_closed", reason);
-        chrome.tabs.remove(tab.id, function() {
-          chrome.test.assertNoLastError();
-          chrome.test.succeed();
-        });
+        chrome.tabs.remove(tab.id, pass())
       }
 
       chrome.test.assertNoLastError();
diff --git a/chrome/test/data/webshare/index.html b/chrome/test/data/webshare/index.html
index 7da49a881bcbb..0d598893c45ba 100644
--- a/chrome/test/data/webshare/index.html
+++ b/chrome/test/data/webshare/index.html
@@ -32,9 +32,10 @@
 
     async function share_multiple_files() {
       try {
-        const first_file = create_file('sample.mp3', 'audio/mpeg', 345);
+        const first_file = create_file('sam.ple.mp3', 'audio/mpeg', 345);
         const second_file = create_file('../sample.mp4', 'video/mp4', 67890);
-        await navigator.share({files: [first_file, second_file]});
+        const third_file = create_file('sam\\ple.gif', 'image/gif', 1);
+        await navigator.share({files: [first_file, second_file, third_file]});
         return 'share succeeded';
       } catch(error) {
         return ('share failed: ' + error);
diff --git a/components/browser_ui/webshare/android/BUILD.gn b/components/browser_ui/webshare/android/BUILD.gn
index 86a332570a336..24424f041e61d 100644
--- a/components/browser_ui/webshare/android/BUILD.gn
+++ b/components/browser_ui/webshare/android/BUILD.gn
@@ -16,6 +16,7 @@ android_library("java") {
     "//content/public/android:content_java",
     "//mojo/public/java:system_java",
     "//mojo/public/java/system:system_impl_java",
+    "//mojo/public/mojom/base:base_java",
     "//third_party/androidx:androidx_annotation_annotation_java",
     "//third_party/blink/public/mojom:android_mojo_bindings_java",
     "//ui/android:ui_java",
diff --git a/components/browser_ui/webshare/android/java/src/org/chromium/components/browser_ui/webshare/ShareServiceImpl.java b/components/browser_ui/webshare/android/java/src/org/chromium/components/browser_ui/webshare/ShareServiceImpl.java
index c43725581e051..5b5504db73583 100644
--- a/components/browser_ui/webshare/android/java/src/org/chromium/components/browser_ui/webshare/ShareServiceImpl.java
+++ b/components/browser_ui/webshare/android/java/src/org/chromium/components/browser_ui/webshare/ShareServiceImpl.java
@@ -215,7 +215,8 @@ public class ShareServiceImpl implements ShareService {
         }
 
         for (SharedFile file : files) {
-            if (isDangerousFilename(file.name) || isDangerousMimeType(file.blob.contentType)) {
+            if (isDangerousFilename(file.name.path.path)
+                    || isDangerousMimeType(file.blob.contentType)) {
                 Log.i(TAG,
                         "Cannot share potentially dangerous \"" + file.blob.contentType
                                 + "\" file \"" + file.name + "\".");
@@ -245,7 +246,8 @@ public class ShareServiceImpl implements ShareService {
 
                     for (int index = 0; index < files.length; ++index) {
                         File tempFile = File.createTempFile("share",
-                                "." + FileUtils.getExtension(files[index].name), sharePath);
+                                "." + FileUtils.getExtension(files[index].name.path.path),
+                                sharePath);
                         fileUris.add(ContentUriUtils.getContentUriFromFile(tempFile));
                         blobReceivers.add(new BlobReceiver(
                                 new FileOutputStream(tempFile), MAX_SHARED_FILE_BYTES));
diff --git a/components/download/content/internal/download_driver_impl.cc b/components/download/content/internal/download_driver_impl.cc
index 668ae8488d4a6..1e508ee22672e 100644
--- a/components/download/content/internal/download_driver_impl.cc
+++ b/components/download/content/internal/download_driver_impl.cc
@@ -194,6 +194,9 @@ void DownloadDriverImpl::Start(
     download_url_params->set_isolation_info(
         request_params.isolation_info.value());
   }
+  download_url_params->set_update_first_party_url_on_redirect(
+      request_params.update_first_party_url_on_redirect);
+
   download_manager_coordinator_->DownloadUrl(std::move(download_url_params));
 }
 
diff --git a/components/download/internal/common/download_utils.cc b/components/download/internal/common/download_utils.cc
index 5ef7d035418b8..8e903f83a5bbd 100644
--- a/components/download/internal/common/download_utils.cc
+++ b/components/download/internal/common/download_utils.cc
@@ -280,8 +280,10 @@ std::unique_ptr<network::ResourceRequest> CreateResourceRequest(
     // cross-site URL has been visited before.
     url::Origin origin = url::Origin::Create(params->url());
     request->trusted_params->isolation_info = net::IsolationInfo::Create(
-        net::IsolationInfo::RequestType::kMainFrame, origin, origin,
-        net::SiteForCookies::FromOrigin(origin));
+        params->update_first_party_url_on_redirect()
+            ? net::IsolationInfo::RequestType::kMainFrame
+            : net::IsolationInfo::RequestType::kOther,
+        origin, origin, net::SiteForCookies::FromOrigin(origin));
     request->site_for_cookies = net::SiteForCookies::FromUrl(params->url());
   }
 
@@ -289,7 +291,8 @@ std::unique_ptr<network::ResourceRequest> CreateResourceRequest(
   request->referrer = params->referrer();
   request->referrer_policy = params->referrer_policy();
   request->is_main_frame = true;
-  request->update_first_party_url_on_redirect = true;
+  request->update_first_party_url_on_redirect =
+      params->update_first_party_url_on_redirect();
 
   // Downloads should be treated as navigations from Fetch spec perspective.
   // See also:
diff --git a/components/download/public/background_service/download_params.h b/components/download/public/background_service/download_params.h
index 8aabeab9399d7..1e3bbb6fa317d 100644
--- a/components/download/public/background_service/download_params.h
+++ b/components/download/public/background_service/download_params.h
@@ -119,6 +119,12 @@ struct RequestParams {
   // The isolation info of the request, this won't be persisted to db and will
   // be invalidate during download resumption in new browser session.
   base::Optional<net::IsolationInfo> isolation_info;
+
+  // First-party URL redirect policy: During server redirects, whether the
+  // first-party URL for cookies will need to be changed. Download is normally
+  // considered a main frame navigation. However, this is not true for
+  // background fetch.
+  bool update_first_party_url_on_redirect = true;
 };
 
 // The parameters that describe a download request made to the DownloadService.
diff --git a/components/download/public/common/download_url_parameters.cc b/components/download/public/common/download_url_parameters.cc
index 4ae3d9b20766b..c17783c6cf860 100644
--- a/components/download/public/common/download_url_parameters.cc
+++ b/components/download/public/common/download_url_parameters.cc
@@ -33,7 +33,8 @@ DownloadUrlParameters::DownloadUrlParameters(
       transient_(false),
       traffic_annotation_(traffic_annotation),
       download_source_(DownloadSource::UNKNOWN),
-      require_safety_checks_(true) {}
+      require_safety_checks_(true),
+      update_first_party_url_on_redirect_(true) {}
 
 DownloadUrlParameters::~DownloadUrlParameters() = default;
 
diff --git a/components/download/public/common/download_url_parameters.h b/components/download/public/common/download_url_parameters.h
index 34dab4fae49fe..6b8a4c37848cb 100644
--- a/components/download/public/common/download_url_parameters.h
+++ b/components/download/public/common/download_url_parameters.h
@@ -266,6 +266,11 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadUrlParameters {
     isolation_info_ = isolation_info;
   }
 
+  void set_update_first_party_url_on_redirect(
+      bool update_first_party_url_on_redirect) {
+    update_first_party_url_on_redirect_ = update_first_party_url_on_redirect;
+  }
+
   OnStartedCallback& callback() { return callback_; }
   bool content_initiated() const { return content_initiated_; }
   const std::string& last_modified() const { return last_modified_; }
@@ -317,6 +322,9 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadUrlParameters {
   const base::Optional<net::IsolationInfo>& isolation_info() const {
     return isolation_info_;
   }
+  bool update_first_party_url_on_redirect() const {
+    return update_first_party_url_on_redirect_;
+  }
 
   // STATE CHANGING: All save_info_ sub-objects will be in an indeterminate
   // state following this call.
@@ -364,6 +372,7 @@ class COMPONENTS_DOWNLOAD_EXPORT DownloadUrlParameters {
   UploadProgressCallback upload_callback_;
   bool require_safety_checks_;
   base::Optional<net::IsolationInfo> isolation_info_;
+  bool update_first_party_url_on_redirect_;
 
   DISALLOW_COPY_AND_ASSIGN(DownloadUrlParameters);
 };
diff --git a/components/offline_pages/core/model/offline_page_model_taskified.cc b/components/offline_pages/core/model/offline_page_model_taskified.cc
index d5fe03c661f6c..7dae681d6cba7 100644
--- a/components/offline_pages/core/model/offline_page_model_taskified.cc
+++ b/components/offline_pages/core/model/offline_page_model_taskified.cc
@@ -32,8 +32,8 @@
 #include "components/offline_pages/core/model/update_publish_id_task.h"
 #include "components/offline_pages/core/model/visuals_availability_task.h"
 #include "components/offline_pages/core/offline_clock.h"
+#include "components/offline_pages/core/offline_page_archive_publisher.h"
 #include "components/offline_pages/core/offline_page_client_policy.h"
-#include "components/offline_pages/core/offline_page_feature.h"
 #include "components/offline_pages/core/offline_page_metadata_store.h"
 #include "components/offline_pages/core/offline_page_model.h"
 #include "components/offline_pages/core/offline_store_utils.h"
@@ -186,7 +186,7 @@ OfflinePageModelTaskified::OfflinePageModelTaskified(
   CreateArchivesDirectoryIfNeeded();
 }
 
-OfflinePageModelTaskified::~OfflinePageModelTaskified() {}
+OfflinePageModelTaskified::~OfflinePageModelTaskified() = default;
 
 void OfflinePageModelTaskified::AddObserver(Observer* observer) {
   observers_.AddObserver(observer);
@@ -582,9 +582,9 @@ void OfflinePageModelTaskified::OnDeleteDone(
 
   // Remove the page from the system download manager. We don't need to wait for
   // completion before calling the delete page callback.
-  task_runner_->PostTask(FROM_HERE,
-                         base::BindOnce(&OfflinePageModelTaskified::Unpublish,
-                                        archive_publisher_.get(), publish_ids));
+  task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&OfflinePageModelTaskified::Unpublish,
+                                archive_publisher_->GetWeakPtr(), publish_ids));
 
   if (!callback.is_null())
     std::move(callback).Run(result);
@@ -609,9 +609,9 @@ void OfflinePageModelTaskified::OnStoreFaviconDone(int64_t offline_id,
 }
 
 void OfflinePageModelTaskified::Unpublish(
-    OfflinePageArchivePublisher* publisher,
+    base::WeakPtr<OfflinePageArchivePublisher> publisher,
     const std::vector<PublishedArchiveId>& publish_ids) {
-  if (!publish_ids.empty())
+  if (publisher && !publish_ids.empty())
     publisher->UnpublishArchives(publish_ids);
 }
 
@@ -663,7 +663,7 @@ void OfflinePageModelTaskified::RunMaintenanceTasks(base::Time now,
 void OfflinePageModelTaskified::OnPersistentPageConsistencyCheckDone(
     bool success,
     const std::vector<PublishedArchiveId>& ids_of_deleted_pages) {
-  Unpublish(archive_publisher_.get(), ids_of_deleted_pages);
+  Unpublish(archive_publisher_->GetWeakPtr(), ids_of_deleted_pages);
 }
 
 void OfflinePageModelTaskified::OnClearCachedPagesDone(
diff --git a/components/offline_pages/core/model/offline_page_model_taskified.h b/components/offline_pages/core/model/offline_page_model_taskified.h
index f11be8da002b9..b36c35e35e0ad 100644
--- a/components/offline_pages/core/model/offline_page_model_taskified.h
+++ b/components/offline_pages/core/model/offline_page_model_taskified.h
@@ -10,19 +10,15 @@
 #include <string>
 #include <vector>
 
-#include "base/callback.h"
 #include "base/macros.h"
-#include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "base/observer_list.h"
-#include "components/keyed_service/core/keyed_service.h"
 #include "components/offline_pages/core/model/clear_storage_task.h"
 #include "components/offline_pages/core/offline_page_archive_publisher.h"
 #include "components/offline_pages/core/offline_page_archiver.h"
 #include "components/offline_pages/core/offline_page_model.h"
 #include "components/offline_pages/core/offline_page_model_event_logger.h"
 #include "components/offline_pages/core/offline_page_types.h"
-#include "components/offline_pages/core/offline_store_types.h"
 #include "components/offline_pages/task/task_queue.h"
 
 class GURL;
@@ -183,7 +179,7 @@ class OfflinePageModelTaskified : public OfflinePageModel,
                                   PublishArchiveResult publish_results);
 
   // Method for unpublishing the page from downloads.
-  static void Unpublish(OfflinePageArchivePublisher* publisher,
+  static void Unpublish(base::WeakPtr<OfflinePageArchivePublisher> publisher,
                         const std::vector<PublishedArchiveId>& publish_ids);
 
   // Other utility methods.
diff --git a/components/offline_pages/core/offline_page_archive_publisher.h b/components/offline_pages/core/offline_page_archive_publisher.h
index 5d90657449796..e4246e8ac9a31 100644
--- a/components/offline_pages/core/offline_page_archive_publisher.h
+++ b/components/offline_pages/core/offline_page_archive_publisher.h
@@ -8,7 +8,6 @@
 #include <cstdint>
 #include <string>
 
-#include "base/callback.h"
 #include "base/files/file_path.h"
 #include "components/offline_pages/core/offline_page_item.h"
 #include "components/offline_pages/core/offline_page_types.h"
@@ -61,7 +60,7 @@ class OfflinePageArchivePublisher {
       base::OnceCallback<void(const OfflinePageItem& /* offline_page */,
                               PublishArchiveResult /* archive_result */)>;
 
-  virtual ~OfflinePageArchivePublisher() {}
+  virtual ~OfflinePageArchivePublisher() = default;
 
   // Publishes the page on a background thread, then returns to the
   // OfflinePageModelTaskified's done callback.
@@ -73,6 +72,8 @@ class OfflinePageArchivePublisher {
   // Removes  archives from downloads.
   virtual void UnpublishArchives(
       const std::vector<PublishedArchiveId>& archive_ids) const = 0;
+
+  virtual base::WeakPtr<OfflinePageArchivePublisher> GetWeakPtr() = 0;
 };
 
 }  // namespace offline_pages
diff --git a/components/offline_pages/core/offline_page_test_archive_publisher.cc b/components/offline_pages/core/offline_page_test_archive_publisher.cc
index d1f774ff425d4..72fef09ce5833 100644
--- a/components/offline_pages/core/offline_page_test_archive_publisher.cc
+++ b/components/offline_pages/core/offline_page_test_archive_publisher.cc
@@ -8,12 +8,10 @@
 #include <utility>
 
 #include "base/bind.h"
-#include "base/files/file_util.h"
 #include "base/location.h"
 #include "base/single_thread_task_runner.h"
 #include "components/offline_pages/core/archive_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "url/gurl.h"
 
 namespace offline_pages {
 
@@ -69,4 +67,9 @@ void OfflinePageTestArchivePublisher::UnpublishArchives(
     last_removed_id_ = archive_ids.back();
 }
 
+base::WeakPtr<OfflinePageArchivePublisher>
+OfflinePageTestArchivePublisher::GetWeakPtr() {
+  return weak_ptr_factory_.GetWeakPtr();
+}
+
 }  // namespace offline_pages
diff --git a/components/offline_pages/core/offline_page_test_archive_publisher.h b/components/offline_pages/core/offline_page_test_archive_publisher.h
index ab285f885b72b..ca5825d211de9 100644
--- a/components/offline_pages/core/offline_page_test_archive_publisher.h
+++ b/components/offline_pages/core/offline_page_test_archive_publisher.h
@@ -8,11 +8,10 @@
 #include <cstdint>
 #include <string>
 
-#include "base/callback.h"
 #include "base/files/file_path.h"
+#include "base/memory/weak_ptr.h"
 #include "components/offline_pages/core/offline_page_archive_publisher.h"
 #include "components/offline_pages/core/offline_page_item.h"
-#include "components/offline_pages/core/offline_page_types.h"
 
 namespace base {
 class SequencedTaskRunner;
@@ -36,6 +35,8 @@ class OfflinePageTestArchivePublisher : public OfflinePageArchivePublisher {
   void UnpublishArchives(
       const std::vector<PublishedArchiveId>& archive_ids) const override;
 
+  base::WeakPtr<OfflinePageArchivePublisher> GetWeakPtr() override;
+
   void set_archive_attempt_failure(bool fail) {
     archive_attempt_failure_ = fail;
   }
@@ -57,6 +58,7 @@ class OfflinePageTestArchivePublisher : public OfflinePageArchivePublisher {
   mutable PublishedArchiveId last_removed_id_;
 
   ArchiveManager* archive_manager_;
+  base::WeakPtrFactory<OfflinePageArchivePublisher> weak_ptr_factory_{this};
 };
 
 }  // namespace offline_pages
diff --git a/components/signin/core/browser/account_reconcilor.cc b/components/signin/core/browser/account_reconcilor.cc
index 35deb4520ad36..fe9504f7be197 100644
--- a/components/signin/core/browser/account_reconcilor.cc
+++ b/components/signin/core/browser/account_reconcilor.cc
@@ -883,7 +883,7 @@ void AccountReconcilor::ScheduleStartReconcileIfChromeAccountsChanged() {
     SetState(AccountReconcilorState::ACCOUNT_RECONCILOR_SCHEDULED);
     base::ThreadTaskRunnerHandle::Get()->PostTask(
         FROM_HERE, base::BindOnce(&AccountReconcilor::StartReconcile,
-                                  base::Unretained(this)));
+                                  weak_factory_.GetWeakPtr()));
   } else if (error_during_last_reconcile_.state() ==
              GoogleServiceAuthError::NONE) {
     SetState(AccountReconcilorState::ACCOUNT_RECONCILOR_OK);
diff --git a/components/viz/common/features.cc b/components/viz/common/features.cc
index eee47ca6df4e6..32ab07f4b77e6 100644
--- a/components/viz/common/features.cc
+++ b/components/viz/common/features.cc
@@ -39,7 +39,7 @@ const base::Feature kEnableOverlayPrioritization {
 const base::Feature kUseSkiaRenderer {
   "UseSkiaRenderer",
 #if defined(OS_WIN) || defined(OS_ANDROID) || BUILDFLAG(IS_CHROMEOS_LACROS) || \
-    (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMECAST))
+    (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMECAST)) || defined(OS_OHOS)
       base::FEATURE_ENABLED_BY_DEFAULT
 #else
       base::FEATURE_DISABLED_BY_DEFAULT
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index b6aaaae0a1940..487065e8ba869 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2093,6 +2093,8 @@ source_set("browser") {
     sources += [
       "media/ohos/ohos_media_player_renderer.cc",
       "media/ohos/ohos_media_player_renderer.h",
+      "media/session/audio_focus_delegate_ohos.cc",
+      "media/session/audio_focus_delegate_ohos.h",
     ]
 
     libs = [
@@ -2196,15 +2198,15 @@ source_set("browser") {
   if (is_ohos) {
     sources += [
       "child_process_launcher_helper_linux.cc",
+      "memory/swap_metrics_driver_impl_linux.cc",
+      "memory/swap_metrics_driver_impl_linux.h",
       "sandbox_host_linux.cc",
       "sandbox_host_linux.h",
       "sandbox_ipc_linux.cc",
       "sandbox_ipc_linux.h",
+      "speech/tts_ohos.cc",
       "zygote_host/zygote_host_impl_linux.cc",
       "zygote_host/zygote_host_impl_linux.h",
-      "memory/swap_metrics_driver_impl_linux.cc",
-      "memory/swap_metrics_driver_impl_linux.h",
-      "speech/tts_ohos.cc",
     ]
 
     public_deps += [ "//components/services/font/public/mojom" ]
@@ -2744,6 +2746,10 @@ source_set("browser") {
       "webauth/virtual_fido_discovery_factory.h",
     ]
 
+    if (is_ohos) {
+      sources -= [ "media/session/audio_focus_delegate_default.cc" ]
+    }
+
     deps += [
       "//components/speech",
       "//third_party/flac",
diff --git a/content/browser/background_fetch/storage/mark_request_complete_task.cc b/content/browser/background_fetch/storage/mark_request_complete_task.cc
index 4881159cd8e2a..987f3c3eefa06 100644
--- a/content/browser/background_fetch/storage/mark_request_complete_task.cc
+++ b/content/browser/background_fetch/storage/mark_request_complete_task.cc
@@ -101,6 +101,8 @@ void MarkRequestCompleteTask::StoreResponse(base::OnceClosure done_closure) {
   BackgroundFetchCrossOriginFilter filter(registration_id_.origin(),
                                           *request_info_);
   if (!filter.CanPopulateBody()) {
+    // Don't expose the initial URL in case of cross-origin redirects.
+    response_->url_list.resize(1);
     failure_reason_ = proto::BackgroundFetchRegistration::FETCH_ERROR;
     // No point writing the response to the cache since it won't be exposed.
     CreateAndStoreCompletedRequest(std::move(done_closure));
diff --git a/content/browser/bad_message.h b/content/browser/bad_message.h
index 583e54e218440..6b961c5c99eb2 100644
--- a/content/browser/bad_message.h
+++ b/content/browser/bad_message.h
@@ -269,6 +269,9 @@ enum BadMessageReason {
   PAYMENTS_WITHOUT_PERMISSION = 241,
   WEB_BUNDLE_INVALID_NAVIGATION_URL = 242,
   RFH_CREATE_CHILD_FRAME_SANDBOX_FLAGS = 254,
+  PMM_SUBSCRIBE_INVALID_ORIGIN = 259,
+  PMM_UNSUBSCRIBE_INVALID_ORIGIN = 260,
+  PMM_GET_SUBSCRIPTION_INVALID_ORIGIN = 261,
 
   // Please add new elements here. The naming convention is abbreviated class
   // name (e.g. RenderFrameHost becomes RFH) plus a unique description of the
diff --git a/content/browser/browser_interface_binders.cc b/content/browser/browser_interface_binders.cc
index 8ba6265041c65..cd370aaba3e99 100644
--- a/content/browser/browser_interface_binders.cc
+++ b/content/browser/browser_interface_binders.cc
@@ -668,6 +668,9 @@ void PopulateFrameBinders(RenderFrameHostImpl* host, mojo::BinderMap* map) {
 #if !defined(OS_ANDROID)
   map->Add<blink::mojom::DeviceAPIService>(base::BindRepeating(
       &RenderFrameHostImpl::GetDeviceInfoService, base::Unretained(host)));
+  map->Add<blink::mojom::ManagedConfigurationService>(
+      base::BindRepeating(&RenderFrameHostImpl::GetManagedConfigurationService,
+                          base::Unretained(host)));
 #endif  // !defined(OS_ANDROID)
 
   map->Add<blink::mojom::ScreenEnumeration>(
diff --git a/content/browser/cross_origin_opener_policy_browsertest.cc b/content/browser/cross_origin_opener_policy_browsertest.cc
index 1739c08c2a913..f210232592096 100644
--- a/content/browser/cross_origin_opener_policy_browsertest.cc
+++ b/content/browser/cross_origin_opener_policy_browsertest.cc
@@ -11,6 +11,7 @@
 #include "content/browser/renderer_host/render_process_host_impl.h"
 #include "content/browser/web_contents/web_contents_impl.h"
 #include "content/common/content_navigation_policy.h"
+#include "content/public/browser/site_isolation_policy.h"
 #include "content/public/common/content_features.h"
 #include "content/public/test/browser_test.h"
 #include "content/public/test/content_browser_test.h"
@@ -2496,6 +2497,104 @@ IN_PROC_BROWSER_TEST_P(CrossOriginOpenerPolicyBrowserTest,
   )"));
 }
 
+// This test is a reproducer for https://crbug.com/1305394.
+IN_PROC_BROWSER_TEST_P(CrossOriginOpenerPolicyBrowserTest,
+                       CrossOriginIframeCoopBypass) {
+  // This test requires that a cross-origin iframe be placed in its own
+  // process. It is irrelevant without strict site isolation.
+  if (!SiteIsolationPolicy::UseDedicatedProcessesForAllSites())
+    return;
+
+  GURL non_coop_page(https_server()->GetURL("a.test", "/title1.html"));
+  GURL cross_origin_non_coop_page(
+      https_server()->GetURL("b.test", "/title1.html"));
+  GURL coop_page(https_server()->GetURL(
+      "a.test", "/set-header?cross-origin-opener-policy: same-origin"));
+
+  // Get an initial non-COOP page with an empty popup.
+  EXPECT_TRUE(NavigateToURL(shell(), non_coop_page));
+  RenderFrameHostImpl* initial_main_rfh = current_frame_host();
+
+  ShellAddedObserver shell_observer;
+  EXPECT_TRUE(
+      ExecJs(initial_main_rfh, JsReplace("window.open($1)", non_coop_page)));
+  WebContentsImpl* popup =
+      static_cast<WebContentsImpl*>(shell_observer.GetShell()->web_contents());
+  RenderFrameHostImpl* popup_rfh = popup->GetMainFrame();
+
+  // At this stage we have a single SiteInstance used both for the main page and
+  // the same-site popup.
+  SiteInstanceImpl* initial_main_si = initial_main_rfh->GetSiteInstance();
+  SiteInstanceImpl* popup_si = popup_rfh->GetSiteInstance();
+  EXPECT_EQ(initial_main_si, popup_si);
+  RenderProcessHost* process_A = initial_main_si->GetProcess();
+
+  // The popup then navigates the opener to a COOP page.
+  EXPECT_TRUE(ExecJs(popup_rfh, JsReplace("opener.location = $1", coop_page)));
+  EXPECT_TRUE(WaitForLoadStop(web_contents()));
+
+  // This should trigger a BrowsingInstance swap. The main frame gets a new
+  // unrelated BrowsingInstance, and clears the opener.
+  // Note: We need to wait for the RenderView deletion to be propagated in the
+  // renderer for window.opener to be cleared. To avoid flakes, we check the
+  // opener at the end of this test.
+  RenderFrameHostImpl* main_rfh = current_frame_host();
+  SiteInstanceImpl* main_si = main_rfh->GetSiteInstance();
+  RenderProcessHost* process_B = main_si->GetProcess();
+  EXPECT_FALSE(popup_si->IsRelatedSiteInstance(main_si));
+
+  // The popup still uses process A, but the main page now uses a different
+  // process. No proxy should remain between the two site instances as the
+  // opener link has been cut.
+  EXPECT_EQ(process_A, popup_si->GetProcess());
+  EXPECT_NE(process_B, process_A);
+  EXPECT_TRUE(popup_rfh->frame_tree_node()
+                  ->render_manager()
+                  ->GetAllProxyHostsForTesting()
+                  .empty());
+  EXPECT_TRUE(main_rfh->frame_tree_node()
+                  ->render_manager()
+                  ->GetAllProxyHostsForTesting()
+                  .empty());
+
+  // Load an iframe that is cross-origin to the top frame's opener.
+  ASSERT_TRUE(ExecJs(popup_rfh, JsReplace(R"(
+    const frame = document.createElement('iframe');
+    frame.src = $1;
+    document.body.appendChild(frame);
+  )",
+                                          cross_origin_non_coop_page)));
+  EXPECT_TRUE(WaitForLoadStop(popup));
+  RenderFrameHostImpl* iframe_rfh =
+      popup_rfh->child_at(0)->current_frame_host();
+  SiteInstanceImpl* iframe_si = iframe_rfh->GetSiteInstance();
+
+  // The iframe being cross-origin, it is put in a different but related
+  // SiteInstance.
+  EXPECT_TRUE(iframe_si->IsRelatedSiteInstance(popup_si));
+  EXPECT_FALSE(iframe_si->IsRelatedSiteInstance(main_si));
+
+  // We end up with the main window, the main popup frame and the iframe all
+  // living in their own process. We should only have proxies from the popup
+  // main frame to iframe and vice versa. Opener links should stay severed.
+  RenderProcessHost* process_C = iframe_si->GetProcess();
+  EXPECT_NE(process_C, process_A);
+  EXPECT_NE(process_C, process_B);
+  EXPECT_EQ(1u, iframe_rfh->frame_tree_node()
+                    ->render_manager()
+                    ->GetAllProxyHostsForTesting()
+                    .size());
+  EXPECT_EQ(1u, popup_rfh->frame_tree_node()
+                    ->render_manager()
+                    ->GetAllProxyHostsForTesting()
+                    .size());
+
+  // The opener should not be reachable either from the popup main frame nor the
+  // popup iframe.
+  EXPECT_EQ(true, EvalJs(popup_rfh, "opener == null"));
+  EXPECT_EQ(true, EvalJs(iframe_rfh, "parent.opener == null"));
+}
+
 // TODO(https://crbug.com/1101339). Test inheritance of the virtual browsing
 // context group when using window.open from an iframe, same-origin and
 // cross-origin.
diff --git a/content/browser/download/download_browsertest.cc b/content/browser/download/download_browsertest.cc
index fcfe6a07228a0..d68823a295538 100644
--- a/content/browser/download/download_browsertest.cc
+++ b/content/browser/download/download_browsertest.cc
@@ -3596,6 +3596,58 @@ IN_PROC_BROWSER_TEST_F(DownloadContentTest, UpdateSiteForCookies) {
                                 site_a.GetURL("a.test", "/")));
 }
 
+// Tests that if `update_first_party_url_on_redirect` is set to false, download
+// will not behave like a top-level frame navigation and SameSite=Strict cookies
+// will not be set on a redirection.
+IN_PROC_BROWSER_TEST_F(
+    DownloadContentTest,
+    SiteForCookies_DownloadUrl_NotUpdateFirstPartyUrlOnRedirect) {
+  net::EmbeddedTestServer site_a;
+  net::EmbeddedTestServer site_b;
+
+  base::StringPairs cookie_headers;
+  cookie_headers.push_back(std::make_pair(
+      std::string("Set-Cookie"), std::string("A=strict; SameSite=Strict")));
+  cookie_headers.push_back(std::make_pair(std::string("Set-Cookie"),
+                                          std::string("B=lax; SameSite=Lax")));
+
+  // This will request a URL on b.test, which redirects to a url that sets the
+  // cookies on a.test.
+  site_a.RegisterRequestHandler(CreateBasicResponseHandler(
+      "/sets-samesite-cookies", net::HTTP_OK, cookie_headers,
+      "application/octet-stream", "abcd"));
+  ASSERT_TRUE(site_a.Start());
+  site_b.RegisterRequestHandler(
+      CreateRedirectHandler("/redirected-download",
+                            site_a.GetURL("a.test", "/sets-samesite-cookies")));
+  ASSERT_TRUE(site_b.Start());
+
+  // Download the file.
+  SetupEnsureNoPendingDownloads();
+  std::unique_ptr<download::DownloadUrlParameters> download_parameters(
+      DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(
+          shell()->web_contents(),
+          site_b.GetURL("b.test", "/redirected-download"),
+          TRAFFIC_ANNOTATION_FOR_TESTS));
+  download_parameters->set_update_first_party_url_on_redirect(false);
+  std::unique_ptr<DownloadTestObserver> observer(CreateWaiter(shell(), 1));
+  DownloadManagerForShell(shell())->DownloadUrl(std::move(download_parameters));
+  observer->WaitForFinished();
+
+  // Get the important info from other threads and check it.
+  EXPECT_TRUE(EnsureNoPendingDownloads());
+
+  std::vector<download::DownloadItem*> downloads;
+  DownloadManagerForShell(shell())->GetAllDownloads(&downloads);
+  ASSERT_EQ(1u, downloads.size());
+  ASSERT_EQ(download::DownloadItem::COMPLETE, downloads[0]->GetState());
+
+  // Check that the cookies were not set on a.test.
+  EXPECT_EQ("",
+            content::GetCookies(shell()->web_contents()->GetBrowserContext(),
+                                site_a.GetURL("a.test", "/")));
+}
+
 // Verifies that isolation info set in DownloadUrlParameters can be populated.
 IN_PROC_BROWSER_TEST_F(DownloadContentTest,
                        SiteForCookies_DownloadUrl_IsolationInfoPopulated) {
diff --git a/content/browser/file_system_access/file_system_chooser.cc b/content/browser/file_system_access/file_system_chooser.cc
index dc02983400070..98d8323fa8a7e 100644
--- a/content/browser/file_system_access/file_system_chooser.cc
+++ b/content/browser/file_system_access/file_system_chooser.cc
@@ -278,13 +278,15 @@ bool FileSystemChooser::IsShellIntegratedExtension(
   base::FilePath::StringType extension_lower =
       base::ToLowerASCII(GetLastExtension(extension));
 
-  // .lnk and .scf files may be used to execute arbitrary code (see
+  // '.lnk' and '.scf' files may be used to execute arbitrary code (see
   // https://nvd.nist.gov/vuln/detail/CVE-2010-2568 and
-  // https://crbug.com/1227995, respectively). .local files are used by Windows
-  // to determine which DLLs to load for an application.
+  // https://crbug.com/1227995, respectively). '.local' files are used by
+  // Windows to determine which DLLs to load for an application. '.url' files
+  // can be used to read arbirtary files (see https://crbug.com/1307930).
   if ((extension_lower == FILE_PATH_LITERAL("lnk")) ||
       (extension_lower == FILE_PATH_LITERAL("local")) ||
-      (extension_lower == FILE_PATH_LITERAL("scf"))) {
+      (extension_lower == FILE_PATH_LITERAL("scf")) ||
+      (extension_lower == FILE_PATH_LITERAL("url"))) {
     return true;
   }
 
diff --git a/content/browser/file_system_access/file_system_chooser_browsertest.cc b/content/browser/file_system_access/file_system_chooser_browsertest.cc
index f65ef61e4cb85..7611a6c5fc06a 100644
--- a/content/browser/file_system_access/file_system_chooser_browsertest.cc
+++ b/content/browser/file_system_access/file_system_chooser_browsertest.cc
@@ -1321,13 +1321,21 @@ IN_PROC_BROWSER_TEST_F(FileSystemChooserBrowserTest, SuggestedName) {
   name_infos.push_back({"not_matching.jpg", ListValueOf(".txt"), false,
                         "not_matching.jpg", false});
 
-  // ".lnk", ".local", and ".scf" extensions should be sanitized.
-  name_infos.push_back({"dangerous_extension.local", ListValueOf(".local"),
-                        true, "dangerous_extension.download", false});
+  // ".lnk", ".local", ".scf", and ".url" extensions should be sanitized.
   name_infos.push_back({"dangerous_extension.lnk", ListValueOf(".lnk"), true,
                         "dangerous_extension.download", false});
+  name_infos.push_back({"dangerous_extension.lnk", ListValueOf(".LNK"), true,
+                        "dangerous_extension.download", false});
+  name_infos.push_back({"dangerous_extension.LNK", ListValueOf(".lnk"), true,
+                        "dangerous_extension.download", false});
+  name_infos.push_back({"dangerous_extension.LNK", ListValueOf(".LNK"), true,
+                        "dangerous_extension.download", false});
+  name_infos.push_back({"dangerous_extension.local", ListValueOf(".local"),
+                        true, "dangerous_extension.download", false});
   name_infos.push_back({"dangerous_extension.scf", ListValueOf(".scf"), true,
                         "dangerous_extension.download", false});
+  name_infos.push_back({"dangerous_extension.url", ListValueOf(".url"), true,
+                        "dangerous_extension.download", false});
   // Compound extensions ending in a dangerous extension should be sanitized.
   name_infos.push_back({"dangerous_extension.png.local", ListValueOf(".local"),
                         true, "dangerous_extension.png.download", false});
@@ -1335,6 +1343,8 @@ IN_PROC_BROWSER_TEST_F(FileSystemChooserBrowserTest, SuggestedName) {
                         true, "dangerous_extension.png.download", false});
   name_infos.push_back({"dangerous_extension.png.scf", ListValueOf(".scf"),
                         true, "dangerous_extension.png.download", false});
+  name_infos.push_back({"dangerous_extension.png.url", ListValueOf(".url"),
+                        true, "dangerous_extension.png.download", false});
   // Compound extensions not ending in a dangerous extension should not be
   // sanitized.
   name_infos.push_back({"dangerous_extension.local.png", ListValueOf(".png"),
@@ -1343,6 +1353,8 @@ IN_PROC_BROWSER_TEST_F(FileSystemChooserBrowserTest, SuggestedName) {
                         true, "dangerous_extension.lnk.png", true});
   name_infos.push_back({"dangerous_extension.scf.png", ListValueOf(".png"),
                         true, "dangerous_extension.scf.png", true});
+  name_infos.push_back({"dangerous_extension.url.png", ListValueOf(".png"),
+                        true, "dangerous_extension.url.png", true});
   // Invalid characters should be sanitized.
   name_infos.push_back({R"(inv*l:d\\char!a<ters.txt)",
                         ListValueOf(".txt"), true,
diff --git a/content/browser/file_system_access/file_system_chooser_unittest.cc b/content/browser/file_system_access/file_system_chooser_unittest.cc
index e684acb8d4c29..f58449d125fe4 100644
--- a/content/browser/file_system_access/file_system_chooser_unittest.cc
+++ b/content/browser/file_system_access/file_system_chooser_unittest.cc
@@ -189,7 +189,7 @@ TEST_F(FileSystemChooserTest, IgnoreShellIntegratedExtensions) {
   accepts.emplace_back(blink::mojom::ChooseFileSystemEntryAcceptsOption::New(
       base::ASCIIToUTF16(""), std::vector<std::string>({}),
       std::vector<std::string>(
-          {"lnk", "foo.lnk", "foo.bar.local", "text", "local", "scf"})));
+          {"lnk", "foo.lnk", "foo.bar.local", "text", "local", "scf", "url"})));
   SyncShowDialog(std::move(accepts), /*include_accepts_all=*/false);
 
   ASSERT_TRUE(dialog_params.file_types);
diff --git a/content/browser/indexed_db/indexed_db_context_impl.cc b/content/browser/indexed_db/indexed_db_context_impl.cc
index e8e2b1846a398..0cb42655fc869 100644
--- a/content/browser/indexed_db/indexed_db_context_impl.cc
+++ b/content/browser/indexed_db/indexed_db_context_impl.cc
@@ -116,7 +116,7 @@ void GetAllOriginsAndPaths(const base::FilePath& indexeddb_path,
 // static
 void IndexedDBContextImpl::ReleaseOnIDBSequence(
     scoped_refptr<IndexedDBContextImpl>&& context) {
-  if (!context->idb_task_runner_->RunsTasksInCurrentSequence()) {
+  if (!context->IDBTaskRunner()->RunsTasksInCurrentSequence()) {
     IndexedDBContextImpl* context_ptr = context.get();
     context_ptr->IDBTaskRunner()->ReleaseSoon(FROM_HERE, std::move(context));
   }
@@ -164,37 +164,32 @@ IndexedDBContextImpl::IndexedDBContextImpl(
       storage::QuotaClientType::kIndexedDatabase,
       {blink::mojom::StorageType::kTemporary});
 
-  // This is safe because the IndexedDBContextImpl must be destructed on the
-  // IDBTaskRunner, and this task will always happen before that.
-  idb_task_runner_->PostTask(
-      FROM_HERE,
-      base::BindOnce(
-          [](mojo::Remote<storage::mojom::BlobStorageContext>*
-                 blob_storage_context,
-             mojo::Remote<storage::mojom::FileSystemAccessContext>*
-                 file_system_access_context,
-             mojo::Receiver<storage::mojom::QuotaClient>* quota_client_receiver,
-             mojo::PendingRemote<storage::mojom::BlobStorageContext>
-                 pending_blob_storage_context,
-             mojo::PendingRemote<storage::mojom::FileSystemAccessContext>
-                 pending_file_system_access_context,
-             mojo::PendingReceiver<storage::mojom::QuotaClient>
-                 quota_client_pending_receiver) {
-            quota_client_receiver->Bind(
-                std::move(quota_client_pending_receiver));
-            if (pending_blob_storage_context) {
-              blob_storage_context->Bind(
-                  std::move(pending_blob_storage_context));
-            }
-            if (pending_file_system_access_context) {
-              file_system_access_context->Bind(
-                  std::move(pending_file_system_access_context));
-            }
-          },
-          &blob_storage_context_, &file_system_access_context_,
-          &quota_client_receiver_, std::move(blob_storage_context),
-          std::move(file_system_access_context),
-          std::move(quota_client_receiver)));
+  IDBTaskRunner()->PostTask(
+      FROM_HERE, base::BindOnce(&IndexedDBContextImpl::BindPipesOnIDBSequence,
+                                weak_factory_.GetWeakPtr(),
+                                std::move(quota_client_receiver),
+                                std::move(blob_storage_context),
+                                std::move(file_system_access_context)));
+}
+
+void IndexedDBContextImpl::BindPipesOnIDBSequence(
+    mojo::PendingReceiver<storage::mojom::QuotaClient>
+        pending_quota_client_receiver,
+    mojo::PendingRemote<storage::mojom::BlobStorageContext>
+        pending_blob_storage_context,
+    mojo::PendingRemote<storage::mojom::FileSystemAccessContext>
+        pending_file_system_access_context) {
+  DCHECK(IDBTaskRunner()->RunsTasksInCurrentSequence());
+  if (pending_quota_client_receiver) {
+    quota_client_receiver_.Bind(std::move(pending_quota_client_receiver));
+  }
+  if (pending_blob_storage_context) {
+    blob_storage_context_.Bind(std::move(pending_blob_storage_context));
+  }
+  if (pending_file_system_access_context) {
+    file_system_access_context_.Bind(
+        std::move(pending_file_system_access_context));
+  }
 }
 
 void IndexedDBContextImpl::Bind(
@@ -453,7 +448,7 @@ void IndexedDBContextImpl::GetAllOriginsDetails(
 }
 
 void IndexedDBContextImpl::SetForceKeepSessionState() {
-  idb_task_runner_->PostTask(
+  IDBTaskRunner()->PostTask(
       FROM_HERE,
       base::BindOnce(
           [](IndexedDBContextImpl* context) {
@@ -838,7 +833,7 @@ IndexedDBContextImpl::~IndexedDBContextImpl() {
 }
 
 void IndexedDBContextImpl::ShutdownOnIDBSequence() {
-  DCHECK(idb_task_runner_->RunsTasksInCurrentSequence());
+  DCHECK(IDBTaskRunner()->RunsTasksInCurrentSequence());
 
   if (force_keep_session_state_)
     return;
@@ -870,7 +865,7 @@ void IndexedDBContextImpl::Shutdown() {
   if (is_incognito())
     return;
 
-  idb_task_runner_->PostTask(
+  IDBTaskRunner()->PostTask(
       FROM_HERE, base::BindOnce(&IndexedDBContextImpl::ShutdownOnIDBSequence,
                                 base::WrapRefCounted(this)));
 }
diff --git a/content/browser/indexed_db/indexed_db_context_impl.h b/content/browser/indexed_db/indexed_db_context_impl.h
index 2ddd0fd64063a..a479f6098eada 100644
--- a/content/browser/indexed_db/indexed_db_context_impl.h
+++ b/content/browser/indexed_db/indexed_db_context_impl.h
@@ -217,6 +217,14 @@ class CONTENT_EXPORT IndexedDBContextImpl
 
   ~IndexedDBContextImpl() override;
 
+  void BindPipesOnIDBSequence(
+      mojo::PendingReceiver<storage::mojom::QuotaClient>
+          pending_quota_client_receiver,
+      mojo::PendingRemote<storage::mojom::BlobStorageContext>
+          pending_blob_storage_context,
+      mojo::PendingRemote<storage::mojom::FileSystemAccessContext>
+          pending_file_system_access_context);
+
   void ShutdownOnIDBSequence();
 
   base::FilePath GetBlobStorePath(const url::Origin& origin) const;
@@ -268,6 +276,10 @@ class CONTENT_EXPORT IndexedDBContextImpl
   mojo::Receiver<storage::mojom::QuotaClient> quota_client_receiver_;
   const std::unique_ptr<storage::FilesystemProxy> filesystem_proxy_;
 
+  // weak_factory_->GetWeakPtr() may be used on any thread, but the resulting
+  // pointer must only be checked/used on idb_task_runner_.
+  base::WeakPtrFactory<IndexedDBContextImpl> weak_factory_{this};
+
   DISALLOW_COPY_AND_ASSIGN(IndexedDBContextImpl);
 };
 
diff --git a/content/browser/media/ohos/ohos_media_player_renderer.cc b/content/browser/media/ohos/ohos_media_player_renderer.cc
index 965ffc4a15e55..654446d9bf62b 100644
--- a/content/browser/media/ohos/ohos_media_player_renderer.cc
+++ b/content/browser/media/ohos/ohos_media_player_renderer.cc
@@ -65,7 +65,11 @@ void OHOSMediaPlayerRenderer::CreateMediaPlayer(
   init_cb_ = std::move(init_cb);
   int32_t ret = media_player_->Initialize();
   if (ret != 0) {
+    LOG(ERROR) << "media player Initialize failed";
     std::move(init_cb_).Run(media::PIPELINE_ERROR_INITIALIZATION_FAILED);
+  } else {
+    initialized_ = true;
+    std::move(init_cb_).Run(media::PIPELINE_OK);
   }
 }
 
@@ -106,7 +110,6 @@ void OHOSMediaPlayerRenderer::SetPlaybackRate(double playback_rate) {
     media_player_->SetPlaybackSpeed(mode);
     media_player_->Start();
   }
-  OnMediaDurationChanged(media_player_->GetDuration());
 }
 
 void OHOSMediaPlayerRenderer::InitiateScopedSurfaceRequest(
@@ -177,16 +180,6 @@ void OHOSMediaPlayerRenderer::OnVideoSizeChanged(int width, int height) {
   }
 }
 
-void OHOSMediaPlayerRenderer::OnPlayerPrepared(int status) {
-  if (status == 0) {
-    UpdateVolume();
-    std::move(init_cb_).Run(media::PIPELINE_OK);
-    initialized_ = true;
-  } else {
-    std::move(init_cb_).Run(media::PIPELINE_ERROR_INITIALIZATION_FAILED);
-  }
-}
-
 void OHOSMediaPlayerRenderer::SetVolume(float volume) {
   volume_ = volume;
   UpdateVolume();
diff --git a/content/browser/media/ohos/ohos_media_player_renderer.h b/content/browser/media/ohos/ohos_media_player_renderer.h
index ff0fb383557d4..8d665aab3ab83 100644
--- a/content/browser/media/ohos/ohos_media_player_renderer.h
+++ b/content/browser/media/ohos/ohos_media_player_renderer.h
@@ -67,7 +67,6 @@ class CONTENT_EXPORT OHOSMediaPlayerRenderer
   void OnPlaybackComplete() override;
   void OnError(int error) override;
   void OnVideoSizeChanged(int width, int height) override;
-  void OnPlayerPrepared(int status) override;
 
   // media::mojom::MediaPlayerRendererExtension implementation.
   //
diff --git a/content/browser/media/session/audio_focus_delegate_ohos.cc b/content/browser/media/session/audio_focus_delegate_ohos.cc
new file mode 100644
index 0000000000000..1daa5dc60f2fe
--- /dev/null
+++ b/content/browser/media/session/audio_focus_delegate_ohos.cc
@@ -0,0 +1,90 @@
+// Copyright 2022 The Huawei Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/media/session/audio_focus_delegate_ohos.h"
+
+#include "audio_renderer_adapter.h"
+#include "audio_system_manager_adapter.h"
+#include "content/browser/media/session/media_session_impl.h"
+#include "media/base/media_switches.h"
+#include "ohos_adapter_helper.h"
+
+namespace content {
+static constexpr AudioAdapterInterrupt kAudioInterrupt = {
+    .streamUsage = AudioAdapterStreamUsage::STREAM_USAGE_MEDIA,
+    .contentType = AudioAdapterContentType::CONTENT_TYPE_MUSIC,
+    .streamType = AudioAdapterStreamType::STREAM_MUSIC};
+
+AudioManagerCallback::AudioManagerCallback(MediaSessionImpl* media_session)
+    : media_session_(media_session) {}
+
+AudioManagerCallback::~AudioManagerCallback() {}
+
+void AudioManagerCallback::OnSuspend() {
+  if (!media_session_->IsActive() ||
+      !base::FeatureList::IsEnabled(media::kAudioFocusLossSuspendMediaSession))
+    return;
+
+  media_session_->Suspend(MediaSession::SuspendType::kSystem);
+}
+
+void AudioManagerCallback::OnResume() {
+  if (!media_session_->IsSuspended())
+    return;
+
+  media_session_->Resume(MediaSession::SuspendType::kSystem);
+}
+
+AudioFocusDelegateOHOS::AudioFocusDelegateOHOS(MediaSessionImpl* media_session)
+    : media_session_(media_session) {}
+
+AudioFocusDelegateOHOS::~AudioFocusDelegateOHOS() {}
+
+AudioFocusDelegate::AudioFocusResult AudioFocusDelegateOHOS::RequestAudioFocus(
+    media_session::mojom::AudioFocusType audio_focus_type) {
+  int32_t ret = OhosAdapterHelper::GetInstance()
+                    .GetAudioSystemManager()
+                    .RequestAudioFocus(kAudioInterrupt);
+  if (ret != AudioAdapterCode::AUDIO_OK) {
+    LOG(ERROR) << "request audio focus failed";
+    return AudioFocusDelegate::AudioFocusResult::kFailed;
+  }
+
+  if (!cb_) {
+    cb_ = std::make_shared<AudioManagerCallback>(media_session_);
+    ret = OhosAdapterHelper::GetInstance()
+              .GetAudioSystemManager()
+              .SetAudioManagerInterruptCallback(cb_);
+    if (ret != AudioAdapterCode::AUDIO_OK) {
+      LOG(ERROR) << "set audio interrupt callback failed";
+      cb_.reset();
+      return AudioFocusDelegate::AudioFocusResult::kFailed;
+    }
+  }
+
+  return AudioFocusDelegate::AudioFocusResult::kSuccess;
+}
+
+void AudioFocusDelegateOHOS::AbandonAudioFocus() {
+  (void)OhosAdapterHelper::GetInstance()
+      .GetAudioSystemManager()
+      .AbandonAudioFocus(kAudioInterrupt);
+}
+
+base::Optional<media_session::mojom::AudioFocusType>
+AudioFocusDelegateOHOS::GetCurrentFocusType() const {
+  return media_session::mojom::AudioFocusType::kGain;
+}
+
+const base::UnguessableToken& AudioFocusDelegateOHOS::request_id() const {
+  return base::UnguessableToken::Null();
+}
+
+// static
+std::unique_ptr<AudioFocusDelegate> AudioFocusDelegate::Create(
+    MediaSessionImpl* media_session) {
+  AudioFocusDelegateOHOS* delegate = new AudioFocusDelegateOHOS(media_session);
+  return std::unique_ptr<AudioFocusDelegate>(delegate);
+}
+}  // namespace content
\ No newline at end of file
diff --git a/content/browser/media/session/audio_focus_delegate_ohos.h b/content/browser/media/session/audio_focus_delegate_ohos.h
new file mode 100644
index 0000000000000..b818bb51efd1d
--- /dev/null
+++ b/content/browser/media/session/audio_focus_delegate_ohos.h
@@ -0,0 +1,55 @@
+// Copyright 2022 The Huawei Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_MEDIA_SESSION_AUDIO_FOCUS_DELEGATE_OHOS_H_
+#define CONTENT_BROWSER_MEDIA_SESSION_AUDIO_FOCUS_DELEGATE_OHOS_H_
+
+#include "audio_system_manager_adapter.h"
+#include "content/browser/media/session/audio_focus_delegate.h"
+
+namespace media_session {
+namespace mojom {
+enum class AudioFocusType;
+}  // namespace mojom
+}  // namespace media_session
+
+namespace content {
+using namespace OHOS::NWeb;
+class AudioFocusDelegateOHOS;
+
+class AudioManagerCallback : public AudioManagerCallbackAdapter {
+ public:
+  AudioManagerCallback(MediaSessionImpl* media_session);
+  ~AudioManagerCallback();
+  void OnSuspend() override;
+  void OnResume() override;
+
+ private:
+  MediaSessionImpl* media_session_;
+};
+
+class AudioFocusDelegateOHOS : public AudioFocusDelegate {
+ public:
+  explicit AudioFocusDelegateOHOS(MediaSessionImpl* media_session);
+  ~AudioFocusDelegateOHOS() override;
+
+  AudioFocusResult RequestAudioFocus(
+      media_session::mojom::AudioFocusType audio_focus_type) override;
+  void AbandonAudioFocus() override;
+  base::Optional<media_session::mojom::AudioFocusType> GetCurrentFocusType()
+      const override;
+  const base::UnguessableToken& request_id() const override;
+  // This is not used by this delegate.
+  void MediaSessionInfoChanged(
+      media_session::mojom::MediaSessionInfoPtr) override {}
+
+ private:
+  MediaSessionImpl* media_session_ = nullptr;
+  std::shared_ptr<AudioManagerCallback> cb_ = nullptr;
+  DISALLOW_COPY_AND_ASSIGN(AudioFocusDelegateOHOS);
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_MEDIA_SESSION_AUDIO_FOCUS_DELEGATE_OHOS_H_
diff --git a/content/browser/message_port_provider.cc b/content/browser/message_port_provider.cc
index 00f6d69705986..f056f234996ac 100644
--- a/content/browser/message_port_provider.cc
+++ b/content/browser/message_port_provider.cc
@@ -73,6 +73,24 @@ void MessagePortProvider::PostMessageToFrame(
                              std::vector<blink::MessagePortDescriptor>());
 }
 
+// static
+#if defined(OS_OHOS)
+void MessagePortProvider::OhosPostMessageToFrame(
+        WebContents* web_contents,
+        const std::u16string& source_origin,
+        const std::u16string& target_origin,
+        const std::u16string& data,
+        std::vector<blink::WebMessagePort>& ports) {
+    LOG(INFO) <<"JSAPI OhosPostMessageToFrame";
+    // Extract the underlying descriptors.
+    std::vector<blink::MessagePortDescriptor> descriptors;
+    for (size_t i = 0; i < ports.size(); ++i) {
+      descriptors.push_back(ports[i].PassPort());
+    }
+    PostMessageToFrameInternal(web_contents, source_origin, target_origin, data, std::move(descriptors));
+}
+#endif
+
 #if defined(OS_ANDROID)
 void MessagePortProvider::PostMessageToFrame(
     WebContents* web_contents,
diff --git a/content/browser/push_messaging/push_messaging_manager.cc b/content/browser/push_messaging/push_messaging_manager.cc
index d39de525ab3f1..c4eb17855a5d7 100644
--- a/content/browser/push_messaging/push_messaging_manager.cc
+++ b/content/browser/push_messaging/push_messaging_manager.cc
@@ -19,6 +19,8 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/task/post_task.h"
 #include "base/time/time.h"
+#include "content/browser/bad_message.h"
+#include "content/browser/child_process_security_policy_impl.h"
 #include "content/browser/permissions/permission_controller_impl.h"
 #include "content/browser/renderer_host/render_process_host_impl.h"
 #include "content/browser/service_worker/service_worker_context_core.h"
@@ -35,6 +37,7 @@
 #include "third_party/blink/public/mojom/permissions/permission_status.mojom.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging.mojom.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom.h"
+#include "url/origin.h"
 
 namespace content {
 
@@ -204,6 +207,10 @@ class PushMessagingManager::Core {
   // only be called from the outer class's constructor).
   base::WeakPtr<Core> GetWeakPtrFromIOParentConstructor();
 
+  int GetRenderProceesId() {
+    return render_process_id_;
+  }
+
  private:
   friend struct BrowserThread::DeleteOnThread<BrowserThread::UI>;
   friend class base::DeleteHelper<Core>;
@@ -302,7 +309,6 @@ void PushMessagingManager::Subscribe(
   DCHECK_CURRENTLY_ON(ServiceWorkerContext::GetCoreThreadId());
   DCHECK(options);
 
-  // TODO(mvanouwerkerk): Validate arguments?
   RegisterData data;
 
   data.service_worker_registration_id = service_worker_registration_id;
@@ -320,7 +326,17 @@ void PushMessagingManager::Subscribe(
         blink::mojom::PushRegistrationStatus::NO_SERVICE_WORKER);
     return;
   }
-  data.requesting_origin = service_worker_registration->scope().GetOrigin();
+
+  GURL origin = service_worker_registration->scope().GetOrigin();
+
+  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanAccessDataForOrigin(
+          ui_core_->GetRenderProceesId(), url::Origin::Create(origin))) {
+    bad_message::ReceivedBadMessage(ui_core_->GetRenderProceesId(),
+                                    bad_message::PMM_SUBSCRIBE_INVALID_ORIGIN);
+    return;
+  }
+
+  data.requesting_origin = std::move(origin);
 
   DCHECK(!(data.options->application_server_key.empty() &&
            IsRequestFromDocument(render_frame_id_)));
@@ -646,12 +662,20 @@ void PushMessagingManager::Unsubscribe(int64_t service_worker_registration_id,
     return;
   }
 
+  GURL origin = service_worker_registration->scope().GetOrigin();
+
+  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanAccessDataForOrigin(
+          ui_core_->GetRenderProceesId(), url::Origin::Create(origin))) {
+    bad_message::ReceivedBadMessage(
+        ui_core_->GetRenderProceesId(), bad_message::PMM_UNSUBSCRIBE_INVALID_ORIGIN);
+    return;
+  }
+
   service_worker_context_->GetRegistrationUserData(
       service_worker_registration_id, {kPushSenderIdServiceWorkerKey},
       base::BindOnce(&PushMessagingManager::UnsubscribeHavingGottenSenderId,
                      weak_factory_.GetWeakPtr(), std::move(callback),
-                     service_worker_registration_id,
-                     service_worker_registration->scope().GetOrigin()));
+                     service_worker_registration_id, std::move(origin)));
 }
 
 void PushMessagingManager::UnsubscribeHavingGottenSenderId(
@@ -755,7 +779,22 @@ void PushMessagingManager::GetSubscription(
     int64_t service_worker_registration_id,
     GetSubscriptionCallback callback) {
   DCHECK_CURRENTLY_ON(ServiceWorkerContext::GetCoreThreadId());
-  // TODO(johnme): Validate arguments?
+
+  scoped_refptr<ServiceWorkerRegistration> registration =
+      service_worker_context_->GetLiveRegistration(
+          service_worker_registration_id);
+  if (registration) {
+    const GURL origin = registration->scope().GetOrigin();
+
+    if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanAccessDataForOrigin(
+            ui_core_->GetRenderProceesId(), url::Origin::Create(origin))) {
+      bad_message::ReceivedBadMessage(
+          ui_core_->GetRenderProceesId(),
+          bad_message::PMM_GET_SUBSCRIPTION_INVALID_ORIGIN);
+      return;
+    }
+  }
+
   service_worker_context_->GetRegistrationUserData(
       service_worker_registration_id,
       {kPushRegistrationIdServiceWorkerKey, kPushSenderIdServiceWorkerKey},
diff --git a/content/browser/renderer_host/frame_tree_node.cc b/content/browser/renderer_host/frame_tree_node.cc
index 2a9ce12ff0935..4a19d2cab9494 100644
--- a/content/browser/renderer_host/frame_tree_node.cc
+++ b/content/browser/renderer_host/frame_tree_node.cc
@@ -55,7 +55,7 @@ const double kLoadingProgressDone = 1.0;
 }  // namespace
 
 // This observer watches the opener of its owner FrameTreeNode and clears the
-// owner's opener if the opener is destroyed.
+// owner's opener if the opener is destroyed or swaps BrowsingInstance.
 class FrameTreeNode::OpenerDestroyedObserver : public FrameTreeNode::Observer {
  public:
   OpenerDestroyedObserver(FrameTreeNode* owner, bool observing_original_opener)
@@ -63,6 +63,15 @@ class FrameTreeNode::OpenerDestroyedObserver : public FrameTreeNode::Observer {
 
   // FrameTreeNode::Observer
   void OnFrameTreeNodeDestroyed(FrameTreeNode* node) override {
+    NullifyOpener(node);
+  }
+
+  // FrameTreeNode::Observer
+  void OnFrameTreeNodeDisownedOpenee(FrameTreeNode* node) override {
+    NullifyOpener(node);
+  }
+
+  void NullifyOpener(FrameTreeNode* node) {
     if (observing_original_opener_) {
       // The "original owner" is special. It's used for attribution, and clients
       // walk down the original owner chain. Therefore, if a link in the chain
@@ -823,4 +832,13 @@ void FrameTreeNode::WriteIntoTracedValue(perfetto::TracedValue context) const {
   dict.Add("is_main_frame", IsMainFrame());
 }
 
+void FrameTreeNode::ClearOpenerReferences() {
+  // Simulate the FrameTreeNode being dead to opener observers. They will
+  // nullify their opener.
+  // Note: observers remove themselves from observers_, no need to take care of
+  // that manually.
+  for (auto& observer : observers_)
+    observer.OnFrameTreeNodeDisownedOpenee(this);
+}
+
 }  // namespace content
diff --git a/content/browser/renderer_host/frame_tree_node.h b/content/browser/renderer_host/frame_tree_node.h
index 61e4e10c80c19..33fea4319a35a 100644
--- a/content/browser/renderer_host/frame_tree_node.h
+++ b/content/browser/renderer_host/frame_tree_node.h
@@ -60,6 +60,10 @@ class CONTENT_EXPORT FrameTreeNode {
     // Invoked when a FrameTreeNode becomes focused.
     virtual void OnFrameTreeNodeFocused(FrameTreeNode* node) {}
 
+    // Invoked when a FrameTreeNode moves to a different BrowsingInstance and
+    // the popups it opened should be disowned.
+    virtual void OnFrameTreeNodeDisownedOpenee(FrameTreeNode* node) {}
+
     virtual ~Observer() = default;
   };
 
@@ -452,6 +456,10 @@ class CONTENT_EXPORT FrameTreeNode {
   // Write a representation of this object into a trace.
   void WriteIntoTracedValue(perfetto::TracedValue context) const;
 
+  // Clears the opener property of popups referencing this FrameTreeNode as
+  // their opener.
+  void ClearOpenerReferences();
+
  private:
   FRIEND_TEST_ALL_PREFIXES(SitePerProcessPermissionsPolicyBrowserTest,
                            ContainerPolicyDynamic);
diff --git a/content/browser/renderer_host/input/input_router_impl.cc b/content/browser/renderer_host/input/input_router_impl.cc
index 3e59f18b36f73..9e00b16800c81 100644
--- a/content/browser/renderer_host/input/input_router_impl.cc
+++ b/content/browser/renderer_host/input/input_router_impl.cc
@@ -148,7 +148,12 @@ void InputRouterImpl::SendGestureEvent(
   input_stream_validator_.Validate(original_gesture_event.event);
 
   GestureEventWithLatencyInfo gesture_event(original_gesture_event);
-
+#if defined(OS_OHOS)
+  if (gesture_event.event.GetType() ==
+      WebInputEvent::Type::kGestureFlingStart) {
+    client_->GetWidgetInputHandler()->StartFling();
+  }
+#endif
   if (gesture_event_queue_.PassToFlingController(gesture_event)) {
     TRACE_EVENT_INSTANT0("input", "FilteredForFling", TRACE_EVENT_SCOPE_THREAD);
     disposition_handler_->OnGestureEventAck(
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index 9da018174d4a9..2279b75bbfe5e 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -8316,6 +8316,12 @@ void RenderFrameHostImpl::GetDeviceInfoService(
                                                          std::move(receiver));
 }
 
+void RenderFrameHostImpl::GetManagedConfigurationService(
+    mojo::PendingReceiver<blink::mojom::ManagedConfigurationService> receiver) {
+  GetContentClient()->browser()->CreateManagedConfigurationService(
+      this, std::move(receiver));
+}
+
 void RenderFrameHostImpl::GetFontAccessManager(
     mojo::PendingReceiver<blink::mojom::FontAccessManager> receiver) {
   static_cast<StoragePartitionImpl*>(GetProcess()->GetStoragePartition())
diff --git a/content/browser/renderer_host/render_frame_host_impl.h b/content/browser/renderer_host/render_frame_host_impl.h
index 3f4984eae05e3..edb936801dc32 100644
--- a/content/browser/renderer_host/render_frame_host_impl.h
+++ b/content/browser/renderer_host/render_frame_host_impl.h
@@ -184,6 +184,7 @@ namespace mojom {
 class CacheStorage;
 class DeviceAPIService;
 class GeolocationService;
+class ManagedConfigurationService;
 class WebUsbService;
 }  // namespace mojom
 }  // namespace blink
@@ -1405,6 +1406,10 @@ class CONTENT_EXPORT RenderFrameHostImpl
   void GetDeviceInfoService(
       mojo::PendingReceiver<blink::mojom::DeviceAPIService> receiver);
 
+  void GetManagedConfigurationService(
+      mojo::PendingReceiver<blink::mojom::ManagedConfigurationService>
+          receiver);
+
   void GetFontAccessManager(
       mojo::PendingReceiver<blink::mojom::FontAccessManager> receiver);
 
diff --git a/content/browser/renderer_host/render_frame_host_manager.cc b/content/browser/renderer_host/render_frame_host_manager.cc
index 61bddc0618162..216333fa8b489 100644
--- a/content/browser/renderer_host/render_frame_host_manager.cc
+++ b/content/browser/renderer_host/render_frame_host_manager.cc
@@ -3272,9 +3272,19 @@ void RenderFrameHostManager::CommitPending(
 
   // If this is a top-level frame, and COOP triggered a BrowsingInstance swap,
   // make sure all relationships with the previous BrowsingInstance are severed
-  // by removing the opener and proxies with unrelated SiteInstances.
+  // by removing the opener, the openee's opener, and the proxies with unrelated
+  // SiteInstances.
   if (clear_proxies_on_commit) {
     DCHECK(frame_tree_node_->IsMainFrame());
+
+    // If this frame has opened popups, we need to clear the opened popup's
+    // opener. This is done here on the browser side. A similar mechanism occurs
+    // in the renderer process when the RenderView of this frame is destroyed,
+    // via blink::OpenedFrameTracker.
+    frame_tree_node_->ClearOpenerReferences();
+
+    // We've just cleared other frames' "opener" referencing this frame, we now
+    // clear this frame's "opener".
     if (frame_tree_node_->opener() &&
         !render_frame_host_->GetSiteInstance()->IsRelatedSiteInstance(
             frame_tree_node_->opener()
@@ -3286,6 +3296,8 @@ void RenderFrameHostManager::CommitPending(
       // after it is not necessary in this particuliar case.
     }
 
+    // Now that opener references are gone in both direction, we can clear the
+    // underlying proxies that were used for that purpose.
     std::vector<RenderFrameProxyHost*> removed_proxies;
     for (auto& it : proxy_hosts_) {
       const auto& proxy = it.second;
diff --git a/content/browser/renderer_host/render_widget_host_impl.cc b/content/browser/renderer_host/render_widget_host_impl.cc
index f50f3837b5506..77b299eb24c34 100644
--- a/content/browser/renderer_host/render_widget_host_impl.cc
+++ b/content/browser/renderer_host/render_widget_host_impl.cc
@@ -295,6 +295,11 @@ class UnboundWidgetInputHandler : public blink::mojom::WidgetInputHandler {
                      DispatchEventCallback callback) override {
     DLOG(WARNING) << "Input request on unbound interface";
   }
+#if defined(OS_OHOS)
+  void StartFling() override {
+    DLOG(WARNING) << "Input request on unbound interface";
+  }
+#endif
   void DispatchNonBlockingEvent(
       std::unique_ptr<blink::WebCoalescedInputEvent> event) override {
     DLOG(WARNING) << "Input request on unbound interface";
diff --git a/content/browser/service_worker/service_worker_version.cc b/content/browser/service_worker/service_worker_version.cc
index faf73f0285625..6dc6a4fae09d0 100644
--- a/content/browser/service_worker/service_worker_version.cc
+++ b/content/browser/service_worker/service_worker_version.cc
@@ -1970,6 +1970,11 @@ void ServiceWorkerVersion::OnTimeoutTimer() {
 
   MarkIfStale();
 
+  // Global `this` protecter.
+  // callbacks initiated by this function sometimes reduce refcnt to 0
+  // to make this instance freed.
+  scoped_refptr<ServiceWorkerVersion> protect_this(this);
+
   // Stopping the worker hasn't finished within a certain period.
   if (GetTickDuration(stop_time_) > kStopWorkerTimeout) {
     DCHECK_EQ(EmbeddedWorkerStatus::STOPPING, running_status());
@@ -1980,12 +1985,6 @@ void ServiceWorkerVersion::OnTimeoutTimer() {
     ReportError(blink::ServiceWorkerStatusCode::kErrorTimeout,
                 "DETACH_STALLED_IN_STOPPING");
 
-    // Detach the worker. Remove |this| as a listener first; otherwise
-    // OnStoppedInternal might try to restart before the new worker
-    // is created. Also, protect |this|, since swapping out the
-    // EmbeddedWorkerInstance could destroy our ServiceWorkerHost which could in
-    // turn destroy |this|.
-    scoped_refptr<ServiceWorkerVersion> protect_this(this);
     embedded_worker_->RemoveObserver(this);
     embedded_worker_->Detach();
     embedded_worker_ = std::make_unique<EmbeddedWorkerInstance>(this);
@@ -2012,7 +2011,6 @@ void ServiceWorkerVersion::OnTimeoutTimer() {
     DCHECK(running_status() == EmbeddedWorkerStatus::STARTING ||
            running_status() == EmbeddedWorkerStatus::STOPPING)
         << static_cast<int>(running_status());
-    scoped_refptr<ServiceWorkerVersion> protect(this);
     FinishStartWorker(blink::ServiceWorkerStatusCode::kErrorTimeout);
     if (running_status() == EmbeddedWorkerStatus::STARTING)
       embedded_worker_->Stop();
@@ -2021,17 +2019,26 @@ void ServiceWorkerVersion::OnTimeoutTimer() {
 
   // Requests have not finished before their expiration.
   bool stop_for_timeout = false;
-  auto timeout_iter = request_timeouts_.begin();
-  while (timeout_iter != request_timeouts_.end()) {
+  // In case, `request_timeouts_` can be modified in the callbacks initiated
+  // in `MaybeTimeoutRequest`, we keep its contents locally during the
+  // following while loop.
+  std::set<InflightRequestTimeoutInfo> request_timeouts;
+  request_timeouts.swap(request_timeouts_);
+  auto timeout_iter = request_timeouts.begin();
+  while (timeout_iter != request_timeouts.end()) {
     const InflightRequestTimeoutInfo& info = *timeout_iter;
-    if (!RequestExpired(info.expiration))
+    if (!RequestExpired(info.expiration)) {
       break;
+    }
     if (MaybeTimeoutRequest(info)) {
       stop_for_timeout =
           stop_for_timeout || info.timeout_behavior == KILL_ON_TIMEOUT;
     }
-    timeout_iter = request_timeouts_.erase(timeout_iter);
+    timeout_iter = request_timeouts.erase(timeout_iter);
   }
+  // Ensure the `request_timeouts_` won't be touched during the loop.
+  DCHECK(request_timeouts_.empty());
+  request_timeouts_.swap(request_timeouts);
   if (stop_for_timeout && running_status() != EmbeddedWorkerStatus::STOPPING)
     embedded_worker_->Stop();
 
diff --git a/content/browser/service_worker/service_worker_version.h b/content/browser/service_worker/service_worker_version.h
index 1db322ab6801a..f1c63f2a8ab66 100644
--- a/content/browser/service_worker/service_worker_version.h
+++ b/content/browser/service_worker/service_worker_version.h
@@ -851,6 +851,8 @@ class CONTENT_EXPORT ServiceWorkerVersion
                                bool is_browser_startup_complete,
                                blink::ServiceWorkerStatusCode status);
 
+  // The caller of MaybeTimeoutRequest must increase reference count of |this|
+  // to avoid it deleted during the execution.
   bool MaybeTimeoutRequest(const InflightRequestTimeoutInfo& info);
   void SetAllRequestExpirations(const base::TimeTicks& expiration);
 
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 4b082de10d3e1..d823ef23b994d 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -121,6 +121,9 @@
 #include "content/public/browser/javascript_dialog_manager.h"
 #include "content/public/browser/keyboard_event_processing_result.h"
 #include "content/public/browser/load_notification_details.h"
+#if defined(OS_OHOS)
+#include "content/public/browser/message_port_provider.h"
+#endif
 #include "content/public/browser/navigation_details.h"
 #include "content/public/browser/notification_details.h"
 #include "content/public/browser/notification_service.h"
@@ -1700,6 +1703,26 @@ void WebContentsImpl::SetDisplayCutoutSafeArea(gfx::Insets insets) {
 
 #endif
 
+#if defined(OS_OHOS)
+void WebContentsImpl::CreateWebMessagePorts(std::vector<blink::WebMessagePort>& ports)
+{
+  std::pair<blink::WebMessagePort, blink::WebMessagePort> pipe = blink::WebMessagePort::CreatePair();
+  ports.emplace_back(std::move(pipe.first));
+  ports.emplace_back(std::move(pipe.second));
+}
+
+void WebContentsImpl::PostWebMessage(std::string& message, std::vector<blink::WebMessagePort>& ports,
+                                      std::string& targetUri)
+{
+  if (targetUri.compare("*") == 0) {
+    targetUri = "";
+  }
+  // send ports to html5.
+  MessagePortProvider::OhosPostMessageToFrame(this, std::u16string(),
+                base::UTF8ToUTF16(targetUri), base::UTF8ToUTF16(message), ports);
+}
+#endif
+
 const std::u16string& WebContentsImpl::GetTitle() {
   WebUI* our_web_ui =
       GetRenderManager()->speculative_frame_host()
@@ -5702,8 +5725,8 @@ WebContentsImpl::GetJavaRenderFrameHostDelegate() {
 #endif
 
 void WebContentsImpl::DOMContentLoaded(RenderFrameHostImpl* render_frame_host) {
-  OPTIONAL_TRACE_EVENT1("content", "WebContentsImpl::DOMContentLoaded",
-                        "render_frame_host", render_frame_host);
+  TRACE_EVENT1("content", "WebContentsImpl::DOMContentLoaded",
+               "render_frame_host", render_frame_host);
   SCOPED_UMA_HISTOGRAM_TIMER("WebContentsObserver.DOMContentLoaded");
   observers_.NotifyObservers(&WebContentsObserver::DOMContentLoaded,
                              render_frame_host);
@@ -6123,8 +6146,8 @@ void WebContentsImpl::UpdateTitleForEntry(NavigationEntry* entry,
 }
 
 void WebContentsImpl::SendChangeLoadProgress() {
-  OPTIONAL_TRACE_EVENT1("content", "WebContentsImpl::SendChangeLoadProgress",
-                        "load_progress", frame_tree_.load_progress());
+  TRACE_EVENT1("content", "WebContentsImpl::SendChangeLoadProgress",
+               "load_progress", frame_tree_.load_progress());
   loading_last_progress_update_ = base::TimeTicks::Now();
 
   SCOPED_UMA_HISTOGRAM_TIMER("WebContentsObserver.LoadProgressChanged");
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index ad513676249e8..8c9ff3de9d468 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -64,6 +64,7 @@
 #include "services/metrics/public/cpp/ukm_recorder.h"
 #include "services/network/public/mojom/fetch_api.mojom-forward.h"
 #include "third_party/blink/public/common/frame/transient_allow_fullscreen.h"
+#include "third_party/blink/public/common/messaging/web_message_port.h"
 #include "third_party/blink/public/common/renderer_preferences/renderer_preferences.h"
 #include "third_party/blink/public/common/web_preferences/web_preferences.h"
 #include "third_party/blink/public/mojom/choosers/color_chooser.mojom.h"
@@ -375,6 +376,11 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   bool IsWebContentsOnlyAccessibilityModeForTesting() override;
   bool IsFullAccessibilityModeForTesting() override;
   const std::u16string& GetTitle() override;
+#if defined(OS_OHOS)
+  void CreateWebMessagePorts(std::vector<blink::WebMessagePort>& ports) override;
+  void PostWebMessage(std::string& message, std::vector<blink::WebMessagePort>& ports,
+                       std::string& targetUri) override;
+#endif
   void UpdateTitleForEntry(NavigationEntry* entry,
                            const std::u16string& title) override;
   SiteInstanceImpl* GetSiteInstance() override;
diff --git a/content/browser/web_contents/web_contents_view_aura.cc b/content/browser/web_contents/web_contents_view_aura.cc
index d8d434d386b40..c30788102b7da 100644
--- a/content/browser/web_contents/web_contents_view_aura.cc
+++ b/content/browser/web_contents/web_contents_view_aura.cc
@@ -1386,8 +1386,9 @@ void WebContentsViewAura::OnDragExited() {
 void WebContentsViewAura::CompleteDragExit() {
   drag_in_progress_ = false;
 
-  if (current_rvh_for_drag_ !=
-      GetRenderViewHostID(web_contents_->GetRenderViewHost()) ||
+  if (web_contents_->IsBeingDestroyed() ||
+      current_rvh_for_drag_ !=
+          GetRenderViewHostID(web_contents_->GetRenderViewHost()) ||
       !current_drop_data_) {
     return;
   }
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index a124ed6a5ca49..b5b0fc92aad95 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -886,6 +886,11 @@ void ContentBrowserClient::CreateDeviceInfoService(
     RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<blink::mojom::DeviceAPIService> receiver) {}
 
+void ContentBrowserClient::CreateManagedConfigurationService(
+    RenderFrameHost* render_frame_host,
+    mojo::PendingReceiver<blink::mojom::ManagedConfigurationService> receiver) {
+}
+
 #if !defined(OS_ANDROID)
 SerialDelegate* ContentBrowserClient::GetSerialDelegate() {
   return nullptr;
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index b4ae72f795c11..658293f214781 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -91,6 +91,7 @@ namespace blink {
 namespace mojom {
 class DeviceAPIService;
 class BadgeService;
+class ManagedConfigurationService;
 class RendererPreferenceWatcher;
 class WebUsbService;
 class WindowFeatures;
@@ -1623,6 +1624,11 @@ class CONTENT_EXPORT ContentBrowserClient {
       RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::DeviceAPIService> receiver);
 
+  virtual void CreateManagedConfigurationService(
+      RenderFrameHost* render_frame_host,
+      mojo::PendingReceiver<blink::mojom::ManagedConfigurationService>
+          receiver);
+
 #if !defined(OS_ANDROID)
   // Allows the embedder to provide an implementation of the Serial API.
   virtual SerialDelegate* GetSerialDelegate();
diff --git a/content/public/browser/message_port_provider.h b/content/public/browser/message_port_provider.h
index 25a97cc35a854..1db07ba6dfa0d 100644
--- a/content/public/browser/message_port_provider.h
+++ b/content/public/browser/message_port_provider.h
@@ -15,6 +15,9 @@
 #include "build/chromecast_buildflags.h"
 #include "content/common/content_export.h"
 #include "third_party/blink/public/common/messaging/web_message_port.h"
+#if defined(OS_OHOS)
+#include "third_party/blink/public/common/messaging/message_port_descriptor.h"
+#endif
 
 #if defined(OS_ANDROID)
 #include "base/android/scoped_java_ref.h"
@@ -40,6 +43,15 @@ class CONTENT_EXPORT MessagePortProvider {
                                  const std::u16string& target_origin,
                                  const std::u16string& data);
 
+#if defined(OS_OHOS)
+static void OhosPostMessageToFrame(
+    WebContents* web_contents,
+    const std::u16string& source_origin,
+    const std::u16string& target_origin,
+    const std::u16string& data,
+    std::vector<blink::WebMessagePort>& ports);
+#endif
+
 #if defined(OS_ANDROID)
   static void PostMessageToFrame(
       WebContents* web_contents,
diff --git a/content/public/browser/web_contents.h b/content/public/browser/web_contents.h
index 356e51e161d6f..70915ab408f91 100644
--- a/content/public/browser/web_contents.h
+++ b/content/public/browser/web_contents.h
@@ -34,6 +34,9 @@
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/data_decoder/public/mojom/web_bundler.mojom.h"
 #include "services/metrics/public/cpp/ukm_source_id.h"
+#if defined(OS_OHOS)
+#include "third_party/blink/public/common/messaging/web_message_port.h"
+#endif
 #include "third_party/blink/public/mojom/frame/find_in_page.mojom-forward.h"
 #include "third_party/blink/public/mojom/input/pointer_lock_result.mojom.h"
 #include "third_party/blink/public/mojom/loader/pause_subresource_loading_handle.mojom-forward.h"
@@ -476,6 +479,27 @@ class WebContents : public PageNavigator,
   // download, in which case the URL would revert to what it was previously).
   virtual const std::u16string& GetTitle() = 0;
 
+  /**
+   * creating two ends of a message channel.
+   *
+   * @param ports the web message ports get from nweb.
+   */
+#if defined(OS_OHOS)
+  virtual void CreateWebMessagePorts(std::vector<blink::WebMessagePort>& ports) = 0;
+#endif
+
+  /**
+   * Posts MessageEvent to the main frame.
+   *
+   * @param message message send to mmain frame.
+   * @param ports the web message ports send to main frame.
+   * @param targetUri the uri which can received the ports.
+   */
+#if defined(OS_OHOS)
+  virtual void PostWebMessage(std::string& message, std::vector<blink::WebMessagePort>& ports,
+        std::string& targetUri) = 0;
+#endif
+
   // Saves the given title to the navigation entry and does associated work. It
   // will update history and the view with the new title, and also synthesize
   // titles for file URLs that have none. Thus |entry| must have a URL set.
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index a8e6cc4550661..1d8613399c2d2 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -975,7 +975,7 @@ const char kEnableSpeechDispatcher[] = "enable-speech-dispatcher";
 const char kEnableMultiRendererProcess[] = "enable-multi-renderer-process";
 const char kForTest[] = "for-test";
 const char kBundleInstallationDir[] = "bundle-installation-dir";
-const char kForBrowser[] = "--for-browser";
+const char kForBrowser[] = "for-browser";
 #endif
 
 #if defined(OS_WIN)
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 3c9ab9200a765..9cab8f40b65e2 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -969,7 +969,7 @@ void FillMiscNavigationParams(
   navigation_params->is_cross_browsing_context_group_navigation =
       commit_params.is_cross_browsing_instance;
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   // Only android webview uses this.
   navigation_params->grant_load_local_resources =
       commit_params.can_load_local_resources;
diff --git a/content/test/data/android/webshare-separator.html b/content/test/data/android/webshare-separator.html
new file mode 100644
index 0000000000000..5ed2a925c285d
--- /dev/null
+++ b/content/test/data/android/webshare-separator.html
@@ -0,0 +1,31 @@
+<!DOCTYPE html>
+<html>
+    <head>
+        <title>Web Share</title>
+        <script>
+            function initiate_share() {
+                if (navigator.share === undefined) {
+                    window.document.title = 'Fail: navigator.share === undefined';
+                    return;
+                }
+
+                const fileBits = ['contents'];
+                const fileName = '/';
+                const options = {type: 'video/ogg'};
+                const data = {files: [new File(fileBits, fileName, options)]};
+                navigator.share(data).then(() => {
+                    window.document.title = 'Success';
+                }).catch(e => {
+                    window.document.title = 'Fail: ' + e;
+                });
+            }
+
+            window.addEventListener('load', () => {
+                window.addEventListener('click', initiate_share);
+            });
+        </script>
+    </head>
+    <body>
+        WebShare Test!
+    </body>
+</html>
diff --git a/content/test/data/gpu/webgl-overly-large-uniform.html b/content/test/data/gpu/webgl-overly-large-uniform.html
new file mode 100644
index 0000000000000..9b28fa5ebc2d6
--- /dev/null
+++ b/content/test/data/gpu/webgl-overly-large-uniform.html
@@ -0,0 +1,137 @@
+<html>
+<head>
+<script type="x-shader/x-vertex" id="vertex">
+#version 100
+uniform mat4 overflow;
+
+void main() {
+  gl_Position = overflow * vec4(0.11, 0.22, 0.33, 1.0);
+}
+</script>
+<script type="x-shader/x-fragment" id="fragment">
+#version 100
+void main() {
+  gl_FragColor = vec4(0.11, 0.22, 0.33, 1.0);
+}
+</script>
+<script type="text/javascript">
+let canvas;
+let w, h;
+let gl;
+let timeout;
+
+function send(result, message) {
+  if (window.domAutomationController)
+    window.domAutomationController.send(result);
+  if (message)
+    console.log(message);
+}
+
+function onContextLost(e) {
+  e.preventDefault();
+  clearTimeout(timeout);
+  // This is the last test in this file.
+  send("SUCCESS");
+}
+
+function onContextRestored() {
+  // Could extend this test to cover context restoration, but ignore
+  // this for now.
+}
+
+function timedOut() {
+  send("FAILURE", "Timed out waiting for context lost event");
+}
+
+function onLoad() {
+  send("LOADED");
+
+  canvas = document.getElementById("canvas1");
+  w = canvas.width;
+  h = canvas.height;
+  if (!canvas)
+    return;
+  canvas.addEventListener("webglcontextlost", onContextLost, false);
+  canvas.addEventListener("webglcontextrestored", onContextRestored, false);
+
+  gl = canvas.getContext("webgl");
+  if (!gl) {
+    send("FAILURE", "Couldn't get WebGL context");
+    return;
+  }
+
+  let vertexShader = gl.createShader(gl.VERTEX_SHADER);
+  gl.shaderSource(vertexShader, document.querySelector("#vertex").innerHTML);
+  gl.compileShader(vertexShader);
+
+  let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
+  gl.shaderSource(fragmentShader, document.querySelector("#fragment").innerHTML);
+  gl.compileShader(fragmentShader);
+
+  program = gl.createProgram();
+  gl.attachShader(program, vertexShader);
+  gl.attachShader(program, fragmentShader);
+  gl.linkProgram(program);
+
+  overflow = gl.getUniformLocation(program, "overflow");
+
+  gl.useProgram(program);
+
+  // 2 GB memory pool, if possible. (64KB Wasm page size)
+  //
+  // If allocation fails (for example, on 32-bit Android), fall back
+  // to 128 MB, and skip the portion of the test which tests the
+  // generation of INVALID_VALUE.
+  let gotLargeAllocation = false;
+  let memory;
+
+  try {
+    memory = new WebAssembly.Memory({initial: 32768});
+    gotLargeAllocation = true;
+  } catch (e) {
+    // Must be on a system that can't allocate that much memory. Try
+    // again with a smaller reservation.
+    try {
+      memory = new WebAssembly.Memory({initial: 2048});
+    } catch (e) {
+      // Unexpected. Fail verbosely.
+      send("FAILURE", "Failed to allocate even the smaller Wasm memory");
+      return;
+    }
+  }
+
+  if (gotLargeAllocation) {
+    // Feeding in all but a few bytes of that memory pool should cause
+    // GL_INVALID_VALUE to be generated as an implementation detail; this can not
+    // be guaranteed by the WebGL conformance tests. Note: this behavior could be
+    // changed to instead force a lost context if desired, per below.
+    const fewBytes = 8;
+    let array = new Int32Array(memory.buffer, fewBytes);
+    gl.uniform1iv(overflow, array);
+    let err = gl.getError();
+    console.log("GL error after very large uniform1iv call: " + err);
+    if (err != gl.INVALID_VALUE) {
+      send("FAILURE", "Expected gl.INVALID_VALUE, got " + err);
+      return;
+    }
+  }
+
+  // Feeding in significantly less of that memory pool (in this case, 64K less)
+  // should cause a lost context as an implementation detail; this can not be
+  // guaranteed by the WebGL conformance tests.
+  const moreBytes = 64 * 1024;
+  array = new Int32Array(memory.buffer, moreBytes);
+  gl.uniform1iv(overflow, array);
+  err = gl.getError();
+  console.log("GL error after slightly less large uniform1iv call: " + err);
+  // Delivery of context loss will race with execution here.
+  // If it hasn't been delivered within 5 seconds, fail the test.
+  timeout = setTimeout(timedOut, 5000);
+}
+</script>
+</head>
+<body onload="onLoad()">
+<canvas id="canvas1" width="64px" height="64px">
+</canvas>
+</body>
+</html>
diff --git a/content/test/gpu/gpu_tests/context_lost_integration_test.py b/content/test/gpu/gpu_tests/context_lost_integration_test.py
index 9096205323b23..315338ca8795a 100644
--- a/content/test/gpu/gpu_tests/context_lost_integration_test.py
+++ b/content/test/gpu/gpu_tests/context_lost_integration_test.py
@@ -160,6 +160,8 @@ class ContextLostIntegrationTest(gpu_integration_test.GpuIntegrationTest):
               'webgl_with_select_element.html'),
              ('ContextLost_WebGLContextLostInHiddenTab',
               'webgl.html?query=kill_after_notification'),
+             ('ContextLost_WebGLContextLostOverlyLargeUniform',
+              'webgl-overly-large-uniform.html'),
              ('ContextLost_WebGLBlockedAfterJSNavigation',
               'webgl-domain-blocking-page1.html'),
              ('ContextLost_WebGLUnblockedAfterUserInitiatedReload',
@@ -387,6 +389,16 @@ class ContextLostIntegrationTest(gpu_integration_test.GpuIntegrationTest):
     tab.Activate()
     self._WaitForTabAndCheckCompletion()
 
+  def _ContextLost_WebGLContextLostOverlyLargeUniform(self,
+                                                      test_path: str) -> None:
+    self.RestartBrowserIfNecessaryWithArgs([
+        cba.DISABLE_DOMAIN_BLOCKING_FOR_3D_APIS,
+        '--enable-features=DisableArrayBufferSizeLimitsForTesting'
+    ])
+    self._NavigateAndWaitForLoad(test_path)
+    # No reason to wait more than 10 seconds for this test to complete.
+    self._WaitForTabAndCheckCompletion(timeout=10)
+
   def _ContextLost_WebGLBlockedAfterJSNavigation(self, test_path):
     self.RestartBrowserIfNecessaryWithArgs([])
     self._NavigateAndWaitForLoad(test_path)
diff --git a/extensions/browser/guest_view/web_view/javascript_dialog_helper.cc b/extensions/browser/guest_view/web_view/javascript_dialog_helper.cc
index 2e9c330e6788d..12f7b4b440685 100644
--- a/extensions/browser/guest_view/web_view/javascript_dialog_helper.cc
+++ b/extensions/browser/guest_view/web_view/javascript_dialog_helper.cc
@@ -66,7 +66,7 @@ void JavaScriptDialogHelper::RunJavaScriptDialog(
   web_view_permission_helper->RequestPermission(
       WEB_VIEW_PERMISSION_TYPE_JAVASCRIPT_DIALOG, request_info,
       base::BindOnce(&JavaScriptDialogHelper::OnPermissionResponse,
-                     base::Unretained(this), std::move(callback)),
+                     weak_factory_.GetWeakPtr(), std::move(callback)),
       false /* allowed_by_default */);
 }
 
diff --git a/extensions/browser/guest_view/web_view/javascript_dialog_helper.h b/extensions/browser/guest_view/web_view/javascript_dialog_helper.h
index ae759a14c1825..125977727f4d4 100644
--- a/extensions/browser/guest_view/web_view/javascript_dialog_helper.h
+++ b/extensions/browser/guest_view/web_view/javascript_dialog_helper.h
@@ -6,6 +6,7 @@
 #define EXTENSIONS_BROWSER_GUEST_VIEW_WEB_VIEW_JAVASCRIPT_DIALOG_HELPER_H_
 
 #include "base/macros.h"
+#include "base/memory/weak_ptr.h"
 #include "content/public/browser/javascript_dialog_manager.h"
 
 namespace extensions {
@@ -43,6 +44,8 @@ class JavaScriptDialogHelper : public content::JavaScriptDialogManager {
   // Pointer to the webview that is being helped.
   WebViewGuest* const web_view_guest_;
 
+  base::WeakPtrFactory<JavaScriptDialogHelper> weak_factory_{this};
+
   DISALLOW_COPY_AND_ASSIGN(JavaScriptDialogHelper);
 };
 
diff --git a/gpu/command_buffer/client/client_discardable_manager_unittest.cc b/gpu/command_buffer/client/client_discardable_manager_unittest.cc
index 4b86fca0a696d..026ee81f42bdc 100644
--- a/gpu/command_buffer/client/client_discardable_manager_unittest.cc
+++ b/gpu/command_buffer/client/client_discardable_manager_unittest.cc
@@ -45,6 +45,9 @@ class FakeCommandBuffer : public CommandBuffer {
     EXPECT_TRUE(found != active_ids_.end());
     active_ids_.erase(found);
   }
+  void ForceLostContext(error::ContextLostReason reason) override {
+    // No-op; doesn't need to be exercised here.
+  }
 
  private:
   int32_t next_id_ = 1;
diff --git a/gpu/command_buffer/client/client_test_helper.cc b/gpu/command_buffer/client/client_test_helper.cc
index 4fd55a3274a87..826f466f40cfa 100644
--- a/gpu/command_buffer/client/client_test_helper.cc
+++ b/gpu/command_buffer/client/client_test_helper.cc
@@ -158,6 +158,13 @@ void MockClientCommandBuffer::DelegateToFake() {
           this, &FakeCommandBufferServiceBase::DestroyTransferBufferHelper));
 }
 
+void MockClientCommandBuffer::ForceLostContext(
+    error::ContextLostReason reason) {
+  // TODO(kbr): add a test for a call to this method.
+  SetParseError(error::kLostContext);
+  SetContextLostReason(reason);
+}
+
 MockClientCommandBufferMockFlush::MockClientCommandBufferMockFlush() {
   DelegateToFake();
 }
diff --git a/gpu/command_buffer/client/client_test_helper.h b/gpu/command_buffer/client/client_test_helper.h
index bd0cc0739efaa..2548be832472a 100644
--- a/gpu/command_buffer/client/client_test_helper.h
+++ b/gpu/command_buffer/client/client_test_helper.h
@@ -86,6 +86,8 @@ class MockClientCommandBuffer : public CommandBuffer,
 
   void SetTokenForSetGetBuffer(int32_t token) { token_ = token; }
 
+  void ForceLostContext(error::ContextLostReason reason) override;
+
  private:
   int32_t put_offset_ = 0;
   int32_t token_ = 10000;  // All token checks in the tests should pass.
diff --git a/gpu/command_buffer/client/cmd_buffer_helper.cc b/gpu/command_buffer/client/cmd_buffer_helper.cc
index 620fa6535a890..5d9d1c23dddf7 100644
--- a/gpu/command_buffer/client/cmd_buffer_helper.cc
+++ b/gpu/command_buffer/client/cmd_buffer_helper.cc
@@ -157,7 +157,8 @@ void CommandBufferHelper::UpdateCachedState(const CommandBuffer::State& state) {
       (state.set_get_buffer_count != set_get_buffer_count_);
   cached_get_offset_ = service_on_old_buffer_ ? 0 : state.get_offset;
   cached_last_token_read_ = state.token;
-  context_lost_ = error::IsError(state.error);
+  // Don't transition from a lost context to a working context.
+  context_lost_ |= error::IsError(state.error);
 }
 
 bool CommandBufferHelper::WaitForGetOffsetInRange(int32_t start, int32_t end) {
@@ -296,7 +297,6 @@ void CommandBufferHelper::WaitForAvailableEntries(int32_t count) {
   if (!AllocateRingBuffer())
     return;
   DCHECK(HaveRingBuffer());
-  DCHECK(count < total_entry_count_);
   if (put_ + count > total_entry_count_) {
     // There's not enough room between the current put and the end of the
     // buffer, so we need to wrap. We will add noops all the way to the end,
@@ -344,7 +344,16 @@ void CommandBufferHelper::WaitForAvailableEntries(int32_t count) {
                                    put_))
         return;
       CalcImmediateEntries(count);
-      DCHECK_GE(immediate_entry_count_, count);
+      if (immediate_entry_count_ < count) {
+        // Tell the underlying command buffer to signal a lost context to higher
+        // levels.
+        command_buffer_->ForceLostContext(error::kGuilty);
+        // Free the ring buffer and lose context.
+        FreeRingBuffer();
+        usable_ = false;
+        context_lost_ = true;
+        return;
+      }
     }
   }
 }
diff --git a/gpu/command_buffer/common/command_buffer.h b/gpu/command_buffer/common/command_buffer.h
index 6335c4757f2e2..5ac9069424fe3 100644
--- a/gpu/command_buffer/common/command_buffer.h
+++ b/gpu/command_buffer/common/command_buffer.h
@@ -125,6 +125,10 @@ class GPU_EXPORT CommandBuffer {
   // before it is safe to call this function to destroy it.
   virtual void DestroyTransferBuffer(int32_t id) = 0;
 
+  // Forcibly lose this context. Used by higher-level code when it determines
+  // the necessity to do so. Has no effect if the context has already been lost.
+  virtual void ForceLostContext(error::ContextLostReason reason) = 0;
+
  private:
   DISALLOW_COPY_AND_ASSIGN(CommandBuffer);
 };
diff --git a/gpu/command_buffer/service/command_buffer_direct.cc b/gpu/command_buffer/service/command_buffer_direct.cc
index e32139b6bfd65..6a7f7e55487ef 100644
--- a/gpu/command_buffer/service/command_buffer_direct.cc
+++ b/gpu/command_buffer/service/command_buffer_direct.cc
@@ -63,6 +63,11 @@ void CommandBufferDirect::DestroyTransferBuffer(int32_t id) {
   service_.DestroyTransferBuffer(id);
 }
 
+void CommandBufferDirect::ForceLostContext(error::ContextLostReason reason) {
+  service_.SetContextLostReason(reason);
+  service_.SetParseError(error::kLostContext);
+}
+
 CommandBufferServiceClient::CommandBatchProcessedResult
 CommandBufferDirect::OnCommandBatchProcessed() {
   return kContinueExecution;
diff --git a/gpu/command_buffer/service/command_buffer_direct.h b/gpu/command_buffer/service/command_buffer_direct.h
index d03ac687b6f4b..4d8175c3f56fa 100644
--- a/gpu/command_buffer/service/command_buffer_direct.h
+++ b/gpu/command_buffer/service/command_buffer_direct.h
@@ -40,6 +40,7 @@ class GPU_EXPORT CommandBufferDirect : public CommandBuffer,
       TransferBufferAllocationOption option =
           TransferBufferAllocationOption::kLoseContextOnOOM) override;
   void DestroyTransferBuffer(int32_t id) override;
+  void ForceLostContext(error::ContextLostReason reason) override;
 
   // CommandBufferServiceClient implementation:
   CommandBatchProcessedResult OnCommandBatchProcessed() override;
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder.cc b/gpu/command_buffer/service/gles2_cmd_decoder.cc
index 6ff497088434f..d1c0e3bd9e0d4 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ b/gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -6803,8 +6803,6 @@ void GLES2DecoderImpl::InvalidateFramebufferImpl(
       }
     } else {
       if (!validators_->backbuffer_attachment.IsValid(attachment)) {
-        LOCAL_SET_GL_ERROR_INVALID_ENUM(function_name, attachment,
-                                        "attachments");
         return;
       }
     }
diff --git a/gpu/ipc/client/command_buffer_proxy_impl.cc b/gpu/ipc/client/command_buffer_proxy_impl.cc
index bfafcdc9524d8..77455d492fbfc 100644
--- a/gpu/ipc/client/command_buffer_proxy_impl.cc
+++ b/gpu/ipc/client/command_buffer_proxy_impl.cc
@@ -407,6 +407,22 @@ void CommandBufferProxyImpl::DestroyTransferBuffer(int32_t id) {
       GpuCommandBufferMsg_DestroyTransferBuffer(route_id_, id));
 }
 
+void CommandBufferProxyImpl::ForceLostContext(error::ContextLostReason reason) {
+  CheckLock();
+  base::AutoLock lock(last_state_lock_);
+  if (last_state_.error == gpu::error::kLostContext) {
+    // Per specification, do nothing if the context is already lost.
+    return;
+  }
+  last_state_.error = gpu::error::kLostContext;
+  // The caller determines the context lost reason.
+  last_state_.context_lost_reason = reason;
+  // Calling code may be in an indeterminate state (possibly including
+  // being in a GpuControlClient callback), so avoid re-entering the
+  // GpuControlClient here.
+  DisconnectChannelInFreshCallStack();
+}
+
 void CommandBufferProxyImpl::SetGpuControlClient(GpuControlClient* client) {
   CheckLock();
   gpu_control_client_ = client;
diff --git a/gpu/ipc/client/command_buffer_proxy_impl.h b/gpu/ipc/client/command_buffer_proxy_impl.h
index 3a541f708a32e..540ca3486d869 100644
--- a/gpu/ipc/client/command_buffer_proxy_impl.h
+++ b/gpu/ipc/client/command_buffer_proxy_impl.h
@@ -111,6 +111,7 @@ class GPU_EXPORT CommandBufferProxyImpl : public gpu::CommandBuffer,
       TransferBufferAllocationOption option =
           TransferBufferAllocationOption::kLoseContextOnOOM) override;
   void DestroyTransferBuffer(int32_t id) override;
+  void ForceLostContext(error::ContextLostReason reason) override;
 
   // gpu::GpuControl implementation:
   void SetGpuControlClient(GpuControlClient* client) override;
diff --git a/gpu/ipc/in_process_command_buffer.cc b/gpu/ipc/in_process_command_buffer.cc
index 18dc45de9fa89..e3e9c59e54588 100644
--- a/gpu/ipc/in_process_command_buffer.cc
+++ b/gpu/ipc/in_process_command_buffer.cc
@@ -1040,6 +1040,21 @@ void InProcessCommandBuffer::DestroyTransferBuffer(int32_t id) {
                      gpu_thread_weak_ptr_factory_.GetWeakPtr(), id));
 }
 
+void InProcessCommandBuffer::ForceLostContext(error::ContextLostReason reason) {
+  ScheduleGpuTask(
+      base::BindOnce(&InProcessCommandBuffer::ForceLostContextOnGpuThread,
+                     gpu_thread_weak_ptr_factory_.GetWeakPtr(), reason));
+}
+
+void InProcessCommandBuffer::ForceLostContextOnGpuThread(
+    error::ContextLostReason reason) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(gpu_sequence_checker_);
+
+  // Similar implementation to CommandBufferDirect.
+  command_buffer_->SetContextLostReason(reason);
+  command_buffer_->SetParseError(error::kLostContext);
+}
+
 void InProcessCommandBuffer::DestroyTransferBufferOnGpuThread(int32_t id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(gpu_sequence_checker_);
   command_buffer_->DestroyTransferBuffer(id);
diff --git a/gpu/ipc/in_process_command_buffer.h b/gpu/ipc/in_process_command_buffer.h
index 82d4dc1c7263d..5c32e278a30ca 100644
--- a/gpu/ipc/in_process_command_buffer.h
+++ b/gpu/ipc/in_process_command_buffer.h
@@ -142,6 +142,7 @@ class GL_IN_PROCESS_CONTEXT_EXPORT InProcessCommandBuffer
       TransferBufferAllocationOption option =
           TransferBufferAllocationOption::kLoseContextOnOOM) override;
   void DestroyTransferBuffer(int32_t id) override;
+  void ForceLostContext(error::ContextLostReason reason) override;
 
   // GpuControl implementation (called on client thread):
   void SetGpuControlClient(GpuControlClient*) override;
@@ -313,6 +314,7 @@ class GL_IN_PROCESS_CONTEXT_EXPORT InProcessCommandBuffer
   void RegisterTransferBufferOnGpuThread(int32_t id,
                                          scoped_refptr<Buffer> buffer);
   void DestroyTransferBufferOnGpuThread(int32_t id);
+  void ForceLostContextOnGpuThread(error::ContextLostReason reason);
 
   void CreateImageOnGpuThread(int32_t id,
                               gfx::GpuMemoryBufferHandle handle,
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index 7cabe2c6d5293..dc69f04dbad1d 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -236,10 +236,24 @@ source_set("audio") {
     ]
   }
 
-  if (is_linux || is_chromeos || is_ohos) {
+  if (is_linux || is_chromeos) {
     sources += [ "linux/audio_manager_linux.cc" ]
   }
 
+  if (is_ohos) {
+    import("//build/config/ohos/config.gni")
+
+    sources += [
+      "ohos/ohos_audio_manager.cc",
+      "ohos/ohos_audio_manager.h",
+      "ohos/ohos_audio_output_stream.cc",
+      "ohos/ohos_audio_output_stream.h",
+    ]
+
+    include_dirs = ohos_src_includes
+    lib_dirs = ohos_libs_dir
+  }
+
   if (use_alsa) {
     libs += [ "asound" ]
     sources += [
diff --git a/media/audio/ohos/ohos_audio_manager.cc b/media/audio/ohos/ohos_audio_manager.cc
new file mode 100644
index 0000000000000..9d3ba2ffb0c23
--- /dev/null
+++ b/media/audio/ohos/ohos_audio_manager.cc
@@ -0,0 +1,97 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/ohos/ohos_audio_manager.h"
+
+#include "audio_system_manager_adapter.h"
+#include "base/command_line.h"
+#include "media/base/media_switches.h"
+#include "ohos_adapter_helper.h"
+
+namespace media {
+
+constexpr int kDefaultSampleRate = 48000;
+constexpr int kDefaultChannelCount = 2;
+constexpr int kMinimumOutputBufferSize = 512;
+static const char* AUDIO_MANAGER_NAME = "OHOS";
+
+std::unique_ptr<AudioManager> CreateAudioManager(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory) {
+  return std::make_unique<OHOSAudioManager>(std::move(audio_thread),
+                                            audio_log_factory);
+}
+
+OHOSAudioManager::OHOSAudioManager(std::unique_ptr<AudioThread> audio_thread,
+                                   AudioLogFactory* audio_log_factory)
+    : AudioManagerBase(std::move(audio_thread), audio_log_factory) {}
+
+OHOSAudioManager::~OHOSAudioManager() = default;
+
+// Implementation of AudioManager.
+bool OHOSAudioManager::HasAudioOutputDevices() {
+  return OhosAdapterHelper::GetInstance()
+      .GetAudioSystemManager()
+      .HasAudioOutputDevices();
+}
+
+bool OHOSAudioManager::HasAudioInputDevices() {
+  return OhosAdapterHelper::GetInstance()
+      .GetAudioSystemManager()
+      .HasAudioInputDevices();
+}
+
+void OHOSAudioManager::GetAudioOutputDeviceNames(
+    AudioDeviceNames* device_names) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableAudioOutput)) {
+    return;
+  }
+  *device_names = {AudioDeviceName::CreateDefault()};
+}
+
+const char* OHOSAudioManager::GetName() {
+  return AUDIO_MANAGER_NAME;
+}
+
+// Implementation of AudioManagerBase.
+AudioOutputStream* OHOSAudioManager::MakeLinearOutputStream(
+    const AudioParameters& params,
+    const LogCallback& log_callback) {
+  NOTREACHED();
+  return nullptr;
+}
+
+AudioOutputStream* OHOSAudioManager::MakeLowLatencyOutputStream(
+    const AudioParameters& params,
+    const std::string& device_id,
+    const LogCallback& log_callback) {
+  return new OHOSAudioOutputStream(this, params);
+}
+
+AudioInputStream* OHOSAudioManager::MakeLinearInputStream(
+    const AudioParameters& params,
+    const std::string& device_id,
+    const LogCallback& log_callback) {
+  NOTREACHED();
+  return nullptr;
+}
+
+AudioInputStream* OHOSAudioManager::MakeLowLatencyInputStream(
+    const AudioParameters& params,
+    const std::string& device_id,
+    const LogCallback& log_callback) {
+  NOTREACHED();
+  return nullptr;
+}
+
+AudioParameters OHOSAudioManager::GetPreferredOutputStreamParameters(
+    const std::string& output_device_id,
+    const AudioParameters& input_params) {
+  return AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
+                         GuessChannelLayout(kDefaultChannelCount),
+                         kDefaultSampleRate, kMinimumOutputBufferSize);
+}
+
+}  // namespace media
diff --git a/media/audio/ohos/ohos_audio_manager.h b/media/audio/ohos/ohos_audio_manager.h
new file mode 100644
index 0000000000000..c422f2ab40bec
--- /dev/null
+++ b/media/audio/ohos/ohos_audio_manager.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_OHOS_AUDIO_MANAGER_H_
+#define MEDIA_AUDIO_OHOS_AUDIO_MANAGER_H_
+
+#include "media/audio/audio_manager_base.h"
+#include "media/audio/ohos/ohos_audio_output_stream.h"
+
+namespace media {
+
+class MEDIA_EXPORT OHOSAudioManager : public AudioManagerBase {
+ public:
+  OHOSAudioManager(std::unique_ptr<AudioThread> audio_thread,
+                   AudioLogFactory* audio_log_factory);
+  ~OHOSAudioManager() override;
+
+  // Implementation of AudioManager.
+  bool HasAudioOutputDevices() override;
+  bool HasAudioInputDevices() override;
+  void GetAudioOutputDeviceNames(AudioDeviceNames* device_names) override;
+  const char* GetName() override;
+
+  // Implementation of AudioManagerBase.
+  AudioOutputStream* MakeLinearOutputStream(
+      const AudioParameters& params,
+      const LogCallback& log_callback) override;
+  AudioOutputStream* MakeLowLatencyOutputStream(
+      const AudioParameters& params,
+      const std::string& device_id,
+      const LogCallback& log_callback) override;
+  AudioInputStream* MakeLinearInputStream(
+      const AudioParameters& params,
+      const std::string& device_id,
+      const LogCallback& log_callback) override;
+  AudioInputStream* MakeLowLatencyInputStream(
+      const AudioParameters& params,
+      const std::string& device_id,
+      const LogCallback& log_callback) override;
+
+ protected:
+  AudioParameters GetPreferredOutputStreamParameters(
+      const std::string& output_device_id,
+      const AudioParameters& input_params) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(OHOSAudioManager);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_OHOS_AUDIO_MANAGER_H_
diff --git a/media/audio/ohos/ohos_audio_output_stream.cc b/media/audio/ohos/ohos_audio_output_stream.cc
new file mode 100644
index 0000000000000..c2f24d768a48b
--- /dev/null
+++ b/media/audio/ohos/ohos_audio_output_stream.cc
@@ -0,0 +1,203 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/ohos/ohos_audio_output_stream.h"
+
+#include "media/base/audio_timestamp_helper.h"
+#include "ohos_adapter_helper.h"
+
+namespace media {
+
+OHOSAudioOutputStream::OHOSAudioOutputStream(OHOSAudioManager* manager,
+                                             const AudioParameters& parameters)
+    : manager_(manager),
+      parameters_(parameters),
+      audio_bus_(AudioBus::Create(parameters)) {
+  audio_renderer_ =
+      OhosAdapterHelper::GetInstance().CreateAudioRendererAdapter();
+  sample_format_ = kSampleFormatS16;
+  bytes_per_frame_ = parameters.GetBytesPerFrame(sample_format_);
+  buffer_size_bytes_ = parameters.GetBytesPerBuffer(sample_format_);
+}
+
+OHOSAudioOutputStream::~OHOSAudioOutputStream() {
+  // Close() must be called first.
+  if (audio_renderer_ != nullptr) {
+    (void)audio_renderer_->Release();
+    audio_renderer_ = nullptr;
+  }
+}
+
+bool OHOSAudioOutputStream::Open() {
+  AudioAdapterRendererOptions rendererOptions;
+  rendererOptions.samplingRate =
+      static_cast<AudioAdapterSamplingRate>(parameters_.sample_rate());
+  rendererOptions.encoding = AudioAdapterEncodingType::ENCODING_PCM;
+  rendererOptions.format = AudioAdapterSampleFormat::SAMPLE_S16LE;
+  rendererOptions.channels =
+      static_cast<AudioAdapterChannel>(parameters_.channels());
+  rendererOptions.contentType = AudioAdapterContentType::CONTENT_TYPE_MUSIC;
+  rendererOptions.streamUsage = AudioAdapterStreamUsage::STREAM_USAGE_MEDIA;
+  rendererOptions.rendererFlags = 0;
+
+  if (InitRender(rendererOptions)) {
+    SetupAudioBuffer();
+    active_buffer_index_ = 0;
+    return true;
+  }
+  return false;
+}
+
+void OHOSAudioOutputStream::Close() {
+  Stop();
+  ReleaseAudioBuffer();
+  manager_->ReleaseOutputStream(this);
+}
+
+void OHOSAudioOutputStream::Start(AudioSourceCallback* callback) {
+  DCHECK(!callback_);
+  DCHECK(reference_time_.is_null());
+  DCHECK(!timer_.IsRunning());
+
+  if (StartRender()) {
+    callback_ = callback;
+    memset(audio_data_[active_buffer_index_], 0, buffer_size_bytes_);
+    active_buffer_index_ = (active_buffer_index_ + 1) % kMaxNumOfBuffersInQueue;
+    if (callback_) {
+      DCHECK(!timer_.IsRunning());
+      PumpSamples();
+    }
+  }
+}
+
+void OHOSAudioOutputStream::Stop() {
+  callback_ = nullptr;
+  if (!reference_time_.is_null()) {
+    reference_time_ = base::TimeTicks();
+  }
+  timer_.Stop();
+  if (!audio_renderer_->Stop()) {
+    ReportError();
+  }
+}
+
+// This stream is always used with sub second buffer sizes, where it's
+// sufficient to simply always flush upon Start().
+void OHOSAudioOutputStream::Flush() {}
+
+void OHOSAudioOutputStream::SetVolume(double volume) {
+  DCHECK(0.0 <= volume && volume <= 1.0) << volume;
+  (void)audio_renderer_->SetVolume(volume);
+}
+
+void OHOSAudioOutputStream::GetVolume(double* volume) {
+  *volume = static_cast<double>(audio_renderer_->GetVolume());
+}
+
+base::TimeTicks OHOSAudioOutputStream::GetCurrentStreamTime() {
+  DCHECK(!reference_time_.is_null());
+  return reference_time_ +
+         AudioTimestampHelper::FramesToTime(stream_position_samples_,
+                                            parameters_.sample_rate());
+}
+
+bool OHOSAudioOutputStream::InitRender(
+    const AudioAdapterRendererOptions& rendererOptions) {
+  int32_t ret = audio_renderer_->Create(rendererOptions);
+  if (ret != 0) {
+    if (!audio_renderer_->Release()) {
+      LOG(ERROR) << "ohos audio render release failed";
+    }
+    return false;
+  }
+  return true;
+}
+
+bool OHOSAudioOutputStream::StartRender() {
+  if (!audio_renderer_->Start()) {
+    LOG(ERROR) << "ohos audio render start failed";
+    if (!audio_renderer_->Release()) {
+      LOG(ERROR) << "ohos audio render release failed";
+    }
+    ReportError();
+    return false;
+  }
+  return true;
+}
+
+void OHOSAudioOutputStream::ReportError() {
+  LOG(ERROR) << "ohos audio render error happened";
+  reference_time_ = base::TimeTicks();
+  timer_.Stop();
+  if (callback_)
+    callback_->OnError(AudioSourceCallback::ErrorType::kUnknown);
+}
+
+void OHOSAudioOutputStream::PumpSamples() {
+  base::TimeTicks now = base::TimeTicks::Now();
+  base::TimeDelta delay;
+
+  if (reference_time_.is_null()) {
+    stream_position_samples_ = 0;
+  } else {
+    auto stream_time = GetCurrentStreamTime();
+    // Adjust stream position if we missed timer deadline.
+    if (now > stream_time + parameters_.GetBufferDuration() / 2) {
+      stream_position_samples_ += AudioTimestampHelper::TimeToFrames(
+          now - stream_time - parameters_.GetBufferDuration() / 2,
+          parameters_.sample_rate());
+    }
+
+    uint64_t latency = 0;
+    audio_renderer_->GetLatency(latency);
+    delay = base::TimeDelta::FromMicroseconds(latency);
+  }
+
+  // Request more samples from |callback_|.
+  int frames_filled = callback_->OnMoreData(delay, now, 0, audio_bus_.get());
+  DCHECK_EQ(frames_filled, audio_bus_->frames());
+  audio_bus_->Scale(volume_);
+  audio_bus_->ToInterleaved<SignedInt16SampleTypeTraits>(
+      frames_filled,
+      reinterpret_cast<int16_t*>(audio_data_[active_buffer_index_]));
+  const int num_filled_bytes = frames_filled * bytes_per_frame_;
+
+  int32_t result = audio_renderer_->Write(audio_data_[active_buffer_index_],
+                                          num_filled_bytes);
+  if (result < 0) {
+    ReportError();
+  }
+
+  active_buffer_index_ = (active_buffer_index_ + 1) % kMaxNumOfBuffersInQueue;
+
+  if (reference_time_.is_null()) {
+    reference_time_ = now;
+  }
+
+  stream_position_samples_ += frames_filled;
+  SchedulePumpSamples(now);
+}
+
+void OHOSAudioOutputStream::SchedulePumpSamples(base::TimeTicks now) {
+  timer_.Start(FROM_HERE, GetCurrentStreamTime() - now,
+               base::BindOnce(&OHOSAudioOutputStream::PumpSamples,
+                              base::Unretained(this)));
+}
+
+void OHOSAudioOutputStream::SetupAudioBuffer() {
+  DCHECK(!audio_data_[0]);
+  for (int i = 0; i < kMaxNumOfBuffersInQueue; ++i)
+    audio_data_[i] = new uint8_t[buffer_size_bytes_];
+}
+
+void OHOSAudioOutputStream::ReleaseAudioBuffer() {
+  if (audio_data_[0]) {
+    for (int i = 0; i < kMaxNumOfBuffersInQueue; ++i) {
+      delete[] audio_data_[i];
+      audio_data_[i] = nullptr;
+    }
+  }
+}
+
+}  // namespace media
diff --git a/media/audio/ohos/ohos_audio_output_stream.h b/media/audio/ohos/ohos_audio_output_stream.h
new file mode 100644
index 0000000000000..2f09455dab8f0
--- /dev/null
+++ b/media/audio/ohos/ohos_audio_output_stream.h
@@ -0,0 +1,97 @@
+// Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_OHOS_AUDIO_OUTPUT_STREAM_H_
+#define MEDIA_AUDIO_OHOS_AUDIO_OUTPUT_STREAM_H_
+
+#include "audio_renderer_adapter.h"
+#include "base/logging.h"
+#include "base/timer/timer.h"
+#include "media/audio/ohos/ohos_audio_manager.h"
+
+namespace media {
+using namespace OHOS::NWeb;
+
+class OHOSAudioManager;
+
+class OHOSAudioOutputStream : public AudioOutputStream {
+ public:
+  static const int kMaxNumOfBuffersInQueue = 2;
+
+  // Caller must ensure that manager outlives the stream.
+  OHOSAudioOutputStream(OHOSAudioManager* manager,
+                        const AudioParameters& parameters);
+
+  // AudioOutputStream interface.
+  bool Open() override;
+  void Start(AudioSourceCallback* callback) override;
+  void Stop() override;
+  void Flush() override;
+  void SetVolume(double volume) override;
+  void GetVolume(double* volume) override;
+  void Close() override;
+
+ private:
+  ~OHOSAudioOutputStream() override;
+
+  base::TimeTicks GetCurrentStreamTime();
+
+  // Resets internal state and reports an error to |callback_|.
+  void ReportError();
+
+  // Requests data from AudioSourceCallback, passes it to the mixer and
+  // schedules |timer_| for the next call.
+  void PumpSamples();
+
+  // Schedules |timer_| to call PumpSamples() when appropriate for the next
+  // packet.
+  void SchedulePumpSamples(base::TimeTicks now);
+
+  // Called in Open();
+  void SetupAudioBuffer();
+
+  // Called in Close();
+  void ReleaseAudioBuffer();
+
+  bool InitRender(const AudioAdapterRendererOptions& rendererOptions);
+
+  bool StartRender();
+
+  OHOSAudioManager* manager_;
+
+  AudioParameters parameters_;
+
+  // |audio_bus_| is used only in PumpSamples(). It is kept here to avoid
+  // reallocating the memory every time.
+  std::unique_ptr<AudioBus> audio_bus_;
+
+  AudioSourceCallback* callback_ = nullptr;
+
+  double volume_ = 1.0;
+
+  base::TimeTicks reference_time_;
+
+  int64_t stream_position_samples_;
+
+  // Timer that's scheduled to call PumpSamples().
+  base::OneShotTimer timer_;
+
+  uint8_t* audio_data_[kMaxNumOfBuffersInQueue];
+
+  int active_buffer_index_;
+
+  int bytes_per_frame_;
+
+  size_t buffer_size_bytes_;
+
+  SampleFormat sample_format_;
+
+  std::unique_ptr<AudioRendererAdapter> audio_renderer_;
+
+  DISALLOW_COPY_AND_ASSIGN(OHOSAudioOutputStream);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_OHOS_AUDIO_OUTPUT_STREAM_H_
diff --git a/media/base/ohos/ohos_media_player_bridge.cc b/media/base/ohos/ohos_media_player_bridge.cc
index 9000caac7bf33..a694ca965f646 100644
--- a/media/base/ohos/ohos_media_player_bridge.cc
+++ b/media/base/ohos/ohos_media_player_bridge.cc
@@ -23,35 +23,71 @@ OHOSMediaPlayerBridge::OHOSMediaPlayerBridge(
     Client* client,
     bool allow_credentials,
     bool is_hls)
-    : client_(client), url_(url) {}
+    : client_(client),
+      url_(url),
+      prepared_(false),
+      pending_play_(false),
+      should_seek_on_prepare_(false) {}
 
 OHOSMediaPlayerBridge::~OHOSMediaPlayerBridge() {
+  if (player_) {
+    player_->Release();
+    player_ = nullptr;
+  }
+
   cached_buffers_.clear();
 }
 
 int32_t OHOSMediaPlayerBridge::Initialize() {
   if (url_.SchemeIsBlob()) {
     NOTREACHED();
-    return -1;
+    return PLAYER_INIT_ERROR;
   }
-  task_runner_ = base::ThreadTaskRunnerHandle::Get();
-  if (task_runner_ == nullptr) {
-    LOG(ERROR) << "media task runner failed";
-    return -1;
+  return PLAYER_INIT_OK;
+}
+
+void OHOSMediaPlayerBridge::Start() {
+  if (!player_) {
+    pending_play_ = true;
+    Prepare();
+  } else {
+    if (prepared_) {
+      StartInternal();
+    } else {
+      pending_play_ = true;
+    }
   }
+}
+
+void OHOSMediaPlayerBridge::Prepare() {
+  DCHECK(!player_);
+
+  if (url_.SchemeIsBlob()) {
+    NOTREACHED();
+    return;
+  }
+
   player_ = OHOS::Media::PlayerFactory::CreatePlayer();
-  if (player_ == nullptr) {
+  if (!player_) {
     LOG(ERROR) << "media create player failed";
-    return -1;
+    return;
+  }
+
+  task_runner_ = base::ThreadTaskRunnerHandle::Get();
+  if (!task_runner_) {
+    LOG(ERROR) << "media task runner failed";
+    return;
   }
+
   std::shared_ptr<OHOSMediaPlayerCallback> media_player_callback =
       std::make_shared<OHOSMediaPlayerCallback>(task_runner_,
                                                 weak_factory_.GetWeakPtr());
   int32_t ret = player_->SetPlayerCallback(media_player_callback);
   if (ret != 0) {
     LOG(ERROR) << "SetPlayerCallback error::ret=" << ret;
-    return ret;
+    return;
   }
+
   if (url_.SchemeIsFile()) {
     ret = SetFdSource(url_.GetContent());
   } else {
@@ -59,12 +95,13 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
   }
   if (ret != 0) {
     LOG(ERROR) << "SetSource error::ret=" << ret;
-    return ret;
+    return;
   }
+
   consumer_surface_ = OHOS::Surface::CreateSurfaceAsConsumer();
   if (consumer_surface_ == nullptr) {
     LOG(ERROR) << "media create surface failed";
-    return -1;
+    return;
   }
   listener_ = new OHOSMediaPlayerListener(
       task_runner_, weak_factory_.GetWeakPtr(), consumer_surface_);
@@ -75,23 +112,19 @@ int32_t OHOSMediaPlayerBridge::Initialize() {
   ret = player_->SetVideoSurface(consumer_surface_);
   if (ret != 0) {
     LOG(ERROR) << "SetVideoSurface error::ret=" << ret;
-    return ret;
+    consumer_surface_ = nullptr;
+    return;
   }
+
   ret = player_->PrepareAsync();
   if (ret != 0) {
     LOG(ERROR) << "Prepare error::ret=" << ret << " url=" << url_.spec();
-    return ret;
   }
-  return ret;
 }
 
-void OHOSMediaPlayerBridge::Start() {
-  if (player_ && is_player_prepared_ &&
-      player_state_ != OHOS::Media::PLAYER_STARTED) {
-    int32_t ret = player_->Play();
-    if (ret != 0) {
-      LOG(ERROR) << "Play error::ret=" << ret;
-    }
+void OHOSMediaPlayerBridge::StartInternal() {
+  if (player_ && prepared_) {
+    player_->Play();
   }
 }
 
@@ -105,14 +138,19 @@ void OHOSMediaPlayerBridge::Pause() {
 }
 
 void OHOSMediaPlayerBridge::SeekTo(base::TimeDelta time) {
-  if (player_) {
-    seeking_ = true;
-    pending_seek_ = time;
-    int32_t ret = player_->Seek(time.InMilliseconds(),
-                                OHOS::Media::PlayerSeekMode::SEEK_CLOSEST);
-    if (ret != 0) {
-      LOG(ERROR) << "Seek error::ret=" << ret;
-    }
+  pending_seek_ = time;
+  should_seek_on_prepare_ = true;
+
+  if (prepared_) {
+    SeekInternal(time);
+  }
+}
+
+void OHOSMediaPlayerBridge::SeekInternal(base::TimeDelta time) {
+  int32_t ret = player_->Seek(time.InMilliseconds(),
+                              OHOS::Media::PlayerSeekMode::SEEK_CLOSEST);
+  if (ret != 0) {
+    LOG(ERROR) << "Seek error::ret=" << ret;
   }
 }
 
@@ -125,8 +163,13 @@ void OHOSMediaPlayerBridge::SetVolume(float volume) {
   }
 }
 
+void OHOSMediaPlayerBridge::PropagateDuration(base::TimeDelta duration) {
+  duration_ = duration;
+  client_->OnMediaDurationChanged(duration_);
+}
+
 base::TimeDelta OHOSMediaPlayerBridge::GetDuration() {
-  if (player_) {
+  if (player_ && prepared_) {
     int32_t time = -1;
     (void)player_->GetDuration(time);
     return base::TimeDelta::FromMilliseconds(time);
@@ -135,16 +178,13 @@ base::TimeDelta OHOSMediaPlayerBridge::GetDuration() {
 }
 
 base::TimeDelta OHOSMediaPlayerBridge::GetMediaTime() {
-  if (player_) {
-    if (seeking_) {
-      return pending_seek_;
-    } else {
-      int32_t time = -1;
-      (void)player_->GetCurrentTime(time);
-      return base::TimeDelta::FromMilliseconds(time);
-    }
+  if (!player_ || !prepared_) {
+    return pending_seek_;
   }
-  return base::TimeDelta::FromMilliseconds(0);
+
+  int32_t time = -1;
+  (void)player_->GetCurrentTime(time);
+  return base::TimeDelta::FromMilliseconds(time);
 }
 
 void OHOSMediaPlayerBridge::FinishPaint(int fd) {
@@ -192,22 +232,33 @@ void OHOSMediaPlayerBridge::OnError(int32_t error_code) {
   client_->OnError(error_code);
 }
 
-void OHOSMediaPlayerBridge::OnSeekDone() {
-  seeking_ = false;
-}
-
 void OHOSMediaPlayerBridge::OnPlayerStateUpdate(
     OHOS::Media::PlayerStates player_state) {
+  if (!player_) {
+    return;
+  }
+
   player_state_ = player_state;
   if (player_state == OHOS::Media::PLAYER_PREPARED) {
-    is_player_prepared_ = true;
-    client_->OnPlayerPrepared(PLAYER_INIT_OK);
+    prepared_ = true;
+
+    PropagateDuration(GetDuration());
+
+    if (should_seek_on_prepare_) {
+      SeekInternal(pending_seek_);
+      pending_seek_ = base::TimeDelta::FromMilliseconds(0);
+      should_seek_on_prepare_ = false;
+    }
+
+    if (pending_play_) {
+      StartInternal();
+      pending_play_ = false;
+    }
   } else if (player_state == OHOS::Media::PLAYER_STATE_ERROR ||
              player_state == OHOS::Media::PLAYER_IDLE ||
              player_state == OHOS::Media::PLAYER_INITIALIZED ||
              player_state == OHOS::Media::PLAYER_PREPARING) {
-    is_player_prepared_ = false;
-    client_->OnPlayerPrepared(PLAYER_INIT_ERROR);
+    prepared_ = false;
   }
 }
 
diff --git a/media/base/ohos/ohos_media_player_bridge.h b/media/base/ohos/ohos_media_player_bridge.h
index 84afaea19baf2..a0f2afa4287fd 100644
--- a/media/base/ohos/ohos_media_player_bridge.h
+++ b/media/base/ohos/ohos_media_player_bridge.h
@@ -39,8 +39,6 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
 
     // Called when video size has changed.
     virtual void OnVideoSizeChanged(int width, int height) = 0;
-
-    virtual void OnPlayerPrepared(int status) = 0;
   };
 
   enum MediaErrorType {
@@ -74,11 +72,14 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
   void OnEnd();
   void OnError(int32_t errorCode);
   void OnBufferAvailable(OHOS::sptr<OHOS::SurfaceBuffer> buffer);
-  void OnSeekDone();
   void OnPlayerStateUpdate(OHOS::Media::PlayerStates player_state);
 
  private:
   int32_t SetFdSource(const std::string& path);
+  void Prepare();
+  void StartInternal();
+  void SeekInternal(base::TimeDelta time);
+  void PropagateDuration(base::TimeDelta duration);
 
   const std::string surfaceFormat = "SURFACE_FORMAT";
   std::shared_ptr<OHOS::Media::Player> player_ = nullptr;
@@ -88,8 +89,10 @@ class MEDIA_EXPORT OHOSMediaPlayerBridge {
   scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
   Client* client_;
   GURL url_;
-  bool seeking_ = false;
-  bool is_player_prepared_ = false;
+  bool prepared_;
+  bool pending_play_;
+  bool should_seek_on_prepare_;
+  base::TimeDelta duration_;
   base::TimeDelta pending_seek_;
   OHOS::Media::PlayerStates player_state_;
   base::WeakPtrFactory<OHOSMediaPlayerBridge> weak_factory_{this};
diff --git a/media/base/ohos/ohos_media_player_callback.cc b/media/base/ohos/ohos_media_player_callback.cc
index 36c9ab8c1fc09..4fe5ec01456de 100644
--- a/media/base/ohos/ohos_media_player_callback.cc
+++ b/media/base/ohos/ohos_media_player_callback.cc
@@ -38,11 +38,6 @@ void OHOSMediaPlayerCallback::OnInfo(OHOS::Media::PlayerOnInfoType type,
                                      const OHOS::Media::Format& infoBody) {
   (void)infoBody;
   switch (type) {
-    case OHOS::Media::INFO_TYPE_SEEKDONE:
-      task_runner_->PostTask(
-          FROM_HERE,
-          base::BindOnce(&OHOSMediaPlayerBridge::OnSeekDone, media_player_));
-      break;
     case OHOS::Media::INFO_TYPE_EOS:
       task_runner_->PostTask(
           FROM_HERE,
diff --git a/media/midi/midi_manager.cc b/media/midi/midi_manager.cc
index 6378948b125a6..c79d03f71f207 100644
--- a/media/midi/midi_manager.cc
+++ b/media/midi/midi_manager.cc
@@ -186,7 +186,7 @@ void MidiManager::EndAllSessions() {
 }
 
 void MidiManager::StartInitialization() {
-  CompleteInitialization(Result::NOT_SUPPORTED);
+  CompleteInitialization(Result::OK);
 }
 
 void MidiManager::CompleteInitialization(Result result) {
diff --git a/mojo/public/cpp/base/BUILD.gn b/mojo/public/cpp/base/BUILD.gn
index ee0eb1589395c..b277232f58447 100644
--- a/mojo/public/cpp/base/BUILD.gn
+++ b/mojo/public/cpp/base/BUILD.gn
@@ -92,6 +92,8 @@ component("shared_typemap_traits") {
     "read_only_buffer_mojom_traits.h",
     "read_only_file_mojom_traits.cc",
     "read_only_file_mojom_traits.h",
+    "safe_base_name_mojom_traits.cc",
+    "safe_base_name_mojom_traits.h",
     "shared_memory_mojom_traits.cc",
     "shared_memory_mojom_traits.h",
     "time_mojom_traits.cc",
@@ -125,6 +127,7 @@ source_set("tests") {
     "process_id_unittest.cc",
     "read_only_buffer_unittest.cc",
     "ref_counted_memory_unittest.cc",
+    "safe_base_name_unittest.cc",
     "shared_memory_unittest.cc",
     "string16_unittest.cc",
     "text_direction_unittest.cc",
diff --git a/mojo/public/cpp/base/safe_base_name_mojom_traits.cc b/mojo/public/cpp/base/safe_base_name_mojom_traits.cc
new file mode 100644
index 0000000000000..ddf2a2b808fe7
--- /dev/null
+++ b/mojo/public/cpp/base/safe_base_name_mojom_traits.cc
@@ -0,0 +1,29 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "mojo/public/cpp/base/safe_base_name_mojom_traits.h"
+#include "mojo/public/cpp/base/file_path_mojom_traits.h"
+
+namespace mojo {
+
+// static
+bool StructTraits<mojo_base::mojom::SafeBaseNameDataView, base::SafeBaseName>::
+    Read(mojo_base::mojom::SafeBaseNameDataView data, base::SafeBaseName* out) {
+  base::FilePath path;
+  if (!data.ReadPath(&path))
+    return false;
+
+  if (path.BaseName() != path)
+    return false;
+
+  auto maybe_basename = base::SafeBaseName::Create(path);
+  if (!maybe_basename)
+    return false;
+
+  *out = *maybe_basename;
+
+  return true;
+}
+
+}  // namespace mojo
\ No newline at end of file
diff --git a/mojo/public/cpp/base/safe_base_name_mojom_traits.h b/mojo/public/cpp/base/safe_base_name_mojom_traits.h
new file mode 100644
index 0000000000000..aa6b81b2fd904
--- /dev/null
+++ b/mojo/public/cpp/base/safe_base_name_mojom_traits.h
@@ -0,0 +1,28 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MOJO_PUBLIC_CPP_BASE_SAFE_BASE_NAME_MOJOM_TRAITS_H_
+#define MOJO_PUBLIC_CPP_BASE_SAFE_BASE_NAME_MOJOM_TRAITS_H_
+
+#include "base/component_export.h"
+#include "base/files/safe_base_name.h"
+#include "mojo/public/cpp/bindings/struct_traits.h"
+#include "mojo/public/mojom/base/safe_base_name.mojom-shared.h"
+
+namespace mojo {
+
+template <>
+struct COMPONENT_EXPORT(MOJO_BASE_SHARED_TRAITS)
+    StructTraits<mojo_base::mojom::SafeBaseNameDataView, base::SafeBaseName> {
+  static const base::FilePath& path(const base::SafeBaseName& path) {
+    return path.path();
+  }
+
+  static bool Read(mojo_base::mojom::SafeBaseNameDataView data,
+                   base::SafeBaseName* out);
+};
+
+}  // namespace mojo
+
+#endif  // MOJO_PUBLIC_CPP_BASE_SAFE_BASE_NAME_MOJOM_TRAITS_H_
diff --git a/mojo/public/cpp/base/safe_base_name_unittest.cc b/mojo/public/cpp/base/safe_base_name_unittest.cc
new file mode 100644
index 0000000000000..863291b81c25e
--- /dev/null
+++ b/mojo/public/cpp/base/safe_base_name_unittest.cc
@@ -0,0 +1,98 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "mojo/public/cpp/base/safe_base_name_mojom_traits.h"
+#include "mojo/public/cpp/test_support/test_utils.h"
+#include "mojo/public/mojom/base/safe_base_name.mojom.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace mojo_base {
+
+namespace {
+absl::optional<base::SafeBaseName> CreateSafeBaseName() {
+  return base::SafeBaseName::Create(base::FilePath());
+}
+}  // namespace
+
+TEST(SafeBaseNameTest, PathEmpty) {
+  absl::optional<base::SafeBaseName> basename = CreateSafeBaseName();
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  ASSERT_TRUE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      *basename, *basename_out));
+  EXPECT_EQ(basename->path(), basename_out->path());
+}
+
+TEST(SafeBaseNameTest, PathContainsNoSeparators) {
+  absl::optional<base::SafeBaseName> basename(
+      base::SafeBaseName::Create(FILE_PATH_LITERAL("hello")));
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  ASSERT_TRUE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      *basename, *basename_out));
+  EXPECT_EQ(basename->path(), basename_out->path());
+}
+
+TEST(SafeBaseNameTest, PathContainsSeparators) {
+  base::FilePath file = base::FilePath(FILE_PATH_LITERAL("hello"))
+                            .Append(FILE_PATH_LITERAL("world"));
+  absl::optional<base::SafeBaseName> basename(base::SafeBaseName::Create(file));
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  ASSERT_TRUE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      *basename, *basename_out));
+  EXPECT_EQ(basename->path(), basename_out->path());
+}
+
+TEST(SafeBaseNameTest, PathEndsWithSeparator) {
+  base::FilePath file = base::FilePath(FILE_PATH_LITERAL("hello"))
+                            .Append(FILE_PATH_LITERAL("world"))
+                            .AsEndingWithSeparator();
+  absl::optional<base::SafeBaseName> basename(base::SafeBaseName::Create(file));
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  ASSERT_TRUE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      *basename, *basename_out));
+  EXPECT_EQ(basename->path(), basename_out->path());
+}
+
+#if defined(FILE_PATH_USES_DRIVE_LETTERS)
+TEST(SafeBaseNameTest, PathIsRootWin) {
+  mojo_base::mojom::SafeBaseNamePtr mojom_basename =
+      mojo_base::mojom::SafeBaseName::New();
+  mojom_basename->path = base::FilePath(FILE_PATH_LITERAL("C:\\"));
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  // Expect deserialization to fail because "C:\\ is an absolute path. See
+  // safe_base_name.h
+  ASSERT_FALSE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      mojom_basename, *basename_out));
+}
+#else
+TEST(SafeBaseNameTest, PathIsRoot) {
+  mojo_base::mojom::SafeBaseNamePtr mojom_basename =
+      mojo_base::mojom::SafeBaseName::New();
+  mojom_basename->path = base::FilePath(FILE_PATH_LITERAL("/"));
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  // Expect deserialization to fail because "/" is an absolute path. See
+  // safe_base_name.h
+  ASSERT_FALSE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      mojom_basename, *basename_out));
+}
+#endif  // FILE_PATH_USES_DRIVE_LETTERS
+
+#if defined(FILE_PATH_USES_WIN_SEPARATORS)
+TEST(SafeBaseNameTest, PathIsFileInRootWin) {
+  absl::optional<base::SafeBaseName> basename(
+      base::SafeBaseName::Create(FILE_PATH_LITERAL("C:\\foo.txt")));
+  absl::optional<base::SafeBaseName> basename_out = CreateSafeBaseName();
+
+  ASSERT_TRUE(mojo::test::SerializeAndDeserialize<mojom::SafeBaseName>(
+      *basename, *basename_out));
+  EXPECT_EQ(basename->path(), basename_out->path());
+}
+#endif  // FILE_PATH_USES_WIN_SEPARATORS
+
+}  // namespace mojo_base
\ No newline at end of file
diff --git a/mojo/public/mojom/base/BUILD.gn b/mojo/public/mojom/base/BUILD.gn
index 9d6373643e4cc..ba822d9c67c77 100644
--- a/mojo/public/mojom/base/BUILD.gn
+++ b/mojo/public/mojom/base/BUILD.gn
@@ -23,6 +23,7 @@ mojom_component("base") {
     "read_only_buffer.mojom",
     "read_only_file.mojom",
     "ref_counted_memory.mojom",
+    "safe_base_name.mojom",
     "shared_memory.mojom",
     "string16.mojom",
     "text_direction.mojom",
@@ -49,6 +50,21 @@ mojom_component("base") {
   macro_prefix = "MOJO_BASE_MOJOM"
 
   common_typemaps = [
+    {
+      types = [
+        {
+          mojom = "mojo_base.mojom.SafeBaseName"
+          cpp = "::base::SafeBaseName"
+        },
+      ]
+      traits_headers =
+          [ "//mojo/public/cpp/base/safe_base_name_mojom_traits.h" ]
+      traits_public_deps = [
+        "//base",
+        "//mojo/public/cpp/base",
+        "//mojo/public/cpp/base:shared_typemap_traits",
+      ]
+    },
     {
       types = [
         {
diff --git a/mojo/public/mojom/base/safe_base_name.mojom b/mojo/public/mojom/base/safe_base_name.mojom
new file mode 100644
index 0000000000000..3c993b4db1bf5
--- /dev/null
+++ b/mojo/public/mojom/base/safe_base_name.mojom
@@ -0,0 +1,12 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+module mojo_base.mojom;
+
+import "mojo/public/mojom/base/file_path.mojom";
+
+// mojom transport for base::SafeBaseName.
+struct SafeBaseName {
+  FilePath path;
+};
diff --git a/net/cert/cert_status_flags_list.h b/net/cert/cert_status_flags_list.h
index 523942c892432..1fec1a68cbd06 100644
--- a/net/cert/cert_status_flags_list.h
+++ b/net/cert/cert_status_flags_list.h
@@ -45,3 +45,4 @@ CERT_STATUS_FLAG(CERTIFICATE_TRANSPARENCY_REQUIRED, 1 << 24)
 CERT_STATUS_FLAG(SYMANTEC_LEGACY, 1 << 25)
 CERT_STATUS_FLAG(KNOWN_INTERCEPTION_BLOCKED, 1 << 26)
 CERT_STATUS_FLAG(LEGACY_TLS, 1 << 27)
+CERT_STATUS_FLAG(DEPTH_ZERO_SELF_SIGNED_CERT, 1 << 28)
diff --git a/net/cert/cert_verify_proc.cc b/net/cert/cert_verify_proc.cc
index e6e463a24a8c0..2ee870b38f14a 100644
--- a/net/cert/cert_verify_proc.cc
+++ b/net/cert/cert_verify_proc.cc
@@ -700,6 +700,12 @@ int CertVerifyProc::Verify(X509Certificate* cert,
 
   net_log.EndEvent(NetLogEventType::CERT_VERIFY_PROC,
                    [&] { return verify_result->NetLogParams(rv); });
+
+  if ((verify_result->cert_status & CERT_STATUS_COMMON_NAME_INVALID) &&
+      (verify_result->cert_status & CERT_STATUS_DEPTH_ZERO_SELF_SIGNED_CERT)) {
+    return OK;
+  }
+
   return rv;
 }
 
diff --git a/net/cert/cert_verify_proc_ohos.cc b/net/cert/cert_verify_proc_ohos.cc
index 82d219d37d603..84a663ea45961 100644
--- a/net/cert/cert_verify_proc_ohos.cc
+++ b/net/cert/cert_verify_proc_ohos.cc
@@ -2,30 +2,40 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "net/cert/cert_verify_proc_ohos.h"
 #include <string>
 #include <vector>
+
 #include "base/logging.h"
+#include "crypto/sha2.h"
+#include "net/cert/asn1_util.h"
 #include "net/cert/cert_net_fetcher.h"
+#include "net/cert/cert_verify_proc_ohos.h"
+#include "net/cert/cert_verify_result.h"
+#include "net/cert/internal/cert_errors.h"
+#include "net/cert/internal/parsed_certificate.h"
+#include "net/cert/known_roots.h"
 #include "net/cert/x509_certificate.h"
 #include "net/cert/x509_util.h"
 #include "openssl/err.h"
 #include "openssl/ossl_typ.h"
 #include "openssl/x509.h"
 #include "openssl/x509_vfy.h"
+#include "url/gurl.h"
 
 #define ROOT_CERT "/etc/ssl/certs/cacert.pem"
 #define MIN_CERT_NUM 1
-namespace net {
-CertVerifyProcOHOS::CertVerifyProcOHOS(
-    scoped_refptr<CertNetFetcher> cert_net_fetcher)
-    : cert_net_fetcher_(std::move(cert_net_fetcher)) {}
 
-CertVerifyProcOHOS::~CertVerifyProcOHOS() {}
+namespace net {
+// OH ignores the authType parameter to
+// X509TrustManager.checkServerTrusted, so pass in a dummy value. See
+// https://crbug.com/627154.
+const char kAuthType[] = "RSA";
 
-bool CertVerifyProcOHOS::SupportsAdditionalTrustAnchors() const {
-  return false;
-}
+// The maximum number of AIA fetches that TryVerifyWithAIAFetching() will
+// attempt. If a valid chain cannot be built after this many fetches,
+// TryVerifyWithAIAFetching() will give up and return
+// X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.
+const unsigned int kMaxAIAFetches = 5;
 
 void GetChainDEREncodedBytes(X509Certificate* cert,
                              std::vector<std::string>* chain_bytes) {
@@ -45,62 +55,62 @@ void X509_d2i_free(X509* server_cert[], uint32_t server_cert_sum) {
   }
 }
 
-bool CertChainVerify(X509* server_cert[],
-                     uint32_t server_cert_sum,
-                     X509_STORE* root_store) {
+int CertChainVerify(X509* server_cert[],
+                    int32_t server_cert_sum,
+                    X509_STORE* ca_store) {
   uint32_t i;
   STACK_OF(X509)* ca_stack = nullptr;
   X509_STORE_CTX* ctx = nullptr;
 
-  // certificate chain verify
+  // Add the server certificate to the certificate store
   for (i = server_cert_sum - 1; i > 0; i--) {
-    // Create certificate store context function
-    ctx = X509_STORE_CTX_new();
-    if (ctx == nullptr) {
-      LOG(ERROR) << "Create certificate store context function failed";
-      X509_d2i_free(server_cert, server_cert_sum);
-      X509_STORE_free(root_store);
-      return false;
-    }
+    X509_STORE_add_cert(ca_store, server_cert[i]);
+  }
 
-    // Initialize the certificate chain
-    X509_STORE_CTX_init(ctx, root_store, server_cert[i], ca_stack);
-
-    // If verification fails, for detailed error information, see
-    // X509_verify_cert_error_string
-    if (!X509_verify_cert(ctx)) {
-      LOG(ERROR) << "Certificate verify error: " << ctx->error
-                 << "\nCertificate verify info: "
-                 << X509_verify_cert_error_string(ctx->error)
-                 << "\nTotal number of server certificates: " << server_cert_sum
-                 << "\nserver certificates count: " << i;
-      X509_d2i_free(server_cert, server_cert_sum);
-      X509_STORE_CTX_free(ctx);
-      X509_STORE_free(root_store);
-      return false;
-    }
+  // Create certificate store context function
+  ctx = X509_STORE_CTX_new();
+  if (ctx == nullptr) {
+    LOG(ERROR) << "Create certificate store context function failed";
+    X509_d2i_free(server_cert, server_cert_sum);
+    X509_STORE_free(ca_store);
+    return X509_V_ERR_UNSPECIFIED;
+  }
 
+  X509_STORE_CTX_init(ctx, ca_store, server_cert[0], ca_stack);
+
+  // If verification fails, for detailed error information, see
+  // X509_verify_cert_error_string
+  if (!X509_verify_cert(ctx)) {
+    auto error = ctx->error;
+    LOG(ERROR) << "Certificate verify error: " << error
+               << ", Certificate verify info: "
+               << X509_verify_cert_error_string(ctx->error)
+               << ", Total number of server certificate: " << server_cert_sum;
+    X509_d2i_free(server_cert, server_cert_sum);
     X509_STORE_CTX_free(ctx);
+    X509_STORE_free(ca_store);
+    return error;
   }
 
+  X509_STORE_CTX_free(ctx);
   X509_d2i_free(server_cert, server_cert_sum);
-  X509_STORE_free(root_store);
+  X509_STORE_free(ca_store);
 
-  return true;
+  return X509_V_OK;
 }
 
-bool CertVerify(std::vector<std::string>& cert_bytes) {
+int CertVerify(std::vector<std::string>& cert_bytes) {
   uint32_t server_cert_sum;
   const unsigned char* der_encoded_tmp = nullptr;
   uint32_t i;
   int root_cert_sum = 0;
-  X509_STORE* root_store = nullptr;
+  X509_STORE* ca_store = nullptr;
   X509_LOOKUP* look_up = nullptr;
 
   server_cert_sum = cert_bytes.size();
   if (server_cert_sum < MIN_CERT_NUM) {
-    LOG(ERROR) << "Total number of server certificates is error";
-    return false;
+    LOG(ERROR) << "Total number of server certificate is error";
+    return X509_V_ERR_UNSPECIFIED;
   }
 
   // Convert cert_bytes to internal X509 data structure(server_cert[]), If the
@@ -113,30 +123,30 @@ bool CertVerify(std::vector<std::string>& cert_bytes) {
       LOG(ERROR)
           << "Server certificate DEREncoded converted to X509 error, Reason: "
           << ERR_reason_error_string(ERR_get_error())
-          << "\nTotal number of server certificates: " << server_cert_sum
+          << "\nTotal number of server certificate: " << server_cert_sum
           << "\nError certificate count:" << i;
       ERR_clear_error();
       X509_d2i_free(server_cert, i);
-      return false;
+      return X509_V_ERR_UNSPECIFIED;
     }
   }
 
   // Create X509 certificate store
-  root_store = X509_STORE_new();
-  if (root_store == nullptr) {
+  ca_store = X509_STORE_new();
+  if (ca_store == nullptr) {
     LOG(ERROR) << "Create X509 certificate store failed";
     X509_d2i_free(server_cert, server_cert_sum);
-    return false;
+    return X509_V_ERR_UNSPECIFIED;
   }
 
   // Create X509_LOOKUP, the store_ctx member of this data structure is
-  // associated with the newly created certificate store root_store
-  look_up = X509_STORE_add_lookup(root_store, X509_LOOKUP_file());
+  // associated with the newly created certificate store ca_store
+  look_up = X509_STORE_add_lookup(ca_store, X509_LOOKUP_file());
   if (look_up == nullptr) {
     LOG(ERROR) << "Create X509 LOOKUP failed";
     X509_d2i_free(server_cert, server_cert_sum);
-    X509_STORE_free(root_store);
-    return false;
+    X509_STORE_free(ca_store);
+    return X509_V_ERR_UNSPECIFIED;
   }
 
   // Parse the root certificate file
@@ -145,11 +155,312 @@ bool CertVerify(std::vector<std::string>& cert_bytes) {
   if (root_cert_sum == 0) {
     LOG(ERROR) << "Root certificate number is 0";
     X509_d2i_free(server_cert, server_cert_sum);
-    X509_STORE_free(root_store);
+    X509_STORE_free(ca_store);
+    return X509_V_ERR_UNSPECIFIED;
+  }
+
+  return CertChainVerify(server_cert, server_cert_sum, ca_store);
+}
+
+// Starting at certs[start], this function searches |certs| for an issuer of
+// certs[start], then for an issuer of that issuer, and so on until it finds a
+// certificate |cert| for which |certs| does not contain an issuer of
+// |cert|. Returns a pointer to this |cert|, or nullptr if all certificates
+// while path-building from |start| have an issuer in |certs| (including if
+// there is a loop). Note that the returned certificate will be equal to |start|
+// if |start| does not have an issuer in |certs|.
+//
+// TODO(estark): when searching for an issuer, this always uses the first
+// encountered issuer in |certs|, and does not handle the situation where
+// |certs| contains more than one issuer for a given certificate.
+scoped_refptr<ParsedCertificate> FindLastCertWithUnknownIssuer(
+    const ParsedCertificateList& certs,
+    const scoped_refptr<ParsedCertificate>& start) {
+  DCHECK_GE(certs.size(), 1u);
+  std::set<scoped_refptr<ParsedCertificate>> used_in_path;
+  scoped_refptr<ParsedCertificate> last = start;
+  while (true) {
+    used_in_path.insert(last);
+    scoped_refptr<ParsedCertificate> last_issuer;
+    // Find an issuer for |last| (which might be |last| itself if self-signed).
+    for (const auto& cert : certs) {
+      if (cert->normalized_subject() == last->normalized_issuer()) {
+        last_issuer = cert;
+        break;
+      }
+    }
+    if (!last_issuer) {
+      // There is no issuer for |last| in |certs|.
+      return last;
+    }
+    if (last_issuer->normalized_subject() == last_issuer->normalized_issuer()) {
+      // A chain can be built from |start| to a self-signed certificate, so
+      // return nullptr to indicate that there is no certificate with an unknown
+      // issuer.
+      return nullptr;
+    }
+    if (used_in_path.find(last_issuer) != used_in_path.end()) {
+      // |certs| contains a loop.
+      return nullptr;
+    }
+    // Continue the search for |last_issuer|'s issuer.
+    last = last_issuer;
+  }
+  NOTREACHED();
+  return nullptr;
+}
+
+// Uses |fetcher| to fetch issuers from |uri|. If the fetch succeeds, the
+// certificate is parsed and added to |cert_list|. Returns true if the fetch was
+// successful and the result could be parsed as a certificate, and false
+// otherwise.
+bool PerformAIAFetchAndAddResultToVector(scoped_refptr<CertNetFetcher> fetcher,
+                                         base::StringPiece uri,
+                                         ParsedCertificateList* cert_list) {
+  GURL url(uri);
+  if (!url.is_valid())
+    return false;
+  std::unique_ptr<CertNetFetcher::Request> request(fetcher->FetchCaIssuers(
+      url, CertNetFetcher::DEFAULT, CertNetFetcher::DEFAULT));
+  Error error;
+  std::vector<uint8_t> aia_fetch_bytes;
+  request->WaitForResult(&error, &aia_fetch_bytes);
+
+  if (error != OK)
     return false;
+  CertErrors errors;
+  return ParsedCertificate::CreateAndAddToVector(
+      x509_util::CreateCryptoBuffer(aia_fetch_bytes.data(),
+                                    aia_fetch_bytes.size()),
+      x509_util::DefaultParseCertificateOptions(), cert_list, &errors);
+}
+
+void X509CertChainVerify(std::vector<std::string>& cert_chain,
+                         base::StringPiece auth_type,
+                         base::StringPiece host,
+                         int* status,
+                         bool* is_issued_by_known_root,
+                         std::vector<std::string>* verified_chain) {
+ *is_issued_by_known_root = true;
+ *status = X509_V_OK;
+
+ *status = CertVerify(cert_chain);
+  if (*status == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) {
+    *is_issued_by_known_root = false;
   }
 
-  return CertChainVerify(server_cert, server_cert_sum, root_store);
+  verified_chain->swap(cert_chain);
+}
+
+// Uses X509CertChainVerify() to verify the certificates in |certs| for
+// |hostname| and returns the verification status. If the verification was
+// successful, this function populates |verify_result| and |verified_chain|;
+// otherwise it leaves them untouched.
+int AttemptVerificationAfterAIAFetch(
+    const ParsedCertificateList& certs,
+    const std::string& hostname,
+    CertVerifyResult* verify_result,
+    std::vector<std::string>* verified_chain) {
+  std::vector<std::string> cert_bytes;
+  for (const auto& cert : certs) {
+    cert_bytes.push_back(cert->der_cert().AsString());
+  }
+
+  bool is_issued_by_known_root;
+  std::vector<std::string> candidate_verified_chain;
+  int status;
+  X509CertChainVerify(cert_bytes, kAuthType, hostname, &status,
+                      &is_issued_by_known_root,
+                      &candidate_verified_chain);
+
+  if (status == X509_V_OK) {
+    verify_result->is_issued_by_known_root = is_issued_by_known_root;
+    *verified_chain = candidate_verified_chain;
+  }
+  return status;
+}
+
+int TryVerifyWithAIAFetching(
+    const std::vector<std::string>& cert_bytes,
+    const std::string& hostname,
+    scoped_refptr<CertNetFetcher> cert_net_fetcher,
+    CertVerifyResult* verify_result,
+    std::vector<std::string>* verified_chain) {
+  if (!cert_net_fetcher) {
+    return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+  }
+
+
+  // Convert the certificates into ParsedCertificates for ease of pulling out
+  // AIA URLs.
+  CertErrors errors;
+  ParsedCertificateList certs;
+  for (const auto& cert : cert_bytes) {
+    if (!ParsedCertificate::CreateAndAddToVector(
+            x509_util::CreateCryptoBuffer(cert),
+            x509_util::DefaultParseCertificateOptions(), &certs, &errors)) {
+      return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+    }
+  }
+
+  // Build a chain as far as possible from the target certificate at index 0,
+  // using the initially provided certificates.
+  scoped_refptr<ParsedCertificate> last_cert_with_unknown_issuer =
+      FindLastCertWithUnknownIssuer(certs, certs[0].get());
+  if (!last_cert_with_unknown_issuer) {
+    // |certs| either contains a loop, or contains a full chain to a self-signed
+    // certificate. Do not attempt AIA fetches for such a chain.
+    return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+  }
+
+  unsigned int num_aia_fetches = 0;
+  while (true) {
+    // If chain-building has terminated in a certificate that does not have an
+    // AIA URL, give up.
+    //
+    // TODO(estark): Instead of giving up at this point, it would be more robust
+    // to go back to the certificate before |last_cert| in the chain and attempt
+    // an AIA fetch from that point (if one hasn't already been done). This
+    // would accomodate chains where the server serves Leaf -> I1 signed by a
+    // root not in the client's trust store, but AIA fetching would yield an
+    // intermediate I2 signed by a root that *is* in the client's trust store.
+    if (!last_cert_with_unknown_issuer->has_authority_info_access()) {
+      return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+    }
+
+
+    for (const auto& uri : last_cert_with_unknown_issuer->ca_issuers_uris()) {
+      num_aia_fetches++;
+      if (num_aia_fetches > kMaxAIAFetches) {
+        return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+      }
+
+      if (!PerformAIAFetchAndAddResultToVector(cert_net_fetcher, uri, &certs))
+        continue;
+      int status =
+          AttemptVerificationAfterAIAFetch(certs, hostname, verify_result,
+                                           verified_chain);
+      if (status == X509_V_OK) {
+        return status;
+      }
+    }
+
+    // If verification still failed but the path expanded, continue to attempt
+    // AIA fetches.
+    scoped_refptr<ParsedCertificate> new_last_cert_with_unknown_issuer =
+        FindLastCertWithUnknownIssuer(certs, last_cert_with_unknown_issuer);
+    if (!new_last_cert_with_unknown_issuer ||
+        new_last_cert_with_unknown_issuer == last_cert_with_unknown_issuer) {
+      // The last round of AIA fetches (if there were any) didn't expand the
+      // path, or it did such that |certs| now contains a full path to an
+      // (untrusted) root or a loop.
+      //
+      // TODO(estark): As above, it would be more robust to go back one
+      // certificate and attempt an AIA fetch from that point.
+      return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+    }
+    last_cert_with_unknown_issuer = new_last_cert_with_unknown_issuer;
+  }
+
+  NOTREACHED();
+  return X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+}
+
+// Returns true if the certificate verification call was successful (regardless
+// of its result), i.e. if |verify_result| was set. Otherwise returns false.
+bool VerifyFromOhosTrustManager(
+    std::vector<std::string>& cert_bytes,
+    const std::string& hostname,
+    scoped_refptr<CertNetFetcher> cert_net_fetcher,
+    CertVerifyResult* verify_result) {
+  int status;
+  std::vector<std::string> verified_chain;
+
+  X509CertChainVerify(cert_bytes, kAuthType, hostname, &status, 
+                      &verify_result->is_issued_by_known_root, 
+                      &verified_chain);
+
+  // If verification resulted in a X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY error,
+  //  then fetch intermediates and retry.
+  if (status == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) {
+    status = TryVerifyWithAIAFetching(cert_bytes, hostname,
+                                      std::move(cert_net_fetcher),
+                                      verify_result, &verified_chain);
+  }
+
+  switch (status) {
+    case X509_V_ERR_UNSPECIFIED:
+      return false;
+    case X509_V_OK:
+      break;
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
+      verify_result->cert_status |= CERT_STATUS_AUTHORITY_INVALID;
+      break;
+    case X509_V_ERR_CERT_HAS_EXPIRED:
+    case X509_V_ERR_CERT_NOT_YET_VALID:
+      verify_result->cert_status |= CERT_STATUS_DATE_INVALID;
+      break;
+    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+      verify_result->cert_status |= CERT_STATUS_DEPTH_ZERO_SELF_SIGNED_CERT;
+      break;
+    default:
+      NOTREACHED();
+      verify_result->cert_status |= CERT_STATUS_INVALID;
+      break;
+  }
+
+  // Save the verified chain.
+  if (!verified_chain.empty()) {
+    std::vector<base::StringPiece> verified_chain_pieces(verified_chain.size());
+    for (size_t i = 0; i < verified_chain.size(); i++) {
+      verified_chain_pieces[i] = base::StringPiece(verified_chain[i]);
+    }
+    scoped_refptr<X509Certificate> verified_cert =
+        X509Certificate::CreateFromDERCertChain(verified_chain_pieces);
+    if (verified_cert.get())
+      verify_result->verified_cert = std::move(verified_cert);
+    else
+      verify_result->cert_status |= CERT_STATUS_INVALID;
+  }
+
+  // Extract the public key hashes and check whether or not any are known
+  // roots. Walk from the end of the chain (root) to leaf, to optimize for
+  // known root checks.
+  for (auto it = verified_chain.rbegin(); it != verified_chain.rend(); ++it) {
+    base::StringPiece spki_bytes;
+    if (!asn1::ExtractSPKIFromDERCert(*it, &spki_bytes)) {
+      verify_result->cert_status |= CERT_STATUS_INVALID;
+      continue;
+    }
+
+    HashValue sha256(HASH_VALUE_SHA256);
+    crypto::SHA256HashString(spki_bytes, sha256.data(), crypto::kSHA256Length);
+    verify_result->public_key_hashes.push_back(sha256);
+
+    if (!verify_result->is_issued_by_known_root) {
+      verify_result->is_issued_by_known_root =
+          GetNetTrustAnchorHistogramIdForSPKI(sha256) != 0;
+    }
+  }
+
+  // Reverse the hash list, to maintain the leaf->root ordering.
+  std::reverse(verify_result->public_key_hashes.begin(),
+               verify_result->public_key_hashes.end());
+
+  return true;
+}
+
+CertVerifyProcOHOS::CertVerifyProcOHOS(
+    scoped_refptr<CertNetFetcher> cert_net_fetcher)
+    : cert_net_fetcher_(std::move(cert_net_fetcher)) {
+      if (!std::move(cert_net_fetcher)) {
+      }
+    }
+
+CertVerifyProcOHOS::~CertVerifyProcOHOS() {}
+
+bool CertVerifyProcOHOS::SupportsAdditionalTrustAnchors() const {
+  return false;
 }
 
 int CertVerifyProcOHOS::VerifyInternal(
@@ -163,13 +474,22 @@ int CertVerifyProcOHOS::VerifyInternal(
     CertVerifyResult* verify_result,
     const NetLogWithSource& net_log) {
   std::vector<std::string> cert_bytes;
-
   GetChainDEREncodedBytes(cert, &cert_bytes);
 
-  if (!CertVerify(cert_bytes)) {
+  if (!cert->VerifyNameMatch(hostname)) {
+    verify_result->cert_status = CERT_STATUS_COMMON_NAME_INVALID;
+  }
+
+  if (!VerifyFromOhosTrustManager(cert_bytes, hostname, cert_net_fetcher_, verify_result)) {
+    LOG(ERROR) << "CertVerifyProcOHOS::VerifyInternal: trust manager verify failed";
+    NOTREACHED();
     return ERR_FAILED;
   }
 
+  if (IsCertStatusError(verify_result->cert_status)) {
+    return MapCertStatusToNetError(verify_result->cert_status);
+  }
+
   return OK;
 }
 
diff --git a/net/cookies/canonical_cookie.cc b/net/cookies/canonical_cookie.cc
index 8af2c1b14b443..baea756b998a6 100644
--- a/net/cookies/canonical_cookie.cc
+++ b/net/cookies/canonical_cookie.cc
@@ -56,6 +56,7 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/strcat.h"
 #include "base/strings/string_number_conversions.h"
+#include "base/strings/string_piece.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
 #include "net/base/features.h"
@@ -423,6 +424,11 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::Create(
   CookiePrefix prefix = GetCookiePrefix(parsed_cookie.Name());
   bool is_cookie_prefix_valid = IsCookiePrefixValid(prefix, url, parsed_cookie);
   RecordCookiePrefixMetrics(prefix, is_cookie_prefix_valid);
+
+  if (parsed_cookie.Name() == "") {
+    is_cookie_prefix_valid = !HasHiddenPrefixName(parsed_cookie.Value());
+  }
+
   if (!is_cookie_prefix_valid) {
     DVLOG(net::cookie_util::kVlogSetCookies)
         << "Create() failed because the cookie violated prefix rules.";
@@ -471,7 +477,6 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::Create(
 }
 
 // static
-// TODO(crbug.com/957184): This should ideally return a CookieInclusionStatus.
 std::unique_ptr<CanonicalCookie> CanonicalCookie::CreateSanitizedCookie(
     const GURL& url,
     const std::string& name,
@@ -485,49 +490,93 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::CreateSanitizedCookie(
     bool http_only,
     CookieSameSite same_site,
     CookiePriority priority,
-    bool same_party) {
+    bool same_party,
+    CookieInclusionStatus* status) {
+  // Put a pointer on the stack so the rest of the function can assign to it if
+  // the default nullptr is passed in.
+  CookieInclusionStatus blank_status;
+  if (status == nullptr) {
+    status = &blank_status;
+  }
+  *status = CookieInclusionStatus();
+
   // Validate consistency of passed arguments.
   if (ParsedCookie::ParseTokenString(name) != name ||
-      ParsedCookie::ParseValueString(value) != value ||
-      !ParsedCookie::IsValidCookieAttributeValue(name) ||
-      !ParsedCookie::IsValidCookieAttributeValue(value) ||
-      ParsedCookie::ParseValueString(domain) != domain ||
-      ParsedCookie::ParseValueString(path) != path) {
-    return nullptr;
+      !ParsedCookie::IsValidCookieAttributeValue(name)) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE);
+  } else if (ParsedCookie::ParseValueString(value) != value ||
+             !ParsedCookie::IsValidCookieAttributeValue(value)) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE);
+  } else if (ParsedCookie::ParseValueString(path) != path) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE);
+  } else if (name.empty() && value.empty()) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE);
   }
 
-  if (name.empty() && value.empty())
-    return nullptr;
+  if (ParsedCookie::ParseValueString(domain) != domain) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN);
+  }
 
+  std::string cookie_domain;
   // This validation step must happen before GetCookieDomainWithString, so it
   // doesn't fail DCHECKs.
-  if (!cookie_util::DomainIsHostOnly(url.host()))
-    return nullptr;
-
-  std::string cookie_domain;
-  if (!cookie_util::GetCookieDomainWithString(url, domain, &cookie_domain))
-    return nullptr;
+  if (!cookie_util::DomainIsHostOnly(url.host())) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN);
+  } else if (!cookie_util::GetCookieDomainWithString(url, domain,
+                                                     &cookie_domain)) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN);
+  }
 
-  CookieSourceScheme source_scheme = url.SchemeIsCryptographic()
-                                         ? CookieSourceScheme::kSecure
-                                         : CookieSourceScheme::kNonSecure;
+  CookieSourceScheme source_scheme = CookieSourceScheme::kNonSecure;
+  // This validation step must happen before SchemeIsCryptographic, so it
+  // doesn't fail DCHECKs.
+  if (!url.is_valid()) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN);
+  } else {
+    source_scheme = url.SchemeIsCryptographic()
+                        ? CookieSourceScheme::kSecure
+                        : CookieSourceScheme::kNonSecure;
+  }
 
   // Get the port, this will get a default value if a port isn't provided.
   int source_port = url.EffectiveIntPort();
 
   std::string cookie_path = CanonicalCookie::CanonPathWithString(url, path);
-  if (!path.empty() && cookie_path != path)
-    return nullptr;
+  if (!path.empty() && cookie_path != path) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE);
+  }
 
   if (!IsCookiePrefixValid(GetCookiePrefix(name), url, secure, domain,
                            cookie_path)) {
-    return nullptr;
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_PREFIX);
   }
 
-  if (!IsCookieSamePartyValid(same_party, secure, same_site))
-    return nullptr;
+  if (name == "" && HasHiddenPrefixName(value)) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_PREFIX);
+  }
 
-  if (!last_access_time.is_null() && creation_time.is_null())
+  if (!IsCookieSamePartyValid(same_party, secure, same_site)) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_INVALID_SAMEPARTY);
+  }
+
+  if (!last_access_time.is_null() && creation_time.is_null()) {
+    status->AddExclusionReason(
+        net::CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE);
+  }
+
+  if (!status->IsInclude())
     return nullptr;
 
   // Canonicalize path again to make sure it escapes characters as needed.
@@ -1081,6 +1130,9 @@ bool CanonicalCookie::IsCanonical() const {
       break;
   }
 
+  if (name_ == "" && HasHiddenPrefixName(value_))
+    return false;
+
   return IsCookieSamePartyValid(same_party_, secure_, same_site_);
 }
 
@@ -1208,6 +1260,40 @@ CookieEffectiveSameSite CanonicalCookie::GetEffectiveSameSite(
   }
 }
 
+// static
+bool CanonicalCookie::HasHiddenPrefixName(
+    const base::StringPiece cookie_value) {
+  // Skip BWS as defined by HTTPSEM as SP or HTAB (0x20 or 0x9).
+  base::StringPiece value_without_BWS =
+      base::TrimString(cookie_value, " \t", base::TRIM_LEADING);
+
+  const base::StringPiece host_prefix = "__Host-";
+
+  // Compare the value to the host_prefix.
+  if (base::StartsWith(value_without_BWS, host_prefix)) {
+    // The prefix matches, now check if the value string contains a subsequent
+    // '='.
+    if (value_without_BWS.find_first_of('=', host_prefix.size()) !=
+        base::StringPiece::npos) {
+      // This value contains a hidden prefix name.
+      return true;
+    }
+    return false;
+  }
+
+  // Do a similar check for the secure prefix
+  const base::StringPiece secure_prefix = "__Secure-";
+
+  if (base::StartsWith(value_without_BWS, secure_prefix)) {
+    if (value_without_BWS.find_first_of('=', secure_prefix.size()) !=
+        base::StringPiece::npos) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
 bool CanonicalCookie::IsRecentlyCreated(base::TimeDelta age_threshold) const {
   return (base::Time::Now() - creation_date_) <= age_threshold;
 }
diff --git a/net/cookies/canonical_cookie.h b/net/cookies/canonical_cookie.h
index 38808e473f778..ba5645d7b6565 100644
--- a/net/cookies/canonical_cookie.h
+++ b/net/cookies/canonical_cookie.h
@@ -12,6 +12,7 @@
 
 #include "base/gtest_prod_util.h"
 #include "base/optional.h"
+#include "base/strings/string_piece.h"
 #include "base/time/time.h"
 #include "net/base/net_export.h"
 #include "net/cookies/cookie_access_result.h"
@@ -89,8 +90,9 @@ class NET_EXPORT CanonicalCookie {
 
   // Create a canonical cookie based on sanitizing the passed inputs in the
   // context of the passed URL.  Returns a null unique pointer if the inputs
-  // cannot be sanitized.  If a cookie is created, |cookie->IsCanonical()|
-  // will be true.
+  // cannot be sanitized.  If `status` is provided it will have any relevant
+  // CookieInclusionStatus rejection reasons set. If a cookie is created,
+  // `cookie->IsCanonical()` will be true.
   static std::unique_ptr<CanonicalCookie> CreateSanitizedCookie(
       const GURL& url,
       const std::string& name,
@@ -104,7 +106,8 @@ class NET_EXPORT CanonicalCookie {
       bool http_only,
       CookieSameSite same_site,
       CookiePriority priority,
-      bool same_party);
+      bool same_party,
+      CookieInclusionStatus* status = nullptr);
 
   // FromStorage is a factory method which is meant for creating a new
   // CanonicalCookie using properties of a previously existing cookie
@@ -349,6 +352,7 @@ class NET_EXPORT CanonicalCookie {
 
  private:
   FRIEND_TEST_ALL_PREFIXES(CanonicalCookieTest, TestPrefixHistograms);
+  FRIEND_TEST_ALL_PREFIXES(CanonicalCookieTest, TestHasHiddenPrefixName);
 
   // This constructor does not validate or canonicalize their inputs;
   // the resulting CanonicalCookies should not be relied on to be canonical
@@ -412,6 +416,9 @@ class NET_EXPORT CanonicalCookie {
   CookieEffectiveSameSite GetEffectiveSameSite(
       CookieAccessSemantics access_semantics) const;
 
+  // Checks for values that could be misinterpreted as a cookie name prefix.
+  static bool HasHiddenPrefixName(const base::StringPiece cookie_value);
+
   // Returns whether the cookie was created at most |age_threshold| ago.
   bool IsRecentlyCreated(base::TimeDelta age_threshold) const;
 
diff --git a/net/cookies/canonical_cookie_unittest.cc b/net/cookies/canonical_cookie_unittest.cc
index d42132030c872..e488549ba7335 100644
--- a/net/cookies/canonical_cookie_unittest.cc
+++ b/net/cookies/canonical_cookie_unittest.cc
@@ -1801,6 +1801,18 @@ TEST(CanonicalCookieTest, SecureCookiePrefix) {
                                        creation_time, server_time, &status));
   EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
       {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
+
+  // Hidden __Secure- prefixes should be rejected.
+  EXPECT_FALSE(CanonicalCookie::Create(
+      https_url, "=__Secure-A=B; Secure", creation_time, server_time,
+      &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
+
+  // While tricky, this isn't considered hidden and is fine.
+  EXPECT_TRUE(CanonicalCookie::Create(
+      https_url, "A=__Secure-A=B; Secure", creation_time, server_time,
+      &status));
 }
 
 TEST(CanonicalCookieTest, HostCookiePrefix) {
@@ -1877,6 +1889,18 @@ TEST(CanonicalCookieTest, HostCookiePrefix) {
   EXPECT_TRUE(CanonicalCookie::Create(
       https_url, "__HostA=B; Domain=" + domain + "; Secure;", creation_time,
       server_time));
+
+  // Hidden __Host- prefixes should be rejected.
+  EXPECT_FALSE(CanonicalCookie::Create(
+      https_url, "=__Host-A=B; Path=/; Secure;", creation_time, server_time,
+      &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
+
+  // While tricky, this isn't considered hidden and is fine.
+  EXPECT_TRUE(CanonicalCookie::Create(
+      https_url, "A=__Host-A=B; Path=/; Secure;", creation_time, server_time,
+      &status));
 }
 
 TEST(CanonicalCookieTest, CanCreateSecureCookiesFromAnyScheme) {
@@ -2174,6 +2198,31 @@ TEST(CanonicalCookieTest, IsCanonical) {
                    base::Time(), true, false, CookieSameSite::STRICT_MODE,
                    COOKIE_PRIORITY_LOW, true)
                    ->IsCanonical());
+
+  // Hidden cookie prefixes.
+  EXPECT_FALSE(CanonicalCookie::CreateUnsafeCookieForTesting(
+                   "", "__Secure-a=b", "x.y", "/", base::Time(), base::Time(),
+                   base::Time(), true, false,
+                   CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_LOW, false)
+                   ->IsCanonical());
+
+  EXPECT_FALSE(CanonicalCookie::CreateUnsafeCookieForTesting(
+                   "", "__Host-a=b", "x.y", "/", base::Time(), base::Time(),
+                   base::Time(), true, false,
+                   CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_LOW, false)
+                   ->IsCanonical());
+
+  EXPECT_TRUE(CanonicalCookie::CreateUnsafeCookieForTesting(
+                  "a", "__Secure-a=b", "x.y", "/", base::Time(), base::Time(),
+                  base::Time(), true, false,
+                  CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_LOW, false)
+                  ->IsCanonical());
+
+  EXPECT_TRUE(CanonicalCookie::CreateUnsafeCookieForTesting(
+                  "a", "__Host-a=b", "x.y", "/", base::Time(), base::Time(),
+                  base::Time(), true, false,
+                  CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_LOW, false)
+                  ->IsCanonical());
 }
 
 TEST(CanonicalCookieTest, TestSetCreationDate) {
@@ -2268,13 +2317,14 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Inputs) {
   base::Time one_hour_ago = base::Time::Now() - base::TimeDelta::FromHours(1);
   base::Time one_hour_from_now =
       base::Time::Now() + base::TimeDelta::FromHours(1);
-
+  CookieInclusionStatus status;
   std::unique_ptr<CanonicalCookie> cc;
+
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_EQ("A", cc->Name());
   EXPECT_EQ("B", cc->Value());
@@ -2289,87 +2339,97 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Inputs) {
   EXPECT_EQ(COOKIE_PRIORITY_MEDIUM, cc->Priority());
   EXPECT_FALSE(cc->IsSameParty());
   EXPECT_FALSE(cc->IsDomainCookie());
+  EXPECT_TRUE(status.IsInclude());
 
   // Creation date
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       two_hours_ago, base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_EQ(two_hours_ago, cc->CreationDate());
+  EXPECT_TRUE(status.IsInclude());
 
   // Last access date
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       two_hours_ago, base::Time(), one_hour_ago, false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_EQ(one_hour_ago, cc->LastAccessDate());
+  EXPECT_TRUE(status.IsInclude());
 
   // Expiry
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_EQ(one_hour_from_now, cc->ExpiryDate());
+  EXPECT_TRUE(status.IsInclude());
 
   // Secure
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), true /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_TRUE(cc->IsSecure());
+  EXPECT_TRUE(status.IsInclude());
 
   // Httponly
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       true /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_TRUE(cc->IsHttpOnly());
+  EXPECT_TRUE(status.IsInclude());
 
   // Same site
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::LAX_MODE, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/);
+      false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_EQ(CookieSameSite::LAX_MODE, cc->SameSite());
+  EXPECT_TRUE(status.IsInclude());
 
   // Priority
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_LOW,
-      false /*same_party*/);
+      false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_EQ(COOKIE_PRIORITY_LOW, cc->Priority());
+  EXPECT_TRUE(status.IsInclude());
 
   // Domain cookie
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", "www.foo.com", "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_TRUE(cc->IsDomainCookie());
+  EXPECT_TRUE(status.IsInclude());
 
   // SameParty
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), true /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_LOW,
-      true /*same_party*/);
+      true /*same_party*/, &status);
   EXPECT_TRUE(cc);
   EXPECT_TRUE(cc->IsSameParty());
+  EXPECT_TRUE(status.IsInclude());
 }
 
 // Make sure sanitization and blocking of cookies works correctly.
@@ -2378,103 +2438,135 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Logic) {
   base::Time one_hour_ago = base::Time::Now() - base::TimeDelta::FromHours(1);
   base::Time one_hour_from_now =
       base::Time::Now() + base::TimeDelta::FromHours(1);
+  CookieInclusionStatus status;
 
   // Simple path and domain variations.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", std::string(), "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/bar"), "C", "D", "www.foo.com", "/",
       two_hours_ago, base::Time(), one_hour_ago, false /*secure*/,
       true /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "E", "F", std::string(), std::string(),
       base::Time(), base::Time(), base::Time(), true /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
 
   // Test the file:// protocol.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("file:///"), "A", "B", std::string(), "/foo", one_hour_ago,
       one_hour_from_now, base::Time(), false /*secure*/, false /*httponly*/,
       CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("file:///home/user/foo.txt"), "A", "B", std::string(), "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("file:///home/user/foo.txt"), "A", "B", "home", "/foo", one_hour_ago,
       one_hour_from_now, base::Time(), false /*secure*/, false /*httponly*/,
       CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
 
   // Test that malformed attributes fail to set the cookie.
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), " A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A;", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A=", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A\x07", "B", std::string(), "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", " B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "\x0fZ", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "B", "www.foo.com ", "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", "foo.ozzzzzzle", "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", std::string(), "foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "B", std::string(), "/foo ",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", "%2Efoo.com", "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://domaintest.%E3%81%BF%E3%82%93%E3%81%AA"), "A", "B",
       "domaintest.%E3%81%BF%E3%82%93%E3%81%AA", "/foo", base::Time(),
       base::Time(), base::Time(), false /*secure*/, false /*httponly*/,
       CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
 
   std::unique_ptr<CanonicalCookie> cc;
 
@@ -2484,133 +2576,163 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Logic) {
       GURL("http://www.foo.com/foo"), "A", "B", "www.foo.com", "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   ASSERT_TRUE(cc);
   EXPECT_TRUE(cc->IsDomainCookie());
   EXPECT_EQ(".www.foo.com", cc->Domain());
+  EXPECT_TRUE(status.IsInclude());
 
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", ".www.foo.com", "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   ASSERT_TRUE(cc);
   EXPECT_TRUE(cc->IsDomainCookie());
   EXPECT_EQ(".www.foo.com", cc->Domain());
+  EXPECT_TRUE(status.IsInclude());
 
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", ".foo.com", "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   ASSERT_TRUE(cc);
   EXPECT_TRUE(cc->IsDomainCookie());
   EXPECT_EQ(".foo.com", cc->Domain());
+  EXPECT_TRUE(status.IsInclude());
 
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com/foo"), "A", "B", ".www2.www.foo.com", "/foo",
       one_hour_ago, one_hour_from_now, base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   EXPECT_FALSE(cc);
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
 
   // Secure/URL Scheme mismatch.
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "B", std::string(), "/foo ",
       base::Time(), base::Time(), base::Time(), true /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
 
   // Null creation date/non-null last access date conflict.
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "B", std::string(), "/foo", base::Time(),
       base::Time(), base::Time::Now(), false /*secure*/, false /*httponly*/,
       CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
 
   // Domain doesn't match URL
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "B", "www.bar.com", "/", base::Time(),
       base::Time(), base::Time(), false /*secure*/, false /*httponly*/,
       CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
 
   // Path with unusual characters escaped.
   cc = CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "A", "B", std::string(), "/foo",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false /*same_party*/);
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status);
   ASSERT_TRUE(cc);
   EXPECT_EQ("/foo%7F", cc->Path());
+  EXPECT_TRUE(status.IsInclude());
 
   // Empty name and value.
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://www.foo.com"), "", "", std::string(), "/", base::Time(),
       base::Time(), base::Time(), false /*secure*/, false /*httponly*/,
       CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
-      false /*same_party*/));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE}));
 
   // A __Secure- cookie must be Secure.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Secure-A", "B", ".www.foo.com", "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Secure-A", "B", ".www.foo.com", "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, false, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
 
   // A __Host- cookie must be Secure.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Host-A", "B", std::string(), "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Host-A", "B", std::string(), "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, false, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
 
   // A __Host- cookie must have path "/".
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Host-A", "B", std::string(), "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Host-A", "B", std::string(), "/foo",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
 
   // A __Host- cookie must not specify a domain.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Host-A", "B", std::string(), "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "__Host-A", "B", ".www.foo.com", "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
+
   // Without __Host- prefix, this is a valid host cookie because it does not
   // specify a domain.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", std::string(), "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
+
   // Without __Host- prefix, this is a valid domain (not host) cookie.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", ".www.foo.com", "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
 
   // The __Host- prefix should not prevent otherwise-valid host cookies from
   // being accepted.
@@ -2618,24 +2740,62 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Logic) {
       GURL("https://127.0.0.1"), "A", "B", std::string(), "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://127.0.0.1"), "__Host-A", "B", std::string(), "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
+
   // Host cookies should not specify domain unless it is an IP address that
   // matches the URL.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://127.0.0.1"), "A", "B", "127.0.0.1", "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://127.0.0.1"), "__Host-A", "B", "127.0.0.1", "/",
       two_hours_ago, one_hour_from_now, one_hour_ago, true, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      false));
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
+
+  // Cookies with hidden prefixes should be rejected.
+
+  EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
+      GURL("https://www.foo.com"), "", "__Host-A=B", "", "/", two_hours_ago,
+      one_hour_from_now, one_hour_ago, true, false,
+      CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
+
+  EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
+      GURL("https://www.foo.com"), "", "__Secure-A=B", "", "/", two_hours_ago,
+      one_hour_from_now, one_hour_ago, true, false,
+      CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_PREFIX}));
+
+  // While tricky, this aren't considered hidden prefixes and should succeed.
+  EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
+      GURL("https://www.foo.com"), "A", "__Host-A=B", "", "/", two_hours_ago,
+      one_hour_from_now, one_hour_ago, true, false,
+      CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
+
+  EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
+      GURL("https://www.foo.com"), "A", "__Secure-A=B", "", "/", two_hours_ago,
+      one_hour_from_now, one_hour_ago, true, false,
+      CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
 
   // SameParty attribute requires Secure and forbids SameSite=Strict.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
@@ -2643,21 +2803,28 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Logic) {
       one_hour_from_now, one_hour_ago, true /*secure*/, false,
       CookieSameSite::NO_RESTRICTION, CookiePriority::COOKIE_PRIORITY_DEFAULT,
       true /*same_party*/));
+  EXPECT_TRUE(status.IsInclude());
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", ".www.foo.com", "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, false /*secure*/, false,
       CookieSameSite::LAX_MODE, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      true /*same_party*/));
+      true /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_SAMEPARTY}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", ".www.foo.com", "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, true /*secure*/, false,
       CookieSameSite::STRICT_MODE, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      true /*same_party*/));
+      true /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_SAMEPARTY}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("https://www.foo.com"), "A", "B", ".www.foo.com", "/", two_hours_ago,
       one_hour_from_now, one_hour_ago, false /*secure*/, false,
       CookieSameSite::STRICT_MODE, CookiePriority::COOKIE_PRIORITY_DEFAULT,
-      true /*same_party*/));
+      true /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_SAMEPARTY}));
 
   // Check that CreateSanitizedCookie can gracefully fail on inputs that would
   // crash cookie_util::GetCookieDomainWithString due to failing
@@ -2667,36 +2834,60 @@ TEST(CanonicalCookieTest, CreateSanitizedCookie_Logic) {
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://..."), "A", "B", "...", "/", base::Time(), base::Time(),
       base::Time(), false /*secure*/, false /*httponly*/,
-      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT, false));
+      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://."), "A", "B", std::string(), "/", base::Time(),
       base::Time(), base::Time(), false /*secure*/, false /*httponly*/,
-      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT, false));
+      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
   EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
       GURL("http://.chromium.org"), "A", "B", ".chromium.org", "/",
       base::Time(), base::Time(), base::Time(), false /*secure*/,
       false /*httponly*/, CookieSameSite::NO_RESTRICTION,
-      COOKIE_PRIORITY_DEFAULT, false));
+      COOKIE_PRIORITY_DEFAULT, false /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
 
   // Check that a file URL with an IPv6 host, and matching IPv6 domain, are
   // valid.
   EXPECT_TRUE(CanonicalCookie::CreateSanitizedCookie(
       GURL("file://[A::]"), "A", "B", "[A::]", "", base::Time(), base::Time(),
       base::Time(), false /*secure*/, false /*httponly*/,
-      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT, false));
+      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status));
+  EXPECT_TRUE(status.IsInclude());
 
   // On Windows, URLs beginning with two backslashes are considered file
   // URLs. On other platforms, they are invalid.
   auto double_backslash_ipv6_cookie = CanonicalCookie::CreateSanitizedCookie(
       GURL("\\\\[A::]"), "A", "B", "[A::]", "", base::Time(), base::Time(),
       base::Time(), false /*secure*/, false /*httponly*/,
-      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT, false);
+      CookieSameSite::NO_RESTRICTION, COOKIE_PRIORITY_DEFAULT,
+      false /*same_party*/, &status);
 #if defined(OS_WIN)
   EXPECT_TRUE(double_backslash_ipv6_cookie);
   EXPECT_TRUE(double_backslash_ipv6_cookie->IsCanonical());
+  EXPECT_TRUE(status.IsInclude());
 #else
   EXPECT_FALSE(double_backslash_ipv6_cookie);
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN}));
 #endif
+
+  // Confirm multiple error types can be set.
+  EXPECT_FALSE(CanonicalCookie::CreateSanitizedCookie(
+      GURL(""), "", "", "", "", base::Time(), base::Time(), base::Time::Now(),
+      true /*secure*/, true /*httponly*/, CookieSameSite::STRICT_MODE,
+      COOKIE_PRIORITY_DEFAULT, true /*same_party*/, &status));
+  EXPECT_TRUE(status.HasExactlyExclusionReasonsForTesting(
+      {CookieInclusionStatus::EXCLUDE_FAILURE_TO_STORE,
+       CookieInclusionStatus::EXCLUDE_INVALID_DOMAIN,
+       CookieInclusionStatus::EXCLUDE_INVALID_SAMEPARTY}));
 }
 
 TEST(CanonicalCookieTest, FromStorage) {
@@ -3689,4 +3880,47 @@ TEST(CanonicalCookieTest, IsSetPermitted_SameParty) {
   }
 }
 
+TEST(CanonicalCookieTest, TestHasHiddenPrefixName) {
+  const struct {
+    const char* value;
+    bool result;
+  } kTestCases[] = {
+      {"", false},
+      {"  ", false},
+      {"foobar=", false},
+      {"foo=bar", false},
+      {" \t ", false},
+      {"\t", false},
+      {"__Secure-abc", false},
+      {"__Secur=e-abc", false},
+      {"__Secureabc", false},
+      {"__Host-abc", false},
+      {"__Hos=t-abc", false},
+      {"_Host", false},
+      {"   __Secure-abc", false},
+      {"\t__Host-", false},
+      {"a__Host-abc=123", false},
+      {"a__Secure-abc=123", false},
+      {"__Host-abc=", true},
+      {"__Host-abc=123", true},
+      {" __Host-abc=123", true},
+      {"    __Host-abc=", true},
+      {"\t\t\t\t\t__Host-abc=123", true},
+      {"\t __Host-abc=", true},
+      {"__Secure-abc=", true},
+      {"__Secure-abc=123", true},
+      {" __Secure-abc=123", true},
+      {"    __Secure-abc=", true},
+      {"\t\t\t\t\t__Secure-abc=123", true},
+      {"\t __Secure-abc=", true},
+      {"__Secure-abc=123=d=4=fg=", true},
+  };
+
+  for (auto test_case : kTestCases) {
+    EXPECT_EQ(CanonicalCookie::HasHiddenPrefixName(test_case.value),
+              test_case.result)
+        << test_case.value << " failed check";
+  }
+}
+
 }  // namespace net
diff --git a/net/http/http_status_code.cc b/net/http/http_status_code.cc
index 84d8c23e36d18..8a7aba554478d 100644
--- a/net/http/http_status_code.cc
+++ b/net/http/http_status_code.cc
@@ -24,4 +24,20 @@ const char* GetHttpReasonPhrase(HttpStatusCode code) {
   return "";
 }
 
+#if defined(OS_OHOS)
+const char* GetHttpErrorPhrase(HttpStatusCode code) {
+  switch (code) {
+
+#define HTTP_STATUS(label, code, reason) case HTTP_ ## label: return # label;
+#include "net/http/http_status_code_list.h"
+#undef HTTP_STATUS
+
+    default:
+      NOTREACHED() << "unknown HTTP status code " << code;
+  }
+
+  return "";
+}
+#endif
+
 }  // namespace net
diff --git a/net/http/http_status_code.h b/net/http/http_status_code.h
index a4b398b5038c2..86c68339c1c26 100644
--- a/net/http/http_status_code.h
+++ b/net/http/http_status_code.h
@@ -28,6 +28,10 @@ enum HttpStatusCode {
 // not yet covered or just invalid. Please extend it when needed.
 NET_EXPORT const char* GetHttpReasonPhrase(HttpStatusCode code);
 
+#if defined(OS_OHOS)
+NET_EXPORT const char* GetHttpErrorPhrase(HttpStatusCode code);
+#endif
+
 }  // namespace net
 
 #endif  // NET_HTTP_HTTP_STATUS_CODE_H_
diff --git a/net/url_request/url_request.cc b/net/url_request/url_request.cc
index 865fb4db6a439..bb56abc1cf86d 100644
--- a/net/url_request/url_request.cc
+++ b/net/url_request/url_request.cc
@@ -17,6 +17,7 @@
 #include "base/synchronization/lock.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/values.h"
+#include "base/trace_event/trace_event.h"
 #include "net/base/auth.h"
 #include "net/base/load_flags.h"
 #include "net/base/load_timing_info.h"
@@ -496,6 +497,8 @@ void URLRequest::set_allow_credentials(bool allow_credentials) {
 }
 
 void URLRequest::Start() {
+  TRACE_EVENT2("net", "URLRequest::Start", "original_url", original_url(),
+               "url", url());
   DCHECK(delegate_);
 
   if (status_ != OK)
diff --git a/ohos_nweb/BUILD.gn b/ohos_nweb/BUILD.gn
index ce1eae4b7873f..9392fec824247 100644
--- a/ohos_nweb/BUILD.gn
+++ b/ohos_nweb/BUILD.gn
@@ -11,6 +11,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+import("//ohos_nweb/src/nweb_sysevent.gni")
 import("//build/buildflag_header.gni")
 import("//build/config/features.gni")
 import("//tools/grit/grit_rule.gni")
@@ -37,6 +38,7 @@ config("cef_nweb_config") {
     "include",
     "src",
     "src/cef_delegate",
+    "src/sysevent",
     "//cef",
     "//cef/include",
     "//cef/libcef/browser/net_service",
@@ -49,7 +51,8 @@ config("cef_nweb_config") {
     "ipc_core.z",
     "inputmethod_ability.z",
     "accesstoken_sdk.z",
-    "nweb_ohos_adapter.z"
+    "nweb_ohos_adapter.z",
+    "hisysevent.z"
   ]
 
   defines = [
@@ -57,13 +60,19 @@ config("cef_nweb_config") {
   ]
 
   if (product_name == "rk3568") {
-    defines += [ "DEFAULT_PORTRAIT" ]
+    defines += [ "DEFAULT_PORTRAIT",
+                 "RK3568", ]
+  }
+
+  if (report_sys_event) {
+    defines += [ "REPORT_SYS_EVENT" ]
   }
 }
 
 component("cef_nweb") {
   configs += [
     ":cef_nweb_config",
+    ":nweb_config",
   ]
 
   sources = [
@@ -92,6 +101,10 @@ component("cef_nweb") {
     "src/cef_delegate/nweb_js_dialog_result_impl.h",
     "src/cef_delegate/nweb_js_http_auth_result_impl.cc",
     "src/cef_delegate/nweb_js_http_auth_result_impl.h",
+    "src/cef_delegate/nweb_js_ssl_error_result_impl.cc",
+    "src/cef_delegate/nweb_js_ssl_error_result_impl.h",
+    "src/cef_delegate/nweb_js_ssl_select_cert_result_impl.cc",
+    "src/cef_delegate/nweb_js_ssl_select_cert_result_impl.h",
     "src/cef_delegate/nweb_geolocation_callback.h",
     "src/cef_delegate/nweb_geolocation_callback.cc",
     "src/cef_delegate/nweb_preference_delegate.h",
@@ -105,14 +118,20 @@ component("cef_nweb") {
     "src/cef_delegate/nweb_access_request_delegate.h",
     "src/cef_delegate/nweb_web_storage_delegate.cc",
     "src/cef_delegate/nweb_web_storage_delegate.h",
+    "src/cef_delegate/nweb_find_delegate.cc",
+    "src/cef_delegate/nweb_find_delegate.h",
+    "src/cef_delegate/nweb_touch_handle_state_impl.h",
+    "src/cef_delegate/nweb_touch_handle_state_impl.cc",
+    "src/sysevent/event_reporter.cc",
+    "src/sysevent/event_reporter.h",
   ]
 
   deps = [
     "//base:base",
-    "//cef:libweb_engine",
     "//cef:libcef_dll_wrapper",
-    "//ui/events/keycodes:x11",
+    "//cef:libweb_engine",
     "//content/public/common:static_switches",
+    "//ui/events/keycodes:x11",
   ]
 }
 
@@ -148,6 +167,7 @@ component("nweb_sources") {
     "include/nweb_console_log.h",
     "include/nweb_cookie_manager.h",
     "include/nweb_download_callback.h",
+    "include/nweb_find_callback.h",
     "include/nweb_geolocation_callback_interface.h",
     "include/nweb_js_dialog_result.h",
     "include/nweb_js_http_auth_result.h",
@@ -192,10 +212,12 @@ component("nweb_sources") {
 }
 
 shared_library("libnweb_adapter") {
-  deps = [
-    ":nweb_sources",
-    #"//ohos_nweb_ex:nweb_ex",
-  ]
+  configs += [ "//build/config/sanitizers:cfi_config" ]
+  deps = [ ":nweb_sources" ]
+
+  if (defined(ohos_nweb_ex) && ohos_nweb_ex) {
+    deps += [ "//ohos_nweb_ex:nweb_ex" ]
+  }
 }
 
 static_library("libohosnweb_static") {
@@ -222,6 +244,7 @@ config("ohosnweb_core_config") {
 
 executable("web_render") {
   configs += [
+    "//build/config/sanitizers:cfi_config",
     ":ohosnweb_core_config",
   ]
 
@@ -232,17 +255,18 @@ executable("web_render") {
     ":nweb_hilog",
   ]
 }
- 
+
 shared_library("libnweb_render") {
+  configs += [ "//build/config/sanitizers:cfi_config" ]
   defines = [
     "OHOS_NWEB",
   ]
- 
+
   include_dirs = [
     "include",
   ]
   include_dirs += ohos_src_includes
- 
+
   sources = [
     "src/nweb_render_main.cc",
   ]
diff --git a/ohos_nweb/include/nweb.h b/ohos_nweb/include/nweb.h
index 5f05192a4adf4..92fbff9408255 100755
--- a/ohos_nweb/include/nweb.h
+++ b/ohos_nweb/include/nweb.h
@@ -23,6 +23,8 @@
 #include "nweb_export.h"
 
 #include "nweb_download_callback.h"
+#include "nweb_find_callback.h"
+
 #include "nweb_javascript_result_callback.h"
 #include "nweb_preference.h"
 #include "nweb_value_callback.h"
@@ -55,6 +57,22 @@ struct OHOS_NWEB_EXPORT NWebCreateInfo {
     void *producer_surface = nullptr;
 };
 
+enum class OHOS_NWEB_EXPORT DragAction {
+    DRAG_START = 0,
+    DRAG_ENTER,
+    DRAG_LEAVE,
+    DRAG_OVER,
+    DRAG_DROP,
+    DRAG_END,
+    DRAG_CANCEL,
+};
+
+struct OHOS_NWEB_EXPORT DragEvent {
+    double x;
+    double y;
+    DragAction action;
+};
+
 class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
     public:
     NWeb() = default;
@@ -79,7 +97,7 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
     virtual void OnNavigateBack() = 0;
     virtual bool SendKeyEvent(int32_t keyCode, int32_t keyAction) = 0;
     virtual void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY);
-    virtual void SendMouseEvent(int x, int y, int button, int action);
+    virtual void SendMouseEvent(int x, int y, int button, int action, int count);
 
     /**
      * Loads the given URL.
@@ -130,6 +148,7 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      * Delete back and forward history list.
      */
     virtual void DeleteNavigateHistory() = 0;
+
     /**
      * Reloads the current URL.
      *
@@ -242,6 +261,7 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      * @return title string for the current page.
      */
     virtual std::string Title() = 0;
+
     /**
      * Gets the progress for the current page.
      *
@@ -342,6 +362,111 @@ class OHOS_NWEB_EXPORT NWeb : public std::enable_shared_from_this<NWeb> {
      */
     virtual void SetNWebJavaScriptResultCallBack(
             std::shared_ptr<NWebJavaScriptResultCallBack> callback) = 0;
+
+    /**
+     * Set the NWebFindCallback that will receive find event.
+     * This will replace the current handler.
+     *
+     * @param findListener NWebFindCallback : find callback
+     */
+    virtual void PutFindCallback(
+        std::shared_ptr<NWebFindCallback> findListener) = 0;
+
+    /**
+     * Finds all instances of find on the page and highlights them,
+     * asynchronously.
+     *
+     * @param searchStr String: target string to find.
+     */
+    virtual void FindAllAsync(const std::string& searchStr) const = 0;
+
+    /**
+     * Clears the highlighting surrounding text matches created by findAllAsync
+     *
+     */
+    virtual void ClearMatches() const = 0;
+
+    /**
+     * Highlights and scrolls to the next match found by findAllAsync(String),
+     * wrapping around page boundaries as necessary.
+     *
+     * @param forward bool: find back or forward:
+     */
+    virtual void FindNext(const bool forward) const = 0;
+
+    /**
+     * Saves the current view as a web archive.
+     *
+     * @param baseName the filename where the archive should be placed This
+     * value cannot be null.
+     * @param autoName if false, takes basename to be a file. If true, basename
+     * is assumed to be a directory in which a filename will be chosen according
+     * to the URL of the current page.
+     */
+    virtual void StoreWebArchive(
+        const std::string& baseName,
+        bool autoName,
+        std::shared_ptr<NWebValueCallback<std::string>> callback) const = 0;
+
+    /**
+     * creating two ends of a message channel.
+     *
+     * @param ports the web message ports get from nweb.
+     */
+    virtual void CreateWebMessagePorts(std::vector<std::string>& ports) = 0;
+
+    /**
+     * Posts MessageEvent to the main frame.
+     *
+     * @param message message send to mmain frame.
+     * @param ports the web message ports send to main frame.
+     * @param targetUri the uri which can received the ports.
+     */
+    virtual void PostWebMessage(std::string& message, std::vector<std::string>& ports, std::string& targetUri) = 0;
+
+    /**
+     * close the message port.
+     *
+     * @param portHandle the port to close.
+     */
+    virtual void ClosePort(std::string& portHandle) = 0;
+
+    /**
+     * use the port to send message.
+     *
+     * @param portHandle the port to send message.
+     * @param data the message to send.
+     */
+    virtual void PostPortMessage(std::string& portHandle, std::string& data) = 0;
+
+    /**
+     * set the callback of the message port.
+     *
+     * @param portHandle the port to set callback.
+     * @param callback to reveive the result when the other port post message.
+     */
+    virtual void SetPortMessageCallback(std::string& portHandle,
+        std::shared_ptr<NWebValueCallback<std::string>> callback) = 0;
+
+    virtual void SendDragEvent(const DragEvent& dragEvent) const = 0;
+
+    /**
+     * Clear ssl cache.
+     */
+    virtual void ClearSslCache() = 0;
+
+    /**
+     * get web page url.
+     *
+     * @return web page url.
+     */
+    virtual std::string GetUrl() const = 0;
+
+    /**
+     * Clears the client authentication certificate Cache in the Web.
+     *
+     */
+    virtual void ClearClientAuthenticationCache() = 0;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_context_menu_params.h b/ohos_nweb/include/nweb_context_menu_params.h
index 725458b5e101d..197f4050d6b6f 100644
--- a/ohos_nweb/include/nweb_context_menu_params.h
+++ b/ohos_nweb/include/nweb_context_menu_params.h
@@ -16,9 +16,11 @@
 #ifndef NWEB_CONTEXT_MENU_PARAMS_H
 #define NWEB_CONTEXT_MENU_PARAMS_H
 
+#include <memory>
 #include <string>
 
 #include "nweb_export.h"
+#include "nweb_touch_handle_state.h"
 
 namespace OHOS::NWeb {
 class OHOS_NWEB_EXPORT NWebContextMenuParams {
@@ -62,6 +64,12 @@ public:
 
     virtual int32_t GetContextMenuTypeFlags() = 0;
 
+    virtual std::string GetLinkUrl() = 0;
+ 
+    virtual std::string GetUnfilteredLinkUrl() = 0;
+ 
+    virtual std::string GetSourceUrl() = 0;
+
     virtual bool HasImageContents() = 0;
 
     virtual std::string GetTitleText() = 0;
@@ -83,6 +91,7 @@ public:
         QM_EF_CAN_CUT = 1 << 1,
         QM_EF_CAN_COPY = 1 << 2,
         QM_EF_CAN_PASTE = 1 << 3,
+        QM_EF_CAN_SELECT_ALL = 1 << 4,
     };
 
     virtual ~NWebQuickMenuParams() = default;
@@ -96,6 +105,9 @@ public:
     virtual int32_t GetHeight() = 0;
 
     virtual int32_t GetEditStateFlags() = 0;
+
+    virtual std::shared_ptr<NWebTouchHandleState> GetTouchHandleState(
+        NWebTouchHandleState::TouchHandleType type) = 0;
 };
 
 enum MenuEventFlags {
@@ -109,6 +121,10 @@ enum MenuEventFlags {
     EF_RIGHT_MOUSE_BUTTON = 1 << 6,
 };
 
+enum MenuCommandId {
+    CI_IMAGE_COPY = 0,
+};
+
 class OHOS_NWEB_EXPORT NWebContextMenuCallback {
 public:
     virtual ~NWebContextMenuCallback() = default;
diff --git a/ohos_nweb/include/nweb_cookie_manager.h b/ohos_nweb/include/nweb_cookie_manager.h
index fc5c58ddc93b2..2e0ff107d845f 100644
--- a/ohos_nweb/include/nweb_cookie_manager.h
+++ b/ohos_nweb/include/nweb_cookie_manager.h
@@ -42,6 +42,19 @@ public:
      * @param accept whether the instance should send and accept cookies.
      */
     virtual void PutAcceptCookieEnabled(bool accept) = 0;
+    /**
+     * @brief Get whether the instance allows setting cookies of third parties
+     *
+     * @return true if the instance allows the setting of third-party cookies.
+     */
+    virtual bool IsThirdPartyCookieAllowed() const = 0;
+    /**
+     * @brief Set whether the instance allows setting cookies of third parties.
+     * By default, this value is set to true. Nweb allows the setting of third-party cookies.
+     *
+     * @param accept whether the instance allows the setting of third-party cookies.
+     */
+    virtual void PutAcceptThirdPartyCookieEnabled(bool accept) = 0;
     /**
      * @brief Get whether instances can send and accept cookies for file scheme URLs.
      *
@@ -94,6 +107,12 @@ public:
      * @param callback a callback to be executed when the cookie has checked.
      */
     virtual void ExistCookies(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
+    /**
+    * @brief Gets whether there are stored cookies.
+    *
+    * @return true if there are stored cookies else false.
+    */
+    virtual bool ExistCookies() = 0;
     /**
      * @brief Ensures all cookies currently accessible through the ReturnCookie API are written to
      * persistent storage.
diff --git a/ohos_nweb/include/nweb_data_base.h b/ohos_nweb/include/nweb_data_base.h
index 98249200b394d..f007da2ebf8b0 100644
--- a/ohos_nweb/include/nweb_data_base.h
+++ b/ohos_nweb/include/nweb_data_base.h
@@ -24,6 +24,9 @@
 namespace OHOS::NWeb {
 class OHOS_NWEB_EXPORT NWebDataBase {
 public:
+    enum WebPermissionType {
+        GEOLOCATION_TYPE
+    };
     NWebDataBase() = default;
 
     virtual ~NWebDataBase() = default;
@@ -61,6 +64,57 @@ public:
      */
     virtual std::vector<std::string> GetHttpAuthCredentials(const std::string& host,
         const std::string& realm) const = 0;
+
+    /**
+     * @brief gets whether the instance holds the specified permissions for the specified source.
+     *
+     * @param origin url source.
+     * @param type specifies permission type.
+     * @return true if instances saved origin specified permissions.
+     */
+    virtual bool ExistPermissionByOrigin(const std::string& origin, int type) = 0;
+
+    /**
+     * @brief get specifies permission type result by origin.
+     *
+     * @param origin url source.
+     * @param type specifies permission type.
+     * @param result saved result.
+     * @return return Whether there is a saved result.
+     */
+    virtual bool GetPermissionResultByOrigin(const std::string& origin, int type, bool& result) = 0;
+
+    /**
+     * @brief set specifies permission type result by origin.
+     *
+     * @param origin url source.
+     * @param type specifies permission type.
+     * @param result set result.
+     */
+    virtual void SetPermissionByOrigin(const std::string& origin, int type, bool result) = 0;
+
+    /**
+     * @brief delete specifies permission type by origin.
+     *
+     * @param origin url source.
+     * @param type specifies permission type.
+     */
+    virtual void ClearPermissionByOrigin(const std::string& origin, int type) = 0;
+
+    /**
+     * @brief delete all specifies permission type.
+     *
+     * @param type specifies permission type.
+     */
+    virtual void ClearAllPermission(int type) = 0;
+
+    /**
+     * @brief obtains all origins of a specified permission type.
+     *
+     * @param type specifies permission type.
+     * @return return all origin.
+     */
+    virtual std::vector<std::string> GetOriginsByPermission(int type) = 0;
 };
 } // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_find_callback.h b/ohos_nweb/include/nweb_find_callback.h
new file mode 100644
index 0000000000000..4f8accc4bba65
--- /dev/null
+++ b/ohos_nweb/include/nweb_find_callback.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_FIND_CALLBACK_H
+#define NWEB_FIND_CALLBACK_H
+
+#include <string>
+
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebFindCallback {
+ public:
+  NWebFindCallback() = default;
+
+  virtual ~NWebFindCallback() = default;
+
+  /**
+   * @brief Notify the host application that onFindResultReceived
+   *
+   * @param activeMatchOrdinal int: the zero-based ordinal of the currently
+   * selected match
+   * @param numberOfMatches int: how many matches have been found
+   * @param isDoneCounting bool: whether the find operation has actually
+   * completed. The listener may be notified multiple times while the operation
+   * is underway, and the numberOfMatches value should not be considered final
+   * unless isDoneCounting is true.
+   */
+  virtual void OnFindResultReceived(const int activeMatchOrdinal,
+                                    const int numberOfMatches,
+                                    const bool isDoneCounting) = 0;
+};
+}  // namespace OHOS::NWeb
+
+#endif  // NWEB_FIND_CALLBACK_H
diff --git a/ohos_nweb/include/nweb_handler.h b/ohos_nweb/include/nweb_handler.h
index a2a45c970c3fd..86a68a27e2a67 100644
--- a/ohos_nweb/include/nweb_handler.h
+++ b/ohos_nweb/include/nweb_handler.h
@@ -29,6 +29,9 @@
 #include "nweb_geolocation_callback_interface.h"
 #include "nweb_js_dialog_result.h"
 #include "nweb_js_http_auth_result.h"
+#include "nweb_js_ssl_error_result.h"
+#include "nweb_js_ssl_select_cert_result.h"
+#include "nweb_touch_handle_state.h"
 #include "nweb_url_resource_error.h"
 #include "nweb_url_resource_request.h"
 #include "nweb_url_resource_response.h"
@@ -82,6 +85,27 @@ enum class RenderExitReason {
     PROCESS_EXIT_UNKNOWN,
 };
 
+struct ImageOptions {
+    ImageColorType colorType;
+    ImageAlphaType alphaType;
+    size_t width;
+    size_t height;
+};
+
+enum class SslError {
+    // General error
+    INVALID,
+
+    // Hostname mismatch
+    HOSTMISMATCH,
+
+    // The certificate date is invalid
+    DATEINVALID,
+
+    // The certificate authority is not trusted
+    UNTRUSTED,
+};
+
 using FileSelectorCallback = NWebValueCallback<std::vector<std::string>&>;
 
 class OHOS_NWEB_EXPORT NWebHandler {
@@ -323,7 +347,7 @@ public:
     /**
      * @brief Ask for the permission.
      *
-     * @param request  std::shared_ptr<NWebAccessRequest>: A request to ask for the
+     * @param request std::shared_ptr<NWebAccessRequest>: A request to ask for the
      * permission.
      */
     virtual void OnPermissionRequest(std::shared_ptr<NWebAccessRequest> request) {}
@@ -331,7 +355,7 @@ public:
     /**
      * @brief Cancel the request to ask for the permission.
      *
-     * @param request  std::shared_ptr<NWebAccessRequest>: A request to ask for the
+     * @param request std::shared_ptr<NWebAccessRequest>: A request to ask for the
      * permission.
      */
     virtual void OnPermissionRequestCanceled(std::shared_ptr<NWebAccessRequest> request) {}
@@ -378,11 +402,36 @@ public:
 
     virtual void OnQuickMenuDismissed() {}
 
+    virtual void OnTouchSelectionChanged(
+        std::shared_ptr<NWebTouchHandleState> insertHandle,
+        std::shared_ptr<NWebTouchHandleState> startSelectionHandle,
+        std::shared_ptr<NWebTouchHandleState> endSelectionHandle) {}
+
     virtual bool OnHttpAuthRequestByJS(std::shared_ptr<NWebJSHttpAuthResult> result,
                                        const std::string& host,
                                        const std::string& realm) {
         return false;
     }
+
+    virtual void OnScroll(double xOffset, double yOffset) {}
+
+    virtual bool OnDragAndDropData(const void* data, size_t len, const ImageOptions& opt) {
+        return false;
+    }
+
+    virtual bool OnSslErrorRequestByJS(std::shared_ptr<NWebJSSslErrorResult> result,
+                                       SslError error) {
+        return false;
+    }
+
+    virtual bool OnSslSelectCertRequestByJS(
+        std::shared_ptr<NWebJSSslSelectCertResult> result,
+        const std::string& host,
+        int port,
+        const std::vector<std::string>& keyTypes,
+        const std::vector<std::string>& issuers) {
+        return false;
+    }
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/include/nweb_js_ssl_error_result.h b/ohos_nweb/include/nweb_js_ssl_error_result.h
new file mode 100644
index 0000000000000..44f636cacaebd
--- /dev/null
+++ b/ohos_nweb/include/nweb_js_ssl_error_result.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_JS_SSL_ERROR_RESULT_H
+#define NWEB_JS_SSL_ERROR_RESULT_H
+
+#include <string>
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebJSSslErrorResult {
+public:
+    virtual ~NWebJSSslErrorResult() = default;
+    /**
+     * @brief Handle a confirmation response from the user, the url request will be continued.
+     */
+    virtual void HandleConfirm() = 0;
+    /**
+     * @brief Handle the result if the user cancelled the url request.
+     */
+    virtual void HandleCancel() = 0;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/include/nweb_js_ssl_select_cert_result.h b/ohos_nweb/include/nweb_js_ssl_select_cert_result.h
new file mode 100644
index 0000000000000..8bf3b115c7de6
--- /dev/null
+++ b/ohos_nweb/include/nweb_js_ssl_select_cert_result.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_JS_SSL_SELECT_CERT_RESULT_H
+#define NWEB_JS_SSL_SELECT_CERT_RESULT_H
+
+#include <string>
+#include "nweb_export.h"
+
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebJSSslSelectCertResult {
+public:
+    virtual ~NWebJSSslSelectCertResult() = default;
+
+    /**
+     * @brief Confirm to use the specified private key and client certificate chain.
+     */
+    virtual void Confirm(const std::string& privateKeyFile, const std::string& certChainFile) = 0;
+
+    /**
+     * @brief Cancel this certificate request.
+     */
+    virtual void Cancel() = 0;
+
+    /**
+     * @brief Ignore this certificate request temporarily.
+     */
+    virtual void Ignore() = 0;
+};
+}
+
+#endif
diff --git a/ohos_nweb/include/nweb_preference.h b/ohos_nweb/include/nweb_preference.h
index a9032eb49067d..f9509b1e32ebe 100644
--- a/ohos_nweb/include/nweb_preference.h
+++ b/ohos_nweb/include/nweb_preference.h
@@ -249,6 +249,16 @@ public:
      */
     virtual void PutWebDebuggingAccess(bool flag) = 0;
 
+    /**
+     * Put whether media playback needs to be triggered by user gestures, default value is false.
+     */
+    virtual void PutMediaPlayGestureAccess(bool flag) = 0;
+
+    /**
+     * Put whether smooth mode is supported.
+     */
+    virtual void PutPinchSmoothMode(bool flag) = 0;
+
     /* get methods */
     /**
      * Get if content URL(content from a content provider installed
@@ -482,6 +492,18 @@ public:
      * @see PutWebDebuggingAccess
      */
     virtual bool IsWebDebuggingAccess() = 0;
+
+    /**
+     * Get whether media playback needs to be triggered by user gestures.
+     *
+     * @see PutMediaPlayGestureAccess
+     */
+    virtual bool GetMediaPlayGestureAccess() = 0;
+
+    /**
+     * Get whether smooth mode is supported.
+     */
+    virtual bool GetPinchSmoothMode() = 0;
 };
 }  // namespace OHOS::NWeb
 #endif  // NWEB_PREFERENCE_H
diff --git a/ohos_nweb/include/nweb_touch_handle_state.h b/ohos_nweb/include/nweb_touch_handle_state.h
new file mode 100644
index 0000000000000..9bf00893c7491
--- /dev/null
+++ b/ohos_nweb/include/nweb_touch_handle_state.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_TOUCH_HANDLE_STATE_H
+#define NWEB_TOUCH_HANDLE_STATE_H
+
+#include <string>
+
+#include "nweb_export.h"
+namespace OHOS::NWeb {
+class OHOS_NWEB_EXPORT NWebTouchHandleState {
+public:
+    enum TouchHandleType {
+        INSERT_HANDLE,
+        SELECTION_BEGIN_HANDLE,
+        SELECTION_END_HANDLE,
+        INVALID_HANDLE
+    };
+
+    NWebTouchHandleState() = default;
+
+    virtual ~NWebTouchHandleState() = default;
+
+    virtual int32_t GetTouchHandleId() const = 0;
+
+    virtual int32_t GetX() const = 0;
+
+    virtual int32_t GetY() const = 0;
+
+    virtual TouchHandleType GetTouchHandleType() const = 0;
+
+    virtual bool IsEnable() const = 0;
+
+    virtual float GetAlpha() const = 0;
+
+    virtual float GetEdgeHeight() const = 0;
+};
+}
+
+#endif // NWEB_TOUCH_HANDLE_STATE_H
\ No newline at end of file
diff --git a/ohos_nweb/include/nweb_url_resource_response.h b/ohos_nweb/include/nweb_url_resource_response.h
index c0743d2430fea..f0b9fd6f388c9 100644
--- a/ohos_nweb/include/nweb_url_resource_response.h
+++ b/ohos_nweb/include/nweb_url_resource_response.h
@@ -20,10 +20,18 @@
 #include <string>
 
 namespace OHOS::NWeb {
+
+class NWebResourceReadyCallback {
+public:
+    virtual ~NWebResourceReadyCallback() {};
+    virtual void Continue() = 0;
+    virtual void Cancel() = 0;
+};
+
 class NWebUrlResourceResponse {
 public:
     /**
-     * @brief Constructs a resource response with the given parameters.
+     * @brief Construct a resource response with the given parameters.
      *
      * @param mime_type the resource response's MIME type, for example {
      * "text/html"}.
@@ -79,10 +87,12 @@ public:
     void PutResponseData(std::string& input_stream)
     {
         input_stream_ = input_stream;
+        fd_ = 0;
+        isFileFd_ = false;
     }
 
     /**
-     * @brief Constructs a resource response with the given parameters.
+     * @brief Construct a resource response with the given parameters.
      *
      * @param encoding encoding { "utf-8" }
      */
@@ -102,7 +112,7 @@ public:
     }
 
     /**
-     * @brief Constructs a resource response with the given parameters.
+     * @brief Construct a resource response with the given parameters.
      *
      * @param mime_type mime_type{ "text/html" }
      */
@@ -112,7 +122,7 @@ public:
     }
 
     /**
-     * @brief get mimetype
+     * @brief Get mimetype
      *
      * @retval mimetype The resource response's MIME type
      */
@@ -155,7 +165,7 @@ public:
     }
 
     /**
-     * @brief get status code
+     * @brief Get status code
      *
      * @retval status code
     */
@@ -173,6 +183,41 @@ public:
     {
         return reason_phrase_;
     }
+
+    void PutResponseDataStatus(bool isDataReady)
+    {
+        isDataReady_ = isDataReady;
+        if (isDataReady_ == true && readyCallback_ != nullptr) {
+            readyCallback_->Continue();
+            readyCallback_ = nullptr;
+        }
+    }
+
+    bool ResponseDataStatus() {
+        return isDataReady_;
+    }
+
+    bool ResponseIsFileHandle() {
+        return isFileFd_;
+    }
+
+    void PutResponseFileHandle(int fd)
+    {
+        fd_ = fd;
+        isFileFd_ = true;
+        input_stream_.clear();
+    }
+
+    int ResponseFileHandle()
+    {
+        return fd_;
+    }
+
+    void PutResponseReadyCallback(std::shared_ptr<NWebResourceReadyCallback> readyCallback)
+    {
+        readyCallback_ = readyCallback;
+    }
+
 private:
     std::string mime_type_;
     std::string encoding_;
@@ -180,6 +225,11 @@ private:
     std::string reason_phrase_;
     std::map<std::string, std::string> response_headers_;
     std::string input_stream_;
+    int fd_;
+    bool isFileFd_ = false;
+    bool isDataReady_ = true;
+    std::shared_ptr<NWebResourceReadyCallback> readyCallback_;
 };
-}
-#endif
+} // namespace OHOS::NWeb
+
+#endif // NWEB_URL_RESOURCE_RESPONSE_H
diff --git a/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc
index d9e40643e3ca7..99caa88d787ad 100644
--- a/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_access_request_delegate.cc
@@ -25,7 +25,7 @@ std::string NWebAccessRequestDelegate::Origin() {
   if (request_ != nullptr) {
     return request_->Origin();
   }
-  return nullptr;
+  return "";
 }
 
 int NWebAccessRequestDelegate::ResourceAcessId() {
diff --git a/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc
index 81a7c77e493b5..803a2571a8968 100644
--- a/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.cc
@@ -13,7 +13,6 @@
  * limitations under the License.
  */
 #include <unordered_map>
-
 #include "nweb_context_menu_params_impl.h"
 
 #include "nweb_context_menu_params.h"
@@ -25,7 +24,6 @@ using CmTf = NWebContextMenuParams::ContextMenuTypeFlags;
 using CmMt = NWebContextMenuParams::ContextMenuMediaType;
 using CmEf = NWebContextMenuParams::ContextMenuEditStateFlags;
 using QmEf = NWebQuickMenuParams::QuickMenuEditStateFlags;
-
 const std::unordered_map<int, int> kCmTypeFlagMap = {
   {CM_TYPEFLAG_NONE, CmTf::CM_TF_NONE},
   {CM_TYPEFLAG_PAGE, CmTf::CM_TF_PAGE},
@@ -63,6 +61,7 @@ const std::unordered_map<int, int> kQmEditStateFlagsMap = {
   {QM_EDITFLAG_CAN_CUT, QmEf::QM_EF_CAN_CUT},
   {QM_EDITFLAG_CAN_COPY, QmEf::QM_EF_CAN_COPY},
   {QM_EDITFLAG_CAN_PASTE, QmEf::QM_EF_CAN_PASTE},
+  {QM_EDITFLAG_CAN_SELECT_ALL, QmEf::QM_EF_CAN_SELECT_ALL},
 };
 
 const std::unordered_map<int, int> KMenuEventFlagsMap = {
@@ -76,8 +75,21 @@ const std::unordered_map<int, int> KMenuEventFlagsMap = {
   {EF_RIGHT_MOUSE_BUTTON, EVENTFLAG_RIGHT_MOUSE_BUTTON},
 };
 
+const std::unordered_map<int32_t, cef_menu_id_t> KMenuCommandIdMap = {
+  {CI_IMAGE_COPY, MENU_ID_IMAGE_COPY},
+};
+
+cef_menu_id_t ConvertCommandId(int32_t id) {
+  std::unordered_map<int32_t, cef_menu_id_t>::const_iterator iter =
+    KMenuCommandIdMap.find(id);
+  if (iter != KMenuCommandIdMap.end()) {
+    return iter->second;
+  }
+  return MENU_ID_CUSTOM_FIRST;
+}
+
 int32_t ConvertMenuFlags(int32_t value,
-  const std::unordered_map<int, int> &flags_map) {
+  const std::unordered_map<int, int>& flags_map) {
   int32_t result = 0;
   for (auto& kv : flags_map) {
     if ((kv.first & value) != 0) {
@@ -123,6 +135,27 @@ int32_t NWebContextMenuParamsImpl::GetContextMenuTypeFlags() {
   return 0;
 }
 
+std::string NWebContextMenuParamsImpl::GetLinkUrl() {
+  if (params_ != nullptr) {
+    return params_->GetLinkUrl().ToString();
+  }
+  return std::string();
+}
+ 
+std::string NWebContextMenuParamsImpl::GetUnfilteredLinkUrl() {
+  if (params_ != nullptr) {
+    return params_->GetUnfilteredLinkUrl().ToString();
+  }
+  return std::string();
+}
+ 
+std::string NWebContextMenuParamsImpl::GetSourceUrl() {
+  if (params_ != nullptr) {
+    return params_->GetSourceUrl().ToString();
+  }
+  return std::string();
+}
+
 bool NWebContextMenuParamsImpl::HasImageContents() {
   if (params_ != nullptr) {
     return params_->HasImageContents();
@@ -190,6 +223,39 @@ int32_t NWebQuickMenuParamsImpl::GetEditStateFlags() {
   return edit_flags_;
 }
 
+std::shared_ptr<NWebTouchHandleState>
+NWebQuickMenuParamsImpl::GetTouchHandleState(
+  NWebTouchHandleState::TouchHandleType type) {
+  switch (type) {
+    case NWebTouchHandleState::TouchHandleType::INSERT_HANDLE:
+      return insert_touch_handle_state_;
+    case NWebTouchHandleState::TouchHandleType::SELECTION_BEGIN_HANDLE:
+      return begin_touch_handle_state_;
+    case NWebTouchHandleState::TouchHandleType::SELECTION_END_HANDLE:
+      return end_touch_handle_state_;
+    default:
+      return nullptr;
+  }
+}
+
+void NWebQuickMenuParamsImpl::SetTouchHandleState(
+    std::shared_ptr<NWebTouchHandleState> state,
+    NWebTouchHandleState::TouchHandleType type) {
+  switch (type) {
+    case NWebTouchHandleState::TouchHandleType::INSERT_HANDLE:
+      insert_touch_handle_state_ = state;
+      break;
+    case NWebTouchHandleState::TouchHandleType::SELECTION_BEGIN_HANDLE:
+      begin_touch_handle_state_ = state;
+      break;
+    case NWebTouchHandleState::TouchHandleType::SELECTION_END_HANDLE:
+      end_touch_handle_state_ = state;
+      break;
+    default:
+      return;
+  }
+}
+
 NWebContextMenuCallbackImpl::NWebContextMenuCallbackImpl(
   CefRefPtr<CefRunContextMenuCallback> callback) : callback_(callback) {}
 
@@ -198,7 +264,7 @@ void NWebContextMenuCallbackImpl::Continue(
   if (callback_ != nullptr) {
     int32_t event_flag = 
       ConvertMenuFlags(static_cast<int32_t>(flag), KMenuEventFlagsMap);
-    callback_->Continue(commandId,
+    callback_->Continue(ConvertCommandId(commandId),
                         static_cast<cef_event_flags_t>(event_flag));
   }
 }
diff --git a/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h
index 67a277e72fb22..0ea7e5d7d0b08 100644
--- a/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h
+++ b/ohos_nweb/src/cef_delegate/nweb_context_menu_params_impl.h
@@ -28,6 +28,9 @@ class NWebContextMenuParamsImpl : public NWebContextMenuParams {
   int32_t GetXCoord() override;
   int32_t GetYCoord() override;
   int32_t GetContextMenuTypeFlags() override;
+  std::string GetLinkUrl() override;
+  std::string GetUnfilteredLinkUrl() override;
+  std::string GetSourceUrl() override;
   bool HasImageContents() override;
   std::string GetTitleText() override;
   std::string GetPageUrl() override;
@@ -48,13 +51,20 @@ class NWebQuickMenuParamsImpl : public NWebQuickMenuParams {
   int32_t GetWidth() override;
   int32_t GetHeight() override;
   int32_t GetEditStateFlags() override;
-
+  std::shared_ptr<NWebTouchHandleState> GetTouchHandleState(
+    NWebTouchHandleState::TouchHandleType type) override;
+  void SetTouchHandleState(
+    std::shared_ptr<NWebTouchHandleState> state,
+    NWebTouchHandleState::TouchHandleType type);
  private:
   int32_t x_;
   int32_t y_;
   int32_t width_;
   int32_t height_;
   int32_t edit_flags_;
+  std::shared_ptr<NWebTouchHandleState> insert_touch_handle_state_;
+  std::shared_ptr<NWebTouchHandleState> begin_touch_handle_state_;
+  std::shared_ptr<NWebTouchHandleState> end_touch_handle_state_;
 };
 
 class NWebContextMenuCallbackImpl : public NWebContextMenuCallback {
diff --git a/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
index 18084ffe5b7fa..e5d11e749c1e9 100644
--- a/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.cc
@@ -81,14 +81,19 @@ class CookieSetCallback : public CefSetCookieCallback {
 class HasCookieVisitor : public CefCookieVisitor {
  public:
   HasCookieVisitor() = delete;
-  explicit HasCookieVisitor(std::shared_ptr<NWebValueCallback<bool>> callback)
-      : callback_(callback) {}
+  explicit HasCookieVisitor(std::shared_ptr<WaitableEvent> event,
+                            std::shared_ptr<NWebValueCallback<bool>> callback)
+      : event_(event), callback_(callback) {}
   ~HasCookieVisitor() = default;
 
   bool Visit(const CefCookie& cookie,
              int count,
              int total,
              bool& deleteCookie) override {
+    total_cookies_number = total;
+    if (event_ != nullptr) {
+      event_->Signal();
+    }
     if (total == 0) {
       if (callback_ != nullptr) {
         callback_->OnReceiveValue(false);
@@ -103,9 +108,13 @@ class HasCookieVisitor : public CefCookieVisitor {
     }
   }
 
+  bool IsExistCookies() const { return total_cookies_number == 0 ? false : true; }
+
  private:
+  std::shared_ptr<WaitableEvent> event_;
   std::shared_ptr<NWebValueCallback<bool>> callback_;
   IMPLEMENT_REFCOUNTING(HasCookieVisitor);
+  int total_cookies_number;
 };
 
 class ReturnCookieVisitor : public CefCookieVisitor {
@@ -210,6 +219,7 @@ NWebCookieManagerDelegate::GetGlobalCookieManager() {
 bool NWebCookieManagerDelegate::IsAcceptCookieAllowed() {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
   if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
     return false;
   }
   return cookie_manager->IsAcceptCookieAllowed();
@@ -218,14 +228,34 @@ bool NWebCookieManagerDelegate::IsAcceptCookieAllowed() {
 void NWebCookieManagerDelegate::PutAcceptCookieEnabled(bool accept) {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
   if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
     return;
   }
   cookie_manager->PutAcceptCookieEnabled(accept);
 }
 
+bool NWebCookieManagerDelegate::IsThirdPartyCookieAllowed() {
+  CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
+  if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
+    return false;
+  }
+  return cookie_manager->IsThirdPartyCookieAllowed();
+}
+
+void NWebCookieManagerDelegate::PutAcceptThirdPartyCookieEnabled(bool accept) {
+  CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
+  if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
+    return;
+  }
+  cookie_manager->PutAcceptThirdPartyCookieEnabled(accept);
+}
+
 bool NWebCookieManagerDelegate::IsFileURLSchemeCookiesAllowed() {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
   if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
     return false;
   }
   return cookie_manager->IsFileURLSchemeCookiesAllowed();
@@ -235,6 +265,7 @@ void NWebCookieManagerDelegate::PutAcceptFileURLSchemeCookiesEnabled(
     bool allow) {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
   if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
     return;
   }
   cookie_manager->PutAcceptFileURLSchemeCookiesEnabled(allow);
@@ -331,13 +362,29 @@ void NWebCookieManagerDelegate::ExistCookies(
   if (cookie_manager == nullptr) {
     return;
   }
-  CefRefPtr<HasCookieVisitor> visitor = new HasCookieVisitor(callback);
+  CefRefPtr<HasCookieVisitor> visitor = new HasCookieVisitor(nullptr ,callback);
   if (!cookie_manager->VisitAllCookies(visitor)) {
     LOG(INFO) << "VisitAllCookies failed";
     return;
   }
 }
 
+bool NWebCookieManagerDelegate::ExistCookies() {
+  CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
+  if (cookie_manager == nullptr) {
+    LOG(ERROR) << "GetGlobalCookieManager failed";
+    return false;
+  }
+  std::shared_ptr<base::WaitableEvent> completion =
+    std::make_shared<base::WaitableEvent>(
+      base::WaitableEvent::ResetPolicy::AUTOMATIC,
+      base::WaitableEvent::InitialState::NOT_SIGNALED);
+  CefRefPtr<HasCookieVisitor> visitor = new HasCookieVisitor(completion, nullptr);
+  cookie_manager->VisitAllCookies(visitor);
+  completion->Wait();
+  return visitor->IsExistCookies();
+}
+
 void NWebCookieManagerDelegate::Store(
     std::shared_ptr<NWebValueCallback<bool>> callback) {
   CefRefPtr<CefCookieManager> cookie_manager = GetGlobalCookieManager();
diff --git a/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h b/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h
index c77cb4c9a6bea..31ea78e550fd4 100644
--- a/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_cookie_manager_delegate.h
@@ -29,6 +29,8 @@ class NWebCookieManagerDelegate : public NWebCookieManagerDelegateInterface {
 
   bool IsAcceptCookieAllowed() override;
   void PutAcceptCookieEnabled(bool accept) override;
+  bool IsThirdPartyCookieAllowed() override;
+  void PutAcceptThirdPartyCookieEnabled(bool accept) override;
   bool IsFileURLSchemeCookiesAllowed() override;
   void PutAcceptFileURLSchemeCookiesEnabled(bool allow) override;
   void ReturnCookie(
@@ -41,6 +43,7 @@ class NWebCookieManagerDelegate : public NWebCookieManagerDelegateInterface {
   bool SetCookie(const std::string &url,
                  const std::string &value) override;
   void ExistCookies(std::shared_ptr<NWebValueCallback<bool>> callback) override;
+  bool ExistCookies() override;
   void Store(std::shared_ptr<NWebValueCallback<bool>> callback) override;
   bool Store() override;
   void DeleteSessionCookies(
diff --git a/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc
index 6ff1f635af9de..283950d3698a7 100644
--- a/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.cc
@@ -50,7 +50,7 @@ void NWebDataBaseDelegate::SaveHttpAuthCredentials(const std::string& host,
   if (data_base == nullptr) {
     return;
   }
-  return data_base->SaveHttpAuthCredentials(host, realm,username, password);
+  data_base->SaveHttpAuthCredentials(host, realm,username, password);
 }
 
 std::vector<std::string> NWebDataBaseDelegate::GetHttpAuthCredentials(const std::string& host, const std::string& realm) {
@@ -69,6 +69,68 @@ std::vector<std::string> NWebDataBaseDelegate::GetHttpAuthCredentials(const std:
   return username_password;
 }
 
+bool NWebDataBaseDelegate::ExistPermissionByOrigin(const std::string& origin, int type)
+{
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return false;
+  }
+  return data_base->ExistPermissionByOrigin(origin, type);
+}
+
+bool NWebDataBaseDelegate::GetPermissionResultByOrigin(const std::string& origin, int type, bool& result)
+{
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return false;
+  }
+  return data_base->GetPermissionResultByOrigin(origin, type, result);
+}
+
+void NWebDataBaseDelegate::SetPermissionByOrigin(const std::string& origin, int type, bool result)
+{
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return;
+  }
+  data_base->SetPermissionByOrigin(origin, type, result);
+}
+
+void NWebDataBaseDelegate::ClearPermissionByOrigin(const std::string& origin, int type)
+{
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return;
+  }
+  data_base->ClearPermissionByOrigin(origin, type);
+}
+
+void NWebDataBaseDelegate::ClearAllPermission(int type)
+{
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return;
+  }
+  data_base->ClearAllPermission(type);
+}
+
+std::vector<std::string> NWebDataBaseDelegate::GetOriginsByPermission(int type)
+{
+  CefRefPtr<CefDataBase> data_base = GetGlobalCefDataBase();
+  if (data_base == nullptr) {
+    return {};
+  }
+
+  std::vector<CefString> method_vector;
+  data_base->GetOriginsByPermission(type, method_vector);
+
+  std::vector<std::string> origins;
+  for (std::string value : method_vector) {
+    origins.push_back(value);
+  }
+  return origins;
+}
+
 bool NWebDataBaseDelegate::ExistFormData() {
   return false;
 }
@@ -77,4 +139,4 @@ void NWebDataBaseDelegate::ClearFormData() {
   return;
 }
 
-}  // namespace OHOS::NWeb
\ No newline at end of file
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h
index 70fa3303f66b4..cdfa1f5024e2e 100644
--- a/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_data_base_delegate.h
@@ -37,6 +37,18 @@ class NWebDataBaseDelegate {
 
   std::vector<std::string> GetHttpAuthCredentials(const std::string& host, const std::string& realm);
 
+  bool ExistPermissionByOrigin(const std::string& origin, int type);
+
+  bool GetPermissionResultByOrigin(const std::string& origin, int type, bool& result);
+
+  void SetPermissionByOrigin(const std::string& origin, int type, bool result);
+
+  void ClearPermissionByOrigin(const std::string& origin, int type);
+
+  void ClearAllPermission(int type);
+
+  std::vector<std::string> GetOriginsByPermission(int type);
+
   bool ExistFormData();
 
   void ClearFormData();
@@ -47,4 +59,4 @@ class NWebDataBaseDelegate {
   CefRefPtr<CefDataBase> data_base_ = nullptr;
 };
 }  // namespace OHOS::NWeb
-#endif
\ No newline at end of file
+#endif
diff --git a/ohos_nweb/src/cef_delegate/nweb_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_delegate.cc
index 654fe5694a896..edf330a54c2cd 100755
--- a/ohos_nweb/src/cef_delegate/nweb_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_delegate.cc
@@ -20,8 +20,11 @@
 #include "nweb_handler_delegate.h"
 #include "nweb_render_handler.h"
 
+#include "base/strings/utf_string_conversions.h"
 #include "cef/include/base/cef_logging.h"
 #include "cef/include/cef_app.h"
+#include "cef/include/cef_request_context.h"
+#include "nweb_find_delegate.h"
 #include "nweb_preference_delegate.h"
 
 namespace OHOS::NWeb {
@@ -46,6 +49,25 @@ class JavaScriptResultCallbackImpl : public CefJavaScriptResultCallback {
   DISALLOW_COPY_AND_ASSIGN(JavaScriptResultCallbackImpl);
 };
 
+class StoreWebArchiveResultCallbackImpl
+    : public CefStoreWebArchiveResultCallback {
+ public:
+  StoreWebArchiveResultCallbackImpl(
+      std::shared_ptr<NWebValueCallback<std::string>> callback)
+      : callback_(callback){};
+  void OnStoreWebArchiveDone(const CefString& result) override {
+    if (callback_ != nullptr) {
+      callback_->OnReceiveValue(result.ToString());
+    }
+  }
+
+ private:
+  std::shared_ptr<NWebValueCallback<std::string>> callback_;
+
+  IMPLEMENT_REFCOUNTING(StoreWebArchiveResultCallbackImpl);
+  DISALLOW_COPY_AND_ASSIGN(StoreWebArchiveResultCallbackImpl);
+};
+
 NWebDelegate::NWebDelegate(int argc, const char* argv[])
     : argc_(argc), argv_(argv) {}
 
@@ -58,6 +80,7 @@ NWebDelegate::~NWebDelegate() {
 
 bool NWebDelegate::Init(void* window) {
   preference_delegate_ = std::make_shared<NWebPreferenceDelegate>();
+  find_delegate_ = std::make_shared<NWebFindDelegate>();
 
   display_manager_adapter_ =
     OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
@@ -72,7 +95,7 @@ bool NWebDelegate::Init(void* window) {
   }
 
   if (!display_manager_adapter_->RegisterDisplayListener(display_listener_)) {
-    LOG(ERROR) << "jcz RegisterDisplayListener failed";
+    LOG(ERROR) << "RegisterDisplayListener failed";
     return false;
   }
 
@@ -88,15 +111,16 @@ bool NWebDelegate::Init(void* window) {
     return false;
   }
 
+  std::string url_for_init = "";
+  InitializeCef(url_for_init, window);
+
   std::shared_ptr<DisplayAdapter> display =
     display_manager_adapter_->GetDefaultDisplay();
   if (display != nullptr) {
     NotifyScreenInfoChanged(display->GetRotation(), display->GetOrientation());
+    SetVirtualPixelRatio(display->GetVirtualPixelRatio());
   }
 
-  std::string url_for_init = "";
-  InitializeCef(url_for_init, window);
-
   return true;
 }
 
@@ -111,6 +135,10 @@ void NWebDelegate::OnDestroy(bool is_close_all) {
   if (preference_delegate_ != nullptr) {
     preference_delegate_->OnDestroy();
   }
+  if (!GetBrowser().get()) {
+    return;
+  }
+  GetBrowser()->GetHost()->DestroyAllWebMessagePorts();
 }
 
 void NWebDelegate::RegisterDownLoadListener(
@@ -122,6 +150,41 @@ void NWebDelegate::RegisterDownLoadListener(
   handler_delegate_->RegisterDownLoadListener(download_listener);
 }
 
+void NWebDelegate::RegisterFindListener(
+    std::shared_ptr<NWebFindCallback> find_listener) {
+  if (find_delegate_ == nullptr) {
+    LOG(ERROR) << "fail to register FindListener, find_delegate_ is nullptr";
+    return;
+  }
+  find_delegate_->SetListener(find_listener);
+}
+
+void NWebDelegate::FindAllAsync(const std::string& search_string) const {
+  if (find_delegate_ == nullptr) {
+    LOG(ERROR) << "fail to FindAllAsync, find_delegate_ is nullptr";
+    return;
+  }
+  find_delegate_->FindAllAsync(GetBrowser().get(),
+                               base::UTF8ToUTF16(search_string));
+}
+
+void NWebDelegate::ClearMatches() const {
+  if (find_delegate_ == nullptr) {
+    LOG(ERROR) << "fail to ClearMatches, find_delegate_ is nullptr";
+    return;
+  }
+
+  find_delegate_->ClearMatches(GetBrowser().get());
+}
+
+void NWebDelegate::FindNext(const bool forward) const {
+  if (find_delegate_ == nullptr) {
+    LOG(ERROR) << "fail to FindNext, find_delegate_ is nullptr";
+    return;
+  }
+  find_delegate_->FindNext(GetBrowser().get(), forward);
+}
+
 void NWebDelegate::RegisterNWebHandler(std::shared_ptr<NWebHandler> handler) {
   if (handler_delegate_ == nullptr) {
     LOG(ERROR)
@@ -196,9 +259,9 @@ void NWebDelegate::SendMouseWheelEvent(double x, double y, double deltaX, double
   }
 }
 
-void NWebDelegate::SendMouseEvent(int x, int y, int button, int action) {
+void NWebDelegate::SendMouseEvent(int x, int y, int button, int action, int count) {
   if (event_handler_ != nullptr) {
-    event_handler_->SendMouseEvent(x, y, button, action);
+    event_handler_->SendMouseEvent(x, y, button, action, count);
   }
 }
 
@@ -214,6 +277,17 @@ void NWebDelegate::NotifyScreenInfoChanged(
   }
 }
 
+void NWebDelegate::SetVirtualPixelRatio(float ratio) {
+  if (ratio <= 0 || ratio == default_virtual_pixel_ratio_) {
+    return;
+  }
+  default_virtual_pixel_ratio_ = ratio;
+  auto browser = GetBrowser();
+  if (browser != nullptr && browser->GetHost() != nullptr) {
+    browser->GetHost()->SetVirtualPixelRatio(ratio);
+  }
+}
+
 std::shared_ptr<NWebPreference> NWebDelegate::GetPreference() const {
   return preference_delegate_;
 }
@@ -279,6 +353,22 @@ void NWebDelegate::DeleteNavigateHistory() {
   }
 }
 
+void NWebDelegate::ClearSslCache() {
+  LOG(INFO) << "NWebDelegate::ClearSslCache";
+  CefRefPtr<CefRequestContext> context = CefRequestContext::GetGlobalContext();
+  if (context != nullptr) {
+    context->ClearCertificateExceptions(nullptr);
+  }
+}
+
+void NWebDelegate::ClearClientAuthenticationCache() {
+  LOG(INFO) << "NWebDelegate::ClearClientAuthenticationCache";
+  CefRefPtr<CefRequestContext> context = CefRequestContext::GetGlobalContext();
+  if (context != nullptr) {
+    context->ClearClientAuthenticationCache(nullptr);
+  }
+}
+
 void NWebDelegate::Reload() const {
   LOG(INFO) << "NWebDelegate::Reload";
   if (GetBrowser().get()) {
@@ -293,6 +383,25 @@ void NWebDelegate::ReloadOriginalUrl() const {
   }
 }
 
+void NWebDelegate::SetBrowserUserAgentString(const std::string& user_agent) {
+  LOG(INFO) << "NWebDelegate::SetBrowserUserAgentString";
+  if (GetBrowser().get()) {
+    GetBrowser()->SetBrowserUserAgentString(user_agent);
+  }
+}
+
+void NWebDelegate::StoreWebArchive(
+    const std::string& base_name,
+    bool auto_name,
+    std::shared_ptr<NWebValueCallback<std::string>> callback) const {
+  if (GetBrowser().get()) {
+    CefRefPtr<StoreWebArchiveResultCallbackImpl> save_webarchive_callback =
+        new StoreWebArchiveResultCallbackImpl(callback);
+    GetBrowser()->GetHost()->StoreWebArchive(base_name, auto_name,
+                                             save_webarchive_callback);
+  }
+}
+
 void NWebDelegate::Zoom(float zoomFactor) const {
   LOG(INFO) << "NWebDelegate::Zoom";
   if (GetBrowser().get()) {
@@ -426,7 +535,7 @@ void NWebDelegate::OnContinue() {
 
 void NWebDelegate::InitializeCef(std::string url, void* window) {
   handler_delegate_ = NWebHandlerDelegate::Create(
-      preference_delegate_, render_handler_, event_handler_);
+      preference_delegate_, render_handler_, event_handler_, find_delegate_, window);
   nweb_app_ =
       new NWebApplication(preference_delegate_, url, handler_delegate_, window);
 
@@ -441,7 +550,6 @@ void NWebDelegate::InitializeCef(std::string url, void* window) {
   settings.windowless_rendering_enabled = true;
   settings.log_severity = LOGSEVERITY_INFO;
   settings.multi_threaded_message_loop = false;
-
   settings.persist_session_cookies = true;
 
 #if !defined(CEF_USE_SANDBOX)
@@ -475,6 +583,84 @@ std::string NWebDelegate::Title() {
   return GetBrowser()->GetHost()->Title();
 }
 
+void NWebDelegate::CreateWebMessagePorts(std::vector<std::string>& ports) {
+  if (!GetBrowser().get()) {
+    LOG(ERROR) << "JSAPI CreateWebMessagePorts can not get browser";
+    return;
+  }
+  std::vector<CefString> cefPorts;
+  GetBrowser()->GetHost()->CreateWebMessagePorts(cefPorts);
+
+  for (CefString port : cefPorts) {
+    ports.push_back(port.ToString());
+  }
+}
+
+void NWebDelegate::PostWebMessage(std::string& message, std::vector<std::string>& ports, std::string& targetUri) {
+  if (!GetBrowser().get()) {
+    LOG(ERROR) << "JSAPI PostWebMessage can not get browser";
+    return;
+  }
+
+  std::vector<CefString> cefPorts;
+  for (std::string port : ports) {
+    CefString portCef;
+    portCef.FromString(port);
+    cefPorts.push_back(portCef);
+  }
+
+  CefString msgCef;
+  msgCef.FromString(message);
+  CefString uri;
+  uri.FromString(targetUri);
+
+  GetBrowser()->GetHost()->PostWebMessage(msgCef, cefPorts, uri);
+}
+
+void NWebDelegate::ClosePort(std::string& portHandle) {
+  if (!GetBrowser().get()) {
+    LOG(ERROR) << "JSAPI ClosePort can not get browser";
+    return;
+  }
+  CefString handleCef;
+  handleCef.FromString(portHandle);
+
+  GetBrowser()->GetHost()->ClosePort(handleCef);
+}
+
+void NWebDelegate::PostPortMessage(std::string& portHandle, std::string& data) {
+  if (!GetBrowser().get()) {
+    LOG(ERROR) << "JSAPI PostPortMessage can not get browser";
+    return;
+  }
+  CefString handleCef;
+  handleCef.FromString(portHandle);
+  CefString dataCef;
+  dataCef.FromString(data);
+
+  GetBrowser()->GetHost()->PostPortMessage(handleCef, dataCef);
+}
+
+void NWebDelegate::SetPortMessageCallback(std::string& portHandle,
+    std::shared_ptr<NWebValueCallback<std::string>> callback) {
+  if (!GetBrowser().get()) {
+    LOG(ERROR) << "JSAPI SetPortMessageCallback can not get browser";
+    return;
+  }
+  CefRefPtr<JavaScriptResultCallbackImpl> JsResultCb = new JavaScriptResultCallbackImpl(callback);
+  CefString handleCef;
+  handleCef.FromString(portHandle);
+  GetBrowser()->GetHost()->SetPortMessageCallback(handleCef, JsResultCb);
+}
+
+std::string NWebDelegate::GetUrl() const {
+  LOG(INFO) << "NWebDelegate::get url";
+  if (GetBrowser().get()) {
+    return GetBrowser()->GetMainFrame()->GetURL().ToString();
+  }
+  return "";
+}
+
 HitTestResult NWebDelegate::GetHitTestResult() const {
   HitTestResult data;
   if (!GetBrowser().get()) {
@@ -633,4 +819,58 @@ void NWebDelegate::OnBlur() const {
 
   GetBrowser()->GetHost()->SendFocusEvent(false);
 }
+
+#if defined(REPORT_SYS_EVENT)
+void NWebDelegate::SetNWebId(uint32_t nwebId) {
+  nweb_id_ = nwebId;
+  if (nweb_id_ != 0) {
+    handler_delegate_->SetNWebId(nweb_id_);
+  }
+}
+#endif
+
+void NWebDelegate::SendDragEvent(const DelegateDragEvent& dragEvent) const {
+  if (!GetBrowser().get()) {
+    LOG(ERROR) << "browser is nullptr";
+    return;
+  }
+  CefMouseEvent event;
+  event.x = dragEvent.x;
+  event.y = dragEvent.y;
+  event.modifiers = EVENTFLAG_LEFT_MOUSE_BUTTON;
+  switch (dragEvent.action) {
+    case DelegateDragAction::DRAG_START:
+      break;
+    case DelegateDragAction::DRAG_ENTER:
+      if (render_handler_) {
+        LOG(INFO) << "SendDragEvent enter";
+        GetBrowser()->GetHost()->DragTargetDragEnter(render_handler_->GetDragData(), event, DRAG_OPERATION_MOVE);
+      }
+      break;
+    case DelegateDragAction::DRAG_LEAVE:
+      LOG(INFO) << "SendDragEvent leave";
+      GetBrowser()->GetHost()->DragTargetDragLeave();
+      break;
+    case DelegateDragAction::DRAG_OVER:
+      GetBrowser()->GetHost()->DragTargetDragOver(event, DRAG_OPERATION_MOVE);
+      break;
+    case DelegateDragAction::DRAG_DROP:
+      event.modifiers = EVENTFLAG_NONE;
+      LOG(INFO) << "SendDragEvent drop";
+      GetBrowser()->GetHost()->DragTargetDrop(event);
+      break;
+    case DelegateDragAction::DRAG_END:
+      LOG(INFO) << "SendDragEvent end";
+      GetBrowser()->GetHost()->DragSourceEndedAt(event.x, event.y, DRAG_OPERATION_MOVE);
+      GetBrowser()->GetHost()->DragSourceSystemDragEnded();
+      break;
+    case DelegateDragAction::DRAG_CANCEL:
+      LOG(INFO) << "SendDragEvent cancel";
+      GetBrowser()->GetHost()->DragSourceSystemDragEnded();
+      break;
+    default:
+      LOG(INFO) << "invalid drag action";
+      break;
+  }
+}
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_delegate.h b/ohos_nweb/src/cef_delegate/nweb_delegate.h
index 43e74826868ba..1db2a635c82de 100755
--- a/ohos_nweb/src/cef_delegate/nweb_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_delegate.h
@@ -55,7 +55,7 @@ class NWebDelegate : public NWebDelegateInterface,
   void OnTouchCancel() override;
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction) override;
   void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) override;
-  void SendMouseEvent(int x, int y, int button, int action) override;
+  void SendMouseEvent(int x, int y, int button, int action, int count) override;
   void NotifyScreenInfoChanged(RotationType rotation,
                                OrientationType orientation) override;
 
@@ -67,6 +67,8 @@ class NWebDelegate : public NWebDelegateInterface,
   void NavigateForward() const override;
   void NavigateBackOrForward(int32_t step) const override;
   void DeleteNavigateHistory() override;
+  void ClearSslCache() override;
+  void ClearClientAuthenticationCache() override;
   void Reload() const override;
   void ReloadOriginalUrl() const override;
   void Zoom(float zoomFactor) const override;
@@ -83,6 +85,12 @@ class NWebDelegate : public NWebDelegateInterface,
   void OnContinue() override;
   std::shared_ptr<NWebPreference> GetPreference() const override;
   std::string Title() override;
+  void CreateWebMessagePorts(std::vector<std::string>& ports) override;
+  void PostWebMessage(std::string& message, std::vector<std::string>& ports, std::string& targetUri) override;
+  void ClosePort(std::string& port_handle) override;
+  void PostPortMessage(std::string& port_handle, std::string& data) override;
+  void SetPortMessageCallback(std::string& port_handle,
+      std::shared_ptr<NWebValueCallback<std::string>> callback) override;
   HitTestResult GetHitTestResult() const override;
   int PageLoadProgress() override;
   float Scale() override;
@@ -109,8 +117,29 @@ class NWebDelegate : public NWebDelegateInterface,
       std::shared_ptr<NWebJavaScriptResultCallBack> callback) override;
   void OnFocus() const override;
   void OnBlur() const override;
+
+  void RegisterFindListener(
+      std::shared_ptr<NWebFindCallback> find_listener) override;
+  void FindAllAsync(const std::string& search_string) const override;
+  void ClearMatches() const override;
+  void FindNext(const bool forward) const override;
+  std::string GetUrl() const override;
+
   bool SetZoomInFactor(float factor);
   bool SetZoomOutFactor(float factor);
+
+#if defined(REPORT_SYS_EVENT)
+  void SetNWebId(uint32_t nwebId) override;
+#endif
+
+  void StoreWebArchive(
+      const std::string& base_name,
+      bool auto_name,
+      std::shared_ptr<NWebValueCallback<std::string>> callback) const override;
+  void SetBrowserUserAgentString(const std::string& user_agent) override;
+
+  void SendDragEvent(const DelegateDragEvent& dragEvent) const override;
+
  public:
   int argc_;
   const char** argv_;
@@ -120,10 +149,12 @@ class NWebDelegate : public NWebDelegateInterface,
   void InitializeCef(std::string url, void* window);
   const CefRefPtr<CefBrowser> GetBrowser() const;
   void RequestVisitedHistory();
+  void SetVirtualPixelRatio(float ratio);
 
  private:
   float zoom_in_factor_ = 2.0;
   float zoom_out_factor_ = -2.0;
+  float default_virtual_pixel_ratio_ = 2.0;
   float intial_scale_ = 0;
   bool has_requested_visited_history = false;
   CefRefPtr<NWebApplication> nweb_app_ = nullptr;
@@ -131,12 +162,17 @@ class NWebDelegate : public NWebDelegateInterface,
   CefRefPtr<NWebRenderHandler> render_handler_ = nullptr;
   std::shared_ptr<NWebEventHandler> event_handler_ = nullptr;
   std::shared_ptr<NWebPreferenceDelegate> preference_delegate_ = nullptr;
+  std::shared_ptr<NWebFindDelegate> find_delegate_ = nullptr;
   std::unique_ptr<OHOS::NWeb::DisplayManagerAdapter>
     display_manager_adapter_ = nullptr;
   std::shared_ptr<OHOS::NWeb::DisplayScreenListener>
     display_listener_ = nullptr;
   // Members only accessed on the main thread.
   bool hidden_ = false;
+
+#if defined(REPORT_SYS_EVENT)
+  uint32_t nweb_id_;
+#endif
 };
 }  // namespace OHOS::NWeb
 #endif
diff --git a/ohos_nweb/src/cef_delegate/nweb_display_listener.cc b/ohos_nweb/src/cef_delegate/nweb_display_listener.cc
index 037d93ad61a5c..141e2df8332f9 100644
--- a/ohos_nweb/src/cef_delegate/nweb_display_listener.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_display_listener.cc
@@ -20,7 +20,7 @@
 namespace OHOS::NWeb {
 DisplayScreenListener::DisplayScreenListener(
   std::shared_ptr<NWebDelegateInterface> nweb)
-  : nweb_(nweb) {
+  : nweb_(std::weak_ptr<NWebDelegateInterface>(nweb)) {
   display_manager_adapter_ =
     OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
 }
@@ -38,8 +38,9 @@ void DisplayScreenListener::OnChange(DisplayId id) {
   if (id == display_manager_adapter_->GetDefaultDisplayId()) {
     std::shared_ptr<DisplayAdapter> display =
       display_manager_adapter_->GetDefaultDisplay();
-    if (nweb_ != nullptr && display != nullptr) {
-      nweb_->NotifyScreenInfoChanged(display->GetRotation(), display->GetOrientation());
+    auto nweb = nweb_.lock();
+    if (nweb != nullptr && display != nullptr) {
+      nweb->NotifyScreenInfoChanged(display->GetRotation(), display->GetOrientation());
     } else {
       LOG(ERROR) << "notify screen info change failed";
     }
diff --git a/ohos_nweb/src/cef_delegate/nweb_display_listener.h b/ohos_nweb/src/cef_delegate/nweb_display_listener.h
index c6d958d364054..272c4d3b32f04 100644
--- a/ohos_nweb/src/cef_delegate/nweb_display_listener.h
+++ b/ohos_nweb/src/cef_delegate/nweb_display_listener.h
@@ -31,7 +31,7 @@ class DisplayScreenListener : public DisplayListenerAdapter {
   void OnDestroy(DisplayId id) override;
   void OnChange(DisplayId id) override;
  private:
-  std::shared_ptr<NWebDelegateInterface> nweb_;
+  std::weak_ptr<NWebDelegateInterface> nweb_;
   std::unique_ptr<DisplayManagerAdapter>
     display_manager_adapter_;
 };
diff --git a/ohos_nweb/src/cef_delegate/nweb_event_handler.cc b/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
index 2b02a41cfbacd..da697a8331dab 100644
--- a/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_event_handler.cc
@@ -45,10 +45,11 @@ void NWebEventHandler::SetBrowser(CefRefPtr<CefBrowser> browser) {
 void NWebEventHandler::OnTouchPress(int32_t id, double x, double y) {
   CefTouchEvent touch_pressed;
   touch_pressed.type = CEF_TET_PRESSED;
+  touch_pressed.pointer_type = CEF_POINTER_TYPE_TOUCH;
   touch_pressed.id = id;
   touch_pressed.x = x;
   touch_pressed.y = y;
-  touch_pressed.modifiers = EVENTFLAG_LEFT_MOUSE_BUTTON;
+  touch_pressed.modifiers = EVENTFLAG_NONE;
   if (browser_ && browser_->GetHost()) {
     browser_->GetHost()->SendTouchEvent(touch_pressed);
   }
@@ -57,10 +58,11 @@ void NWebEventHandler::OnTouchPress(int32_t id, double x, double y) {
 void NWebEventHandler::OnTouchMove(int32_t id, double x, double y) {
   CefTouchEvent touch_move;
   touch_move.type = CEF_TET_MOVED;
+  touch_move.pointer_type = CEF_POINTER_TYPE_TOUCH;
   touch_move.id = id;
   touch_move.x = x;
   touch_move.y = y;
-  touch_move.modifiers = EVENTFLAG_LEFT_MOUSE_BUTTON;
+  touch_move.modifiers = EVENTFLAG_NONE;
   if (browser_ && browser_->GetHost()) {
     browser_->GetHost()->SendTouchEvent(touch_move);
   }
@@ -69,10 +71,11 @@ void NWebEventHandler::OnTouchMove(int32_t id, double x, double y) {
 void NWebEventHandler::OnTouchRelease(int32_t id, double x, double y) {
   CefTouchEvent touch_end;
   touch_end.type = CEF_TET_RELEASED;
+  touch_end.pointer_type = CEF_POINTER_TYPE_TOUCH;
   touch_end.id = id;
   touch_end.x = x;
   touch_end.y = y;
-  touch_end.modifiers = EVENTFLAG_LEFT_MOUSE_BUTTON;
+  touch_end.modifiers = EVENTFLAG_NONE;
   if (browser_ && browser_->GetHost()) {
     browser_->GetHost()->SendTouchEvent(touch_end);
   }
@@ -114,7 +117,7 @@ bool NWebEventHandler::SendKeyEvent(int32_t keyCode, int32_t keyAction) {
     }
   }
 
-  return false;
+  return true;
 }
 
 void NWebEventHandler::SendMouseWheelEvent(double x,
@@ -132,7 +135,7 @@ void NWebEventHandler::SendMouseWheelEvent(double x,
   }
 }
 
-void NWebEventHandler::SendMouseEvent(int x, int y, int button, int action) {
+void NWebEventHandler::SendMouseEvent(int x, int y, int button, int action, int count) {
   CefMouseEvent mouseEvent;
   mouseEvent.x = x;
   mouseEvent.y = y;
@@ -142,8 +145,7 @@ void NWebEventHandler::SendMouseEvent(int x, int y, int button, int action) {
 
   if (browser_ && browser_->GetHost()) {
     if (NWebInputDelegate::IsMouseDown(action)) {
-      browser_->GetHost()->SendMouseClickEvent(mouseEvent, buttonType, false,
-                                               1);
+      browser_->GetHost()->SendMouseClickEvent(mouseEvent, buttonType, false, count);
     } else if (NWebInputDelegate::IsMouseUp(action)) {
       browser_->GetHost()->SendMouseClickEvent(mouseEvent, buttonType, true, 1);
     } else if (NWebInputDelegate::IsMouseMove(action)) {
diff --git a/ohos_nweb/src/cef_delegate/nweb_event_handler.h b/ohos_nweb/src/cef_delegate/nweb_event_handler.h
index 963202633b2af..6df938dccae32 100644
--- a/ohos_nweb/src/cef_delegate/nweb_event_handler.h
+++ b/ohos_nweb/src/cef_delegate/nweb_event_handler.h
@@ -38,7 +38,7 @@ class NWebEventHandler {
   void OnKeyBack();
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction);
   void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY);
-  void SendMouseEvent(int x, int y, int button, int action);
+  void SendMouseEvent(int x, int y, int button, int action, int count);
 
  private:
   bool IsCharInputEvent(CefKeyEvent& keyEvent);
diff --git a/ohos_nweb/src/cef_delegate/nweb_find_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_find_delegate.cc
new file mode 100644
index 0000000000000..33d6492747cd8
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_find_delegate.cc
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_find_delegate.h"
+#include "cef/include/cef_browser.h"
+#include "nweb_find_callback.h"
+
+namespace OHOS::NWeb {
+
+NWebFindDelegate::NWebFindDelegate()
+    : listener_(nullptr),
+      async_find_started_(false),
+      find_request_id_counter_(0),
+      current_request_id_(0),
+      current_session_id_(0),
+      last_match_count_(-1),
+      last_active_ordinal_(-1) {}
+
+NWebFindDelegate::~NWebFindDelegate() {}
+
+void NWebFindDelegate::SetListener(std::shared_ptr<NWebFindCallback> listener) {
+  listener_ = listener;
+}
+
+void NWebFindDelegate::FindAllAsync(CefBrowser* browser,
+                                    const std::u16string& search_string) {
+  if (browser == nullptr)
+    return;
+  // Stop any ongoing asynchronous request.
+  browser->GetHost()->StopFinding(false);
+
+  async_find_started_ = true;
+
+  StartNewSession(search_string);
+
+  if (MaybeHandleEmptySearch(browser, search_string))
+    return;
+
+  browser->GetHost()->Find(current_request_id_, search_string,
+                           true /* forward*/, false /* matchCase*/,
+                           false /* findNext*/, /* newSession*/ true);
+}
+
+void NWebFindDelegate::HandleFindReply(int request_id,
+                                       int match_count,
+                                       int active_ordinal,
+                                       bool finished) {
+  if (!async_find_started_ || request_id < current_session_id_)
+    return;
+
+  NotifyResults(active_ordinal, match_count, finished);
+}
+
+void NWebFindDelegate::FindNext(CefBrowser* browser, bool forward) {
+  if (browser == nullptr)
+    return;
+  if (!async_find_started_)
+    return;
+
+  current_request_id_ = find_request_id_counter_++;
+
+  if (MaybeHandleEmptySearch(browser, last_search_string_))
+    return;
+
+  browser->GetHost()->Find(current_request_id_, last_search_string_,
+                           forward /* forward*/, false /* matchCase*/,
+                           true /* findNext*/, /* newSession*/ false);
+}
+
+void NWebFindDelegate::ClearMatches(CefBrowser* browser) {
+  if (browser == nullptr)
+    return;
+  browser->GetHost()->StopFinding(true);
+
+  async_find_started_ = false;
+  last_search_string_.clear();
+  last_match_count_ = -1;
+  last_active_ordinal_ = -1;
+}
+
+bool NWebFindDelegate::MaybeHandleEmptySearch(
+    CefBrowser* browser,
+    const std::u16string& search_string) {
+  if (!search_string.empty())
+    return false;
+
+  browser->GetHost()->StopFinding(true);
+  NotifyResults(0, 0, true);
+  return true;
+}
+
+void NWebFindDelegate::StartNewSession(const std::u16string& search_string) {
+  current_request_id_ = find_request_id_counter_++;
+  current_session_id_ = current_request_id_;
+  last_search_string_ = search_string;
+  last_match_count_ = -1;
+  last_active_ordinal_ = -1;
+}
+
+void NWebFindDelegate::NotifyResults(int active_ordinal,
+                                     int match_count,
+                                     bool finished) {
+  // Match count or ordinal values set to -1 refer to received replies.
+  if (match_count == -1)
+    match_count = last_match_count_;
+  else
+    last_match_count_ = match_count;
+
+  if (active_ordinal == -1)
+    active_ordinal = last_active_ordinal_;
+  else
+    last_active_ordinal_ = active_ordinal;
+
+  // Skip the update if we don't still have a valid ordinal.
+  // The next update, final or not, should have this information.
+  if (!finished && active_ordinal == -1)
+    return;
+
+  // Safeguard in case of errors to prevent reporting -1 to the API listeners.
+  if (match_count == -1) {
+    NOTREACHED();
+    match_count = 0;
+  }
+
+  if (active_ordinal == -1) {
+    NOTREACHED();
+    active_ordinal = 0;
+  }
+
+  // WebView.FindListener active match ordinals are 0-based while WebKit sends
+  // 1-based ordinals. Still we can receive 0 ordinal in case of no results.
+  active_ordinal = std::max(active_ordinal - 1, 0);
+
+  if (listener_)
+    listener_->OnFindResultReceived(active_ordinal, match_count, finished);
+}
+
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_find_delegate.h b/ohos_nweb/src/cef_delegate/nweb_find_delegate.h
new file mode 100644
index 0000000000000..0a967ec67bd21
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_find_delegate.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_FIND_DELEGATE_H
+#define NWEB_FIND_DELEGATE_H
+#include <functional>
+#include <string>
+#include "cef/include/base/cef_macros.h"
+
+class CefBrowser;
+
+namespace OHOS::NWeb {
+class NWebFindCallback;
+
+// Handles the ohos find-in-page API requests.
+class NWebFindDelegate {
+ public:
+  class Listener {
+   public:
+    // Called when receiving a new find-in-page update.
+    // This will be triggered when the results of FindAllSync, FindAllAsync and
+    // FindNext are available. The value provided in active_ordinal is 0-based.
+    virtual void OnFindResultReceived(int active_ordinal,
+                                      int match_count,
+                                      bool finished) = 0;
+    virtual ~Listener() {}
+  };
+
+  explicit NWebFindDelegate();
+  ~NWebFindDelegate();
+
+  // Asynchronous API.
+  void FindAllAsync(CefBrowser* browser, const std::u16string& search_string);
+  void HandleFindReply(int request_id,
+                       int match_count,
+                       int active_ordinal,
+                       bool finished);
+
+  // Methods valid in both synchronous and asynchronous modes.
+  void FindNext(CefBrowser* browser, bool forward);
+  void ClearMatches(CefBrowser* browser);
+  void SetListener(std::shared_ptr<NWebFindCallback> listener);
+
+ private:
+  void StartNewSession(const std::u16string& search_string);
+  bool MaybeHandleEmptySearch(CefBrowser* browser,
+                              const std::u16string& search_string);
+  void NotifyResults(int active_ordinal, int match_count, bool finished);
+
+  // Listener results are reported to.
+  std::shared_ptr<NWebFindCallback> listener_;
+
+  // Used to check the validity of FindNext operations.
+  bool async_find_started_;
+
+  // Used to provide different IDs to each request and for result
+  // verification in asynchronous calls.
+  int find_request_id_counter_;
+  int current_request_id_;
+
+  // Used to mark the beginning of the current find session. This is the ID of
+  // the first find request in the current session.
+  int current_session_id_;
+
+  // Required by FindNext and the incremental find replies.
+  std::u16string last_search_string_;
+  int last_match_count_;
+  int last_active_ordinal_;
+
+  DISALLOW_COPY_AND_ASSIGN(NWebFindDelegate);
+};
+
+}  // namespace OHOS::NWeb
+
+#endif  // NWEB_FIND_DELEGATE_H
diff --git a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
index 3daf76d7ab25f..fd61d1bce105e 100755
--- a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.cc
@@ -16,25 +16,39 @@
 #include "nweb_handler_delegate.h"
 
 #include <thread>
+#include <window.h>
 
 #include "base/bind.h"
 #include "base/callback.h"
 #include "cef/include/cef_app.h"
+#include "cef/include/cef_cookie.h"
 #include "cef/include/cef_parser.h"
 #include "cef/include/wrapper/cef_closure_task.h"
 #include "cef/include/wrapper/cef_helpers.h"
 #include "nweb_access_request_delegate.h"
 #include "nweb_context_menu_params_impl.h"
 #include "nweb_file_selector_params_impl.h"
+#include "nweb_find_delegate.h"
+
+#include "nweb_cookie_manager_impl.h"
 #include "nweb_geolocation_callback.h"
 #include "nweb_js_dialog_result_impl.h"
 #include "nweb_js_http_auth_result_impl.h"
+#include "nweb_js_ssl_error_result_impl.h"
+#include "nweb_js_ssl_select_cert_result_impl.h"
+#include "nweb_preference_delegate.h"
 #include "nweb_resource_handler.h"
 #include "nweb_url_resource_error_impl.h"
 #include "nweb_url_resource_request_impl.h"
 #include "nweb_url_resource_response.h"
 #include "nweb_value_callback.h"
 
+#include "ohos_adapter_helper.h"
+
+#if defined(REPORT_SYS_EVENT)
+#include "event_reporter.h"
+#endif
+
 namespace OHOS::NWeb {
 namespace {
 ImageColorType TransformColorType(cef_color_type_t color_type) {
@@ -61,6 +75,32 @@ ImageAlphaType TransformAlphaType(cef_alpha_type_t alpha_type) {
   }
 }
 
+SslError SslErrorConvert(cef_errorcode_t cert_error)
+{
+  SslError err;
+  switch (cert_error) {
+    case ERR_CERT_COMMON_NAME_INVALID:
+      err = SslError::HOSTMISMATCH;
+      break;
+    case ERR_CERT_DATE_INVALID:
+      err = SslError::DATEINVALID;
+      break;
+    case ERR_CERT_KNOWN_INTERCEPTION_BLOCKED:
+    case ERR_CERT_AUTHORITY_INVALID:
+      err = SslError::UNTRUSTED;
+      break;
+    default:
+      // all other codes to INVALID
+      err = SslError::INVALID;
+      break;
+  }
+
+  LOG(INFO) << "NWebHandlerDelegate::OnCertificateError SslErrorConvert: "
+    << "cef err = " << cert_error
+    << ", nweb err = " << static_cast<int32_t>(err);
+  return err;
+}
+
 void ConvertMapToHeaderMap(const CefRequest::HeaderMap& headers,
                            std::map<std::string, std::string>& map) {
   for (auto iter = headers.begin(); iter != headers.end(); ++iter) {
@@ -108,9 +148,11 @@ NWebFileSelectorParams::FileSelectorMode ConvertFileSelectorMode(
 CefRefPtr<NWebHandlerDelegate> NWebHandlerDelegate::Create(
     std::shared_ptr<NWebPreferenceDelegate> preference_delegate,
     CefRefPtr<NWebRenderHandler> render_handler,
-    std::shared_ptr<NWebEventHandler> event_handler) {
+    std::shared_ptr<NWebEventHandler> event_handler,
+    std::shared_ptr<NWebFindDelegate> find_delegate,
+    void* window) {
   CefRefPtr<NWebHandlerDelegate> handler_delegate = new NWebHandlerDelegate(
-      preference_delegate, render_handler, event_handler);
+      preference_delegate, render_handler, event_handler, find_delegate, window);
   if (handler_delegate == nullptr) {
     LOG(ERROR) << "fail to create NWebHandlerDelegate instance";
     return nullptr;
@@ -121,10 +163,20 @@ CefRefPtr<NWebHandlerDelegate> NWebHandlerDelegate::Create(
 NWebHandlerDelegate::NWebHandlerDelegate(
     std::shared_ptr<NWebPreferenceDelegate> preference_delegate,
     CefRefPtr<NWebRenderHandler> render_handler,
-    std::shared_ptr<NWebEventHandler> event_handler)
+    std::shared_ptr<NWebEventHandler> event_handler,
+    std::shared_ptr<NWebFindDelegate> find_delegate,
+    void* window)
     : preference_delegate_(preference_delegate),
       render_handler_(render_handler),
-      event_handler_(event_handler) {}
+      event_handler_(event_handler),
+      find_delegate_(find_delegate),
+      window_(reinterpret_cast<NativeWindow*>(window)) {
+#if defined(REPORT_SYS_EVENT)
+  access_sum_count_ = 0;
+  access_success_count_ = 0;
+  access_fail_count_ = 0;
+#endif
+}
 
 void NWebHandlerDelegate::OnDestroy() {
   if (main_browser_) {
@@ -145,6 +197,9 @@ void NWebHandlerDelegate::RegisterNWebHandler(
     std::shared_ptr<NWebHandler> handler) {
   LOG(INFO) << "RegisterNWebHandler";
   nweb_handler_ = handler;
+  if (render_handler_ != nullptr) {
+    render_handler_->RegisterNWebHandler(handler);
+  }
 }
 
 void NWebHandlerDelegate::RegisterNWebJavaScriptCallBack(
@@ -224,6 +279,13 @@ CefRefPtr<CefContextMenuHandler> NWebHandlerDelegate::GetContextMenuHandler() {
   return this;
 }
 
+CefRefPtr<CefCookieAccessFilter> NWebHandlerDelegate::GetCookieAccessFilter(
+                                              CefRefPtr<CefBrowser> browser,
+                                              CefRefPtr<CefFrame> frame,
+                                              CefRefPtr<CefRequest> request) {
+  return this;
+}
+
 bool NWebHandlerDelegate::OnProcessMessageReceived(
     CefRefPtr<CefBrowser> browser,
     CefRefPtr<CefFrame> frame,
@@ -247,6 +309,11 @@ bool NWebHandlerDelegate::OnProcessMessageReceived(
 
   return false;
 }
+
+CefRefPtr<CefFindHandler> NWebHandlerDelegate::GetFindHandler() {
+  return this;
+}
+
 /* CefClient methods end */
 
 /* CefLifeSpanHandler methods begin */
@@ -290,6 +357,11 @@ void NWebHandlerDelegate::OnBeforeClose(CefRefPtr<CefBrowser> browser) {
   LOG(INFO) << "NWebHandlerDelegate::OnBeforeClose";
   CEF_REQUIRE_UI_THREAD();
 
+  // Destruct window here to ensure that the GPU thread has stopped
+  // and will not use window again.
+  DestoryNativeWindow(window_);
+  window_ = nullptr;
+
   // Remove from the list of existing browsers.
   BrowserList::iterator bit = browser_list_.begin();
   for (; bit != browser_list_.end(); ++bit) {
@@ -355,9 +427,26 @@ void NWebHandlerDelegate::OnLoadEnd(CefRefPtr<CefBrowser> browser,
     return;
   }
   LOG(INFO) << "NWebHandlerDelegate:: Mainframe OnLoadEnd";
+
   if (nweb_handler_ != nullptr) {
     nweb_handler_->OnPageLoadEnd(http_status_code, frame->GetURL().ToString());
   }
+
+#if defined(REPORT_SYS_EVENT)
+  std::string error_type = "";
+  std::string error_desc = "refer to https://www.iana.org/assignments/http-status-codes/http-status-codes.xml";
+  if (http_status_code < 400) {
+    access_success_count_++;
+  } else if (http_status_code >= 400 && http_status_code < 500) {
+    error_type = "http client error";
+    access_fail_count_++;
+    ReportPageLoadErrorInfo(nweb_id_, error_type, http_status_code, error_desc);
+  } else {
+    access_fail_count_++;
+  }
+  access_sum_count_ = access_success_count_ + access_fail_count_;
+  ReportPageLoadStats(nweb_id_, access_sum_count_, access_success_count_, access_fail_count_);
+#endif
 }
 
 // Returns a data: URI with the specified contents.
@@ -392,6 +481,14 @@ void NWebHandlerDelegate::OnLoadError(CefRefPtr<CefBrowser> browser,
 
     frame->LoadURL(GetDataURI(ss.str(), "text/html"));
   }
+
+#if defined(REPORT_SYS_EVENT)
+  std::string error_type = "failded url";
+  access_fail_count_++;
+  access_sum_count_ = access_success_count_ + access_fail_count_;
+  ReportPageLoadErrorInfo(nweb_id_, error_type, int(error_code), std::string(error_text));
+  ReportPageLoadStats(nweb_id_, access_sum_count_, access_success_count_, access_fail_count_);
+#endif
 }
 
 void NWebHandlerDelegate::OnLoadErrorWithRequest(CefRefPtr<CefRequest> request,
@@ -412,6 +509,14 @@ void NWebHandlerDelegate::OnLoadErrorWithRequest(CefRefPtr<CefRequest> request,
   if (nweb_handler_ != nullptr) {
     nweb_handler_->OnResourceLoadError(web_request, error);
   }
+
+#if defined(REPORT_SYS_EVENT)
+  std::string error_type = "resource load error";
+  access_fail_count_++;
+  access_sum_count_ = access_success_count_ + access_fail_count_;
+  ReportPageLoadErrorInfo(nweb_id_, error_type, error_code, error_text.ToString());
+  ReportPageLoadStats(nweb_id_, access_sum_count_, access_success_count_, access_fail_count_);
+#endif
 }
 
 void NWebHandlerDelegate::OnHttpError(CefRefPtr<CefRequest> request,
@@ -435,6 +540,14 @@ void NWebHandlerDelegate::OnHttpError(CefRefPtr<CefRequest> request,
             data);
     nweb_handler_->OnHttpError(web_request, web_response);
   }
+
+#if defined(REPORT_SYS_EVENT)
+  std::string error_type = "http error";
+  access_fail_count_++;
+  access_sum_count_ = access_success_count_ + access_fail_count_;
+  ReportPageLoadErrorInfo(nweb_id_, error_type, response->GetStatus(), std::string(response->GetStatusText()));
+  ReportPageLoadStats(nweb_id_, access_sum_count_, access_success_count_, access_fail_count_);
+#endif
 }
 
 void NWebHandlerDelegate::OnRefreshAccessedHistory(CefRefPtr<CefBrowser> browser,
@@ -477,7 +590,43 @@ bool NWebHandlerDelegate::OnCertificateError(
     const CefString& request_url,
     CefRefPtr<CefSSLInfo> ssl_info,
     CefRefPtr<CefRequestCallback> callback) {
-  LOG(INFO) << "NWebHandlerDelegate::OnCertificateError";
+  LOG(INFO) << "NWebHandlerDelegate::OnCertificateError happened";
+  SslError error = SslErrorConvert(cert_error);
+
+  CEF_REQUIRE_IO_THREAD();
+  std::shared_ptr<NWebJSSslErrorResult> js_result = std::make_shared<NWebJSSslErrorResultImpl>(callback);
+  if (nweb_handler_ != nullptr) {
+    return nweb_handler_->OnSslErrorRequestByJS(js_result, error);
+  }
+  return false;
+}
+
+bool NWebHandlerDelegate::OnSelectClientCertificate(
+    CefRefPtr<CefBrowser> browser,
+    bool isProxy,
+    const CefString& host,
+    int port,
+    const std::vector<CefString>& key_types,
+    const std::vector<CefString>& principals,
+    const CefRequestHandler::X509CertificateList& certificates,
+    CefRefPtr<CefSelectClientCertificateCallback> callback) {
+  LOG(INFO) << "NWebHandlerDelegate::OnSelectClientCertificate";
+  CEF_REQUIRE_IO_THREAD();
+
+  std::vector<std::string> key_types_str;
+  for (std::string value : key_types) {
+    key_types_str.push_back(value);
+  }
+
+  std::vector<std::string> principals_str;
+  for (std::string value : principals) {
+    principals_str.push_back(value);
+  }
+
+  std::shared_ptr<NWebJSSslSelectCertResultImpl> js_result = std::make_shared<NWebJSSslSelectCertResultImpl>(callback);
+  if (nweb_handler_ != nullptr) {
+    return nweb_handler_->OnSslSelectCertRequestByJS(js_result, host, port, key_types_str, principals_str);
+  }
   return false;
 }
 
@@ -499,26 +648,49 @@ void NWebHandlerDelegate::OnRenderProcessTerminated(CefRefPtr<CefBrowser> browse
   }
 
   RenderExitReason reason;
+#if defined(REPORT_SYS_EVENT)
+  std::string error_desc = "";
+#endif
   switch (status) {
     case TS_ABNORMAL_TERMINATION:
       reason = RenderExitReason::PROCESS_ABNORMAL_TERMINATION;
+#if defined(REPORT_SYS_EVENT)
+      error_desc = "Pprocess abnormal termination";
+#endif
       break;
     case TS_PROCESS_WAS_KILLED:
       reason = RenderExitReason::PROCESS_WAS_KILLED;
+#if defined(REPORT_SYS_EVENT)
+      error_desc = "process was killed";
+#endif
       break;
     case TS_PROCESS_CRASHED:
       reason = RenderExitReason::PROCESS_CRASHED;
+#if defined(REPORT_SYS_EVENT)
+      error_desc = "process crashed";
+#endif
       break;
     case TS_PROCESS_OOM:
       reason = RenderExitReason::PROCESS_OOM;
+#if defined(REPORT_SYS_EVENT)
+      error_desc = "process out of memory";
+#endif
       break;
     default:
       reason = RenderExitReason::PROCESS_EXIT_UNKNOWN;
+#if defined(REPORT_SYS_EVENT)
+      error_desc = "process exit unkonow";
+#endif
       break;
   }
 
   LOG(INFO) << "render process exit, reason = " << static_cast<int>(reason);
   nweb_handler_->OnRenderExited(reason);
+
+#if defined(REPORT_SYS_EVENT)
+  std::string error_type = "render exitted";
+  ReportPageLoadErrorInfo(nweb_id_, error_type, static_cast<int>(reason), error_desc);
+#endif
 }
 
 bool NWebHandlerDelegate::GetAuthCredentials(
@@ -835,9 +1007,43 @@ void NWebHandlerDelegate::OnBeforeContextMenu(
 
 void NWebHandlerDelegate::OnGetImageForContextNode(
   CefRefPtr<CefImage> image) {
+  LOG(INFO) << "NWebHandlerDelegate::OnGetImageForContextNode";
   if (image != nullptr &&
       image->GetWidth() > 0 && image->GetHeight() > 0) {
-    // TODO: Copy or other operation    
+    int pixel_width = 0;
+    int pixel_height = 0;
+    CefRefPtr<CefBinaryValue> bitMap = image->GetAsBitmap(1, CEF_COLOR_TYPE_BGRA_8888,
+      CEF_ALPHA_TYPE_OPAQUE, pixel_width, pixel_height);
+    size_t bitMapSize = bitMap->GetSize();
+    uint8_t *data = (uint8_t *)calloc((size_t)bitMapSize, sizeof(uint8_t));
+    if (data == nullptr) {
+        LOG(ERROR) <<"calloc bitmap failed";
+        return;
+    }
+    bitMap->GetData((void *)data, bitMapSize, 0);
+
+    ClipBoardImageData imageInfo;
+    imageInfo.colorType = ClipBoardImageColorType::COLOR_TYPE_RGBA_8888;
+    imageInfo.alphaType = ClipBoardImageAlphaType::ALPHA_TYPE_OPAQUE;
+    imageInfo.data = (uint32_t *)data;
+    imageInfo.dataSize = bitMapSize;
+    imageInfo.width = pixel_width;
+    imageInfo.height = pixel_height;
+    std::shared_ptr<ClipBoardImageData> imgData =
+      std::make_shared<ClipBoardImageData>(imageInfo);
+    std::shared_ptr<PasteDataRecordAdapter> imgRecord =
+        PasteDataRecordAdapter::NewRecord("pixelMap");
+    PasteRecordList recordList;
+    if (imgRecord->SetImgData(imgData)) {
+      recordList.push_back(imgRecord);
+      LOG(INFO) << "set img to record success";
+    } else {
+      LOG(ERROR) << "set img to record failed";
+      free(data);
+      return;
+    }
+    OhosAdapterHelper::GetInstance().GetPasteBoard().SetPasteData(recordList);
+    free(data);
   } else {
     LOG(WARNING) << "OnGetImageForContextNode image is invalid";
   }
@@ -856,7 +1062,13 @@ bool NWebHandlerDelegate::RunContextMenu(
     std::make_shared<NWebContextMenuParamsImpl>(params);
   std::shared_ptr<NWebContextMenuCallback> nweb_callback =
     std::make_shared<NWebContextMenuCallbackImpl>(callback);
-  return nweb_handler_->RunContextMenu(nweb_param, nweb_callback);
+  if (nweb_handler_->RunContextMenu(nweb_param, nweb_callback)) {
+    return true;
+  }
+  if (nweb_callback) {
+    nweb_callback->Cancel();
+  }
+  return false;
 }
 
 bool NWebHandlerDelegate::OnContextMenuCommand(
@@ -865,7 +1077,13 @@ bool NWebHandlerDelegate::OnContextMenuCommand(
     CefRefPtr<CefContextMenuParams> params,
   int command_id,
   CefContextMenuHandler::EventFlags event_flags) {
-  // TODO: Execute commands such as copy paste etc.
+  if ((command_id == MENU_ID_IMAGE_COPY) &&
+      (browser != nullptr) &&
+      (browser->GetHost() != nullptr)) {
+        browser->GetHost()->GetImageForContextNode();
+        LOG(INFO) << "OnContextMenuCommand: start image copy";
+        return true;
+  }
   return false;
 }
 
@@ -884,14 +1102,30 @@ bool NWebHandlerDelegate::RunQuickMenu(
     const CefSize& size,
     CefContextMenuHandler::QuickMenuEditStateFlags edit_state_flags,
     CefRefPtr<CefRunQuickMenuCallback> callback) {
-  if (nweb_handler_ == nullptr) {
+  if (nweb_handler_ == nullptr || render_handler_ == nullptr) {
     return false;
   }
-  std::shared_ptr<NWebQuickMenuParams> nweb_param =
+  std::shared_ptr<NWebQuickMenuParamsImpl> nweb_param =
     std::make_shared<NWebQuickMenuParamsImpl>(location.x, location.y,
       size.width, size.height, edit_state_flags);
   std::shared_ptr<NWebQuickMenuCallback> nweb_callback =
     std::make_shared<NWebQuickMenuCallbackImpl>(callback);
+
+  auto insert_touch_handle = render_handler_->GetTouchHandleState(
+    NWebTouchHandleState::TouchHandleType::INSERT_HANDLE);
+  auto begin_touch_handle = render_handler_->GetTouchHandleState(
+    NWebTouchHandleState::TouchHandleType::SELECTION_BEGIN_HANDLE);
+  auto end_touch_handle = render_handler_->GetTouchHandleState(
+    NWebTouchHandleState::TouchHandleType::SELECTION_END_HANDLE);
+  nweb_param->SetTouchHandleState(
+    insert_touch_handle,
+    NWebTouchHandleState::TouchHandleType::INSERT_HANDLE);
+  nweb_param->SetTouchHandleState(
+    begin_touch_handle,
+    NWebTouchHandleState::TouchHandleType::SELECTION_BEGIN_HANDLE);
+  nweb_param->SetTouchHandleState(
+    end_touch_handle,
+    NWebTouchHandleState::TouchHandleType::SELECTION_END_HANDLE);
   return nweb_handler_->RunQuickMenu(nweb_param, nweb_callback);
 }
 
@@ -913,6 +1147,38 @@ void NWebHandlerDelegate::OnQuickMenuDismissed(
 }
 /* CefContextMenuHandler method end */
 
+/* CefFindandler method begin */
+
+void NWebHandlerDelegate::OnFindResult(CefRefPtr<CefBrowser> browser,
+                                       int identifier,
+                                       int count,
+                                       const CefRect& selectionRect,
+                                       int activeMatchOrdinal,
+                                       bool finalUpdate) {
+  if (find_delegate_ != nullptr)
+    find_delegate_->HandleFindReply(identifier, count, activeMatchOrdinal,
+                                    finalUpdate);
+}
+
+/* CefFindandler method end */
+
+/* CefResourceRequestHandler methods begin */
+
+bool NWebHandlerDelegate::CanSendCookie(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            CefRefPtr<CefRequest> request,
+                            const CefCookie& cookie) {
+  return NWebCookieManagerImpl::GetCookieManagerInstance()->IsAcceptCookieAllowed();
+}
+bool NWebHandlerDelegate::CanSaveCookie(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            CefRefPtr<CefRequest> request,
+                            CefRefPtr<CefResponse> response,
+                            const CefCookie& cookie) {
+  return NWebCookieManagerImpl::GetCookieManagerInstance()->IsAcceptCookieAllowed();
+}
+/* CefResourceRequestHandler methods end */
+
 const std::vector<std::string> NWebHandlerDelegate::GetVisitedHistory() {
   if (nweb_handler_ != nullptr) {
     return nweb_handler_->VisitedUrlHistory();
@@ -1055,4 +1321,10 @@ int NWebHandlerDelegate::NotifyJavaScriptResult(
   ParseNWebValueToValue(ark_result, result);
   return ark_result->error_;
 }
+
+#if defined(REPORT_SYS_EVENT)
+void NWebHandlerDelegate::SetNWebId(uint32_t nwebId) {
+  nweb_id_ = nwebId;
+}
+#endif
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
index 0a3920c156aa0..186efab0ef1b9 100755
--- a/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_handler_delegate.h
@@ -20,7 +20,9 @@
 #include "cef/include/cef_client.h"
 #include "cef/include/cef_jsdialog_handler.h"
 #include "cef/include/cef_permission_request.h"
+#include "cef/include/cef_resource_request_handler.h"
 #include "cef/include/cef_dialog_handler.h"
+
 #include "nweb_event_handler.h"
 #include "nweb_handler.h"
 #include "nweb_preference_delegate.h"
@@ -35,9 +37,12 @@
 #include "nweb_javascript_result_callback.h"
 #include "nweb_value.h"
 
+struct NativeWindow;
+
 namespace OHOS::NWeb {
 class NWebHandler;
 class NWebGeolocationCallback;
+class NWebFindDelegate;
 
 class NWebHandlerDelegate : public CefClient,
                             public CefLifeSpanHandler,
@@ -50,17 +55,23 @@ class NWebHandlerDelegate : public CefClient,
                             public CefPermissionRequest,
                             public CefJSDialogHandler,
                             public CefDialogHandler,
-                            public CefContextMenuHandler {
+                            public CefContextMenuHandler,
+                            public CefFindHandler,
+                            public CefCookieAccessFilter {
  public:
   static CefRefPtr<NWebHandlerDelegate> Create(
       std::shared_ptr<NWebPreferenceDelegate> preference_delegate,
       CefRefPtr<NWebRenderHandler> render_handler,
-      std::shared_ptr<NWebEventHandler> event_handler);
+      std::shared_ptr<NWebEventHandler> event_handler,
+      std::shared_ptr<NWebFindDelegate> find_delegate,
+      void* window);
 
   NWebHandlerDelegate(
       std::shared_ptr<NWebPreferenceDelegate> preference_delegate,
       CefRefPtr<NWebRenderHandler> render_handler,
-      std::shared_ptr<NWebEventHandler> event_handler);
+      std::shared_ptr<NWebEventHandler> event_handler,
+      std::shared_ptr<NWebFindDelegate> find_delegate,
+      void* window);
   ~NWebHandlerDelegate() = default;
 
   void OnDestroy();
@@ -88,6 +99,10 @@ class NWebHandlerDelegate : public CefClient,
   CefRefPtr<CefJSDialogHandler> GetJSDialogHandler() override;
   CefRefPtr<CefDialogHandler> GetDialogHandler() override;
   CefRefPtr<CefContextMenuHandler> GetContextMenuHandler() override;
+  CefRefPtr<CefCookieAccessFilter> GetCookieAccessFilter(
+                            CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            CefRefPtr<CefRequest> request) override;
   virtual bool OnProcessMessageReceived(
       CefRefPtr<CefBrowser> browser,
       CefRefPtr<CefFrame> frame,
@@ -97,6 +112,7 @@ class NWebHandlerDelegate : public CefClient,
                              const CefString& method,
                              const CefString& object_name,
                              CefRefPtr<CefListValue> result) override;
+  CefRefPtr<CefFindHandler> GetFindHandler() override;
   /* CefClient methods end */
 
   /* CefLifeSpanHandler methods begin */
@@ -166,6 +182,17 @@ class NWebHandlerDelegate : public CefClient,
                           const CefString& request_url,
                           CefRefPtr<CefSSLInfo> ssl_info,
                           CefRefPtr<CefRequestCallback> callback) override;
+
+  bool OnSelectClientCertificate(
+      CefRefPtr<CefBrowser> browser,
+      bool isProxy,
+      const CefString& host,
+      int port,
+      const std::vector<CefString>& key_types,
+      const std::vector<CefString>& principals,
+      const X509CertificateList& certificates,
+      CefRefPtr<CefSelectClientCertificateCallback> callback) override;
+
   CefRefPtr<CefResourceRequestHandler> GetResourceRequestHandler(
       CefRefPtr<CefBrowser> browser,
       CefRefPtr<CefFrame> frame,
@@ -303,8 +330,33 @@ class NWebHandlerDelegate : public CefClient,
                             CefRefPtr<CefFrame> frame) override;
   /* CefContextMenuHandler method end */
 
+  /* CefFindandler methods begin */
+  void OnFindResult(CefRefPtr<CefBrowser> browser,
+                    int identifier,
+                    int count,
+                    const CefRect& selectionRect,
+                    int activeMatchOrdinal,
+                    bool finalUpdate) override;
+  /* CefFindandler methods end */
+
+  /* CefResourceRequestHandler methods begin */
+  bool CanSendCookie(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            CefRefPtr<CefRequest> request,
+                            const CefCookie& cookie) override;
+  bool CanSaveCookie(CefRefPtr<CefBrowser> browser,
+                            CefRefPtr<CefFrame> frame,
+                            CefRefPtr<CefRequest> request,
+                            CefRefPtr<CefResponse> response,
+                            const CefCookie& cookie) override;
+  /* CefResourceRequestHandler methods end */
+
   const std::vector<std::string> GetVisitedHistory();
 
+#if defined(REPORT_SYS_EVENT)
+  void SetNWebId(uint32_t nwebId);
+#endif
+
  private:
   // List of existing browser windows. Only accessed on the CEF UI thread.
   typedef std::list<CefRefPtr<CefBrowser>> BrowserList;
@@ -325,8 +377,19 @@ class NWebHandlerDelegate : public CefClient,
   std::shared_ptr<NWebHandler> nweb_handler_ = nullptr;
   std::shared_ptr<NWebJavaScriptResultCallBack> nweb_javascript_callback_ =
       nullptr;
+  std::shared_ptr<NWebFindDelegate> find_delegate_ = nullptr;
+
   // lifecycle wrapped by ace WebGeolocationOhos
   NWebGeolocationCallback* callback_ = nullptr;
+  NativeWindow* window_ = nullptr;
+
+#if defined(REPORT_SYS_EVENT)
+  uint32_t nweb_id_ = 0;
+  // For page load statistics
+  uint32_t access_sum_count_ = 0;
+  uint32_t access_success_count_ = 0;
+  uint32_t access_fail_count_ = 0;
+#endif
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
index 815aed01f535c..2a086f2d90e13 100644
--- a/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_input_delegate.cc
@@ -20,6 +20,11 @@
 
 using namespace OHOS::NWeb;
 using namespace OHOS::MMI;
+
+namespace OHOS::NWeb {
+NWebInputEventHandle<int, int> NWebInputDelegate::keyEventHandle_;
+}
+
 const int32_t KEY_DOWN = 0;
 const int32_t KEY_UP = 1;
 const int32_t LEFT_BUTTON = 1;
diff --git a/ohos_nweb/src/cef_delegate/nweb_input_delegate.h b/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
index 0c4ca7f169f20..9ab19d09109ca 100644
--- a/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_input_delegate.h
@@ -50,7 +50,7 @@ class NWebInputDelegate {
  private:
   static bool KeyValueConvert(const std::string keyValue,
                               std::unordered_map<int, int>& map);
-  NWebInputEventHandle<int, int> keyEventHandle_;
+  static NWebInputEventHandle<int, int> keyEventHandle_;
   float mouseWheelRatio_ = -5.0;
 };
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h b/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h
index 2d4bcad12a81d..8ce8c9fc7363b 100644
--- a/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h
+++ b/ohos_nweb/src/cef_delegate/nweb_inputmethod_client.h
@@ -23,7 +23,7 @@ namespace OHOS::NWeb {
 class NWebInputMethodClient: public virtual CefBaseRefCounted {
  public:
   virtual ~NWebInputMethodClient() = default;
-  virtual void Attach(CefRefPtr<CefBrowser> browser) = 0;
+  virtual void Attach(CefRefPtr<CefBrowser> browser, bool show_keyboard) = 0;
   virtual void ShowTextInput() = 0;
   virtual void HideTextInput() = 0;
   virtual void OnTextSelectionChanged(CefRefPtr<CefBrowser> browser,
diff --git a/ohos_nweb/src/cef_delegate/nweb_js_ssl_error_result_impl.cc b/ohos_nweb/src/cef_delegate/nweb_js_ssl_error_result_impl.cc
new file mode 100644
index 0000000000000..86f7a1115673a
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_js_ssl_error_result_impl.cc
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_js_ssl_error_result_impl.h"
+
+using namespace OHOS::NWeb;
+
+NWebJSSslErrorResultImpl::NWebJSSslErrorResultImpl(CefRefPtr<CefRequestCallback> callback)
+  : callback_(callback) {}
+
+void NWebJSSslErrorResultImpl::HandleConfirm() {
+  if (callback_ != nullptr) {
+    return callback_->Continue(true);
+  }
+}
+
+void NWebJSSslErrorResultImpl::HandleCancel() {
+  if (callback_ != nullptr) {
+    return callback_->Cancel();
+  }
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_js_ssl_error_result_impl.h b/ohos_nweb/src/cef_delegate/nweb_js_ssl_error_result_impl.h
new file mode 100644
index 0000000000000..b93e9e7a40509
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_js_ssl_error_result_impl.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_JS_SSL_ERROR_RESULT_IMPL_H
+#define NWEB_JS_SSL_ERROR_RESULT_IMPL_H
+
+#include "cef/include/cef_request_callback.h"
+#include "nweb_js_ssl_error_result.h"
+
+namespace OHOS::NWeb {
+class NWebJSSslErrorResultImpl : public NWebJSSslErrorResult {
+ public:
+  NWebJSSslErrorResultImpl() = default;
+  explicit NWebJSSslErrorResultImpl(CefRefPtr<CefRequestCallback> callback);
+  ~NWebJSSslErrorResultImpl() = default;
+  void HandleConfirm() override;
+  void HandleCancel() override;
+ private:
+  CefRefPtr<CefRequestCallback> callback_;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_js_ssl_select_cert_result_impl.cc b/ohos_nweb/src/cef_delegate/nweb_js_ssl_select_cert_result_impl.cc
new file mode 100644
index 0000000000000..e1491784eb221
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_js_ssl_select_cert_result_impl.cc
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_js_ssl_select_cert_result_impl.h"
+#include "base/logging.h"
+
+using namespace OHOS::NWeb;
+
+NWebJSSslSelectCertResultImpl::NWebJSSslSelectCertResultImpl(
+    CefRefPtr<CefSelectClientCertificateCallback> callback)
+    : callback_(callback) {}
+
+void NWebJSSslSelectCertResultImpl::Confirm(const std::string& private_key_file, const std::string& cert_chain_file) {
+  if (callback_ != nullptr) {
+    return callback_->Select(CefString(private_key_file), CefString(cert_chain_file));
+  }
+}
+
+void NWebJSSslSelectCertResultImpl::Cancel() {
+  if (callback_ != nullptr) {
+    return callback_->Cancel();
+  }
+}
+
+void NWebJSSslSelectCertResultImpl::Ignore() {
+  if (callback_ != nullptr) {
+    return callback_->Ignore();
+  }
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_js_ssl_select_cert_result_impl.h b/ohos_nweb/src/cef_delegate/nweb_js_ssl_select_cert_result_impl.h
new file mode 100644
index 0000000000000..6b033efc910b4
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_js_ssl_select_cert_result_impl.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_JS_SSL_SELECT_CERT_RESULT_IMPL_H
+#define NWEB_JS_SSL_SELECT_CERT_RESULT_IMPL_H
+
+#include "cef/include/cef_request_callback.h"
+#include "nweb_js_ssl_select_cert_result.h"
+
+namespace OHOS::NWeb {
+class NWebJSSslSelectCertResultImpl : public NWebJSSslSelectCertResult {
+ public:
+  NWebJSSslSelectCertResultImpl() = default;
+
+  explicit NWebJSSslSelectCertResultImpl(CefRefPtr<CefSelectClientCertificateCallback> callback);
+
+  ~NWebJSSslSelectCertResultImpl() = default;
+
+  void Confirm(const std::string& private_key_file, const std::string& cert_chain_file) override;
+
+  void Ignore() override;
+
+  void Cancel() override;
+
+ private:
+  CefRefPtr<CefSelectClientCertificateCallback> callback_;
+};
+}
+
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc b/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
index 3c7e41cae5cfd..7541ad84b9257 100644
--- a/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_preference_delegate.cc
@@ -144,10 +144,13 @@ void NWebPreferenceDelegate::ComputeBrowserSettings(
   browser_settings.geolocation_enabled = GeolocationAllowed();
   browser_settings.supports_double_tap_zoom = ZoomingfunctionEnabled();
   browser_settings.supports_multi_touch_zoom = ZoomingfunctionEnabled();
+  browser_settings.user_gesture_required = GetMediaPlayGestureAccess();
+  browser_settings.pinch_smooth_mode = GetPinchSmoothMode();
   CefRefPtr<CefCommandLine> command_line =
       CefCommandLine::GetGlobalCommandLine();
   if (command_line->HasSwitch(::switches::kForBrowser)) {
-    bool is_win = (UserAgent().find("Windows NT") >= 0) &&
+    bool is_win =
+        (UserAgent().find("Windows NT") >= 0) &&
         (UserAgent().find("Win64") >= 0 || UserAgent().find("WOW64") >= 0);
     browser_settings.viewport_meta_enabled = !is_win;
   }
@@ -337,6 +340,17 @@ void NWebPreferenceDelegate::PutWebDebuggingAccess(bool flag) {
   browser_->GetHost()->SetWebDebuggingAccess(flag);
 }
 
+void NWebPreferenceDelegate::PutMediaPlayGestureAccess(bool flag) {
+  is_need_gesture_access_ = flag;
+  WebPreferencesChanged();
+}
+
+void NWebPreferenceDelegate::PutPinchSmoothMode(bool flag) {
+  pinch_smooth_mode_ = flag;
+  LOG(ERROR) << "Put Pinch Smooth Mode:" << pinch_smooth_mode_;
+  WebPreferencesChanged();
+}
+
 bool NWebPreferenceDelegate::EnableContentAccess() {
   return content_access_;
 }
@@ -452,7 +466,8 @@ bool NWebPreferenceDelegate::GeolocationAllowed() {
   return geolocation_allowed_;
 }
 
-NWebPreference::AccessMode NWebPreferenceDelegate::AccessModeForSecureOriginLoadFromInsecure() {
+NWebPreference::AccessMode
+NWebPreferenceDelegate::AccessModeForSecureOriginLoadFromInsecure() {
   return access_mode_;
 }
 
@@ -498,4 +513,13 @@ bool NWebPreferenceDelegate::IsWebDebuggingAccess() {
 
   return browser_->GetHost()->GetWebDebuggingAccess();
 }
+
+bool NWebPreferenceDelegate::GetMediaPlayGestureAccess() {
+  return is_need_gesture_access_;
+}
+
+bool NWebPreferenceDelegate::GetPinchSmoothMode() {
+  return pinch_smooth_mode_;
+}
+
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h b/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h
index f3f21f72eb5c6..13bfc975f5804 100644
--- a/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h
+++ b/ohos_nweb/src/cef_delegate/nweb_preference_delegate.h
@@ -63,6 +63,8 @@ class NWebPreferenceDelegate : public NWebPreference {
   void PutBlockNetwork(bool flag) override;
   void PutCacheMode(NWebPreference::CacheModeFlag flag) override;
   void PutWebDebuggingAccess(bool flag) override;
+  void PutMediaPlayGestureAccess(bool flag) override;
+  void PutPinchSmoothMode(bool flag) override;
 
   /* get methods*/
   bool EnableContentAccess() override;
@@ -97,10 +99,12 @@ class NWebPreferenceDelegate : public NWebPreference {
   bool IsNetworkBlocked() override;
   NWebPreference::CacheModeFlag CacheMode() override;
   bool IsWebDebuggingAccess() override;
+  bool GetMediaPlayGestureAccess() override;
 
   bool RunningInsecureContentAllowed();
   bool UseStricMixedContentCheckingAllowed();
   bool MixedContentAutoupgradesAllowed();
+  bool GetPinchSmoothMode() override;
 
   void PutHasInternetPermission(bool flag);
 
@@ -129,6 +133,8 @@ class NWebPreferenceDelegate : public NWebPreference {
   bool universal_access_from_file_urls_{false};
   bool raw_file_access_from_file_urls_{false};
   bool dark_mode_enabled_{false};
+  bool is_need_gesture_access_{true};
+  bool pinch_smooth_mode_{false};
   /* Web preferences end*/
   bool create_windows_by_javascript_allowed_{false};
   std::string user_agent_{""};
diff --git a/ohos_nweb/src/cef_delegate/nweb_render_handler.cc b/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
index ec58add1c1a32..e880a47a4f0e1 100644
--- a/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_render_handler.cc
@@ -20,6 +20,9 @@
 #include <cstring>
 
 #include "base/logging.h"
+#include "nweb_touch_handle_state_impl.h"
+
+#include "ohos_adapter_helper.h"
 
 namespace {
 cef_screen_orientation_type_t ConvertOrientationType(
@@ -103,6 +106,11 @@ void NWebRenderHandler::RegisterRenderCb(
   render_update_cb_ = render_update_cb;
 }
 
+void NWebRenderHandler::RegisterNWebHandler(
+    std::shared_ptr<NWebHandler> handler) {
+  handler_ = std::weak_ptr<NWebHandler>(handler);
+}
+
 void NWebRenderHandler::SetInputMethodClient(
     CefRefPtr<NWebInputMethodClient> client) {
   inputmethod_client_ = client;
@@ -169,6 +177,14 @@ void NWebRenderHandler::OnRootLayerChanged(CefRefPtr<CefBrowser> browser,
   content_width_ = width;
 }
 
+void NWebRenderHandler::OnScrollOffsetChanged(CefRefPtr<CefBrowser> browser,
+                                     double x,
+                                     double y) {
+  if (auto handler = handler_.lock()) {
+    handler->OnScroll(x, y);
+  }
+}
+
 int NWebRenderHandler::ContentHeight() {
   return content_height_;
 }
@@ -191,14 +207,156 @@ void NWebRenderHandler::OnTextSelectionChanged(CefRefPtr<CefBrowser> browser,
 
 void NWebRenderHandler::OnVirtualKeyboardRequested(
     CefRefPtr<CefBrowser> browser,
-    TextInputMode input_mode) {
+    TextInputMode input_mode, bool show_keyboard) {
+  LOG(INFO) << "NWebRenderHandler::OnVirtualKeyboardRequested input_mode = " << input_mode << ", show_keyboard = " << show_keyboard;
+
   if (inputmethod_client_) {
     if (input_mode != CEF_TEXT_INPUT_MODE_NONE) {
-      inputmethod_client_->Attach(browser);
-      inputmethod_client_->ShowTextInput();
+      inputmethod_client_->Attach(browser, show_keyboard);
     } else {
       inputmethod_client_->HideTextInput();
     }
   }
 }
+
+void NWebRenderHandler::GetTouchHandleSize(
+    CefRefPtr<CefBrowser> browser,
+    cef_horizontal_alignment_t orientation,
+    CefSize& size) {
+  // TODO: need to refactor in 3.2.8.1 use arkui refactor.
+  size.width = 20;
+  size.height = 20;
+  if (display_ratio_ <= 0.0) {
+    auto display_manager_adapter = OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
+    if (display_manager_adapter == nullptr) {
+      LOG(ERROR) << "display_manager_adapter is nullptr.";
+      return;
+    }
+    auto display = display_manager_adapter->GetDefaultDisplay();
+    if (display == nullptr) {
+      LOG(ERROR) << "display is nullptr.";
+      return;
+    }
+    float ratio = display->GetVirtualPixelRatio();
+    if (ratio <= 0) {
+      LOG(ERROR) << "invalid ratio, ratio = " << ratio;
+      return;
+    }
+    display_ratio_ = ratio;
+  } else { 
+    if (display_ratio_ > 1 && display_ratio_ < 1.7) {
+      // rk
+      size.width = 15;
+      size.height = 15;
+    } else if (display_ratio_ >= 1.7 && display_ratio_ < 2.5) {
+      // wgr
+      size.width = 20;
+      size.height = 20;
+    } else {
+      // wgr
+      size.width = 30;
+      size.height = 30;
+    }
+  }
+}
+
+std::shared_ptr<NWebTouchHandleState> NWebRenderHandler::GetTouchHandleState(
+    NWebTouchHandleState::TouchHandleType type) {
+  switch (type) {
+    case NWebTouchHandleState::TouchHandleType::INSERT_HANDLE:
+      return insert_handle_.enabled ?
+        std::make_shared<NWebTouchHandleStateImpl>(insert_handle_) : nullptr;
+    case NWebTouchHandleState::TouchHandleType::SELECTION_BEGIN_HANDLE:
+      return start_selection_handle_.enabled ?
+        std::make_shared<NWebTouchHandleStateImpl>(start_selection_handle_) : nullptr;
+    case NWebTouchHandleState::TouchHandleType::SELECTION_END_HANDLE:
+      return end_selection_handle_.enabled ?
+        std::make_shared<NWebTouchHandleStateImpl>(end_selection_handle_) : nullptr;
+    default:
+      return nullptr;
+  }
+  return nullptr;
+}
+
+void NWebRenderHandler::OnTouchSelectionChanged(
+    const CefTouchHandleState& insert_handle,
+    const CefTouchHandleState& start_selection_handle,
+    const CefTouchHandleState& end_selection_handle,
+    bool need_report) {
+  insert_handle_ = insert_handle;
+  start_selection_handle_ = start_selection_handle;
+  end_selection_handle_ = end_selection_handle;
+  if (!need_report) {
+    return;
+  }
+  if (auto handler = handler_.lock()) {
+    handler->OnTouchSelectionChanged(
+      std::make_shared<NWebTouchHandleStateImpl>(insert_handle_),
+      std::make_shared<NWebTouchHandleStateImpl>(start_selection_handle_),
+      std::make_shared<NWebTouchHandleStateImpl>(end_selection_handle_));
+  }
+}
+
+bool NWebRenderHandler::StartDragging(CefRefPtr<CefBrowser> browser,
+                                      CefRefPtr<CefDragData> drag_data,
+                                      DragOperationsMask allowed_ops,
+                                      int x,
+                                      int y) {
+  LOG(INFO) << "received start dragging callback, operation = " << allowed_ops << ", x = " << x << ", y = " << y;
+  if (!drag_data && !drag_data->HasImage()) {
+    LOG(ERROR) << "drag data invalid";
+    return false;
+  }
+
+  auto image = drag_data->GetImage();
+  if (!image) {
+    LOG(ERROR) << "drag data image invalid";
+    return false;
+  }
+
+  int width;
+  int height;
+  auto bitmap = image->GetAsBitmap(1, CEF_COLOR_TYPE_BGRA_8888, CEF_ALPHA_TYPE_OPAQUE, width, height);
+  if (!bitmap) {
+    LOG(ERROR) << "drag data bitmap invalid";
+    return false;
+  }
+
+  size_t data_size = bitmap->GetSize();
+  void* buffer = calloc(1, data_size);
+  if (!buffer) {
+    LOG(ERROR) << "calloc failed";
+    return false;
+  }
+  size_t read_size = bitmap->GetData(buffer, data_size, 0);
+  if (read_size != data_size) {
+    free(buffer);
+    LOG(ERROR) << "get data from bitmap failed";
+    return false;
+  }
+
+  LOG(INFO) << "drag image width : " << width << ", height : " << height<<  ", buffer size : " << read_size;
+  auto handler = handler_.lock();
+  if (handler == nullptr) {
+    LOG(ERROR) << "can't get strong ptr with handler";
+    free(buffer);
+    return false;
+  }
+
+  ImageOptions opt;
+  opt.colorType = ImageColorType::COLOR_TYPE_BGRA_8888;
+  opt.alphaType = ImageAlphaType::ALPHA_TYPE_OPAQUE;
+  opt.width = width;
+  opt.height = height;
+  bool isNeedDrag = handler->OnDragAndDropData(buffer, read_size, opt);
+  if (isNeedDrag) {
+    drag_data_ = drag_data;
+  }
+  free(buffer);
+  return isNeedDrag;
+}
+
+CefRefPtr<CefDragData> NWebRenderHandler::GetDragData() {
+  return drag_data_;
+}
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_render_handler.h b/ohos_nweb/src/cef_delegate/nweb_render_handler.h
index fd6c3eb8c82d8..a9d13ffd09996 100644
--- a/ohos_nweb/src/cef_delegate/nweb_render_handler.h
+++ b/ohos_nweb/src/cef_delegate/nweb_render_handler.h
@@ -18,9 +18,12 @@
 
 #include <functional>
 #include <memory>
+#include <vector>
 #include "cef/include/cef_render_handler.h"
 #include "display_manager_adapter.h"
 #include "nweb_inputmethod_client.h"
+#include "nweb_handler.h"
+#include "nweb_touch_handle_state_impl.h"
 
 namespace OHOS::NWeb {
 class NWebRenderHandler : public CefRenderHandler {
@@ -30,6 +33,7 @@ class NWebRenderHandler : public CefRenderHandler {
   ~NWebRenderHandler() = default;
 
   void RegisterRenderCb(std::function<void(const char*)> render_update_cb);
+  void RegisterNWebHandler(std::shared_ptr<NWebHandler> handler);
   void Resize(uint32_t width, uint32_t height);
   void SetOrientation(RotationType rotation, OrientationType orientation);
   int ContentHeight();
@@ -46,10 +50,15 @@ class NWebRenderHandler : public CefRenderHandler {
                        const void* buffer,
                        int width,
                        int height) override;
+                       
   void OnRootLayerChanged(CefRefPtr<CefBrowser> browser,
                           int height,
                           int width) override;
 
+  void OnScrollOffsetChanged(CefRefPtr<CefBrowser> browser,
+                                     double x,
+                                     double y) override;
+
   virtual void OnImeCompositionRangeChanged(
       CefRefPtr<CefBrowser> browser,
       const CefRange& selected_range,
@@ -60,9 +69,28 @@ class NWebRenderHandler : public CefRenderHandler {
                                       const CefRange& selected_range) override;
 
   virtual void OnVirtualKeyboardRequested(CefRefPtr<CefBrowser> browser,
-                                          TextInputMode input_mode) override;
+                                          TextInputMode input_mode, bool show_keyboard) override;
+
+  void GetTouchHandleSize(CefRefPtr<CefBrowser> browser,
+                          cef_horizontal_alignment_t orientation,
+                          CefSize& size) override;
+  void OnTouchSelectionChanged(const CefTouchHandleState& insert_handle,
+                               const CefTouchHandleState& start_selection_handle,
+                               const CefTouchHandleState& end_selection_handle,
+                               bool need_report) override;
+
+  bool StartDragging(CefRefPtr<CefBrowser> browser,
+                     CefRefPtr<CefDragData> drag_data,
+                     DragOperationsMask allowed_ops,
+                     int x,
+                     int y) override;
   /* CefRenderHandler method end */
 
+  std::shared_ptr<NWebTouchHandleState> GetTouchHandleState(
+      NWebTouchHandleState::TouchHandleType type);
+
+  CefRefPtr<CefDragData> GetDragData();
+
   // Include the default reference counting implementation.
   IMPLEMENT_REFCOUNTING(NWebRenderHandler);
 
@@ -75,6 +103,13 @@ class NWebRenderHandler : public CefRenderHandler {
   OrientationType orientation_ = OrientationType::UNSPECIFIED;
   int content_height_ = 0;
   int content_width_ = 0;
+  double display_ratio_ = -1.0;
+
+  std::weak_ptr<NWebHandler> handler_;
+  CefTouchHandleState insert_handle_;
+  CefTouchHandleState start_selection_handle_;
+  CefTouchHandleState end_selection_handle_;
+  CefRefPtr<CefDragData> drag_data_ = nullptr;
 };
 }
 
diff --git a/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc b/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc
index adbd62a1fc5e9..815c50ec8a2e3 100644
--- a/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc
+++ b/ohos_nweb/src/cef_delegate/nweb_resource_handler.cc
@@ -17,6 +17,26 @@
 #include "base/logging.h"
 
 namespace OHOS::NWeb {
+
+class NWebResourceReadyCallbackImpl : public NWebResourceReadyCallback {
+public:
+    NWebResourceReadyCallbackImpl(CefRefPtr<CefCallback> callback) : callback_(callback) {}
+    ~NWebResourceReadyCallbackImpl() = default;
+    void Continue() override
+    {
+        LOG(INFO) << "intecept NWebResourceReadyCallbackImpl::Continue";
+        callback_->Continue();
+    }
+  
+    void Cancel() override
+    {
+        LOG(INFO) << "intecept NWebResourceReadyCallbackImpl::Cancel";
+        callback_->Cancel();
+    }
+private:
+    CefRefPtr<CefCallback> callback_;
+};
+
 void ConvertMapToHeaderMap(
     CefRequest::HeaderMap& headers,
     const std::map<std::string, std::string> response_map) {
@@ -39,23 +59,30 @@ NWebResourceHandler::NWebResourceHandler(
 bool NWebResourceHandler::Open(CefRefPtr<CefRequest> request,
                                bool& handle_request,
                                CefRefPtr<CefCallback> callback) {
-  LOG(INFO) << "NWebResourceHandler::Open";
-  handle_request = true;
-
-  if (response_) {
-    data_ = response_->ResponseData();
+  LOG(INFO) << "intercept NWebResourceHandler::Open";
+  if (response_ == nullptr) {
+    return false;
   }
+  if (response_->ResponseDataStatus()) {
+    LOG(INFO) << "intercept open reponse sync";
+    handle_request = true;
+    data_ = response_->ResponseData();
+    return true;
+  } 
+  LOG(INFO) << "intercept open async";
+  handle_request = false;
+  std::shared_ptr<NWebResourceReadyCallbackImpl> nwebCb = std::make_shared<NWebResourceReadyCallbackImpl>(callback);
+  response_->PutResponseReadyCallback(nwebCb);
   return true;
 }
 
-bool NWebResourceHandler::Read(void* data_out,
-                               int bytes_to_read,
-                               int& bytes_read,
-                               CefRefPtr<CefResourceReadCallback> callback) {
-  LOG(INFO) << "NWebResourceHandler::Read";
+bool NWebResourceHandler::ReadStringData(void* data_out, int bytes_to_read, int& bytes_read)
+{
+  LOG(INFO) << "intercept ReadStringData";
   bool has_data = false;
   bytes_read = 0;
 
+  data_ = response_->ResponseData();
   if (offset_ < data_.length()) {
     // Copy the next block of data into the buffer.
     int transfer_size =
@@ -70,6 +97,48 @@ bool NWebResourceHandler::Read(void* data_out,
   return has_data;
 }
 
+bool NWebResourceHandler::ReadFileData(void* data_out, int bytes_to_read, int& bytes_read)
+{
+  LOG(INFO) << "intercept ReadFileData";
+  int fd = response_->ResponseFileHandle();
+  if (fd <= 0) {
+    bytes_read = fd;
+    return false;
+  }
+  int ret = read(fd, data_out, bytes_to_read);
+  // read fail
+  if (ret < 0) {
+    LOG(ERROR) << "intercept read fail : " << ret;
+    bytes_read = ret;
+    return false;
+  }
+  // completed read
+  if (ret == 0) {
+    LOG(INFO) << "intercept ReadFileData completed";
+    bytes_read = 0;
+    return false;
+  }
+  LOG(INFO) << "intercept contiunue to read:" << ret;
+  bytes_read = ret;
+  return true;
+}
+
+bool NWebResourceHandler::Read(void* data_out,
+                               int bytes_to_read,
+                               int& bytes_read,
+                               CefRefPtr<CefResourceReadCallback> callback) {
+  if (response_ == nullptr) {
+    bytes_read = -1;
+    return false;
+  }
+
+  if (response_->ResponseIsFileHandle()) {
+    return ReadFileData(data_out, bytes_to_read, bytes_read);
+  } else {
+    return ReadStringData(data_out, bytes_to_read, bytes_read);
+  }
+}
+
 void NWebResourceHandler::GetResponseHeaders(CefRefPtr<CefResponse> response,
                                              int64& response_length,
                                              CefString& redirectUrl) {
@@ -85,10 +154,23 @@ void NWebResourceHandler::GetResponseHeaders(CefRefPtr<CefResponse> response,
     ConvertMapToHeaderMap(cef_request_headers, request_headers);
     response->SetHeaderMap(cef_request_headers);
   }
-
-  response_length = data_.length();
+  if (response_->ResponseIsFileHandle()) {
+    response_length = -1;
+  } else {
+    response_length = data_.length();
+  }
 }
 
-void NWebResourceHandler::Cancel() {}
+void NWebResourceHandler::Cancel() {
+  LOG(INFO) << "intercept NWebResourceHandler::Cancel";
+  if (response_ == nullptr) {
+    return;
+  }
+  int fd = response_->ResponseFileHandle();
+  if (fd <= 0) {
+    return;
+  }
+  close(fd);
+}
 /* CefResourceHandler method end */
 }  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/cef_delegate/nweb_resource_handler.h b/ohos_nweb/src/cef_delegate/nweb_resource_handler.h
index e423190bd4c8d..c6048a67224d6 100644
--- a/ohos_nweb/src/cef_delegate/nweb_resource_handler.h
+++ b/ohos_nweb/src/cef_delegate/nweb_resource_handler.h
@@ -50,6 +50,12 @@ class NWebResourceHandler : public CefResourceHandler {
   IMPLEMENT_REFCOUNTING(NWebResourceHandler);
 
  private:
+  bool ReadStringData(void* data_out,
+            int bytes_to_read,
+            int& bytes_read);
+  bool ReadFileData(void* data_out,
+            int bytes_to_read,
+            int& bytes_read);
   std::string data_;
   size_t offset_ = 0;
   std::shared_ptr<NWebUrlResourceResponse> response_;
diff --git a/ohos_nweb/src/cef_delegate/nweb_touch_handle_state_impl.cc b/ohos_nweb/src/cef_delegate/nweb_touch_handle_state_impl.cc
new file mode 100644
index 0000000000000..e5289f8718777
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_touch_handle_state_impl.cc
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nweb_touch_handle_state_impl.h"
+
+namespace OHOS::NWeb {
+NWebTouchHandleStateImpl::NWebTouchHandleStateImpl(const CefTouchHandleState& state)
+  : state_(state) {}
+
+int32_t NWebTouchHandleStateImpl::GetTouchHandleId() const {
+  return state_.touch_handle_id;
+}
+
+int32_t NWebTouchHandleStateImpl::GetX() const {
+  return state_.origin.x;
+}
+
+int32_t NWebTouchHandleStateImpl::GetY() const {
+  return state_.origin.y;
+}
+
+NWebTouchHandleState::TouchHandleType
+NWebTouchHandleStateImpl::GetTouchHandleType() const {
+  switch (state_.orientation) {
+    case CEF_HORIZONTAL_ALIGNMENT_CENTER:
+      return INSERT_HANDLE;
+    case CEF_HORIZONTAL_ALIGNMENT_LEFT:
+      return SELECTION_BEGIN_HANDLE;
+    case CEF_HORIZONTAL_ALIGNMENT_RIGHT:
+      return SELECTION_END_HANDLE;
+    default:
+      return INVALID_HANDLE;
+  }
+}
+
+bool NWebTouchHandleStateImpl::IsEnable() const {
+  return state_.enabled;
+}
+
+float NWebTouchHandleStateImpl::GetAlpha() const {
+  return state_.alpha;
+}
+
+float NWebTouchHandleStateImpl::GetEdgeHeight() const {
+  return state_.edge_height;
+}
+}
\ No newline at end of file
diff --git a/ohos_nweb/src/cef_delegate/nweb_touch_handle_state_impl.h b/ohos_nweb/src/cef_delegate/nweb_touch_handle_state_impl.h
new file mode 100644
index 0000000000000..ec8812dd2c3a6
--- /dev/null
+++ b/ohos_nweb/src/cef_delegate/nweb_touch_handle_state_impl.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NWEB_TOUCH_HANDLE_STATE_IMPL_H
+#define NWEB_TOUCH_HANDLE_STATE_IMPL_H
+
+#include "nweb_touch_handle_state.h"
+#include "cef/include/cef_render_handler.h"
+
+namespace OHOS::NWeb {
+class NWebTouchHandleStateImpl : public NWebTouchHandleState {
+ public:
+  explicit NWebTouchHandleStateImpl(const CefTouchHandleState& state);
+  int32_t GetTouchHandleId() const override;
+  int32_t GetX() const override;
+  int32_t GetY() const override;
+  TouchHandleType GetTouchHandleType() const override;
+  bool IsEnable() const override;
+  float GetAlpha() const override;
+  float GetEdgeHeight() const override;
+ private:
+  CefTouchHandleState state_;
+};
+}
+#endif
\ No newline at end of file
diff --git a/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h b/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h
index 5364766d8801d..78c74c4794464 100644
--- a/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h
+++ b/ohos_nweb/src/nweb_cookie_manager_delegate_interface.h
@@ -26,6 +26,8 @@ class NWebCookieManagerDelegateInterface {
   virtual ~NWebCookieManagerDelegateInterface() = default;
   virtual bool IsAcceptCookieAllowed() = 0;
   virtual void PutAcceptCookieEnabled(bool accept) = 0;
+  virtual bool IsThirdPartyCookieAllowed() = 0;
+  virtual void PutAcceptThirdPartyCookieEnabled(bool accept) = 0;
   virtual bool IsFileURLSchemeCookiesAllowed() = 0;
   virtual void PutAcceptFileURLSchemeCookiesEnabled(bool allow) = 0;
   virtual void ReturnCookie(
@@ -39,6 +41,7 @@ class NWebCookieManagerDelegateInterface {
                          const std::string &value) = 0;
   virtual void ExistCookies(
       std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
+  virtual bool ExistCookies() = 0;
   virtual void Store(std::shared_ptr<NWebValueCallback<bool>> callback) = 0;
   virtual bool Store() = 0;
   virtual void DeleteSessionCookies(
diff --git a/ohos_nweb/src/nweb_cookie_manager_impl.cc b/ohos_nweb/src/nweb_cookie_manager_impl.cc
index 64c0a0415805d..3df99a43d29a0 100644
--- a/ohos_nweb/src/nweb_cookie_manager_impl.cc
+++ b/ohos_nweb/src/nweb_cookie_manager_impl.cc
@@ -21,11 +21,16 @@ using namespace OHOS::NWeb;
 
 extern "C" OHOS_NWEB_EXPORT NWebCookieManager* GetCookieManager() {
   WVLOG_I("GetCookieManager");
+  return NWebCookieManagerImpl::GetCookieManagerInstance();
+}
+
+namespace OHOS::NWeb {
+
+NWebCookieManager* NWebCookieManagerImpl::GetCookieManagerInstance() {
   static NWebCookieManagerImpl cookie_manager;
   return &cookie_manager;
 }
 
-namespace OHOS::NWeb {
 NWebCookieManagerImpl::NWebCookieManagerImpl() {
 #if defined(USE_CEF)
   delegate_ = std::make_shared<NWebCookieManagerDelegate>();
@@ -45,6 +50,19 @@ void NWebCookieManagerImpl::PutAcceptCookieEnabled(bool accept) {
   }
 }
 
+bool NWebCookieManagerImpl::IsThirdPartyCookieAllowed() const {
+  if (delegate_ != nullptr) {
+    return delegate_->IsThirdPartyCookieAllowed();
+  }
+  return false;
+}
+
+void NWebCookieManagerImpl::PutAcceptThirdPartyCookieEnabled(bool accept) {
+  if (delegate_ != nullptr) {
+    delegate_->PutAcceptThirdPartyCookieEnabled(accept);
+  }
+}
+
 bool NWebCookieManagerImpl::IsFileURLSchemeCookiesAllowed() const {
   if (delegate_ != nullptr) {
     return delegate_->IsFileURLSchemeCookiesAllowed();
@@ -99,6 +117,13 @@ void NWebCookieManagerImpl::ExistCookies(
   }
 }
 
+bool NWebCookieManagerImpl::ExistCookies() {
+  if (delegate_ != nullptr) {
+    return delegate_->ExistCookies();
+  }
+  return false;
+}
+
 void NWebCookieManagerImpl::Store(
     std::shared_ptr<NWebValueCallback<bool>> callback) {
   if (delegate_ != nullptr) {
diff --git a/ohos_nweb/src/nweb_cookie_manager_impl.h b/ohos_nweb/src/nweb_cookie_manager_impl.h
index baa468006d54b..ae32d2dbb0927 100644
--- a/ohos_nweb/src/nweb_cookie_manager_impl.h
+++ b/ohos_nweb/src/nweb_cookie_manager_impl.h
@@ -25,8 +25,11 @@ class NWebCookieManagerImpl : public NWebCookieManager {
   NWebCookieManagerImpl();
   ~NWebCookieManagerImpl() = default;
 
+  static NWebCookieManager* GetCookieManagerInstance();
   bool IsAcceptCookieAllowed() const override;
   void PutAcceptCookieEnabled(bool accept) override;
+  bool IsThirdPartyCookieAllowed() const override;
+  void PutAcceptThirdPartyCookieEnabled(bool accept) override;
   bool IsFileURLSchemeCookiesAllowed() const override;
   void PutAcceptFileURLSchemeCookiesEnabled(bool allow) override;
   void ReturnCookie(
@@ -39,6 +42,7 @@ class NWebCookieManagerImpl : public NWebCookieManager {
   bool SetCookie(const std::string &url,
                  const std::string &value) override;
   void ExistCookies(std::shared_ptr<NWebValueCallback<bool>> callback) override;
+  bool ExistCookies() override;
   void Store(std::shared_ptr<NWebValueCallback<bool>> callback) override;
   bool Store() override;
   void DeleteSessionCookies(
diff --git a/ohos_nweb/src/nweb_data_base_impl.cc b/ohos_nweb/src/nweb_data_base_impl.cc
index b7f27bf58c663..464f3116a6102 100644
--- a/ohos_nweb/src/nweb_data_base_impl.cc
+++ b/ohos_nweb/src/nweb_data_base_impl.cc
@@ -60,6 +60,51 @@ std::vector<std::string> NWebDataBaseImpl::GetHttpAuthCredentials(const std::str
   return {};
 }
 
+bool NWebDataBaseImpl::ExistPermissionByOrigin(const std::string& origin, int type)
+{
+  if (delegate_ != nullptr) {
+    return delegate_->ExistPermissionByOrigin(origin, type);
+  }
+  return false;
+}
+
+bool NWebDataBaseImpl::GetPermissionResultByOrigin(const std::string& origin, int type, bool& result)
+{
+  if (delegate_ != nullptr) {
+    return delegate_->GetPermissionResultByOrigin(origin, type, result);
+  }
+  return false;
+}
+
+void NWebDataBaseImpl::SetPermissionByOrigin(const std::string& origin, int type, bool result)
+{
+  if (delegate_ != nullptr) {
+    delegate_->SetPermissionByOrigin(origin, type, result);
+  }
+}
+
+void NWebDataBaseImpl::ClearPermissionByOrigin(const std::string& origin, int type)
+{
+  if (delegate_ != nullptr) {
+    delegate_->ClearPermissionByOrigin(origin, type);
+  }
+}
+
+void NWebDataBaseImpl::ClearAllPermission(int type)
+{
+  if (delegate_ != nullptr) {
+    delegate_->ClearAllPermission(type);
+  }
+}
+
+std::vector<std::string> NWebDataBaseImpl::GetOriginsByPermission(int type)
+{
+  if (delegate_ != nullptr) {
+    return delegate_->GetOriginsByPermission(type);
+  }
+  return {};
+}
+
 bool NWebDataBaseImpl::ExistFormData() const {
   if (delegate_ != nullptr) {
     return delegate_->ExistFormData();
@@ -74,4 +119,4 @@ void NWebDataBaseImpl::ClearFormData() {
   return;
 }
 
-}  // namespace OHOS::NWeb
\ No newline at end of file
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/nweb_data_base_impl.h b/ohos_nweb/src/nweb_data_base_impl.h
index 767193c56f337..5a3c774677277 100644
--- a/ohos_nweb/src/nweb_data_base_impl.h
+++ b/ohos_nweb/src/nweb_data_base_impl.h
@@ -37,6 +37,18 @@ class NWebDataBaseImpl : public NWebDataBase {
   std::vector<std::string> GetHttpAuthCredentials(const std::string& host,
     const std::string& realm) const override;
 
+  bool ExistPermissionByOrigin(const std::string& origin, int type) override;
+
+  bool GetPermissionResultByOrigin(const std::string& origin, int type, bool& result) override;
+
+  void SetPermissionByOrigin(const std::string& origin, int type, bool result) override;
+
+  void ClearPermissionByOrigin(const std::string& origin, int type) override;
+
+  void ClearAllPermission(int type) override;
+
+  std::vector<std::string> GetOriginsByPermission(int type) override;
+
   bool ExistFormData() const;
 
   void ClearFormData();
@@ -46,4 +58,4 @@ class NWebDataBaseImpl : public NWebDataBase {
 };
 
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/ohos_nweb/src/nweb_delegate_interface.h b/ohos_nweb/src/nweb_delegate_interface.h
index e5aa0065917a4..74abf0825209e 100755
--- a/ohos_nweb/src/nweb_delegate_interface.h
+++ b/ohos_nweb/src/nweb_delegate_interface.h
@@ -21,10 +21,27 @@
 #include "cef_delegate/nweb_inputmethod_client.h"
 #include "display_manager_adapter.h"
 #include "nweb_download_callback.h"
-#include "nweb_preference.h"
+#include "nweb_find_callback.h"
 #include "nweb_handler.h"
+#include "nweb_preference.h"
 
 namespace OHOS::NWeb {
+enum class DelegateDragAction {
+  DRAG_START = 0,
+  DRAG_ENTER,
+  DRAG_LEAVE,
+  DRAG_OVER,
+  DRAG_DROP,
+  DRAG_END,
+  DRAG_CANCEL,
+};
+
+struct DelegateDragEvent {
+  double x;
+  double y;
+  DelegateDragAction action;
+};
+
 class NWebDelegateInterface
   : public std::enable_shared_from_this<NWebDelegateInterface>{
  public:
@@ -48,7 +65,7 @@ class NWebDelegateInterface
   virtual void OnTouchCancel() = 0;
   virtual bool SendKeyEvent(int32_t keyCode, int32_t keyAction) = 0;
   virtual void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) = 0;
-  virtual void SendMouseEvent(int x, int y, int button, int action) = 0;
+  virtual void SendMouseEvent(int x, int y, int button, int action, int count) = 0;
   virtual void NotifyScreenInfoChanged(RotationType rotation,
                                        OrientationType orientation) = 0;
 
@@ -60,6 +77,8 @@ class NWebDelegateInterface
   virtual void NavigateForward() const = 0;
   virtual void NavigateBackOrForward(int32_t step) const = 0;
   virtual void DeleteNavigateHistory() = 0;
+  virtual void ClearSslCache() = 0;
+  virtual void ClearClientAuthenticationCache() = 0;
   virtual void Reload() const = 0;
   virtual void ReloadOriginalUrl() const = 0;
   virtual void Zoom(float zoomFactor) const = 0;
@@ -76,6 +95,12 @@ class NWebDelegateInterface
   virtual void OnContinue() = 0;
   virtual std::shared_ptr<NWebPreference> GetPreference() const = 0;
   virtual std::string Title() = 0;
+  virtual void CreateWebMessagePorts(std::vector<std::string>& ports) = 0;
+  virtual void PostWebMessage(std::string& message, std::vector<std::string>& ports, std::string& targetUri) = 0;
+  virtual void ClosePort(std::string& portHandle) = 0;
+  virtual void PostPortMessage(std::string& portHandle, std::string& data) = 0;
+  virtual void SetPortMessageCallback(std::string& portHandle,
+      std::shared_ptr<NWebValueCallback<std::string>> callback) = 0;
   virtual HitTestResult GetHitTestResult() const = 0;
   virtual int PageLoadProgress() = 0;
   virtual float Scale() = 0;
@@ -101,6 +126,25 @@ class NWebDelegateInterface
       std::shared_ptr<NWebJavaScriptResultCallBack> callback) = 0;
   virtual void OnFocus() const = 0;
   virtual void OnBlur() const = 0;
+  virtual void RegisterFindListener(
+      std::shared_ptr<NWebFindCallback> find_listener) = 0;
+  virtual void FindAllAsync(const std::string& str) const = 0;
+  virtual void ClearMatches() const = 0;
+  virtual void FindNext(const bool forward) const = 0;
+
+#if defined(REPORT_SYS_EVENT)
+  virtual void SetNWebId(uint32_t nwebId) = 0;
+#endif
+
+  virtual void StoreWebArchive(
+      const std::string& base_name,
+      bool auto_name,
+      std::shared_ptr<NWebValueCallback<std::string>> callback) const = 0;
+
+  virtual void SetBrowserUserAgentString(const std::string& user_agent) = 0;
+
+  virtual void SendDragEvent(const DelegateDragEvent& dragEvent) const  = 0;
+  virtual std::string GetUrl() const = 0;
 };
 }  // namespace OHOS::NWeb
 
diff --git a/ohos_nweb/src/nweb_hilog.h b/ohos_nweb/src/nweb_hilog.h
index 467fc56643c9f..dd8be9d866826 100644
--- a/ohos_nweb/src/nweb_hilog.h
+++ b/ohos_nweb/src/nweb_hilog.h
@@ -18,7 +18,7 @@
 
 #if defined(OHOS_NWEB)
 #include "hilog/log.h"
-constexpr OHOS::HiviewDFX::HiLogLabel kLogLabel = {LOG_APP, 0, "NWEB"};
+constexpr OHOS::HiviewDFX::HiLogLabel kLogLabel = {LOG_CORE, 0xD004500, "NWEB"};
 
 #define FUNC_LINE_FMT " %{public}s<%{public}d>: "
 
diff --git a/ohos_nweb/src/nweb_impl.cc b/ohos_nweb/src/nweb_impl.cc
index ee7dc97585dad..ba79af1070035 100755
--- a/ohos_nweb/src/nweb_impl.cc
+++ b/ohos_nweb/src/nweb_impl.cc
@@ -23,11 +23,16 @@
 #include <thread>
 
 #include "base/lazy_instance.h"
+#include "base/trace_event/common/trace_event_common.h"
 #include "nweb_delegate_adapter.h"
 #include "nweb_export.h"
 #include "nweb_handler.h"
 #include "nweb_hilog.h"
 
+#if defined(REPORT_SYS_EVENT)
+#include "event_reporter.h"
+#endif
+
 namespace {
 uint32_t g_nweb_count = 0;
 const uint32_t kSurfaceMaxWidth = 7680;
@@ -35,6 +40,11 @@ const uint32_t kSurfaceMaxHeight = 7680;
 
 // For NWebEx
 bool g_browser_service_api_enabled = false;
+
+#if defined(REPORT_SYS_EVENT)
+  // For maximum count of nweb instance
+  uint32_t g_nweb_max_count = 0;
+#endif
 }
 
 using namespace OHOS::NWeb;
@@ -42,6 +52,7 @@ extern "C" OHOS_NWEB_EXPORT NWeb* CreateNWeb(
     const NWebCreateInfo& create_info) {
   static uint32_t current_nweb_id = 0;
   uint32_t nweb_id = ++current_nweb_id;
+  TRACE_EVENT1("NWebImpl", "NWebImpl | CreateNWeb", "nweb_id", nweb_id);
   WVLOG_I("creating nweb %{public}u, size %{public}u*%{public}u", nweb_id,
           create_info.width, create_info.height);
   auto nweb = new NWebImpl(nweb_id);
@@ -52,10 +63,18 @@ extern "C" OHOS_NWEB_EXPORT NWeb* CreateNWeb(
 
   if (!nweb->Init(create_info)) {
     WVLOG_E("fail to init nweb");
+    delete nweb;
     return nullptr;
   }
 
   ++g_nweb_count;
+#if defined(REPORT_SYS_EVENT)
+  // Report nweb instance count
+  if (g_nweb_count > g_nweb_max_count) {
+    g_nweb_max_count = g_nweb_count;
+  }
+  ReportMultiInstanceStats(nweb_id, g_nweb_count, g_nweb_max_count);
+#endif
   return nweb;
 }
 
@@ -96,6 +115,7 @@ NWebImpl::~NWebImpl() {
   g_nweb_map.Get().erase(nweb_id_);
 }
 
+
 bool NWebImpl::Init(const NWebCreateInfo& create_info) {
   output_handler_ = NWebOutputHandler::Create(
       create_info.width, create_info.height, create_info.output_render_frame);
@@ -124,15 +144,22 @@ void NWebImpl::OnDestroy() {
   if (g_nweb_count == 0) {
     return;
   }
+  TRACE_EVENT1("NWebImpl", "NWebImpl | DestoryNWeb", "nweb_id", nweb_id_);
   bool is_close_all = (--g_nweb_count) == 0 ? true : false;
   if (nweb_delegate_ != nullptr) {
     nweb_delegate_->OnDestroy(is_close_all);
     nweb_delegate_ = nullptr;
   }
+
   if (input_handler_ != nullptr) {
     input_handler_->OnDestroy();
     input_handler_ = nullptr;
   }
+
+#if defined(REPORT_SYS_EVENT)
+  // Report nweb instance count
+  ReportMultiInstanceStats(nweb_id_, g_nweb_count, g_nweb_max_count);
+#endif
 }
 
 void NWebImpl::ProcessInitArgs(const NWebInitArgs& init_args) {
@@ -168,11 +195,13 @@ bool NWebImpl::InitWebEngine(const NWebCreateInfo& create_info) {
           create_info.producer_surface));
   if (window == nullptr) {
     WVLOG_E("fail to init web engine, get native window from surface failed");
+    delete[] argv;
     return false;
   }
   nweb_delegate_ = NWebDelegateAdapter::CreateNWebDelegate(argc, argv, window);
   if (nweb_delegate_ == nullptr) {
     WVLOG_E("fail to create nweb delegate of web engine");
+    delete[] argv;
     return false;
   }
 
@@ -191,6 +220,10 @@ bool NWebImpl::InitWebEngine(const NWebCreateInfo& create_info) {
   inputmethod_handler_ = new NWebInputMethodHandler();
   nweb_delegate_->SetInputMethodClient(inputmethod_handler_);
 
+#if defined(REPORT_SYS_EVENT)
+  nweb_delegate_->SetNWebId(nweb_id_);
+#endif
+
   delete[] argv;
   return nweb_delegate_->IsReady();
 }
@@ -208,14 +241,17 @@ void NWebImpl::InitWebEngineArgs(const NWebInitArgs& init_args) {
   web_engine_args_.emplace_back("--disable-dev-shm-usage");
 #ifdef GPU_RK3568
   web_engine_args_.emplace_back("--disable-gpu");
+#endif
+#ifdef RK3568
+  web_engine_args_.emplace_back("--off-screen-frame-rate=70");
+#else
+  web_engine_args_.emplace_back("--off-screen-frame-rate=65");
 #endif
   web_engine_args_.emplace_back("--no-unsandboxed-zygote");
   web_engine_args_.emplace_back("--no-zygote");
-  web_engine_args_.emplace_back("--off-screen-frame-rate=60");
   web_engine_args_.emplace_back("--enable-features=UseOzonePlatform");
   web_engine_args_.emplace_back("-ozone-platform=headless");
   web_engine_args_.emplace_back("--no-sandbox");
-  web_engine_args_.emplace_back("--ignore-certificate-errors");
   web_engine_args_.emplace_back("--use-mobile-user-agent");
   web_engine_args_.emplace_back("--enable-gpu-rasterization");
   web_engine_args_.emplace_back("--enable-viewport");
@@ -223,6 +259,7 @@ void NWebImpl::InitWebEngineArgs(const NWebInitArgs& init_args) {
       "--browser-subprocess-path=/system/bin/web_render");
   web_engine_args_.emplace_back("--zygote-cmd-prefix=/system/bin/web_render");
   web_engine_args_.emplace_back("--remote-debugging-port=9222");
+  web_engine_args_.emplace_back("--enable-touch-drag-drop");
 
   for (auto arg : init_args.web_engine_args_to_delete) {
     auto it = std::find(web_engine_args_.begin(), web_engine_args_.end(), arg);
@@ -268,6 +305,7 @@ void NWebImpl::OnTouchPress(int32_t id, double x, double y) {
   if (input_handler_ == nullptr) {
     return;
   }
+
   input_handler_->OnTouchPress(id, x, y);
 }
 
@@ -275,6 +313,7 @@ void NWebImpl::OnTouchRelease(int32_t id, double x, double y) {
   if (input_handler_ == nullptr) {
     return;
   }
+
   input_handler_->OnTouchRelease(id, x, y);
 }
 
@@ -282,6 +321,7 @@ void NWebImpl::OnTouchMove(int32_t id, double x, double y) {
   if (input_handler_ == nullptr) {
     return;
   }
+
   input_handler_->OnTouchMove(id, x, y);
 }
 
@@ -313,11 +353,11 @@ void NWebImpl::SendMouseWheelEvent(double x, double y, double deltaX, double del
   input_handler_->SendMouseWheelEvent(x, y, deltaX, deltaY);
 }
 
-void NWebImpl::SendMouseEvent(int x, int y, int button, int action) {
+void NWebImpl::SendMouseEvent(int x, int y, int button, int action, int count) {
   if (input_handler_ == nullptr) {
     return;
   }
-  input_handler_->SendMouseEvent(x, y, button, action);
+  input_handler_->SendMouseEvent(x, y, button, action, count);
 }
 
 void NWebImpl::Load(const std::string& url) const {
@@ -383,6 +423,22 @@ void NWebImpl::DeleteNavigateHistory() {
   nweb_delegate_->DeleteNavigateHistory();
 }
 
+void NWebImpl::ClearSslCache() {
+  WVLOG_I("NWebImpl::ClearSslCache");
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->ClearSslCache();
+}
+
+void NWebImpl::ClearClientAuthenticationCache() {
+  WVLOG_I("NWebImpl::ClearClientAuthenticationCache");
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->ClearClientAuthenticationCache();
+}
+
 void NWebImpl::Reload() const {
   if (nweb_delegate_ == nullptr) {
     return;
@@ -471,6 +527,48 @@ std::string NWebImpl::Title() {
   return nweb_delegate_->Title();
 }
 
+void NWebImpl::CreateWebMessagePorts(std::vector<std::string>& ports) {
+
+  if (nweb_delegate_ == nullptr) {
+    WVLOG_E("JSAPI nweb_delegate_ its null");
+    return;
+  }
+  nweb_delegate_->CreateWebMessagePorts(ports);
+}
+
+void NWebImpl::PostWebMessage(std::string& message, std::vector<std::string>& ports, std::string& targetUri) {
+  if (nweb_delegate_ == nullptr) {
+    WVLOG_E("JSAPI nweb_delegate_ its null");
+    return;
+  }
+  nweb_delegate_->PostWebMessage(message, ports, targetUri);
+}
+
+void NWebImpl::ClosePort(std::string& portHandle) {
+  if (nweb_delegate_ == nullptr) {
+    WVLOG_E("JSAPI nweb_delegate_ its null");
+    return;
+  }
+  nweb_delegate_->ClosePort(portHandle);
+}
+
+void NWebImpl::PostPortMessage(std::string& portHandle, std::string& data) {
+  if (nweb_delegate_ == nullptr) {
+    WVLOG_E("JSAPI nweb_delegate_ its null");
+    return;
+  }
+  nweb_delegate_->PostPortMessage(portHandle, data);
+}
+
+void NWebImpl::SetPortMessageCallback(std::string& portHandle,
+        std::shared_ptr<NWebValueCallback<std::string>> callback) {
+  if (nweb_delegate_ == nullptr) {
+    WVLOG_E("JSAPI nweb_delegate_ its null");
+    return;
+  }
+  nweb_delegate_->SetPortMessageCallback(portHandle, callback);
+}
+
 uint32_t NWebImpl::GetWebId() const {
   return nweb_id_;
 }
@@ -590,4 +688,74 @@ void NWebImpl::ReloadOriginalUrl() const {
   nweb_delegate_->ReloadOriginalUrl();
 }
 
+void NWebImpl::SetBrowserUserAgentString(const std::string& user_agent) {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->SetBrowserUserAgentString(user_agent);
+}
+
+void NWebImpl::PutFindCallback(std::shared_ptr<NWebFindCallback> findListener) {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->RegisterFindListener(findListener);
+}
+
+void NWebImpl::FindAllAsync(const std::string& search_string) const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->FindAllAsync(search_string);
+}
+
+void NWebImpl::ClearMatches() const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->ClearMatches();
+}
+
+void NWebImpl::FindNext(const bool forward) const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+  nweb_delegate_->FindNext(forward);
+}
+
+void NWebImpl::StoreWebArchive(
+    const std::string& base_name,
+    bool auto_name,
+    std::shared_ptr<NWebValueCallback<std::string>> callback) const {
+  if (nweb_delegate_ == nullptr) {
+    return;
+  }
+
+  nweb_delegate_->StoreWebArchive(base_name, auto_name, callback);
+}
+
+void NWebImpl::SendDragEvent(const DragEvent& dragEvent) const {
+  if (nweb_delegate_ == nullptr) {
+    WVLOG_E("nweb_delegate_ is nullptr");
+    return;
+  }
+  DelegateDragEvent event;
+  event.action = static_cast<DelegateDragAction>(dragEvent.action);
+  event.x = dragEvent.x;
+  event.y = dragEvent.y;
+  nweb_delegate_->SendDragEvent(event);
+}
+
+std::string NWebImpl::GetUrl() const {
+  if (nweb_delegate_ == nullptr) {
+    return "";
+  }
+  return nweb_delegate_->GetUrl();
+}
 }  // namespace OHOS::NWeb
+
+extern "C" OHOS_NWEB_EXPORT NWeb* GetNWeb(int32_t nweb_id) {
+  NWebMap* map = OHOS::NWeb::g_nweb_map.Pointer();
+  auto it = map->find(nweb_id);
+  return it == map->end() ? nullptr : it->second;
+}
diff --git a/ohos_nweb/src/nweb_impl.h b/ohos_nweb/src/nweb_impl.h
index 4d606c4888ab1..10b49dda52bf7 100755
--- a/ohos_nweb/src/nweb_impl.h
+++ b/ohos_nweb/src/nweb_impl.h
@@ -45,7 +45,7 @@ class NWebImpl : public NWeb {
   void OnNavigateBack() override;
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction) override;
   void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY) override;
-  void SendMouseEvent(int x, int y, int button, int action) override;
+  void SendMouseEvent(int x, int y, int button, int action, int count) override;
 
   // public api
   void Load(const std::string& url) const override;
@@ -56,6 +56,8 @@ class NWebImpl : public NWeb {
   void NavigateForward() const override;
   void NavigateBackOrForward(int step) const override;
   void DeleteNavigateHistory() override;
+  void ClearSslCache() override;
+  void ClearClientAuthenticationCache() override;
   void Reload() const override;
   void Zoom(float zoomFactor) const override;
   bool ZoomIn() const override;
@@ -75,6 +77,12 @@ class NWebImpl : public NWeb {
   void SetNWebHandler(std::shared_ptr<NWebHandler> handler) override;
   const std::shared_ptr<NWebHandler> GetNWebHandler() const override;
   std::string Title() override;
+  void CreateWebMessagePorts(std::vector<std::string>& ports) override;
+  void PostWebMessage(std::string& message, std::vector<std::string>& ports, std::string& targetUri) override;
+  void ClosePort(std::string& port_handle) override;
+  void PostPortMessage(std::string& port_handle, std::string& data) override;
+  void SetPortMessageCallback(std::string& port_handle,
+      std::shared_ptr<NWebValueCallback<std::string>> callback) override;
   uint32_t GetWebId() const override;
   HitTestResult GetHitTestResult() const override;
   int PageLoadProgress() override;
@@ -100,12 +108,25 @@ class NWebImpl : public NWeb {
       std::shared_ptr<NWebJavaScriptResultCallBack> callback) override;
   void OnFocus() const override;
   void OnBlur() const override;
+  void StoreWebArchive(
+      const std::string& base_name,
+      bool auto_name,
+      std::shared_ptr<NWebValueCallback<std::string>> callback) const override;
+
+  void PutFindCallback(std::shared_ptr<NWebFindCallback> findListener) override;
+  void FindAllAsync(const std::string& search_string) const override;
+  void ClearMatches() const override;
+  void FindNext(const bool forward) const override;
+
+  void SendDragEvent(const DragEvent& dragEvent) const override;
 
   // For NWebEx
   static NWebImpl* FromID(int32_t nweb_id);
   void ReloadOriginalUrl() const;
   static void InitBrowserServiceApi(std::vector<std::string>& browser_args);
   static bool GetBrowserServiceApiEnabled();
+  void SetBrowserUserAgentString(const std::string& user_agent);
+  std::string GetUrl() const override;
 
  private:
   void ProcessInitArgs(const NWebInitArgs& init_args);
diff --git a/ohos_nweb/src/nweb_input_handler.cc b/ohos_nweb/src/nweb_input_handler.cc
index a7d4acc023464..3333952bfc30b 100644
--- a/ohos_nweb/src/nweb_input_handler.cc
+++ b/ohos_nweb/src/nweb_input_handler.cc
@@ -108,11 +108,11 @@ void NWebInputHandler::SendMouseWheelEvent(double x, double y, double deltaX, do
   nweb_delegate_->SendMouseWheelEvent(x, y, deltaX, deltaY);
 }
 
-void NWebInputHandler::SendMouseEvent(int x, int y, int button, int action) {
+void NWebInputHandler::SendMouseEvent(int x, int y, int button, int action, int count) {
   if (nweb_delegate_ == nullptr) {
     return;
   }
-  nweb_delegate_->SendMouseEvent(x, y, button, action);
+  nweb_delegate_->SendMouseEvent(x, y, button, action, count);
 }
 
 void NWebInputHandler::CheckSlideNavigation(int16_t start_x, int16_t end_x) {
diff --git a/ohos_nweb/src/nweb_input_handler.h b/ohos_nweb/src/nweb_input_handler.h
index e371e77ad8c2c..94a8857352cc4 100644
--- a/ohos_nweb/src/nweb_input_handler.h
+++ b/ohos_nweb/src/nweb_input_handler.h
@@ -41,7 +41,7 @@ class NWebInputHandler {
   void OnNavigateBack();
   bool SendKeyEvent(int32_t keyCode, int32_t keyAction);
   void SendMouseWheelEvent(double x, double y, double deltaX, double deltaY);
-  void SendMouseEvent(int x, int y, int button, int action);
+  void SendMouseEvent(int x, int y, int button, int action, int count);
 
  private:
   void CheckSlideNavigation(int16_t start_x, int16_t end_x);
diff --git a/ohos_nweb/src/nweb_inputmethod_handler.cc b/ohos_nweb/src/nweb_inputmethod_handler.cc
index 8c221788180e8..7a29fbae94e53 100644
--- a/ohos_nweb/src/nweb_inputmethod_handler.cc
+++ b/ohos_nweb/src/nweb_inputmethod_handler.cc
@@ -105,13 +105,13 @@ NWebInputMethodHandler::NWebInputMethodHandler()
 
 NWebInputMethodHandler::~NWebInputMethodHandler() {}
 
-void NWebInputMethodHandler::Attach(CefRefPtr<CefBrowser> browser) {
+void NWebInputMethodHandler::Attach(CefRefPtr<CefBrowser> browser, bool show_keyboard) {
   composing_text_.clear();
   browser_ = browser;
   if (inputmethod_listener_ == nullptr) {
     inputmethod_listener_ = new OnTextChangedListenerImpl(this);
   }
-  InputMethodController::GetInstance()->Attach(inputmethod_listener_);
+  InputMethodController::GetInstance()->Attach(inputmethod_listener_, show_keyboard);
 }
 
 void NWebInputMethodHandler::ShowTextInput() {
@@ -121,6 +121,7 @@ void NWebInputMethodHandler::ShowTextInput() {
 void NWebInputMethodHandler::HideTextInput() {
   LOG(INFO) << "NWebInputMethodHandler::HideTextInput " << ime_shown_;
   InputMethodController::GetInstance()->HideTextInput();
+  InputMethodController::GetInstance()->Close();
 }
 
 void NWebInputMethodHandler::OnTextSelectionChanged(
@@ -181,12 +182,14 @@ void NWebInputMethodHandler::DeleteBackward(int32_t length) {
 
 void NWebInputMethodHandler::DeleteForward(int32_t length) {
   if (browser_ != nullptr && browser_->GetHost() != nullptr) {
-    std::unique_lock<std::mutex> lock(textSelectMutex_);
-    bool isNormal = textSelectCv_.wait_for(lock, std::chrono::seconds(1), [this] { return isTextSelectReady_; });
-    if (!isNormal) {
-        LOG(ERROR) << "DeleteForward wait_for timeout";
+    if (selected_to_ != 0) {
+      std::unique_lock<std::mutex> lock(textSelectMutex_);
+      bool isNormal = textSelectCv_.wait_for(lock, std::chrono::seconds(1), [this] { return isTextSelectReady_; });
+      if (!isNormal) {
+          LOG(ERROR) << "DeleteForward wait_for timeout";
+      }
+      isTextSelectReady_ = false;
     }
-    isTextSelectReady_ = false;
 
     CefRefPtr<CefTask> delete_task = new InputMethodTask(base::Bind(
         &NWebInputMethodHandler::DeleteForwardHandlerOnUI, this, length));
diff --git a/ohos_nweb/src/nweb_inputmethod_handler.h b/ohos_nweb/src/nweb_inputmethod_handler.h
index 289c542bc9a5d..15aba24a698fd 100644
--- a/ohos_nweb/src/nweb_inputmethod_handler.h
+++ b/ohos_nweb/src/nweb_inputmethod_handler.h
@@ -26,7 +26,7 @@ class NWebInputMethodHandler : public NWebInputMethodClient {
  public:
   NWebInputMethodHandler();
   ~NWebInputMethodHandler();
-  void Attach(CefRefPtr<CefBrowser> browser) override;
+  void Attach(CefRefPtr<CefBrowser> browser, bool show_keyboard) override;
   void ShowTextInput() override;
   void HideTextInput() override;
   void OnTextSelectionChanged(CefRefPtr<CefBrowser> browser,
diff --git a/ohos_nweb/src/nweb_output_handler.cc b/ohos_nweb/src/nweb_output_handler.cc
index 570f908ffb8c0..f9abaef29ed95 100644
--- a/ohos_nweb/src/nweb_output_handler.cc
+++ b/ohos_nweb/src/nweb_output_handler.cc
@@ -18,6 +18,7 @@
 #include <sys/time.h>
 #include <unistd.h>
 #include <cerrno>
+#include <cinttypes>
 #include <cstdio>
 #include <cstring>
 #include <iomanip>
@@ -88,10 +89,7 @@ NWebOutputHandler::NWebOutputHandler(
   dump_buf_.reset(nullptr);
 }
 
-NWebOutputHandler::~NWebOutputHandler() {
-  DestoryNativeWindow(window_);
-  window_ = nullptr;
-}
+NWebOutputHandler::~NWebOutputHandler() {}
 
 void NWebOutputHandler::Init(uint32_t width, uint32_t height) {
   Resize(width, height);
@@ -153,6 +151,12 @@ void NWebOutputHandler::StartFrameStat() {
                          (output_handler->local_render_count_ - 1) /
                          (output_handler->local_time_curr_ -
                           output_handler->local_time_base_);
+          WVLOG_W(
+              "NWeb %{public}u fps_cur=%{public}0.1f "
+              "frame_total_count=%{public}" PRId64 ""
+              " frame_miss_count=%{public}" PRId64 "",
+              output_handler->nweb_id_, fps_cur,
+              output_handler->render_count_, output_handler->frame_miss_count_);
           std::cout << "NWeb " << output_handler->nweb_id_
                     << " fps_cur=" << std::fixed << std::setprecision(1)
                     << fps_cur
@@ -311,4 +315,4 @@ NativeWindow* NWebOutputHandler::GetNativeWindowFromSurface(void* surface) {
   NativeWindowHandleOpt(window_, SET_BUFFER_GEOMETRY, width_, height_);
   return window_;
 }
-}  // namespace OHOS::NWeb
\ No newline at end of file
+}  // namespace OHOS::NWeb
diff --git a/ohos_nweb/src/nweb_output_handler.h b/ohos_nweb/src/nweb_output_handler.h
index 165f136f6622f..0b4f34e05a010 100644
--- a/ohos_nweb/src/nweb_output_handler.h
+++ b/ohos_nweb/src/nweb_output_handler.h
@@ -80,7 +80,7 @@ class NWebOutputHandler
   std::string dump_path_;
   std::mutex dump_mtx_;
   std::condition_variable dump_cv_;
-  std::unique_ptr<char> dump_buf_;
+  std::unique_ptr<char[]> dump_buf_;
 
   /* stat info */
   bool frame_info_dump_ = false;
diff --git a/ohos_nweb/src/nweb_sysevent.gni b/ohos_nweb/src/nweb_sysevent.gni
new file mode 100644
index 0000000000000..dc76d76ac9291
--- /dev/null
+++ b/ohos_nweb/src/nweb_sysevent.gni
@@ -0,0 +1,18 @@
+# Copyright (c) 2022 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+# 
+#     http://www.apache.org/licenses/LICENSE-2.0
+# 
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+declare_args() {
+  # enable ohos hisysevent, true by default
+  report_sys_event = true
+}
+
diff --git a/ohos_nweb/src/sysevent/event_reporter.cc b/ohos_nweb/src/sysevent/event_reporter.cc
new file mode 100644
index 0000000000000..3263a19fb7bb7
--- /dev/null
+++ b/ohos_nweb/src/sysevent/event_reporter.cc
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "event_reporter.h"
+#include <hisysevent.h>
+
+using namespace OHOS::HiviewDFX;
+
+namespace {
+//For page load statistics
+constexpr char PAGE_LOAD_STATISTICS[] = "PAGE_LOAD_STATISTICS";
+constexpr char CURRENT_INSTANCE_ID[] = "INSTANCE_ID";
+constexpr char ACCESS_SUM_COUNT[] = "ACCESS_SUM_COUNT";
+constexpr char ACCESS_SUCC_COUNT[] = "ACCESS_SUCC_COUNT";
+constexpr char ACCESS_FAIL_COUNT[] = "ACCESS_FAIL_COUNT";
+constexpr char ACCESS_FAIL_RATIO[] = "ACCESS_FAIL_RATIO";
+
+//For mutiple instance statistics
+constexpr char MULTI_INSTANCE_STATISTICS[] = "MULTI_INSTANCE_STATISTICS";
+constexpr char CURRENT_INSTANCE_COUNT[] = "INSTANCE_COUNT";
+constexpr char INSTANCE_MAX_COUNT[] = "MAX_COUNT";
+
+//For page load error info
+constexpr char PAGE_LOAD_ERROR[] = "PAGE_LOAD_ERROR";
+constexpr char ERROR_TYPE[] = "ERROR_TYPE";
+constexpr char ERROR_CODE[] = "ERROR_CODE";
+constexpr char ERROR_DESC[] = "ERROR_DESC";
+}
+
+void ReportPageLoadStats(int instanceId, int accessSumCount, int accessSuccCount, int accessFailCount) {
+  float failRatio = float(accessFailCount)/accessSumCount;
+  HiSysEvent::Write(HiSysEvent::Domain::WEBVIEW, PAGE_LOAD_STATISTICS, HiSysEvent::EventType::STATISTIC,
+    CURRENT_INSTANCE_ID, instanceId, ACCESS_SUM_COUNT, accessSumCount, ACCESS_SUCC_COUNT, accessSuccCount,
+    ACCESS_FAIL_COUNT, accessFailCount, ACCESS_FAIL_RATIO, failRatio);
+}
+
+void ReportMultiInstanceStats(int instanceId, int nwebCount, int nwebMaxCount) {
+  HiSysEvent::Write(HiSysEvent::Domain::WEBVIEW, MULTI_INSTANCE_STATISTICS, HiSysEvent::EventType::STATISTIC,
+    CURRENT_INSTANCE_ID, instanceId, CURRENT_INSTANCE_COUNT, nwebCount, INSTANCE_MAX_COUNT, nwebMaxCount);
+}
+
+void ReportPageLoadErrorInfo(int instanceId, const std::string errorType, int errorCode, const std::string errorDesc) {
+  std::string error_type = "";
+  std::string error_desc = "";
+  int error_code = errorCode;
+  if (errorType != "") {
+    error_type = errorType;
+  }
+  if (errorDesc != "") {
+    error_desc = errorDesc;
+  }
+  HiSysEvent::Write(HiSysEvent::Domain::WEBVIEW, PAGE_LOAD_ERROR, HiSysEvent::EventType::FAULT,
+    CURRENT_INSTANCE_ID, instanceId, ERROR_TYPE, error_type, ERROR_CODE, error_code, ERROR_DESC, error_desc);
+}
+
diff --git a/ohos_nweb/src/sysevent/event_reporter.h b/ohos_nweb/src/sysevent/event_reporter.h
new file mode 100644
index 0000000000000..a06f72b7dab7a
--- /dev/null
+++ b/ohos_nweb/src/sysevent/event_reporter.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef EVENT_REPORT_H
+#define EVENT_REPORT_H
+
+#include <string>
+
+void ReportPageLoadStats(int instanceId, int accessSumCount, int accessSuccCount, int accessFailCount);
+
+void ReportMultiInstanceStats(int instanceId, int nwebCount, int nwebMaxCount);
+
+void ReportPageLoadErrorInfo(int instanceId, const std::string errorType, int errorCode, const std::string errorDesc);
+
+#endif
diff --git a/pdf/pdfium/findtext_unittest.cc b/pdf/pdfium/findtext_unittest.cc
index acca90d79c8e6..f4599e070b672 100644
--- a/pdf/pdfium/findtext_unittest.cc
+++ b/pdf/pdfium/findtext_unittest.cc
@@ -18,7 +18,8 @@ namespace {
 
 class FindTextTestClient : public TestClient {
  public:
-  FindTextTestClient() = default;
+  explicit FindTextTestClient(bool expected_case_sensitive)
+      : expected_case_sensitive_(expected_case_sensitive) {}
   FindTextTestClient(const FindTextTestClient&) = delete;
   FindTextTestClient& operator=(const FindTextTestClient&) = delete;
   ~FindTextTestClient() override = default;
@@ -30,7 +31,7 @@ class FindTextTestClient : public TestClient {
   std::vector<SearchStringResult> SearchString(const char16_t* string,
                                                const char16_t* term,
                                                bool case_sensitive) override {
-    EXPECT_TRUE(case_sensitive);
+    EXPECT_EQ(case_sensitive, expected_case_sensitive_);
     std::u16string haystack = std::u16string(string);
     std::u16string needle = std::u16string(term);
 
@@ -50,6 +51,9 @@ class FindTextTestClient : public TestClient {
     }
     return results;
   }
+
+ private:
+  const bool expected_case_sensitive_;
 };
 
 }  // namespace
@@ -57,7 +61,7 @@ class FindTextTestClient : public TestClient {
 using FindTextTest = PDFiumTestBase;
 
 TEST_F(FindTextTest, FindText) {
-  FindTextTestClient client;
+  FindTextTestClient client(/*expected_case_sensitive=*/true);
   std::unique_ptr<PDFiumEngine> engine =
       InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
   ASSERT_TRUE(engine);
@@ -76,7 +80,7 @@ TEST_F(FindTextTest, FindText) {
 }
 
 TEST_F(FindTextTest, FindHyphenatedText) {
-  FindTextTestClient client;
+  FindTextTestClient client(/*expected_case_sensitive=*/true);
   std::unique_ptr<PDFiumEngine> engine =
       InitializeEngine(&client, FILE_PATH_LITERAL("spanner.pdf"));
   ASSERT_TRUE(engine);
@@ -95,7 +99,7 @@ TEST_F(FindTextTest, FindHyphenatedText) {
 }
 
 TEST_F(FindTextTest, FindLineBreakText) {
-  FindTextTestClient client;
+  FindTextTestClient client(/*expected_case_sensitive=*/true);
   std::unique_ptr<PDFiumEngine> engine =
       InitializeEngine(&client, FILE_PATH_LITERAL("spanner.pdf"));
   ASSERT_TRUE(engine);
@@ -112,7 +116,7 @@ TEST_F(FindTextTest, FindLineBreakText) {
 }
 
 TEST_F(FindTextTest, FindSimpleQuotationMarkText) {
-  FindTextTestClient client;
+  FindTextTestClient client(/*expected_case_sensitive=*/true);
   std::unique_ptr<PDFiumEngine> engine =
       InitializeEngine(&client, FILE_PATH_LITERAL("bug_142627.pdf"));
   ASSERT_TRUE(engine);
@@ -130,7 +134,7 @@ TEST_F(FindTextTest, FindSimpleQuotationMarkText) {
 }
 
 TEST_F(FindTextTest, FindFancyQuotationMarkText) {
-  FindTextTestClient client;
+  FindTextTestClient client(/*expected_case_sensitive=*/true);
   std::unique_ptr<PDFiumEngine> engine =
       InitializeEngine(&client, FILE_PATH_LITERAL("bug_142627.pdf"));
   ASSERT_TRUE(engine);
@@ -149,4 +153,42 @@ TEST_F(FindTextTest, FindFancyQuotationMarkText) {
   engine->StartFind(base::UTF16ToUTF8(term), /*case_sensitive=*/true);
 }
 
+TEST_F(FindTextTest, SelectFindResultAndSwitchToTwoUpView) {
+  FindTextTestClient client(/*expected_case_sensitive=*/false);
+  std::unique_ptr<PDFiumEngine> engine =
+      InitializeEngine(&client, FILE_PATH_LITERAL("hello_world2.pdf"));
+  ASSERT_TRUE(engine);
+
+  ExpectInitialSearchResults(client, 4);
+  engine->StartFind("world", /*case_sensitive=*/false);
+
+  {
+    InSequence sequence;
+
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(1));
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(2));
+  }
+  ASSERT_TRUE(engine->SelectFindResult(/*forward=*/true));
+  ASSERT_TRUE(engine->SelectFindResult(/*forward=*/true));
+
+  {
+    InSequence sequence;
+
+    for (int i = 0; i < 5; ++i) {
+      EXPECT_CALL(client,
+                  NotifyNumberOfFindResultsChanged(i, /*final_result=*/false));
+    }
+    EXPECT_CALL(client,
+                NotifyNumberOfFindResultsChanged(4, /*final_result=*/true));
+  }
+  engine->SetTwoUpView(true);
+
+  {
+    InSequence sequence;
+
+    EXPECT_CALL(client, NotifySelectedFindResultChanged(2));
+  }
+  ASSERT_TRUE(engine->SelectFindResult(/*forward=*/true));
+}
+
 }  // namespace chrome_pdf
diff --git a/pdf/pdfium/pdfium_engine.cc b/pdf/pdfium/pdfium_engine.cc
index a82747409a7e6..34840e2ab64af 100644
--- a/pdf/pdfium/pdfium_engine.cc
+++ b/pdf/pdfium/pdfium_engine.cc
@@ -1978,7 +1978,7 @@ void PDFiumEngine::SearchUsingICU(const std::u16string& term,
 }
 
 void PDFiumEngine::AddFindResult(const PDFiumRange& result) {
-  bool first_result = find_results_.empty();
+  bool first_result = find_results_.empty() && !resume_find_index_.has_value();
   // Figure out where to insert the new location, since we could have
   // started searching midway and now we wrapped.
   size_t result_index;
@@ -1995,7 +1995,6 @@ void PDFiumEngine::AddFindResult(const PDFiumRange& result) {
   UpdateTickMarks();
   client_->NotifyNumberOfFindResultsChanged(find_results_.size(), false);
   if (first_result) {
-    DCHECK(!resume_find_index_);
     DCHECK(!current_find_index_);
     SelectFindResult(/*forward=*/true);
   }
diff --git a/ppapi/proxy/ppapi_command_buffer_proxy.cc b/ppapi/proxy/ppapi_command_buffer_proxy.cc
index a76aaab2f9ab9..ff4d71888f74c 100644
--- a/ppapi/proxy/ppapi_command_buffer_proxy.cc
+++ b/ppapi/proxy/ppapi_command_buffer_proxy.cc
@@ -171,6 +171,12 @@ void PpapiCommandBufferProxy::DestroyTransferBuffer(int32_t id) {
       ppapi::API_ID_PPB_GRAPHICS_3D, resource_, id));
 }
 
+void PpapiCommandBufferProxy::ForceLostContext(gpu::error::ContextLostReason) {
+  // This entry point was added to CommandBuffer well after PPAPI's
+  // deprecation. No current clients determined its necessity, so it
+  // will not be implemented.
+}
+
 void PpapiCommandBufferProxy::SetLock(base::Lock*) {
   NOTREACHED();
 }
diff --git a/ppapi/proxy/ppapi_command_buffer_proxy.h b/ppapi/proxy/ppapi_command_buffer_proxy.h
index ce2697a5a869e..9c40ab8eaaf45 100644
--- a/ppapi/proxy/ppapi_command_buffer_proxy.h
+++ b/ppapi/proxy/ppapi_command_buffer_proxy.h
@@ -55,6 +55,7 @@ class PPAPI_PROXY_EXPORT PpapiCommandBufferProxy : public gpu::CommandBuffer,
       gpu::TransferBufferAllocationOption option =
           gpu::TransferBufferAllocationOption::kLoseContextOnOOM) override;
   void DestroyTransferBuffer(int32_t id) override;
+  void ForceLostContext(gpu::error::ContextLostReason reason) override;
 
   // gpu::GpuControl implementation:
   void SetGpuControlClient(gpu::GpuControlClient*) override;
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index f0c31f64312c6..58ae96127ca24 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -117,9 +117,11 @@ config("skia_config") {
 
   # TODO: ohos use skia to be adapted
   if (is_ohos) {
-    defines += [
-      "USE_CHROMIUM_SKIA",
-    ]
+    defines += [ "USE_CHROMIUM_SKIA" ]
+
+    if (enable_ohos_bytrace) {
+      defines += [ "ENABLE_OHOS_SKIA_TRACE" ]
+    }
   }
 
   if (is_mac) {
@@ -653,13 +655,13 @@ component("skia") {
     sources += skia_sksg_sources
     sources += skia_shaper_primitive_sources
   }
-}
 
   #ifdef OHOS_NWEB_EX
   if (ohos_nweb_ex_config_name != "") {
     configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
     configs += [ "//build/config:ohos_nweb_ex_def_other" ]
   }  #endif  // OHOS_NWEB_EX
+}
 
 # Template for things that are logically part of :skia, but need to be split out
 # so custom compile flags can be applied.
diff --git a/third_party/blink/common/features.cc b/third_party/blink/common/features.cc
index 4b469825b4cda..766786ebc2dd9 100644
--- a/third_party/blink/common/features.cc
+++ b/third_party/blink/common/features.cc
@@ -887,5 +887,9 @@ const base::FeatureParam<std::string>
 const base::Feature kCLSM90Improvements{"CLSM90Improvements",
                                         base::FEATURE_ENABLED_BY_DEFAULT};
 
+const base::Feature kDisableArrayBufferSizeLimitsForTesting{
+    "DisableArrayBufferSizeLimitsForTesting",
+    base::FEATURE_DISABLED_BY_DEFAULT};
+
 }  // namespace features
 }  // namespace blink
diff --git a/third_party/blink/common/web_preferences/web_preferences.cc b/third_party/blink/common/web_preferences/web_preferences.cc
index 9b24c1c518738..87d0f82223f60 100644
--- a/third_party/blink/common/web_preferences/web_preferences.cc
+++ b/third_party/blink/common/web_preferences/web_preferences.cc
@@ -13,6 +13,11 @@
 #include "third_party/blink/public/mojom/webpreferences/web_preferences.mojom.h"
 #include "ui/base/ui_base_switches_util.h"
 
+#ifdef OS_OHOS
+#include "display_manager_adapter.h"
+#include "ohos_adapter_helper.h"
+#endif
+
 namespace {
 
 bool IsTouchDragDropEnabled() {
@@ -169,7 +174,7 @@ WebPreferences::WebPreferences()
       device_scale_adjustment(1.0f),
       force_enable_zoom(false),
       support_deprecated_target_density_dpi(false),
-      use_legacy_background_size_shorthand_behavior(true),
+      use_legacy_background_size_shorthand_behavior(false),
       wide_viewport_quirk(false),
       use_wide_viewport(false),
       force_zero_layout_height(false),
@@ -228,6 +233,27 @@ WebPreferences::WebPreferences()
       base::ASCIIToUTF16("Impact");
   pictograph_font_family_map[web_pref::kCommonScript] =
       base::ASCIIToUTF16("Times New Roman");
+
+#ifdef OS_OHOS
+  std::unique_ptr<OHOS::NWeb::DisplayManagerAdapter> display_manager_adapter =
+      OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
+  if (display_manager_adapter == nullptr) {
+    LOG(ERROR) << "display_manager_adapter is nullptr.";
+    return;
+  }
+  std::shared_ptr<OHOS::NWeb::DisplayAdapter> display = display_manager_adapter->GetDefaultDisplay();
+  if (display == nullptr) {
+    LOG(ERROR) << "display is nullptr.";
+    return;
+  }
+  float ratio = display->GetVirtualPixelRatio();
+  if (ratio <= 0.0f) {
+    LOG(ERROR) << "get virtual pixel ratio error.";
+    return;
+  }
+  default_minimum_page_scale_factor = ratio;
+  default_maximum_page_scale_factor = ratio * 2;
+#endif
 }
 
 WebPreferences::WebPreferences(const WebPreferences& other) = default;
diff --git a/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc b/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc
index 96ed045f29367..c5302d5ba9fdf 100644
--- a/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc
+++ b/third_party/blink/common/web_preferences/web_preferences_mojom_traits.cc
@@ -222,6 +222,7 @@ bool StructTraits<blink::mojom::WebPreferencesDataView,
   out->always_show_focus = data.always_show_focus();
   out->touch_drag_drop_enabled = data.touch_drag_drop_enabled();
   out->webxr_immersive_ar_allowed = data.webxr_immersive_ar_allowed();
+  out->pinch_smooth_mode = data.pinch_smooth_mode();
   return true;
 }
 
diff --git a/third_party/blink/public/common/features.h b/third_party/blink/public/common/features.h
index e371d93b8ffbd..89c12448b0ec8 100644
--- a/third_party/blink/public/common/features.h
+++ b/third_party/blink/public/common/features.h
@@ -364,6 +364,12 @@ BLINK_COMMON_EXPORT extern const base::FeatureParam<std::string>
 
 BLINK_COMMON_EXPORT extern const base::Feature kCLSM90Improvements;
 
+// TODO(https://crbug.com/1201109): temporary flag to disable new ArrayBuffer
+// size limits, so that tests can be written against code receiving these
+// buffers. Remove when the bindings code instituting these limits is removed.
+BLINK_COMMON_EXPORT extern const base::Feature
+    kDisableArrayBufferSizeLimitsForTesting;
+
 }  // namespace features
 }  // namespace blink
 
diff --git a/third_party/blink/public/common/web_preferences/web_preferences.h b/third_party/blink/public/common/web_preferences/web_preferences.h
index 2ddd9e04944cb..10d1362238bd4 100644
--- a/third_party/blink/public/common/web_preferences/web_preferences.h
+++ b/third_party/blink/public/common/web_preferences/web_preferences.h
@@ -357,6 +357,7 @@ struct BLINK_COMMON_EXPORT WebPreferences {
   // By default, WebXR's immersive-ar session creation is allowed, but this can
   // change depending on the enterprise policy if the platform supports it.
   bool webxr_immersive_ar_allowed = true;
+  bool pinch_smooth_mode = false;
 
   // We try to keep the default values the same as the default values in
   // chrome, except for the cases where it would require lots of extra work for
diff --git a/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h b/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h
index 5a3bcbbc36dfc..3700f83cee1e9 100644
--- a/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h
+++ b/third_party/blink/public/common/web_preferences/web_preferences_mojom_traits.h
@@ -772,6 +772,11 @@ struct BLINK_COMMON_EXPORT StructTraits<blink::mojom::WebPreferencesDataView,
     return r.webxr_immersive_ar_allowed;
   }
 
+  static bool pinch_smooth_mode(
+      const blink::web_pref::WebPreferences& r) {
+    return r.pinch_smooth_mode;
+  }
+
   static bool Read(blink::mojom::WebPreferencesDataView r,
                    blink::web_pref::WebPreferences* out);
 };
diff --git a/third_party/blink/public/mojom/device/device.mojom b/third_party/blink/public/mojom/device/device.mojom
index c4a5869e085a4..750156cd283e5 100644
--- a/third_party/blink/public/mojom/device/device.mojom
+++ b/third_party/blink/public/mojom/device/device.mojom
@@ -17,15 +17,6 @@ interface ManagedConfigurationObserver {
 // renderer process.
 // The connection is terminated when the origin trustness status changes.
 interface DeviceAPIService {
-  // Requests from browser the managed configuration mapped by |keys| provided
-  // by the device administrator. Returns a dictionary, containing JSON
-  // serialized value of the keys that were found in that configuration.
-  GetManagedConfiguration(array<string> keys) =>
-                          (map<string, string> configurations);
-  // Allows to subscribe to the managed configuration updates.
-  SubscribeToManagedConfiguration(
-    pending_remote<ManagedConfigurationObserver> observer);
-
   // Fetches the value of the device identifier of the directory API, that is
   // generated by the server and identifies the cloud record of the device for
   // querying in the cloud directory API. If the current user is not affiliated,
@@ -54,6 +45,20 @@ interface DeviceAPIService {
   GetAnnotatedLocation() => (DeviceAttributeResult result);
 };
 
+// Per-frame interface to provide managed configuration information
+// to the renderer. Available to all frames, regardless of whether or
+// not the frame is hosting a page that's managed by enterprise policy.
+interface ManagedConfigurationService {
+  // Requests from browser the managed configuration mapped by |keys| provided
+  // by the device administrator. Returns a dictionary, containing JSON
+  // serialized value of the keys that were found in that configuration.
+  GetManagedConfiguration(array<string> keys) =>
+                          (map<string, string> configurations);
+  // Allows to subscribe to the managed configuration updates.
+  SubscribeToManagedConfiguration(
+    pending_remote<ManagedConfigurationObserver> observer);
+};
+
 // Returned by methods that either return a nullable string or an error.
 union DeviceAttributeResult {
   // Implies failure.
diff --git a/third_party/blink/public/mojom/input/input_handler.mojom b/third_party/blink/public/mojom/input/input_handler.mojom
index e615a7d95b6a0..edb96e2068446 100644
--- a/third_party/blink/public/mojom/input/input_handler.mojom
+++ b/third_party/blink/public/mojom/input/input_handler.mojom
@@ -398,6 +398,9 @@ interface WidgetInputHandler {
          DidOverscrollParams? overscroll,
          TouchActionOptional? touch_action);
 
+  [EnableIf=is_ohos]
+  StartFling();
+
   // Sends a non-blocking input event to the render widget. The behaviour
   // of this API is the same as DispatchEvent just that there is no callback
   // after the event is processed.
diff --git a/third_party/blink/public/mojom/webpreferences/web_preferences.mojom b/third_party/blink/public/mojom/webpreferences/web_preferences.mojom
index 0b4d0c90ba89a..871b1cabd9020 100644
--- a/third_party/blink/public/mojom/webpreferences/web_preferences.mojom
+++ b/third_party/blink/public/mojom/webpreferences/web_preferences.mojom
@@ -442,4 +442,5 @@ struct WebPreferences {
 
   // Controls whether WebXR's immersive-ar is allowed.
   bool webxr_immersive_ar_allowed;
+  bool pinch_smooth_mode;
 };
diff --git a/third_party/blink/public/mojom/webshare/webshare.mojom b/third_party/blink/public/mojom/webshare/webshare.mojom
index 4ff7e8143dcaa..5e74e387194e0 100644
--- a/third_party/blink/public/mojom/webshare/webshare.mojom
+++ b/third_party/blink/public/mojom/webshare/webshare.mojom
@@ -5,12 +5,13 @@
 [JavaPackage="org.chromium.webshare.mojom"]
 module blink.mojom;
 
+import "mojo/public/mojom/base/safe_base_name.mojom";
 import "third_party/blink/public/mojom/blob/serialized_blob.mojom";
 import "third_party/blink/public/mojom/webshare/share_error.mojom";
 import "url/mojom/url.mojom";
 
 struct SharedFile {
-  string name;
+  mojo_base.mojom.SafeBaseName name;
   SerializedBlob blob;
 };
 
diff --git a/third_party/blink/renderer/core/BUILD.gn b/third_party/blink/renderer/core/BUILD.gn
index b0d8a485e2e62..361fa8cbcf1c4 100644
--- a/third_party/blink/renderer/core/BUILD.gn
+++ b/third_party/blink/renderer/core/BUILD.gn
@@ -70,6 +70,17 @@ import("//third_party/blink/renderer/modules/modules_idl_files.gni")
 import("//third_party/blink/renderer/platform/platform_generated.gni")
 import("//third_party/protobuf/proto_library.gni")
 
+if (is_ohos) {
+  import("//build/config/ohos/config.gni")
+  config("ohos_system_libs") {
+    libs = [
+      "nweb_ohos_adapter.z"
+    ]
+    include_dirs = ohos_src_includes
+    lib_dirs = ohos_libs_dir
+  }
+}
+
 visibility = [
   "//third_party/blink/public/*",
   "//third_party/blink/renderer/*",
@@ -255,6 +266,10 @@ component("core") {
   configs -= core_config_remove
   configs += core_config_add
 
+  if (is_ohos) {
+    configs += [ ":ohos_system_libs" ]
+  }
+
   public_deps = [
     ":core_generated",
     ":core_hot",
diff --git a/third_party/blink/renderer/core/css/properties/css_parsing_utils.cc b/third_party/blink/renderer/core/css/properties/css_parsing_utils.cc
index da5eebcb42588..ed17c7fc352e0 100644
--- a/third_party/blink/renderer/core/css/properties/css_parsing_utils.cc
+++ b/third_party/blink/renderer/core/css/properties/css_parsing_utils.cc
@@ -3131,9 +3131,11 @@ bool ParseBackgroundOrMask(bool important,
 
   for (unsigned i = 0; i < longhand_count; ++i) {
     const CSSProperty& property = *shorthand.properties()[i];
+#if !defined(OS_OHOS)
     if (property.IDEquals(CSSPropertyID::kBackgroundSize) && longhands[i] &&
         context.UseLegacyBackgroundSizeShorthandBehavior())
       continue;
+#endif
     AddProperty(property.PropertyID(), shorthand.id(), *longhands[i], important,
                 implicit ? IsImplicitProperty::kImplicit
                          : IsImplicitProperty::kNotImplicit,
diff --git a/third_party/blink/renderer/core/exported/web_view_impl.cc b/third_party/blink/renderer/core/exported/web_view_impl.cc
index 4552b8ec8c4b7..827df6eecab2f 100644
--- a/third_party/blink/renderer/core/exported/web_view_impl.cc
+++ b/third_party/blink/renderer/core/exported/web_view_impl.cc
@@ -1774,6 +1774,7 @@ void WebView::ApplyWebPreferences(const web_pref::WebPreferences& prefs,
       prefs.translate_service_available);
 
   web_view->SetBaseBackgroundColor(prefs.base_background_color);
+  web_view_impl->SetPinchSmoothMode(prefs.pinch_smooth_mode);
 }
 
 void WebViewImpl::ThemeChanged() {
@@ -2578,6 +2579,23 @@ PageScaleConstraintsSet& WebViewImpl::GetPageScaleConstraintsSet() const {
   return GetPage()->GetPageScaleConstraintsSet();
 }
 
+void WebViewImpl::SetPinchSmoothMode(bool isEnable) {
+
+  if (!MainFrame() || !GetPage() || !GetPage()->MainFrame() ||
+      !GetPage()->MainFrame()->IsLocalFrame() ||
+      !GetPage()->DeprecatedLocalMainFrame()->View()) {
+    return;
+  }
+
+  if (pinch_smooth_mode == isEnable) {
+    return;
+  }
+  pinch_smooth_mode = isEnable;
+  if (does_composite_) {
+    MainFrameImpl()->FrameWidgetImpl()->SetPinchSmoothMode(isEnable);
+  }
+}
+
 void WebViewImpl::RefreshPageScaleFactor() {
   if (!MainFrame() || !GetPage() || !GetPage()->MainFrame() ||
       !GetPage()->MainFrame()->IsLocalFrame() ||
diff --git a/third_party/blink/renderer/core/exported/web_view_impl.h b/third_party/blink/renderer/core/exported/web_view_impl.h
index b0134896b2c20..d4f0ac3e67aa9 100644
--- a/third_party/blink/renderer/core/exported/web_view_impl.h
+++ b/third_party/blink/renderer/core/exported/web_view_impl.h
@@ -595,6 +595,7 @@ class CORE_EXPORT WebViewImpl final : public WebView,
 
   float MaximumLegiblePageScale() const;
   void RefreshPageScaleFactor();
+  void SetPinchSmoothMode(bool isEnable);
   IntSize ContentsSize() const;
 
   void UpdateBrowserControlsConstraint(cc::BrowserControlsState constraint);
@@ -809,6 +810,8 @@ class CORE_EXPORT WebViewImpl final : public WebView,
   // to be called.
   bool needs_preferred_size_update_ = true;
 
+  bool pinch_smooth_mode = false;
+
   // Cache the preferred size of the page in order to prevent sending the IPC
   // when layout() recomputes but doesn't actually change sizes.
   gfx::Size preferred_size_in_dips_;
diff --git a/third_party/blink/renderer/core/frame/local_dom_window.cc b/third_party/blink/renderer/core/frame/local_dom_window.cc
index b93ae92cb6484..c1fb3bab07b45 100644
--- a/third_party/blink/renderer/core/frame/local_dom_window.cc
+++ b/third_party/blink/renderer/core/frame/local_dom_window.cc
@@ -137,6 +137,10 @@
 #include "third_party/blink/renderer/platform/wtf/cross_thread_functional.h"
 #include "v8/include/v8.h"
 
+#if defined(OS_OHOS)
+#include "ohos_adapter_helper.h"
+#endif
+
 namespace blink {
 
 namespace {
@@ -1517,10 +1521,34 @@ ScriptPromise LocalDOMWindow::getComputedAccessibleNode(
 }
 
 double LocalDOMWindow::devicePixelRatio() const {
+#if defined(OS_OHOS)
+  static double ratio = 0;
+  if (!ratio) {
+    auto display_manager_adapter = OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
+    if (display_manager_adapter == nullptr) {
+      LOG(ERROR) << "display_manager_adapter is nullptr.";
+      return 0.0;
+    }
+    auto display = display_manager_adapter->GetDefaultDisplay();
+    if (display == nullptr) {
+      LOG(ERROR) << "display is nullptr.";
+      return 0.0;
+    }
+    ratio = display->GetVirtualPixelRatio();
+    if (ratio <= 0) {
+      LOG(ERROR) << "invalid ratio, ratio = " << ratio;
+      ratio = 0;
+      return 0.0;
+    }
+  }
+
+  return ratio;
+#else
   if (!GetFrame())
     return 0.0;
 
   return GetFrame()->DevicePixelRatio();
+#endif
 }
 
 void LocalDOMWindow::scrollBy(double x, double y) const {
diff --git a/third_party/blink/renderer/core/frame/local_frame_view.cc b/third_party/blink/renderer/core/frame/local_frame_view.cc
index 242a4ee59d559..a21b26e016ff9 100644
--- a/third_party/blink/renderer/core/frame/local_frame_view.cc
+++ b/third_party/blink/renderer/core/frame/local_frame_view.cc
@@ -216,14 +216,48 @@ constexpr int kCommitDelayDefaultInMs = 500;  // 30 frames @ 60hz
 // The maximum number of updatePlugins iterations that should be done before
 // returning.
 static const unsigned kMaxUpdatePluginsIterations = 2;
-static const float kInitialLayoutSizeRatio = 2.0;
+
+#ifdef OS_OHOS
+void LocalFrameView::SetInitalLayoutRatio()
+{
+  static double ratio = 0;
+  if (!ratio) {
+    display_manager_adapter_ = OHOS::NWeb::OhosAdapterHelper::GetInstance().CreateDisplayMgrAdapter();
+    if (display_manager_adapter_ == nullptr) {
+      LOG(ERROR) << "display_manager_adapter is nullptr.";
+      return;
+    }
+    std::shared_ptr<OHOS::NWeb::DisplayAdapter> display =
+      display_manager_adapter_->GetDefaultDisplay();
+    if (display == nullptr) {
+      LOG(ERROR) << "display is nullptr.";
+      return;
+    }
+    ratio = display->GetVirtualPixelRatio();
+    if (ratio <= 0) {
+      LOG(ERROR) << "invalid ratio.";
+      ratio = 0;
+      return;
+    }
+    initial_layout_size_ratio_ = ratio;
+    LOG(INFO) << "SetInitalLayoutRatio get ratio = " << initial_layout_size_ratio_;
+  }
+}
+#endif
+
 LocalFrameView::LocalFrameView(LocalFrame& frame)
     : LocalFrameView(frame, IntRect()) {
+#ifdef OS_OHOS
+  SetInitalLayoutRatio();
+#endif
   Show();
 }
 
 LocalFrameView::LocalFrameView(LocalFrame& frame, const IntSize& initial_size)
     : LocalFrameView(frame, IntRect(IntPoint(), initial_size)) {
+#ifdef OS_OHOS
+  SetInitalLayoutRatio();
+#endif
   SetLayoutSizeInternal(initial_size);
   Show();
 }
@@ -279,6 +313,9 @@ LocalFrameView::LocalFrameView(LocalFrame& frame, IntRect frame_rect)
       is_updating_descendant_dependent_flags_(false)
 #endif
 {
+#ifdef OS_OHOS
+  SetInitalLayoutRatio();
+#endif
   // Propagate the marginwidth/height and scrolling modes to the view.
   if (frame_->Owner() && frame_->Owner()->ScrollbarMode() ==
                              mojom::blink::ScrollbarMode::kAlwaysOff)
@@ -1515,7 +1552,11 @@ void LocalFrameView::SetLayoutSize(const IntSize& size) {
   if (frame_->GetDocument() &&
       frame_->GetDocument()->Lifecycle().LifecyclePostponed())
     return;
-  IntSize size_tmp(size.Width() / kInitialLayoutSizeRatio, size.Height() / kInitialLayoutSizeRatio);
+#ifdef OS_OHOS
+  IntSize size_tmp(size.Width() / initial_layout_size_ratio_, size.Height() / initial_layout_size_ratio_);
+#else
+  IntSize size_tmp(size.Width(), size.Height());
+#endif
   SetLayoutSizeInternal(size_tmp);
 }
 
diff --git a/third_party/blink/renderer/core/frame/local_frame_view.h b/third_party/blink/renderer/core/frame/local_frame_view.h
index 2c05909edcdff..eb07279459e9e 100644
--- a/third_party/blink/renderer/core/frame/local_frame_view.h
+++ b/third_party/blink/renderer/core/frame/local_frame_view.h
@@ -57,6 +57,11 @@
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/casting.h"
 
+#ifdef OS_OHOS
+#include "display_manager_adapter.h"
+#include "ohos_adapter_helper.h"
+#endif
+
 namespace cc {
 class AnimationHost;
 class Layer;
@@ -770,6 +775,10 @@ class CORE_EXPORT LocalFrameView final
  private:
   LocalFrameView(LocalFrame&, IntRect);
 
+#ifdef OS_OHOS
+  void SetInitalLayoutRatio();
+#endif
+
 #if DCHECK_IS_ON()
   class DisallowLayoutInvalidationScope {
     STACK_ALLOCATED();
@@ -1156,6 +1165,12 @@ class CORE_EXPORT LocalFrameView final
   bool is_updating_descendant_dependent_flags_;
 #endif
 
+#ifdef OS_OHOS
+  std::unique_ptr<OHOS::NWeb::DisplayManagerAdapter>
+      display_manager_adapter_ = nullptr;
+  float initial_layout_size_ratio_ = 2.0;
+#endif
+
   FRIEND_TEST_ALL_PREFIXES(FrameThrottlingTest, ForAllThrottledLocalFrameViews);
 };
 
diff --git a/third_party/blink/renderer/core/frame/visual_viewport.cc b/third_party/blink/renderer/core/frame/visual_viewport.cc
index bc7bddaf916c7..70bbfb0cc5ae3 100644
--- a/third_party/blink/renderer/core/frame/visual_viewport.cc
+++ b/third_party/blink/renderer/core/frame/visual_viewport.cc
@@ -612,7 +612,9 @@ void VisualViewport::InitializeScrollbars() {
   scrollbar_layer_vertical_ = nullptr;
   if (VisualViewportSuppliesScrollbars() &&
       !GetPage().GetSettings().GetHideScrollbars()) {
+#ifndef OS_OHOS
     UpdateScrollbarLayer(kHorizontalScrollbar);
+#endif
     UpdateScrollbarLayer(kVerticalScrollbar);
   }
 
diff --git a/third_party/blink/renderer/core/frame/web_frame_widget_impl.cc b/third_party/blink/renderer/core/frame/web_frame_widget_impl.cc
index ff4df30c505c9..a730769bd0e59 100644
--- a/third_party/blink/renderer/core/frame/web_frame_widget_impl.cc
+++ b/third_party/blink/renderer/core/frame/web_frame_widget_impl.cc
@@ -3716,6 +3716,11 @@ void WebFrameWidgetImpl::NotifyPageScaleFactorChanged(
       page_scale_factor, is_pinch_gesture_active));
 }
 
+void WebFrameWidgetImpl::SetPinchSmoothMode(bool isEnable)
+{
+  widget_base_->LayerTreeHost()->SetPinchSmoothMode(isEnable);
+}
+
 void WebFrameWidgetImpl::SetPageScaleStateAndLimits(
     float page_scale_factor,
     bool is_pinch_gesture_active,
diff --git a/third_party/blink/renderer/core/frame/web_frame_widget_impl.h b/third_party/blink/renderer/core/frame/web_frame_widget_impl.h
index 59d85d7fc7c6a..139b126776d67 100644
--- a/third_party/blink/renderer/core/frame/web_frame_widget_impl.h
+++ b/third_party/blink/renderer/core/frame/web_frame_widget_impl.h
@@ -525,6 +525,7 @@ class CORE_EXPORT WebFrameWidgetImpl
                                   bool is_pinch_gesture_active,
                                   float minimum,
                                   float maximum);
+  void SetPinchSmoothMode(bool isEnable);
   void UpdateViewportDescription(
       const ViewportDescription& viewport_description);
 
diff --git a/third_party/blink/renderer/core/layout/layout_video.cc b/third_party/blink/renderer/core/layout/layout_video.cc
index 284b62d03566c..8b69f44cf162e 100644
--- a/third_party/blink/renderer/core/layout/layout_video.cc
+++ b/third_party/blink/renderer/core/layout/layout_video.cc
@@ -28,6 +28,9 @@
 #include "third_party/blink/renderer/core/dom/document.h"
 #include "third_party/blink/renderer/core/html/media/html_video_element.h"
 #include "third_party/blink/renderer/core/paint/video_painter.h"
+#if defined(OS_OHOS)
+#include "cef/libcef/common/soc_perf_util.h"
+#endif
 
 namespace blink {
 
@@ -38,10 +41,17 @@ const float kInitEffectZoom = 1.0f;
 }  // namespace
 
 LayoutVideo::LayoutVideo(HTMLVideoElement* video) : LayoutMedia(video) {
+#if defined(OS_OHOS)
+  soc_perf::video_layout_num++;
+#endif
   SetIntrinsicSize(CalculateIntrinsicSize(kInitEffectZoom));
 }
 
-LayoutVideo::~LayoutVideo() = default;
+LayoutVideo::~LayoutVideo() {
+#if defined(OS_OHOS)
+  soc_perf::video_layout_num--;
+#endif
+}
 
 LayoutSize LayoutVideo::DefaultSize() {
   return LayoutSize(kDefaultWidth, kDefaultHeight);
diff --git a/third_party/blink/renderer/core/paint/paint_timing.cc b/third_party/blink/renderer/core/paint/paint_timing.cc
index b5541a007a7a4..82e35a5cab54f 100644
--- a/third_party/blink/renderer/core/paint/paint_timing.cc
+++ b/third_party/blink/renderer/core/paint/paint_timing.cc
@@ -9,6 +9,7 @@
 
 #include "base/metrics/histogram_macros.h"
 #include "base/time/default_tick_clock.h"
+#include "base/trace_event/trace_event.h"
 #include "third_party/blink/renderer/core/dom/document.h"
 #include "third_party/blink/renderer/core/dom/frame_request_callback_collection.h"
 #include "third_party/blink/renderer/core/frame/local_dom_window.h"
@@ -104,6 +105,7 @@ void PaintTiming::MarkFirstPaint() {
   // markFirstPaint().
   if (!first_paint_.is_null())
     return;
+  TRACE_EVENT0("blink", "FirstPaint");
   SetFirstPaint(clock_->NowTicks());
 }
 
@@ -114,6 +116,7 @@ void PaintTiming::MarkFirstContentfulPaint() {
   // markFirstContentfulPaint().
   if (!first_contentful_paint_.is_null())
     return;
+  TRACE_EVENT0("blink", "FirstContentfulPaint");
   SetFirstContentfulPaint(clock_->NowTicks());
 }
 
@@ -121,6 +124,7 @@ void PaintTiming::MarkFirstImagePaint() {
   if (!first_image_paint_.is_null())
     return;
   first_image_paint_ = clock_->NowTicks();
+  TRACE_EVENT0("blink", "FirstImagePaint");
   SetFirstContentfulPaint(first_image_paint_);
   RegisterNotifyPresentationTime(PaintEvent::kFirstImagePaint);
 }
diff --git a/third_party/blink/renderer/modules/managed_device/device_service.cc b/third_party/blink/renderer/modules/managed_device/device_service.cc
index c49b7b24f65c4..398183103c2e2 100644
--- a/third_party/blink/renderer/modules/managed_device/device_service.cc
+++ b/third_party/blink/renderer/modules/managed_device/device_service.cc
@@ -18,7 +18,7 @@ namespace blink {
 namespace {
 
 const char kNotHighTrustedAppExceptionMessage[] =
-    "This API is available only for high trusted apps.";
+    "This API is available only for managed apps.";
 
 }  // namespace
 
@@ -40,6 +40,7 @@ DeviceService* DeviceService::managed(Navigator& navigator) {
 DeviceService::DeviceService(Navigator& navigator)
     : Supplement<Navigator>(navigator),
       device_api_service_(navigator.DomWindow()),
+      managed_configuration_service_(navigator.DomWindow()),
       configuration_observer_(this, navigator.DomWindow()) {}
 
 const AtomicString& DeviceService::InterfaceName() const {
@@ -62,6 +63,7 @@ void DeviceService::Trace(Visitor* visitor) const {
   Supplement<Navigator>::Trace(visitor);
 
   visitor->Trace(device_api_service_);
+  visitor->Trace(managed_configuration_service_);
   visitor->Trace(pending_promises_);
   visitor->Trace(configuration_observer_);
 }
@@ -80,6 +82,21 @@ mojom::blink::DeviceAPIService* DeviceService::GetService() {
   return device_api_service_.get();
 }
 
+mojom::blink::ManagedConfigurationService*
+DeviceService::GetManagedConfigurationService() {
+  if (!managed_configuration_service_.is_bound()) {
+    GetExecutionContext()->GetBrowserInterfaceBroker().GetInterface(
+        managed_configuration_service_.BindNewPipeAndPassReceiver(
+            GetExecutionContext()->GetTaskRunner(TaskType::kMiscPlatformAPI)));
+    // The access status of Device API can change dynamically. Hence, we have to
+    // properly handle cases when we are losing this access.
+    managed_configuration_service_.set_disconnect_handler(WTF::Bind(
+        &DeviceService::OnServiceConnectionError, WrapWeakPersistent(this)));
+  }
+
+  return managed_configuration_service_.get();
+}
+
 void DeviceService::OnServiceConnectionError() {
   device_api_service_.reset();
   // Resolve all pending promises with a failure.
@@ -96,9 +113,9 @@ ScriptPromise DeviceService::getManagedConfiguration(ScriptState* script_state,
   pending_promises_.insert(resolver);
 
   ScriptPromise promise = resolver->Promise();
-  GetService()->GetManagedConfiguration(
-      keys, Bind(&DeviceService::OnConfigurationReceived,
-                 WrapWeakPersistent(this), WrapPersistent(resolver)));
+  GetManagedConfigurationService()->GetManagedConfiguration(
+      keys, WTF::Bind(&DeviceService::OnConfigurationReceived,
+                      WrapWeakPersistent(this), WrapPersistent(resolver)));
   return promise;
 }
 
@@ -204,7 +221,7 @@ void DeviceService::AddedEventListener(
                                                 registered_listener);
   if (event_type == event_type_names::kManagedconfigurationchange) {
     if (!configuration_observer_.is_bound()) {
-      GetService()->SubscribeToManagedConfiguration(
+      GetManagedConfigurationService()->SubscribeToManagedConfiguration(
           configuration_observer_.BindNewPipeAndPassRemote(
               GetExecutionContext()->GetTaskRunner(
                   TaskType::kMiscPlatformAPI)));
diff --git a/third_party/blink/renderer/modules/managed_device/device_service.h b/third_party/blink/renderer/modules/managed_device/device_service.h
index 91191dcf3b43d..2f4f18defdbe4 100644
--- a/third_party/blink/renderer/modules/managed_device/device_service.h
+++ b/third_party/blink/renderer/modules/managed_device/device_service.h
@@ -81,12 +81,18 @@ class MODULES_EXPORT DeviceService final
   // Lazily binds mojo interface.
   mojom::blink::DeviceAPIService* GetService();
 
+  // Lazily binds mojo interface.
+  mojom::blink::ManagedConfigurationService* GetManagedConfigurationService();
+
   void OnServiceConnectionError();
   void StopObserving();
 
   HeapMojoRemote<mojom::blink::DeviceAPIService,
                  HeapMojoWrapperMode::kWithoutContextObserver>
       device_api_service_;
+  HeapMojoRemote<mojom::blink::ManagedConfigurationService>
+      managed_configuration_service_;
+
   HeapMojoReceiver<mojom::blink::ManagedConfigurationObserver, DeviceService>
       configuration_observer_;
   HeapHashSet<Member<ScriptPromiseResolver>> pending_promises_;
diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index 86415db444bd7..00666c5ff35d8 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -8310,6 +8310,22 @@ bool WebGLRenderingContextBase::ValidateUniformMatrixParameters(
     SynthesizeGLError(GL_INVALID_VALUE, function_name, "invalid size");
     return false;
   }
+  // By design the command buffer has an internal (signed) 32-bit
+  // limit, so ensure that the amount of data passed down to it
+  // doesn't exceed what it can handle. Only integer or float typed
+  // arrays can be passed into the uniform*v or uniformMatrix*v
+  // functions; each has 4-byte elements.
+  base::CheckedNumeric<int32_t> total_size(actual_size);
+  total_size *= 4;
+  // Add on a fixed constant to account for internal metadata in the
+  // command buffer.
+  constexpr int32_t kExtraCommandSize = 1024;
+  total_size += kExtraCommandSize;
+  if (!total_size.IsValid()) {
+    SynthesizeGLError(GL_INVALID_VALUE, function_name,
+                      "size * elementSize, plus a constant, is too large");
+    return false;
+  }
   return true;
 }
 
diff --git a/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc b/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc
index f79c81b8ca2a9..0b3905bc5252c 100644
--- a/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc
+++ b/third_party/blink/renderer/modules/webgpu/gpu_buffer.cc
@@ -305,7 +305,8 @@ void GPUBuffer::ResetMappingState(ScriptState* script_state) {
 
     // |did_detach| would be false if the buffer were already detached.
     DCHECK(did_detach);
-    DCHECK(array_buffer->IsDetached());
+    // TODO(crbug.com/1326210): Temporary CHECK to prevent aliased array buffers.
+    CHECK(array_buffer->IsDetached());
   }
   mapped_array_buffers_.clear();
 }
diff --git a/third_party/blink/renderer/modules/webshare/DEPS b/third_party/blink/renderer/modules/webshare/DEPS
new file mode 100644
index 0000000000000..35ef53d44a7a8
--- /dev/null
+++ b/third_party/blink/renderer/modules/webshare/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+    "+base/files/safe_base_name.h",
+]
\ No newline at end of file
diff --git a/third_party/blink/renderer/modules/webshare/navigator_share.cc b/third_party/blink/renderer/modules/webshare/navigator_share.cc
index 92edaca748aac..651ee4106c707 100644
--- a/third_party/blink/renderer/modules/webshare/navigator_share.cc
+++ b/third_party/blink/renderer/modules/webshare/navigator_share.cc
@@ -7,10 +7,12 @@
 #include <stdint.h>
 #include <utility>
 
+#include "base/files/safe_base_name.h"
 #include "build/build_config.h"
 #include "third_party/blink/public/common/browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/devtools/console_message.mojom-blink.h"
 #include "third_party/blink/public/mojom/permissions_policy/permissions_policy_feature.mojom-blink.h"
+#include "third_party/blink/public/platform/file_path_conversion.h"
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_share_data.h"
 #include "third_party/blink/renderer/core/dom/dom_exception.h"
@@ -274,9 +276,20 @@ ScriptPromise NavigatorShare::share(ScriptState* script_state,
   if (has_files) {
     files.ReserveInitialCapacity(data->files().size());
     for (const blink::Member<blink::File>& file : data->files()) {
+      absl::optional<base::SafeBaseName> name =
+          base::SafeBaseName::Create(StringToFilePath(file->name()));
+      if (!name) {
+        execution_context->AddConsoleMessage(
+            mojom::blink::ConsoleMessageSource::kJavaScript,
+            mojom::blink::ConsoleMessageLevel::kWarning, "Unsafe file name");
+        exception_state.ThrowDOMException(DOMExceptionCode::kNotAllowedError,
+                                          "Permission denied");
+        return ScriptPromise();
+      }
+
       total_bytes += file->size();
-      files.push_back(mojom::blink::SharedFile::New(file->name(),
-                                                    file->GetBlobDataHandle()));
+      files.push_back(
+          mojom::blink::SharedFile::New(*name, file->GetBlobDataHandle()));
     }
 
     if (files.size() > kMaxSharedFileCount ||
diff --git a/third_party/blink/renderer/modules/webshare/navigator_share_test.cc b/third_party/blink/renderer/modules/webshare/navigator_share_test.cc
index f7efe9572f7b9..6c38ef078a9ee 100644
--- a/third_party/blink/renderer/modules/webshare/navigator_share_test.cc
+++ b/third_party/blink/renderer/modules/webshare/navigator_share_test.cc
@@ -8,6 +8,7 @@
 #include <utility>
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/file_path_conversion.h"
 #include "third_party/blink/renderer/bindings/core/v8/script_promise.h"
 #include "third_party/blink/renderer/bindings/core/v8/v8_file_property_bag.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_share_data.h"
@@ -181,7 +182,8 @@ TEST_F(NavigatorShareTest, ShareFile) {
   Share(share_data);
 
   EXPECT_EQ(mock_share_service().files().size(), 1U);
-  EXPECT_EQ(mock_share_service().files()[0]->name, file_name);
+  EXPECT_EQ(mock_share_service().files()[0]->name.path(),
+            StringToFilePath(file_name));
   EXPECT_EQ(mock_share_service().files()[0]->blob->GetType(), content_type);
   EXPECT_EQ(mock_share_service().files()[0]->blob->size(),
             file_contents.length());
diff --git a/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.cc b/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.cc
index add9bfb248c16..c87a46424daa9 100644
--- a/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.cc
+++ b/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.cc
@@ -17,6 +17,9 @@
 #include "third_party/blink/renderer/platform/widget/input/frame_widget_input_handler_impl.h"
 #include "third_party/blink/renderer/platform/widget/input/widget_input_handler_manager.h"
 #include "third_party/blink/renderer/platform/widget/widget_base.h"
+#if defined(OS_OHOS)
+#include "cef/libcef/common/soc_perf_util.h"
+#endif
 
 namespace blink {
 
@@ -134,6 +137,12 @@ void WidgetInputHandlerImpl::DispatchEvent(
   input_handler_manager_->DispatchEvent(std::move(event), std::move(callback));
 }
 
+#if defined(OS_OHOS)
+void WidgetInputHandlerImpl::StartFling() {
+  soc_perf::SocPerUtil::ApplySocConfig();
+}
+#endif
+
 void WidgetInputHandlerImpl::DispatchNonBlockingEvent(
     std::unique_ptr<WebCoalescedInputEvent> event) {
   TRACE_EVENT0("input", "WidgetInputHandlerImpl::DispatchNonBlockingEvent");
diff --git a/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.h b/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.h
index dfd96239ada16..6a1fbe176b0f5 100644
--- a/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.h
+++ b/third_party/blink/renderer/platform/widget/input/widget_input_handler_impl.h
@@ -58,6 +58,9 @@ class WidgetInputHandlerImpl : public mojom::blink::WidgetInputHandler {
                                  bool monitor_request) override;
   void DispatchEvent(std::unique_ptr<WebCoalescedInputEvent>,
                      DispatchEventCallback callback) override;
+#if defined(OS_OHOS)
+  void StartFling() override;
+#endif
   void DispatchNonBlockingEvent(
       std::unique_ptr<WebCoalescedInputEvent>) override;
   void WaitForInputProcessed(WaitForInputProcessedCallback callback) override;
diff --git a/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py b/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
index c7e3e7c59d1e4..f6b13896401cf 100755
--- a/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
+++ b/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
@@ -1130,6 +1130,14 @@ _CONFIG = [
             'webrtc::kAdmMaxGuidSize',
         ]
     },
+    {
+        'paths': [
+            'third_party/blink/renderer/modules/webshare/',
+        ],
+        'allowed': [
+            'base::SafeBaseName',
+        ]
+    },
     {
         'paths': [
             'third_party/blink/renderer/platform/',
diff --git a/third_party/blink/web_tests/external/wpt/html/cross-origin-opener-policy/coop-popup-opener-navigates.https.html b/third_party/blink/web_tests/external/wpt/html/cross-origin-opener-policy/coop-popup-opener-navigates.https.html
new file mode 100644
index 0000000000000..a6c63654a948b
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/html/cross-origin-opener-policy/coop-popup-opener-navigates.https.html
@@ -0,0 +1,84 @@
+<!doctype html>
+<title>
+    Cross-Origin-Opener-Policy: opener is lost because the opener navigates.
+</title>
+<!--
+    COOP tests usually assume that the opener is lost because it navigated to a
+    page that triggered a browsing context group swap. It can also happen when
+    the opener navigates instead. This test verifies the behavior.
+-->
+<script src=/resources/testharness.js></script>
+<script src=/resources/testharnessreport.js></script>
+<script src="/common/dispatcher/dispatcher.js"></script>
+<script src="/common/get-host-info.sub.js"></script>
+<script src="/common/utils.js"></script>
+<script src="resources/common.js"></script>
+<script>
+
+const executor_path = "/common/dispatcher/executor.html?pipe=";
+const coop_same_origin_header =
+    '|header(Cross-Origin-Opener-Policy,same-origin)';
+const coop_unsafe_none_header =
+    '|header(Cross-Origin-Opener-Policy,unsafe-none)';
+
+function getExecutorPath(uuid, origin, coop_header) {
+    return origin.origin + executor_path + coop_header  + `&uuid=${uuid}`;
+}
+
+// Note: Because we can not navigate the main page to verify the behavior,
+// we instead create another layer of popup, and navigate the intermediate
+// one. We can verify the opener behavior from this page, and the openee
+// behavior from the second popup.
+promise_test(async t => {
+  // Set up dispatcher communications.
+  const first_popup_token = token();
+  const post_navigate_first_popup_token = token();
+  const second_popup_token = token();
+  const reply_token = token();
+
+  const first_popup_url = getExecutorPath(
+    first_popup_token,
+    SAME_ORIGIN,
+    coop_same_origin_header);
+
+  const post_navigate_first_popup_url = getExecutorPath(
+    post_navigate_first_popup_token,
+    SAME_ORIGIN,
+    coop_unsafe_none_header);
+
+  const second_popup_url = getExecutorPath(
+    second_popup_token,
+    SAME_ORIGIN,
+    coop_same_origin_header);
+
+  // We open the first popup and then ping it, it will respond after loading.
+  const first_popup = window.open(first_popup_url);
+  send(first_popup_token, `send('${reply_token}', 'Popup loaded');`);
+  assert_equals(await receive(reply_token), "Popup loaded");
+
+  // We open the second popup and the ping it, it will respond after loading.
+  send(first_popup_token,
+      `opener.second_popup_url = window.open('${second_popup_url}');`);
+  send(second_popup_token, `send('${reply_token}', 'Popup loaded');`);
+  assert_equals(await receive(reply_token), "Popup loaded");
+
+  // Both popups are now loaded. We navigate the middle one to a page that
+  // does not have COOP, this should trigger a browsing context group swap.
+  send(first_popup_token, `location.href = '${post_navigate_first_popup_url}'`);
+  send(post_navigate_first_popup_token,
+    `send('${reply_token}', 'Popup navigated');`);
+  assert_equals(await receive(reply_token), "Popup navigated");
+
+  // Give some time for things to settle across processes etc. before
+  // proceeding with verifications.
+  await new Promise((resolve, reject) => { t.step_timeout(resolve, 1500); });
+
+  // The reference held by the main page to the first popup should be closed.
+  assert_equals(first_popup.closed, true);
+
+  // The second popup, opened by the first one should have its opener unset.
+  send(second_popup_token, `send('${reply_token}', opener);`);
+  assert_equals(await receive(reply_token), "");
+
+}, "Verify that having the opener navigate instead of the openee also triggers COOP swaps.");
+ </script>
diff --git a/third_party/blink/web_tests/external/wpt/html/cross-origin-opener-policy/coop-popup-opener-navigates.https.html.headers b/third_party/blink/web_tests/external/wpt/html/cross-origin-opener-policy/coop-popup-opener-navigates.https.html.headers
new file mode 100644
index 0000000000000..46ad58d83bf6e
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/html/cross-origin-opener-policy/coop-popup-opener-navigates.https.html.headers
@@ -0,0 +1 @@
+Cross-Origin-Opener-Policy: same-origin
diff --git a/third_party/devtools-frontend/src/front_end/panels/accessibility/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/accessibility/BUILD.gn
index b4cf3f98a1af8..87da2c2faa41f 100644
--- a/third_party/devtools-frontend/src/front_end/panels/accessibility/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/accessibility/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("accessibility") {
   sources = [
@@ -31,6 +32,13 @@ devtools_entrypoint("bundle") {
   entrypoint = "accessibility.ts"
 
   deps = [ ":accessibility" ]
+
+  visibility = [
+    ":*",
+    "../../entrypoints/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/animation/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/animation/BUILD.gn
index 18f57b81dd4bb..a9c73ffe1e314 100644
--- a/third_party/devtools-frontend/src/front_end/panels/animation/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/animation/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("animation") {
   sources = [
@@ -29,6 +30,14 @@ devtools_entrypoint("bundle") {
   entrypoint = "animation.ts"
 
   deps = [ ":animation" ]
+
+  visibility = [
+    ":*",
+    "../../../test/unittests/front_end/panels/animation/*",
+    "../../entrypoints/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/browser_debugger/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/browser_debugger/BUILD.gn
index 47211b342a212..d999e10d1c54e 100644
--- a/third_party/devtools-frontend/src/front_end/panels/browser_debugger/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/browser_debugger/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("browser_debugger") {
   sources = [
@@ -30,6 +31,14 @@ devtools_entrypoint("bundle") {
   entrypoint = "browser_debugger.ts"
 
   deps = [ ":browser_debugger" ]
+
+  visibility = [
+    ":*",
+    "../../../test/unittests/front_end/entrypoints/missing_entrypoints/*",
+    "../../entrypoints/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/changes/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/changes/BUILD.gn
index 60e056a271263..4907c50fddd4b 100644
--- a/third_party/devtools-frontend/src/front_end/panels/changes/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/changes/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("changes") {
   sources = [
@@ -29,6 +30,14 @@ devtools_entrypoint("bundle") {
   entrypoint = "changes.ts"
 
   deps = [ ":changes" ]
+
+  visibility = [
+    ":*",
+    "../../../test/unittests/front_end/entrypoints/missing_entrypoints/*",
+    "../../entrypoints/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/console/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/console/BUILD.gn
index c802af9651252..3e93360f9f707 100644
--- a/third_party/devtools-frontend/src/front_end/panels/console/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/console/BUILD.gn
@@ -4,11 +4,13 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("console") {
   sources = [
     "ConsoleContextSelector.ts",
     "ConsoleFilter.ts",
+    "ConsoleFormat.ts",
     "ConsolePanel.ts",
     "ConsolePinPane.ts",
     "ConsolePrompt.ts",
@@ -52,6 +54,15 @@ devtools_entrypoint("bundle") {
   entrypoint = "console.ts"
 
   deps = [ ":console" ]
+
+  visibility = [
+    ":*",
+    "../../../test/unittests/front_end/entrypoints/missing_entrypoints/*",
+    "../../../test/unittests/front_end/panels/console/*",
+    "../../entrypoints/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/console/ConsoleFormat.ts b/third_party/devtools-frontend/src/front_end/panels/console/ConsoleFormat.ts
new file mode 100644
index 0000000000000..45047f275fff4
--- /dev/null
+++ b/third_party/devtools-frontend/src/front_end/panels/console/ConsoleFormat.ts
@@ -0,0 +1,178 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import type * as SDK from '../../sdk/sdk.js';
+
+// TODO(crbug/1282837): This is too naive and doesn't support
+// most (anticipated) uses of the ANSI color sequences (i.e.
+// setting both foreground and background color).
+const ANSI_COLOR_CODES = new Map([
+  // Foreground codes
+  [30, 'color:black'],
+  [31, 'color:red'],
+  [32, 'color:green'],
+  [33, 'color:yellow'],
+  [34, 'color:blue'],
+  [35, 'color:magenta'],
+  [36, 'color:cyan'],
+  [37, 'color:lightGray'],
+  [39, 'color:default'],
+  [90, 'color:darkGray'],
+  [91, 'color:lightRed'],
+  [92, 'color:lightGreen'],
+  [93, 'color:lightYellow'],
+  [94, 'color:lightBlue'],
+  [95, 'color:lightMagenta'],
+  [96, 'color:lightCyan'],
+  [97, 'color:white'],
+  // Background codes
+  [40, 'background:black'],
+  [41, 'background:red'],
+  [42, 'background:green'],
+  [43, 'background:yellow'],
+  [44, 'background:blue'],
+  [45, 'background:magenta'],
+  [46, 'background:cyan'],
+  [47, 'background:lightGray'],
+  [49, 'background:default'],
+  [100, 'background:darkGray'],
+  [101, 'background:lightRed'],
+  [102, 'background:lightGreen'],
+  [103, 'background:lightYellow'],
+  [104, 'background:lightBlue'],
+  [105, 'background:lightMagenta'],
+  [106, 'background:lightCyan'],
+  [107, 'background:white'],
+]);
+
+export type FormatToken = {
+  type: 'generic'|'optimal',
+  value: SDK.RemoteObject.RemoteObject,
+}|{
+  type: 'string' | 'style',
+  value: string,
+};
+
+/**
+ * This is the front-end part of the Formatter function specified in the
+ * Console Standard (https://console.spec.whatwg.org/#formatter). Here we
+ * assume that all type conversions have already happened in V8 before and
+ * are only concerned with performing the actual substitutions and dealing
+ * with generic and optimal object formatting as well as styling.
+ *
+ * @param fmt the format string.
+ * @param args the substitution arguments for `fmt`.
+ * @returns a list of `FormatToken`s as well as the unused arguments.
+ */
+export const format = (fmt: string, args: SDK.RemoteObject.RemoteObject[]): {
+  tokens: FormatToken[],
+  args: SDK.RemoteObject.RemoteObject[],
+} => {
+  const tokens: FormatToken[] = [];
+
+  function addStringToken(value: string): void {
+    if (!value) {
+      return;
+    }
+    if (tokens.length && tokens[tokens.length - 1].type === 'string') {
+      tokens[tokens.length - 1].value += value;
+      return;
+    }
+    tokens.push({type: 'string', value});
+  }
+
+  let argIndex = 0;
+  const re = /%([%_Oocsdfi])|\x1B\[(\d+)m/;
+  for (let match = re.exec(fmt); match !== null; match = re.exec(fmt)) {
+    addStringToken(match.input.substring(0, match.index));
+    let substitution: number|string|undefined = undefined;
+    const specifier = match[1];
+    switch (specifier) {
+      case '%':
+        addStringToken('%');
+        substitution = '';
+        break;
+      case 's':
+        if (argIndex < args.length) {
+          const {description} = args[argIndex++];
+          substitution = description ?? '';
+        }
+        break;
+      case 'c':
+        if (argIndex < args.length) {
+          const type = 'style';
+          const value = args[argIndex++].description ?? '';
+          tokens.push({type, value});
+          substitution = '';
+        }
+        break;
+      case 'o':
+      case 'O':
+        if (argIndex < args.length) {
+          const type = specifier === 'O' ? 'generic' : 'optimal';
+          const value = args[argIndex++];
+          tokens.push({type, value});
+          substitution = '';
+        }
+        break;
+      case '_':
+        if (argIndex < args.length) {
+          argIndex++;
+          substitution = '';
+        }
+        break;
+      case 'd':
+      case 'f':
+      case 'i':
+        if (argIndex < args.length) {
+          const {value} = args[argIndex++];
+          substitution = typeof value !== 'number' ? NaN : value;
+          if (specifier !== 'f') {
+            substitution = Math.floor(substitution);
+          }
+        }
+        break;
+      case undefined: {
+        const value = ANSI_COLOR_CODES.get(parseInt(match[2], 10));
+        if (value !== undefined) {
+          const type = 'style';
+          tokens.push({type, value});
+          substitution = '';
+        }
+        break;
+      }
+    }
+    if (substitution === undefined) {
+      // If there's no substitution, emit the original specifier / sequence verbatim.
+      addStringToken(match[0]);
+      substitution = '';
+    }
+    fmt = substitution + match.input.substring(match.index + match[0].length);
+  }
+  addStringToken(fmt);
+  return {tokens, args: args.slice(argIndex)};
+};
+
+export const updateStyle = (currentStyle: Map<string, {value: string, priority: string}>, styleToAdd: string): void => {
+  const ALLOWED_PROPERTY_PREFIXES = ['background', 'border', 'color', 'font', 'line', 'margin', 'padding', 'text'];
+  const BLOCKED_URL_SCHEMES = ['chrome', 'resource', 'about', 'app', 'http', 'https', 'ftp', 'file'];
+
+  currentStyle.clear();
+  const buffer = document.createElement('span');
+  buffer.setAttribute('style', styleToAdd);
+  for (const property of buffer.style) {
+    if (!ALLOWED_PROPERTY_PREFIXES.some(
+            prefix => property.startsWith(prefix) || property.startsWith(`-webkit-${prefix}`))) {
+      continue;
+    }
+    const value = buffer.style.getPropertyValue(property);
+    if (BLOCKED_URL_SCHEMES.some(scheme => value.includes(scheme + ':'))) {
+      continue;
+    }
+    currentStyle.set(property, {
+      value,
+      priority: buffer.style.getPropertyPriority(property),
+    });
+  }
+};
diff --git a/third_party/devtools-frontend/src/front_end/panels/console/ConsoleViewMessage.ts b/third_party/devtools-frontend/src/front_end/panels/console/ConsoleViewMessage.ts
index 31ee82513236f..aff01218593ca 100644
--- a/third_party/devtools-frontend/src/front_end/panels/console/ConsoleViewMessage.ts
+++ b/third_party/devtools-frontend/src/front_end/panels/console/ConsoleViewMessage.ts
@@ -46,6 +46,7 @@ import * as TextUtils from '../../text_utils/text_utils.js';
 import * as ThemeSupport from '../../theme_support/theme_support.js';
 import * as UI from '../../ui/ui.js';
 
+import {format, updateStyle} from './ConsoleFormat.js';
 import type {ConsoleViewportElement} from './ConsoleViewport.js';
 
 const UIStrings = {
@@ -528,9 +529,8 @@ export class ConsoleViewMessage implements ConsoleViewportElement {
 
     // Multiple parameters with the first being a format string. Save unused substitutions.
     if (shouldFormatMessage) {
-      const result = this._formatWithSubstitutionString(
+      parameters = this._formatWithSubstitutionString(
           (parameters[0].description as string), parameters.slice(1), formattedResult);
-      parameters = Array.from(result.unusedSubstitutions || []);
       if (parameters.length) {
         UI.UIUtils.createTextChild(formattedResult, ' ');
       }
@@ -811,169 +811,49 @@ export class ConsoleViewMessage implements ConsoleViewportElement {
   }
 
   _formatWithSubstitutionString(
-      format: string, parameters: SDK.RemoteObject.RemoteObject[], formattedResult: HTMLElement): {
-    formattedResult: Element,
-    unusedSubstitutions: ArrayLike<SDK.RemoteObject.RemoteObject>|null,
-  } {
-    function parameterFormatter(
-        this: ConsoleViewMessage, force: boolean, includePreview: boolean,
-        obj?: string|SDK.RemoteObject.RemoteObject): string|HTMLElement|undefined {
-      if (obj instanceof SDK.RemoteObject.RemoteObject) {
-        return this._formatParameter(obj, force, includePreview);
-      }
-      return stringFormatter(obj);
-    }
-
-    function stringFormatter(obj?: string|SDK.RemoteObject.RemoteObject): string|undefined {
-      if (obj === undefined) {
-        return undefined;
-      }
-      if (typeof obj === 'string') {
-        return obj;
-      }
-      return obj.description;
-    }
-
-    function floatFormatter(obj?: string|SDK.RemoteObject.RemoteObject): number|string|undefined {
-      if (obj instanceof SDK.RemoteObject.RemoteObject) {
-        if (typeof obj.value !== 'number') {
-          return 'NaN';
-        }
-        return obj.value;
-      }
-      return undefined;
-    }
-
-    function integerFormatter(obj?: string|SDK.RemoteObject.RemoteObject): string|number|undefined {
-      if (obj instanceof SDK.RemoteObject.RemoteObject) {
-        if (obj.type === 'bigint') {
-          return obj.description;
-        }
-        if (typeof obj.value !== 'number') {
-          return 'NaN';
-        }
-        return Math.floor(obj.value);
-      }
-      return undefined;
-    }
-
-    function bypassFormatter(obj?: string|SDK.RemoteObject.RemoteObject): Node|string {
-      return (obj instanceof Node) ? obj : '';
-    }
-
-    let currentStyle: Map<string, {value: string, priority: string}>|null = null;
-    function styleFormatter(obj?: string|SDK.RemoteObject.RemoteObject): void {
-      currentStyle = new Map();
-      const buffer = document.createElement('span');
-      if (obj === undefined) {
-        return;
-      }
-      if (typeof obj === 'string' || !obj.description) {
-        return;
-      }
-      buffer.setAttribute('style', obj.description);
-      for (const property of buffer.style) {
-        if (isAllowedProperty(property)) {
-          const info = {
-            value: buffer.style.getPropertyValue(property),
-            priority: buffer.style.getPropertyPriority(property),
-          };
-          currentStyle.set(property, info);
+      formatString: string, parameters: SDK.RemoteObject.RemoteObject[],
+      formattedResult: HTMLElement): SDK.RemoteObject.RemoteObject[] {
+    const currentStyle = new Map();
+    const {tokens, args} = format(formatString, parameters);
+    for (const token of tokens) {
+      switch (token.type) {
+        case 'generic': {
+          formattedResult.append(this._formatParameter(token.value, true /* force */, false /* includePreview */));
+          break;
         }
-      }
-    }
-
-    function isAllowedProperty(property: string): boolean {
-      // Make sure that allowed properties do not interfere with link visibility.
-      const prefixes = [
-        'background',
-        'border',
-        'color',
-        'font',
-        'line',
-        'margin',
-        'padding',
-        'text',
-        '-webkit-background',
-        '-webkit-border',
-        '-webkit-font',
-        '-webkit-margin',
-        '-webkit-padding',
-        '-webkit-text',
-      ];
-      for (const prefix of prefixes) {
-        if (property.startsWith(prefix)) {
-          return true;
+        case 'optimal': {
+          formattedResult.append(this._formatParameter(token.value, false /* force */, true /* includePreview */));
+          break;
         }
-      }
-      return false;
-    }
-
-    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    const formatters: Record<string, Platform.StringUtilities.FormatterFunction<any>> = {};
-    // Firebug uses %o for formatting objects.
-    formatters.o = parameterFormatter.bind(this, false /* force */, true /* includePreview */);
-    formatters.s = stringFormatter;
-    formatters.f = floatFormatter;
-    // Firebug allows both %i and %d for formatting integers.
-    formatters.i = integerFormatter;
-    formatters.d = integerFormatter;
-
-    // Firebug uses %c for styling the message.
-    formatters.c = styleFormatter;
-
-    // Support %O to force object formatting, instead of the type-based %o formatting.
-    formatters.O = parameterFormatter.bind(this, true /* force */, false /* includePreview */);
-
-    formatters._ = bypassFormatter;
-
-    function append(this: ConsoleViewMessage, a: HTMLElement, b?: string|Node): HTMLElement {
-      if (b instanceof Node) {
-        a.appendChild(b);
-        return a;
-      }
-      if (typeof b === 'undefined') {
-        return a;
-      }
-      if (!currentStyle) {
-        a.appendChild(this._linkifyStringAsFragment(String(b)));
-        return a;
-      }
-      const lines = String(b).split('\n');
-      for (let i = 0; i < lines.length; i++) {
-        const line = lines[i];
-        const lineFragment = this._linkifyStringAsFragment(line);
-        const wrapper = (document.createElement('span') as HTMLElement);
-        wrapper.style.setProperty('contain', 'paint');
-        wrapper.style.setProperty('display', 'inline-block');
-        wrapper.style.setProperty('max-width', '100%');
-        wrapper.appendChild(lineFragment);
-        applyCurrentStyle(wrapper);
-        for (const child of wrapper.children) {
-          if (child.classList.contains('devtools-link') && child instanceof HTMLElement) {
-            this._applyForcedVisibleStyle(child);
+        case 'string': {
+          if (currentStyle.size === 0) {
+            formattedResult.append(this._linkifyStringAsFragment(token.value));
+          } else {
+            const lines = token.value.split('\n');
+            for (let i = 0; i < lines.length; i++) {
+              if (i > 0) {
+                formattedResult.append(document.createElement('br'));
+              }
+              const wrapper = document.createElement('span');
+              wrapper.style.setProperty('contain', 'paint');
+              wrapper.style.setProperty('display', 'inline-block');
+              wrapper.style.setProperty('max-width', '100%');
+              wrapper.appendChild(this._linkifyStringAsFragment(lines[i]));
+              for (const [property, {value, priority}] of currentStyle) {
+                wrapper.style.setProperty(property, value, priority);
+              }
+              formattedResult.append(wrapper);
+            }
           }
+          break;
         }
-        a.appendChild(wrapper);
-        if (i < lines.length - 1) {
-          a.appendChild(document.createElement('br'));
-        }
-      }
-      return a;
-    }
-
-    function applyCurrentStyle(element: HTMLElement): void {
-      if (!currentStyle) {
-        return;
-      }
-      for (const [property, {value, priority}] of currentStyle.entries()) {
-        element.style.setProperty((property as string), value, priority);
+        case 'style':
+          // Make sure that allowed properties do not interfere with link visibility.
+          updateStyle(currentStyle, token.value);
+          break;
       }
     }
-
-    // Platform.StringUtilities.format does treat formattedResult like a Builder, result is an object.
-    return Platform.StringUtilities.format(format, parameters, formatters, formattedResult, append.bind(this));
+    return args;
   }
 
   _applyForcedVisibleStyle(element: HTMLElement): void {
diff --git a/third_party/devtools-frontend/src/front_end/panels/console/console.ts b/third_party/devtools-frontend/src/front_end/panels/console/console.ts
index 470b2ba96cfe5..548515d9cd44b 100644
--- a/third_party/devtools-frontend/src/front_end/panels/console/console.ts
+++ b/third_party/devtools-frontend/src/front_end/panels/console/console.ts
@@ -4,6 +4,7 @@
 
 import './ConsoleContextSelector.js';
 import './ConsoleFilter.js';
+import './ConsoleFormat.js';
 import './ConsolePinPane.js';
 import './ConsoleSidebar.js';
 import './ConsoleViewport.js';
@@ -14,6 +15,7 @@ import './ConsolePanel.js';
 
 import * as ConsoleContextSelector from './ConsoleContextSelector.js';
 import * as ConsoleFilter from './ConsoleFilter.js';
+import * as ConsoleFormat from './ConsoleFormat.js';
 import * as ConsolePanel from './ConsolePanel.js';
 import * as ConsolePinPane from './ConsolePinPane.js';
 import * as ConsolePrompt from './ConsolePrompt.js';
@@ -25,6 +27,7 @@ import * as ConsoleViewport from './ConsoleViewport.js';
 export {
   ConsoleContextSelector,
   ConsoleFilter,
+  ConsoleFormat,
   ConsolePanel,
   ConsolePinPane,
   ConsolePrompt,
diff --git a/third_party/devtools-frontend/src/front_end/panels/console_counters/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/console_counters/BUILD.gn
index 1c93dda43cd31..8fb0f946fe2cf 100644
--- a/third_party/devtools-frontend/src/front_end/panels/console_counters/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/console_counters/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("console_counters") {
   sources = [
@@ -26,6 +27,22 @@ devtools_entrypoint("bundle") {
   entrypoint = "console_counters.ts"
 
   deps = [ ":console_counters" ]
+
+  visibility = [
+    ":*",
+    "../../../test/unittests/front_end/entrypoints/missing_entrypoints/*",
+    "../../../test/unittests/front_end/panels/console_counters/*",
+    "../../entrypoints/*",
+    "../../legacy_test_runner/*",
+    "../../ui/components/docs/issue_counter/*",
+
+    # TODO(crbug.com/1202788): Remove invalid dependents
+    "../console/*",
+    "../issues/*",
+    "../sources/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/coverage/BUILD.gn b/third_party/devtools-frontend/src/front_end/panels/coverage/BUILD.gn
index cab2626ea6252..e80352219168e 100644
--- a/third_party/devtools-frontend/src/front_end/panels/coverage/BUILD.gn
+++ b/third_party/devtools-frontend/src/front_end/panels/coverage/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("../../../scripts/build/ninja/devtools_entrypoint.gni")
 import("../../../scripts/build/ninja/devtools_module.gni")
+import("../visibility.gni")
 
 devtools_module("coverage") {
   sources = [
@@ -33,6 +34,19 @@ devtools_entrypoint("bundle") {
   entrypoint = "coverage.ts"
 
   deps = [ ":coverage" ]
+
+  visibility = [
+    ":*",
+    "../../../test/unittests/front_end/entrypoints/missing_entrypoints/*",
+    "../../../test/unittests/front_end/panels/coverage/*",
+    "../../entrypoints/*",
+
+    # TODO(crbug.com/1202788): Remove invalid dependents
+    "../sources/*",
+    "../timeline/*",
+  ]
+
+  visibility += devtools_panels_visibility
 }
 
 devtools_entrypoint("legacy") {
diff --git a/third_party/devtools-frontend/src/front_end/panels/visibility.gni b/third_party/devtools-frontend/src/front_end/panels/visibility.gni
new file mode 100644
index 0000000000000..be7029930be0c
--- /dev/null
+++ b/third_party/devtools-frontend/src/front_end/panels/visibility.gni
@@ -0,0 +1,7 @@
+# Copyright 2021 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+declare_args() {
+  devtools_panels_visibility = []
+}
diff --git a/third_party/devtools-frontend/src/test/e2e/console/console-log_test.ts b/third_party/devtools-frontend/src/test/e2e/console/console-log_test.ts
index a45c09df9048a..47b4e119938af 100644
--- a/third_party/devtools-frontend/src/test/e2e/console/console-log_test.ts
+++ b/third_party/devtools-frontend/src/test/e2e/console/console-log_test.ts
@@ -3,10 +3,11 @@
 // found in the LICENSE file.
 
 import {assert} from 'chai';
+import type * as puppeteer from 'puppeteer';
 
-import {getBrowserAndPages, waitForFunction} from '../../shared/helper.js';
+import {activeElement, activeElementAccessibleName, activeElementTextContent, getBrowserAndPages, tabBackward, tabForward, waitForFunction} from '../../shared/helper.js';
 import {describe, it} from '../../shared/mocha-extensions.js';
-import {getStructuredConsoleMessages, navigateToConsoleTab, showVerboseMessages} from '../helpers/console-helpers.js';
+import {CONSOLE_FIRST_MESSAGES_SELECTOR, focusConsolePrompt, getConsoleMessages, getCurrentConsoleMessages, getStructuredConsoleMessages, navigateToConsoleTab, showVerboseMessages, waitForLastConsoleMessageToHaveContent} from '../helpers/console-helpers.js';
 
 /* eslint-disable no-console */
 
@@ -238,4 +239,150 @@ describe('The Console Tab', async () => {
       assert.deepEqual(actualMessages, test.expectedMessages, 'Console message does not match the expected message');
     });
   }
+
+  describe('keyboard navigation', () => {
+    it('can navigate between individual messages', async () => {
+      const {frontend} = getBrowserAndPages();
+      await getConsoleMessages('focus-interaction');
+      await focusConsolePrompt();
+
+      await tabBackward();
+      assert.strictEqual(await activeElementTextContent(), 'focus-interaction.html:9');
+
+      await frontend.keyboard.press('ArrowUp');
+      assert.strictEqual(await activeElementTextContent(), 'focus-interaction.html:9 Third message');
+
+      await frontend.keyboard.press('ArrowUp');
+      assert.strictEqual(await activeElementTextContent(), 'focus-interaction.html:8');
+
+      await frontend.keyboard.press('ArrowDown');
+      assert.strictEqual(await activeElementTextContent(), 'focus-interaction.html:9 Third message');
+
+      await tabBackward();  // Focus should now be on the console settings, e.g. out of the list of console messages
+      assert.strictEqual(await activeElementAccessibleName(), 'Console settings');
+
+      await tabForward();  // Focus is now back to the list, selecting the last message source URL
+      assert.strictEqual(await activeElementTextContent(), 'focus-interaction.html:9');
+
+      await tabForward();
+      assert.strictEqual(await activeElementAccessibleName(), 'Console prompt');
+    });
+
+    it('should not lose focus on prompt when logging and scrolling', async () => {
+      const {target, frontend} = getBrowserAndPages();
+
+      await getConsoleMessages('focus-interaction');
+      await focusConsolePrompt();
+
+      await target.evaluate(() => {
+        console.log('New message');
+      });
+      await waitForLastConsoleMessageToHaveContent('New message');
+      assert.strictEqual(await activeElementAccessibleName(), 'Console prompt');
+
+      await target.evaluate(() => {
+        for (let i = 0; i < 100; i++) {
+          console.log(`Message ${i}`);
+        }
+      });
+      await waitForLastConsoleMessageToHaveContent('Message 99');
+      assert.strictEqual(await activeElementAccessibleName(), 'Console prompt');
+
+      const consolePrompt = await activeElement();
+      const wrappingBox = await consolePrompt.asElement()?.boundingBox();
+      if (!wrappingBox) {
+        throw new Error('Can\'t compute bounding box of console prompt.');
+      }
+
+      // +20 to move from the top left point so we are definitely scrolling
+      // within the container
+      await frontend.mouse.move(wrappingBox.x + 20, wrappingBox.y + 5);
+      await frontend.mouse.wheel({deltaY: -500});
+
+      assert.strictEqual(await activeElementAccessibleName(), 'Console prompt');
+    });
+  });
+
+  describe('Console log message formatters', () => {
+    async function getConsoleMessageTextChunksWithStyle(
+        frontend: puppeteer.Page, styles: string[] = []): Promise<string[][][]> {
+      return await frontend.evaluate((selector, styles: string[]) => {
+        return [...document.querySelectorAll(selector)].map(message => [...message.childNodes].map(node => {
+          // For all nodes, extract text.
+          const result = [node.textContent];
+          // For element nodes, get the requested styles.
+          for (const style of styles) {
+            result.push(node.style?.[style] ?? '');
+          }
+          return result;
+        }));
+      }, CONSOLE_FIRST_MESSAGES_SELECTOR, styles);
+    }
+
+    async function waitForConsoleMessages(count: number): Promise<void> {
+      await waitForFunction(async () => {
+        const messages = await getCurrentConsoleMessages();
+        return messages.length === count ? messages : null;
+      });
+    }
+
+    it('expand primitive formatters', async () => {
+      const {frontend, target} = getBrowserAndPages();
+      await navigateToConsoleTab();
+      await target.evaluate(() => {
+        console.log('--%s--', 'text');
+        console.log('--%s--', '%s%i', 'u', 2);
+        console.log('Number %i', 42);
+        console.log('Float %f', 1.5);
+      });
+
+      await waitForConsoleMessages(4);
+      const texts = await getConsoleMessageTextChunksWithStyle(frontend);
+      assert.deepEqual(texts, [[['--text--']], [['--u2--']], [['Number 42']], [['Float 1.5']]]);
+    });
+
+    it('expand %c formatter with color style', async () => {
+      const {frontend, target} = getBrowserAndPages();
+      await navigateToConsoleTab();
+      await target.evaluate(() => console.log('PRE%cRED%cBLUE', 'color:red', 'color:blue'));
+
+      await waitForConsoleMessages(1);
+
+      // Extract the text and color.
+      const textsAndStyles = await getConsoleMessageTextChunksWithStyle(frontend, ['color']);
+      assert.deepEqual(textsAndStyles, [[['PRE', ''], ['RED', 'red'], ['BLUE', 'blue']]]);
+    });
+
+    it('expand %c formatter with background image in data URL', async () => {
+      const {frontend, target} = getBrowserAndPages();
+      await navigateToConsoleTab();
+      await target.evaluate(
+          () => console.log(
+              'PRE%cBG',
+              'background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAAAAABzHgM7AAAAF0lEQVR42mM4Awb/wYCBYg6EgghRzAEAWDWBGQVyKPMAAAAASUVORK5CYII=);'));
+
+      await waitForConsoleMessages(1);
+
+      // Check that the 'BG' text has the background image set.
+      const textsAndStyles = await getConsoleMessageTextChunksWithStyle(frontend, ['background-image']);
+      assert.strictEqual(textsAndStyles.length, 1);
+      const message = textsAndStyles[0];
+      assert.strictEqual(message.length, 2);
+      const textWithBackground = message[1];
+      assert.strictEqual(textWithBackground[0], 'BG');
+      assert.include(textWithBackground[1], 'data:image/png;base64');
+    });
+
+    it('filter out %c formatter if background image is remote URL', async () => {
+      const {frontend, target} = getBrowserAndPages();
+      await navigateToConsoleTab();
+      await target.evaluate(() => console.log('PRE%cBG', 'background-image: url(http://localhost/image.png)'));
+
+      await waitForConsoleMessages(1);
+
+      // Check that the 'BG' text has no bakcground image.
+      const textsAndStyles = await getConsoleMessageTextChunksWithStyle(frontend, ['background-image']);
+      assert.deepEqual(textsAndStyles, [[['PRE', ''], ['BG', '']]]);
+    });
+  });
 });
diff --git a/third_party/devtools-frontend/src/test/e2e/emulation/custom-ua-ch_test.ts b/third_party/devtools-frontend/src/test/e2e/emulation/custom-ua-ch_test.ts
index 1ca5d687bc6c9..6d98e91dedb8e 100644
--- a/third_party/devtools-frontend/src/test/e2e/emulation/custom-ua-ch_test.ts
+++ b/third_party/devtools-frontend/src/test/e2e/emulation/custom-ua-ch_test.ts
@@ -4,7 +4,7 @@
 import {assert} from 'chai';
 import * as puppeteer from 'puppeteer';
 
-import {click, getBrowserAndPages, goToResource, pressKey, typeText, waitFor} from '../../shared/helper.js';
+import {click, getBrowserAndPages, goToResource, pressKey, typeText, waitFor, tabForward} from '../../shared/helper.js';
 import {describe, it} from '../../shared/mocha-extensions.js';
 import {waitForDomNodeToBeVisible} from '../helpers/elements-helpers.js';
 import {openDeviceToolbar, reloadDockableFrontEnd, selectEdit, selectTestDevice} from '../helpers/emulation-helpers.js';
@@ -27,11 +27,6 @@ async function targetTextContent(selector: string): Promise<string> {
   return elementTextContent(handle);
 }
 
-export const tabForwardFrontend = async () => {
-  const {frontend} = getBrowserAndPages();
-  await frontend.keyboard.press('Tab');
-};
-
 describe('Custom UA-CH emulation', async () => {
   beforeEach(async function() {
     await reloadDockableFrontEnd();
@@ -47,20 +42,20 @@ describe('Custom UA-CH emulation', async () => {
     await waitFor(FOCUSED_DEVICE_NAME_FIELD_SELECTOR);
     await typeText('Test device');
 
-    await tabForwardFrontend();  // Focus width.
-    await tabForwardFrontend();  // Focus height.
-    await tabForwardFrontend();  // Focus DPR.
+    await tabForward();  // Focus width.
+    await tabForward();  // Focus height.
+    await tabForward();  // Focus DPR.
     await typeText('1.0');
 
-    await tabForwardFrontend();  // Focus UA string.
+    await tabForward();  // Focus UA string.
     await typeText('Test device browser 1.0');
 
-    await tabForwardFrontend();  // Focus device type.
-    await tabForwardFrontend();  // Focus folder.
+    await tabForward();  // Focus device type.
+    await tabForward();  // Focus folder.
     await pressKey('ArrowRight');
 
-    await tabForwardFrontend();  // Focus help button
-    await tabForwardFrontend();  // Focus brand list
+    await tabForward();  // Focus help button
+    await tabForward();  // Focus brand list
 
     // Type in partial, but syntactically invalid value for brand list.
     // The UI should show an error detecting that.
@@ -75,22 +70,22 @@ describe('Custom UA-CH emulation', async () => {
     const errorMsg2 = await elementTextContent(errorWidget);
     assert.strictEqual(errorMsg2, '');
 
-    await tabForwardFrontend();  // Focus full version.
+    await tabForward();  // Focus full version.
     await typeText('1.1.2345');
 
-    await tabForwardFrontend();  // Focus platform.
+    await tabForward();  // Focus platform.
     await typeText('Cyborg');
 
-    await tabForwardFrontend();  // Focus platform version.
+    await tabForward();  // Focus platform version.
     await typeText('C-1');
 
-    await tabForwardFrontend();  // Focus architecture.
+    await tabForward();  // Focus architecture.
     await typeText('Bipedal');
 
-    await tabForwardFrontend();  // Focus device model.
+    await tabForward();  // Focus device model.
     await typeText('C-1-Gardener');
 
-    await tabForwardFrontend();  // Focus add button.
+    await tabForward();  // Focus add button.
     const finishAdd = await waitFor(FOCUSED_SELECTOR);
     const finishAddText = await elementTextContent(finishAdd);
     assert.strictEqual(finishAddText, 'Add');
@@ -130,7 +125,7 @@ describe('Custom UA-CH emulation', async () => {
 
     // Skip over to the version field.
     for (let i = 0; i < 9; ++i) {
-      await tabForwardFrontend();
+      await tabForward();
     }
 
     // Change the value.
diff --git a/third_party/devtools-frontend/src/test/e2e/helpers/console-helpers.ts b/third_party/devtools-frontend/src/test/e2e/helpers/console-helpers.ts
index ee6a2f9e2b027..d307e620013cc 100644
--- a/third_party/devtools-frontend/src/test/e2e/helpers/console-helpers.ts
+++ b/third_party/devtools-frontend/src/test/e2e/helpers/console-helpers.ts
@@ -55,6 +55,17 @@ export async function waitForConsoleMessagesToBeNonEmpty(numberOfMessages: numbe
   });
 }
 
+export async function waitForLastConsoleMessageToHaveContent(expectedTextContent: string) {
+  await waitForFunction(async () => {
+    const messages = await $$(CONSOLE_FIRST_MESSAGES_SELECTOR);
+    if (messages.length === 0) {
+      return false;
+    }
+    const lastMessageContent = await messages[messages.length - 1].evaluate(message => message.textContent);
+    return lastMessageContent === expectedTextContent;
+  });
+}
+
 export async function getConsoleMessages(testName: string, withAnchor = false, callback?: () => Promise<void>) {
   // Ensure Console is loaded before the page is loaded to avoid a race condition.
   await getCurrentConsoleMessages();
diff --git a/third_party/devtools-frontend/src/test/e2e/resources/console/BUILD.gn b/third_party/devtools-frontend/src/test/e2e/resources/console/BUILD.gn
index 26e104cac80bd..6365d3b17f879 100644
--- a/third_party/devtools-frontend/src/test/e2e/resources/console/BUILD.gn
+++ b/third_party/devtools-frontend/src/test/e2e/resources/console/BUILD.gn
@@ -17,6 +17,7 @@ copy_to_gen("console") {
     "empty.html",
     "error-with-async-frame.html",
     "escaping.html",
+    "focus-interaction.html",
     "ignoreMe.js",
     "log-source.js",
     "navigation/after-navigation.html",
diff --git a/third_party/devtools-frontend/src/test/e2e/resources/console/focus-interaction.html b/third_party/devtools-frontend/src/test/e2e/resources/console/focus-interaction.html
new file mode 100644
index 0000000000000..1d77c9abd927e
--- /dev/null
+++ b/third_party/devtools-frontend/src/test/e2e/resources/console/focus-interaction.html
@@ -0,0 +1,10 @@
+<!--
+  Copyright 2020 The Chromium Authors. All rights reserved.
+  Use of this source code is governed by a BSD-style license that can be
+  found in the LICENSE file.
+-->
+<script type="module">
+  console.log('First message');
+  console.log('Second message');
+  console.log('Third message');
+</script>
diff --git a/third_party/devtools-frontend/src/test/shared/helper.ts b/third_party/devtools-frontend/src/test/shared/helper.ts
index d6807e44b9938..40515d4b2990f 100644
--- a/third_party/devtools-frontend/src/test/shared/helper.ts
+++ b/third_party/devtools-frontend/src/test/shared/helper.ts
@@ -352,9 +352,9 @@ export const step = async (description: string, step: Function) => {
 };
 
 export const waitForAnimationFrame = async () => {
-  const {target} = getBrowserAndPages();
+  const {frontend} = getBrowserAndPages();
 
-  await target.waitForFunction(() => {
+  await frontend.waitForFunction(() => {
     return new Promise(resolve => {
       requestAnimationFrame(resolve);
     });
@@ -362,11 +362,11 @@ export const waitForAnimationFrame = async () => {
 };
 
 export const activeElement = async () => {
-  const {target} = getBrowserAndPages();
+  const {frontend} = getBrowserAndPages();
 
   await waitForAnimationFrame();
 
-  return target.evaluateHandle(() => {
+  return frontend.evaluateHandle(() => {
     let activeElement = document.activeElement;
 
     while (activeElement && activeElement.shadowRoot) {
@@ -382,18 +382,35 @@ export const activeElementTextContent = async () => {
   return element.evaluate(node => node.textContent);
 };
 
-export const tabForward = async () => {
-  const {target} = getBrowserAndPages();
+export const activeElementAccessibleName = async () => {
+  const element = await activeElement();
+  return element.evaluate(node => node.getAttribute('aria-label'));
+};
 
-  await target.keyboard.press('Tab');
+export const tabForward = async (page?: puppeteer.Page) => {
+  let targetPage: puppeteer.Page;
+  if (page) {
+    targetPage = page;
+  } else {
+    const {frontend} = getBrowserAndPages();
+    targetPage = frontend;
+  }
+
+  await targetPage.keyboard.press('Tab');
 };
 
-export const tabBackward = async () => {
-  const {target} = getBrowserAndPages();
+export const tabBackward = async (page?: puppeteer.Page) => {
+  let targetPage: puppeteer.Page;
+  if (page) {
+    targetPage = page;
+  } else {
+    const {frontend} = getBrowserAndPages();
+    targetPage = frontend;
+  }
 
-  await target.keyboard.down('Shift');
-  await target.keyboard.press('Tab');
-  await target.keyboard.up('Shift');
+  await targetPage.keyboard.down('Shift');
+  await targetPage.keyboard.press('Tab');
+  await targetPage.keyboard.up('Shift');
 };
 
 export const selectTextFromNodeToNode = async (
diff --git a/third_party/devtools-frontend/src/test/unittests/front_end/BUILD.gn b/third_party/devtools-frontend/src/test/unittests/front_end/BUILD.gn
index 58a9bcde30670..b67d545bf44f4 100644
--- a/third_party/devtools-frontend/src/test/unittests/front_end/BUILD.gn
+++ b/third_party/devtools-frontend/src/test/unittests/front_end/BUILD.gn
@@ -30,6 +30,7 @@ group("front_end") {
     "meta",
     "missing_entrypoints",
     "network",
+    "panels/console",
     "perf_ui",
     "persistence",
     "platform",
diff --git a/third_party/devtools-frontend/src/test/unittests/front_end/panels/console/BUILD.gn b/third_party/devtools-frontend/src/test/unittests/front_end/panels/console/BUILD.gn
new file mode 100644
index 0000000000000..8d69776a63517
--- /dev/null
+++ b/third_party/devtools-frontend/src/test/unittests/front_end/panels/console/BUILD.gn
@@ -0,0 +1,15 @@
+# Copyright 2021 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../../../../third_party/typescript/typescript.gni")
+
+ts_library("console") {
+  testonly = true
+  sources = [ "ConsoleFormat_test.ts" ]
+
+  deps = [
+    "../../../../../front_end/panels/console:bundle",
+    "../../helpers",
+  ]
+}
diff --git a/third_party/devtools-frontend/src/test/unittests/front_end/panels/console/ConsoleFormat_test.ts b/third_party/devtools-frontend/src/test/unittests/front_end/panels/console/ConsoleFormat_test.ts
new file mode 100644
index 0000000000000..1fbdda18a5bbf
--- /dev/null
+++ b/third_party/devtools-frontend/src/test/unittests/front_end/panels/console/ConsoleFormat_test.ts
@@ -0,0 +1,491 @@
+// Copyright (c) 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import * as SDK from '../../../../../front_end/sdk/sdk.js';
+import * as Console from '../../../../../front_end/panels/console/console.js';
+
+const {assert} = chai;
+
+describe('ConsoleFormat', () => {
+  describe('format', () => {
+    it('deals with empty format string', () => {
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('', []), 'tokens', []);
+    });
+
+    it('yields unused arguments', () => {
+      const argNumber = SDK.RemoteObject.RemoteObject.fromLocalObject(42);
+      const argString = SDK.RemoteObject.RemoteObject.fromLocalObject('Hello World!');
+      const argSymbol = SDK.RemoteObject.RemoteObject.fromLocalObject(Symbol('My very special Symbol'));
+      const {args} = Console.ConsoleFormat.format('This string is boring!', [argNumber, argString, argSymbol]);
+      assert.lengthOf(args, 3);
+      assert.strictEqual(args[0], argNumber);
+      assert.strictEqual(args[1], argString);
+      assert.strictEqual(args[2], argSymbol);
+    });
+
+    it('deals with format strings without formatting specifiers', () => {
+      assert.deepNestedPropertyVal(
+          Console.ConsoleFormat.format('This string does NOT contain specifiers', []), 'tokens', [
+            {
+              type: 'string',
+              value: 'This string does NOT contain specifiers',
+            },
+          ]);
+    });
+
+    it('replaces %% with %', () => {
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('Go 100%%, and then another 50%%!', []), 'tokens', [
+        {
+          type: 'string',
+          value: 'Go 100%, and then another 50%!',
+        },
+      ]);
+    });
+
+    it('deals with trailing %', () => {
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('75%', []), 'tokens', [
+        {
+          type: 'string',
+          value: '75%',
+        },
+      ]);
+    });
+
+    it('deals with %o and %O', () => {
+      const argFirst = SDK.RemoteObject.RemoteObject.fromLocalObject({'first': 1});
+      const argSecond = SDK.RemoteObject.RemoteObject.fromLocalObject({'second': 2});
+      const {tokens} = Console.ConsoleFormat.format('%o %O', [argFirst, argSecond]);
+      assert.lengthOf(tokens, 3);
+      assert.propertyVal(tokens[0], 'type', 'optimal');
+      assert.propertyVal(tokens[0], 'value', argFirst);
+      assert.propertyVal(tokens[1], 'type', 'string');
+      assert.propertyVal(tokens[1], 'value', ' ');
+      assert.propertyVal(tokens[2], 'type', 'generic');
+      assert.propertyVal(tokens[2], 'value', argSecond);
+    });
+
+    it('deals with %c', () => {
+      assert.deepNestedPropertyVal(
+          Console.ConsoleFormat.format(
+              '%cColorful%c!',
+              [
+                SDK.RemoteObject.RemoteObject.fromLocalObject('color: red'),
+                SDK.RemoteObject.RemoteObject.fromLocalObject('color: black'),
+              ]),
+          'tokens', [
+            {
+              type: 'style',
+              value: 'color: red',
+            },
+            {
+              type: 'string',
+              value: 'Colorful',
+            },
+            {
+              type: 'style',
+              value: 'color: black',
+            },
+            {
+              type: 'string',
+              value: '!',
+            },
+          ]);
+    });
+
+    it('eats arguments with %_', () => {
+      const argFirst = SDK.RemoteObject.RemoteObject.fromLocalObject({'first': 1});
+      const argSecond = SDK.RemoteObject.RemoteObject.fromLocalObject({'second': 2});
+      const argThird = SDK.RemoteObject.RemoteObject.fromLocalObject({'third': 3});
+      const {tokens, args} = Console.ConsoleFormat.format('This is%_ some %_text!', [argFirst, argSecond, argThird]);
+      assert.lengthOf(args, 1);
+      assert.strictEqual(args[0], argThird);
+      assert.lengthOf(tokens, 1);
+      assert.propertyVal(tokens[0], 'type', 'string');
+      assert.propertyVal(tokens[0], 'value', 'This is some text!');
+    });
+
+    it('leaves unsatisfied formatting specifiers in place', () => {
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('%_ %O %o %d %i %f %s %c', []), 'tokens', [
+        {
+          type: 'string',
+          value: '%_ %O %o %d %i %f %s %c',
+        },
+      ]);
+    });
+
+    it('deals with %s', () => {
+      assert.deepNestedPropertyVal(
+          Console.ConsoleFormat.format(
+              '%s%s%s!',
+              [
+                SDK.RemoteObject.RemoteObject.fromLocalObject('Hello'),
+                SDK.RemoteObject.RemoteObject.fromLocalObject(' '),
+                SDK.RemoteObject.RemoteObject.fromLocalObject('World'),
+              ]),
+          'tokens', [
+            {
+              type: 'string',
+              value: 'Hello World!',
+            },
+          ]);
+      assert.deepNestedPropertyVal(
+          Console.ConsoleFormat.format(
+              '%s!',
+              [
+                SDK.RemoteObject.RemoteObject.fromLocalObject('%s %s'),
+                SDK.RemoteObject.RemoteObject.fromLocalObject('Hello'),
+                SDK.RemoteObject.RemoteObject.fromLocalObject('World'),
+              ]),
+          'tokens', [
+            {
+              type: 'string',
+              value: 'Hello World!',
+            },
+          ]);
+    });
+
+    it('deals with %d, %i, and %f', () => {
+      assert.deepNestedPropertyVal(
+          Console.ConsoleFormat.format(
+              '%d %i %f',
+              [
+                SDK.RemoteObject.RemoteObject.fromLocalObject(42.1),
+                SDK.RemoteObject.RemoteObject.fromLocalObject(21.5),
+                SDK.RemoteObject.RemoteObject.fromLocalObject(3.1415),
+              ]),
+          'tokens', [
+            {
+              type: 'string',
+              value: '42 21 3.1415',
+            },
+          ]);
+      assert.deepNestedPropertyVal(
+          Console.ConsoleFormat.format(
+              '%f %i %d',
+              [
+                SDK.RemoteObject.RemoteObject.fromLocalObject(Symbol('Some %s')),
+                SDK.RemoteObject.RemoteObject.fromLocalObject('Some %s'),
+                SDK.RemoteObject.RemoteObject.fromLocalObject(false),
+              ]),
+          'tokens', [
+            {
+              type: 'string',
+              value: 'NaN NaN NaN',
+            },
+          ]);
+    });
+
+    it('leaves unsupported or broken ANSI SGR sequences in place', () => {
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('\x1B[255m', []), 'tokens', [
+        {
+          type: 'string',
+          value: '\x1B[255m',
+        },
+      ]);
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('Bar\x1B[90', []), 'tokens', [
+        {
+          type: 'string',
+          value: 'Bar\x1B[90',
+        },
+      ]);
+      assert.deepNestedPropertyVal(Console.ConsoleFormat.format('\x1B[39FOO', []), 'tokens', [
+        {
+          type: 'string',
+          value: '\x1B[39FOO',
+        },
+      ]);
+    });
+
+    it('deals with ANSI color escape codes', () => {
+      [
+          // Foreground codes
+          [30, 'color:black'],
+          [31, 'color:red'],
+          [32, 'color:green'],
+          [33, 'color:yellow'],
+          [34, 'color:blue'],
+          [35, 'color:magenta'],
+          [36, 'color:cyan'],
+          [37, 'color:lightGray'],
+          [39, 'color:default'],
+          [90, 'color:darkGray'],
+          [91, 'color:lightRed'],
+          [92, 'color:lightGreen'],
+          [93, 'color:lightYellow'],
+          [94, 'color:lightBlue'],
+          [95, 'color:lightMagenta'],
+          [96, 'color:lightCyan'],
+          [97, 'color:white'],
+          // Background codes
+          [40, 'background:black'],
+          [41, 'background:red'],
+          [42, 'background:green'],
+          [43, 'background:yellow'],
+          [44, 'background:blue'],
+          [45, 'background:magenta'],
+          [46, 'background:cyan'],
+          [47, 'background:lightGray'],
+          [49, 'background:default'],
+          [100, 'background:darkGray'],
+          [101, 'background:lightRed'],
+          [102, 'background:lightGreen'],
+          [103, 'background:lightYellow'],
+          [104, 'background:lightBlue'],
+          [105, 'background:lightMagenta'],
+          [106, 'background:lightCyan'],
+          [107, 'background:white'],
+      ].forEach(([code, value]) => {
+        assert.deepNestedPropertyVal(Console.ConsoleFormat.format('\x1B[' + code + 'm', []), 'tokens', [
+          {
+            type: 'style',
+            value,
+          },
+        ]);
+      });
+    });
+
+    it('deals with ANSI colors and formatting specifiers', () => {
+      const {tokens} = Console.ConsoleFormat.format(
+          '\u001b[30m%d\u001b[31m%f\u001b[90m%s\u001b[91m%d\u001b[40m%f\u001b[41m%s\u001b[100m%d\u001b[101m%f',
+          [1, 1.1, 'a', 2, 2.2, 'b', 3, 3.3].map(obj => SDK.RemoteObject.RemoteObject.fromLocalObject(obj)));
+      assert.deepEqual(tokens, [
+        {
+          type: 'style',
+          value: 'color:black',
+        },
+        {
+          type: 'string',
+          value: '1',
+        },
+        {
+          type: 'style',
+          value: 'color:red',
+        },
+        {
+          type: 'string',
+          value: '1.1',
+        },
+        {
+          type: 'style',
+          value: 'color:darkGray',
+        },
+        {
+          type: 'string',
+          value: 'a',
+        },
+        {
+          type: 'style',
+          value: 'color:lightRed',
+        },
+        {
+          type: 'string',
+          value: '2',
+        },
+        {
+          type: 'style',
+          value: 'background:black',
+        },
+        {
+          type: 'string',
+          value: '2.2',
+        },
+        {
+          type: 'style',
+          value: 'background:red',
+        },
+        {
+          type: 'string',
+          value: 'b',
+        },
+        {
+          type: 'style',
+          value: 'background:darkGray',
+        },
+        {
+          type: 'string',
+          value: '3',
+        },
+        {
+          type: 'style',
+          value: 'background:lightRed',
+        },
+        {
+          type: 'string',
+          value: '3.3',
+        },
+      ]);
+    });
+
+    it('deals with ANSI color combinations', () => {
+      const {tokens} = Console.ConsoleFormat.format(
+          '\x1B[30m1\x1B[31m2\x1B[90m3\x1B[91m4\x1B[40m5\x1B[41m6\x1B[100m7\x1B[101m8', []);
+      assert.deepEqual(tokens, [
+        {
+          type: 'style',
+          value: 'color:black',
+        },
+        {
+          type: 'string',
+          value: '1',
+        },
+        {
+          type: 'style',
+          value: 'color:red',
+        },
+        {
+          type: 'string',
+          value: '2',
+        },
+        {
+          type: 'style',
+          value: 'color:darkGray',
+        },
+        {
+          type: 'string',
+          value: '3',
+        },
+        {
+          type: 'style',
+          value: 'color:lightRed',
+        },
+        {
+          type: 'string',
+          value: '4',
+        },
+        {
+          type: 'style',
+          value: 'background:black',
+        },
+        {
+          type: 'string',
+          value: '5',
+        },
+        {
+          type: 'style',
+          value: 'background:red',
+        },
+        {
+          type: 'string',
+          value: '6',
+        },
+        {
+          type: 'style',
+          value: 'background:darkGray',
+        },
+        {
+          type: 'string',
+          value: '7',
+        },
+        {
+          type: 'style',
+          value: 'background:lightRed',
+        },
+        {
+          type: 'string',
+          value: '8',
+        },
+      ]);
+    });
+  });
+
+  describe('updateStyle', () => {
+    it('allows allow-listed styles', () => {
+      const styles = new Map();
+
+      Console.ConsoleFormat.updateStyle(styles, 'border-top-style:solid');
+      assert.deepEqual(styles.get('border-top-style'), {value: 'solid', priority: ''});
+
+      Console.ConsoleFormat.updateStyle(styles, 'color:red');
+      assert.deepEqual(styles.get('color'), {value: 'red', priority: ''});
+
+      Console.ConsoleFormat.updateStyle(styles, 'font-family:serif');
+      assert.deepEqual(styles.get('font-family'), {value: 'serif', priority: ''});
+
+      Console.ConsoleFormat.updateStyle(styles, 'line-height:100%');
+      assert.deepEqual(styles.get('line-height'), {value: '100%', priority: ''});
+
+      Console.ConsoleFormat.updateStyle(styles, 'margin-top:30px');
+      assert.deepEqual(styles.get('margin-top'), {value: '30px', priority: ''});
+
+      Console.ConsoleFormat.updateStyle(styles, 'padding-top : 20px');
+      assert.deepEqual(styles.get('padding-top'), {value: '20px', priority: ''});
+
+      Console.ConsoleFormat.updateStyle(styles, 'text-align : center');
+      assert.deepEqual(styles.get('text-align'), {value: 'center', priority: ''});
+    });
+
+    it('handles multiple styles', () => {
+      const styles = new Map();
+
+      Console.ConsoleFormat.updateStyle(styles, 'font-size:14px; color:red');
+      assert.deepEqual(styles.get('color'), {value: 'red', priority: ''});
+      assert.deepEqual(styles.get('font-size'), {value: '14px', priority: ''});
+    });
+
+    it('resets styles', () => {
+      const styles = new Map();
+
+      Console.ConsoleFormat.updateStyle(styles, 'font-size:14px; color:red');
+      Console.ConsoleFormat.updateStyle(styles, 'color:red');
+      assert.isFalse(styles.has('font-size'));
+    });
+
+    it('blocks styles outside of allow-list', () => {
+      const styles = new Map();
+
+      Console.ConsoleFormat.updateStyle(styles, 'visibility:hidden');
+      assert.isFalse(styles.has('visibility'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'width:100px');
+      assert.isFalse(styles.has('width'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'box-sizing:border-box');
+      assert.isFalse(styles.has('box-sizing'));
+    });
+
+    it('blocks block-listed url schemes in values', () => {
+      const styles = new Map();
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(http://localhost/a.png)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(https://localhost/a.png)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(resource://localhost/a.png)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(app://com.foo.bar/index.html)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(chrome://a/b.png)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(about:flags)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(ftp://localhost/a.png)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'background-image:url(file://c/a.txt)');
+      assert.isFalse(styles.has('background-image'));
+
+      Console.ConsoleFormat.updateStyle(styles, 'border-image-source:url(file://c/a.txt)');
+      assert.isFalse(styles.has('border-image-source'));
+    });
+
+    it('allows data urls in values', () => {
+      const dataUrl =
+          'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAAAAABzHgM7AAAAF0lEQVR42mM4Awb/wYCBYg6EgghRzAEAWDWBGQVyKPMAAAAASUVORK5CYII=)';
+
+      const styles = new Map();
+
+      Console.ConsoleFormat.updateStyle(styles, `background-image:${dataUrl}`);
+      assert.include(styles.get('background-image').value, 'data:image/png;base64');
+
+      Console.ConsoleFormat.updateStyle(styles, `border-image-source:${dataUrl}`);
+      assert.include(styles.get('border-image-source').value, 'data:image/png;base64');
+    });
+  });
+});
diff --git a/third_party/ffmpeg/ffmpeg_generated.gni b/third_party/ffmpeg/ffmpeg_generated.gni
index 394efcabd9a4c..864e88431fc52 100644
--- a/third_party/ffmpeg/ffmpeg_generated.gni
+++ b/third_party/ffmpeg/ffmpeg_generated.gni
@@ -12,7 +12,7 @@ ffmpeg_c_sources = []
 ffmpeg_gas_sources = []
 ffmpeg_asm_sources = []
 
-use_linux_config = is_linux || is_chromeos || is_fuchsia || use_musl
+use_linux_config = is_linux || is_chromeos || is_fuchsia || use_musl || is_ohos
 
 if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon) || (is_android && current_cpu == "arm64") || (is_android && current_cpu == "x64") || (is_android && current_cpu == "x86") || (is_mac) || (is_win) || (use_linux_config)) {
   ffmpeg_c_sources += [
diff --git a/third_party/ffmpeg/ffmpeg_options.gni b/third_party/ffmpeg/ffmpeg_options.gni
index 532391358b6ad..383d59647809a 100644
--- a/third_party/ffmpeg/ffmpeg_options.gni
+++ b/third_party/ffmpeg/ffmpeg_options.gni
@@ -71,7 +71,7 @@ if ((is_linux || is_chromeos) && is_msan) {
 } else if (is_win && !is_clang) {
   os_config = "win-msvc"
 } else if (is_ohos && !use_musl) {
-  os_config = "android"
+  os_config = "linux"
 } else if(use_musl) {
   os_config = "linux"
 }
diff --git a/third_party/icu/BUILD.gn b/third_party/icu/BUILD.gn
index 1ac0afebc2257..81d95a29a947f 100644
--- a/third_party/icu/BUILD.gn
+++ b/third_party/icu/BUILD.gn
@@ -165,6 +165,11 @@ template("generate_icu_component") {
       configs += [ ":icu_code" ]
       configs += extra_configs
       public_configs = [ ":icu_config" ]
+      #ifdef OHOS_NWEB_EX
+      if (ohos_nweb_ex_config_name != "") {
+        configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
+        configs += [ "//build/config:ohos_nweb_ex_def_other" ]
+      }  #endif  // OHOS_NWEB_EX
     }
   } else {
     component(target_name) {
@@ -208,6 +213,11 @@ template("generate_icu_component") {
         configs -= [ "//build/config/compiler:thin_archive" ]
         complete_static_lib = true
       }
+      #ifdef OHOS_NWEB_EX
+      if (ohos_nweb_ex_config_name != "") {
+        configs -= [ "//build/config:ohos_nweb_ex_def_main" ]
+        configs += [ "//build/config:ohos_nweb_ex_def_other" ]
+      }  #endif  // OHOS_NWEB_EX
     }
   }
 }
diff --git a/third_party/icu/README.chromium b/third_party/icu/README.chromium
index 4b1af52ae4eb6..de327c3caf09f 100644
--- a/third_party/icu/README.chromium
+++ b/third_party/icu/README.chromium
@@ -316,3 +316,7 @@ D. Local Modifications
     patches/fuchsia.patch
     - context bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1184527
 
+19. Patch i18n/formatted_string_builder to fix int32_t overflow bug
+    patches/formatted_string_builder.patch
+  - https://github.com/unicode-org/icu/pull/2070
+  - https://unicode-org.atlassian.net/browse/ICU-22005
diff --git a/third_party/icu/patches/formatted_string_builder.patch b/third_party/icu/patches/formatted_string_builder.patch
index ce9111e5f5f2d..07381496da86e 100644
--- a/third_party/icu/patches/formatted_string_builder.patch
+++ b/third_party/icu/patches/formatted_string_builder.patch
@@ -29,3 +29,128 @@ index 5aabc31c..b370f14f 100644
      uprv_memmove2(getCharPtr() + position,
              getCharPtr() + position + count,
              sizeof(char16_t) * (fLength - index - count));
+diff --git a/source/i18n/formatted_string_builder.cpp b/source/i18n/formatted_string_builder.cpp
+index 73407864..628fbea8 100644
+--- a/source/i18n/formatted_string_builder.cpp
++++ b/source/i18n/formatted_string_builder.cpp
+@@ -6,6 +6,7 @@
+ #if !UCONFIG_NO_FORMATTING
+ 
+ #include "formatted_string_builder.h"
++#include "putilimp.h"
+ #include "unicode/ustring.h"
+ #include "unicode/utf16.h"
+ #include "unicode/unum.h" // for UNumberFormatFields literals
+@@ -197,6 +198,9 @@ FormattedStringBuilder::splice(int32_t startThis, int32_t endThis,  const Unicod
+     int32_t thisLength = endThis - startThis;
+     int32_t otherLength = endOther - startOther;
+     int32_t count = otherLength - thisLength;
++    if (U_FAILURE(status)) {
++        return count;
++    }
+     int32_t position;
+     if (count > 0) {
+         // Overall, chars need to be added.
+@@ -221,6 +225,9 @@ int32_t FormattedStringBuilder::append(const FormattedStringBuilder &other, UErr
+ 
+ int32_t
+ FormattedStringBuilder::insert(int32_t index, const FormattedStringBuilder &other, UErrorCode &status) {
++    if (U_FAILURE(status)) {
++        return 0;
++    }
+     if (this == &other) {
+         status = U_ILLEGAL_ARGUMENT_ERROR;
+         return 0;
+@@ -255,12 +262,18 @@ int32_t FormattedStringBuilder::prepareForInsert(int32_t index, int32_t count, U
+     U_ASSERT(index >= 0);
+     U_ASSERT(index <= fLength);
+     U_ASSERT(count >= 0);
++    U_ASSERT(fZero >= 0);
++    U_ASSERT(fLength >= 0);
++    U_ASSERT(getCapacity() - fZero >= fLength);
++    if (U_FAILURE(status)) {
++        return count;
++    }
+     if (index == 0 && fZero - count >= 0) {
+         // Append to start
+         fZero -= count;
+         fLength += count;
+         return fZero;
+-    } else if (index == fLength && fZero + fLength + count < getCapacity()) {
++    } else if (index == fLength && count <= getCapacity() - fZero - fLength) {
+         // Append to end
+         fLength += count;
+         return fZero + fLength - count;
+@@ -275,18 +288,26 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
+     int32_t oldZero = fZero;
+     char16_t *oldChars = getCharPtr();
+     Field *oldFields = getFieldPtr();
+-    if (fLength + count > oldCapacity) {
+-        if ((fLength + count) > INT32_MAX / 2) {
+-            // If we continue, then newCapacity will overflow int32_t in the next line.
++    int32_t newLength;
++    if (uprv_add32_overflow(fLength, count, &newLength)) {
++        status = U_INPUT_TOO_LONG_ERROR;
++        return -1;
++    }
++    int32_t newZero;
++    if (newLength > oldCapacity) {
++        if (newLength > INT32_MAX / 2) {
++            // We do not support more than 1G char16_t in this code because
++            // dealing with >2G *bytes* can cause subtle bugs.
+             status = U_INPUT_TOO_LONG_ERROR;
+             return -1;
+         }
+-        int32_t newCapacity = (fLength + count) * 2;
+-        int32_t newZero = newCapacity / 2 - (fLength + count) / 2;
++        // Keep newCapacity also to at most 1G char16_t.
++        int32_t newCapacity = newLength * 2;
++        newZero = (newCapacity - newLength) / 2;
+ 
+         // C++ note: malloc appears in two places: here and in the assignment operator.
+-        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * newCapacity));
+-        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * newCapacity));
++        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * static_cast<size_t>(newCapacity)));
++        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * static_cast<size_t>(newCapacity)));
+         if (newChars == nullptr || newFields == nullptr) {
+             uprv_free(newChars);
+             uprv_free(newFields);
+@@ -315,10 +336,8 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
+         fChars.heap.capacity = newCapacity;
+         fFields.heap.ptr = newFields;
+         fFields.heap.capacity = newCapacity;
+-        fZero = newZero;
+-        fLength += count;
+     } else {
+-        int32_t newZero = oldCapacity / 2 - (fLength + count) / 2;
++        newZero = (oldCapacity - newLength) / 2;
+ 
+         // C++ note: memmove is required because src and dest may overlap.
+         // First copy the entire string to the location of the prefix, and then move the suffix
+@@ -331,18 +350,20 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
+         uprv_memmove2(oldFields + newZero + index + count,
+                 oldFields + newZero + index,
+                 sizeof(Field) * (fLength - index));
+-
+-        fZero = newZero;
+-        fLength += count;
+     }
+-    U_ASSERT((fZero + index) >= 0);
++    fZero = newZero;
++    fLength = newLength;
+     return fZero + index;
+ }
+ 
+ int32_t FormattedStringBuilder::remove(int32_t index, int32_t count) {
+-    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
++     U_ASSERT(0 <= index);
++     U_ASSERT(index <= fLength);
++     U_ASSERT(count <= (fLength - index));
++     U_ASSERT(index <= getCapacity() - fZero);
++
+     int32_t position = index + fZero;
+-    U_ASSERT(position >= 0);
++    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
+     uprv_memmove2(getCharPtr() + position,
+             getCharPtr() + position + count,
+             sizeof(char16_t) * (fLength - index - count));
diff --git a/third_party/icu/source/i18n/formatted_string_builder.cpp b/third_party/icu/source/i18n/formatted_string_builder.cpp
index b370f14f2ac4f..e459c791ea337 100644
--- a/third_party/icu/source/i18n/formatted_string_builder.cpp
+++ b/third_party/icu/source/i18n/formatted_string_builder.cpp
@@ -6,6 +6,7 @@
 #if !UCONFIG_NO_FORMATTING
 
 #include "formatted_string_builder.h"
+#include "putilimp.h"
 #include "unicode/ustring.h"
 #include "unicode/utf16.h"
 #include "unicode/unum.h" // for UNumberFormatFields literals
@@ -197,6 +198,9 @@ FormattedStringBuilder::splice(int32_t startThis, int32_t endThis,  const Unicod
     int32_t thisLength = endThis - startThis;
     int32_t otherLength = endOther - startOther;
     int32_t count = otherLength - thisLength;
+    if (U_FAILURE(status)) {
+        return count;
+    }
     int32_t position;
     if (count > 0) {
         // Overall, chars need to be added.
@@ -221,6 +225,9 @@ int32_t FormattedStringBuilder::append(const FormattedStringBuilder &other, UErr
 
 int32_t
 FormattedStringBuilder::insert(int32_t index, const FormattedStringBuilder &other, UErrorCode &status) {
+    if (U_FAILURE(status)) {
+        return 0;
+    }
     if (this == &other) {
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return 0;
@@ -255,12 +262,18 @@ int32_t FormattedStringBuilder::prepareForInsert(int32_t index, int32_t count, U
     U_ASSERT(index >= 0);
     U_ASSERT(index <= fLength);
     U_ASSERT(count >= 0);
+    U_ASSERT(fZero >= 0);
+    U_ASSERT(fLength >= 0);
+    U_ASSERT(getCapacity() - fZero >= fLength);
+    if (U_FAILURE(status)) {
+        return count;
+    }
     if (index == 0 && fZero - count >= 0) {
         // Append to start
         fZero -= count;
         fLength += count;
         return fZero;
-    } else if (index == fLength && fZero + fLength + count < getCapacity()) {
+    } else if (index == fLength && count <= getCapacity() - fZero - fLength) {
         // Append to end
         fLength += count;
         return fZero + fLength - count;
@@ -275,18 +288,26 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
     int32_t oldZero = fZero;
     char16_t *oldChars = getCharPtr();
     Field *oldFields = getFieldPtr();
-    if (fLength + count > oldCapacity) {
-        if ((fLength + count) > INT32_MAX / 2) {
-            // If we continue, then newCapacity will overlow int32_t in the next line.
+    int32_t newLength;
+    if (uprv_add32_overflow(fLength, count, &newLength)) {
+        status = U_INPUT_TOO_LONG_ERROR;
+        return -1;
+    }
+    int32_t newZero;
+    if (newLength > oldCapacity) {
+        if (newLength > INT32_MAX / 2) {
+            // We do not support more than 1G char16_t in this code because
+            // dealing with >2G *bytes* can cause subtle bugs.
             status = U_INPUT_TOO_LONG_ERROR;
             return -1;
         }
-        int32_t newCapacity = (fLength + count) * 2;
-        int32_t newZero = newCapacity / 2 - (fLength + count) / 2;
+	// Keep newCapacity also to at most 1G char16_t.
+        int32_t newCapacity = newLength * 2;
+        newZero = (newCapacity - newLength) / 2;
 
         // C++ note: malloc appears in two places: here and in the assignment operator.
-        auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * newCapacity));
-        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * newCapacity));
+	auto newChars = static_cast<char16_t *> (uprv_malloc(sizeof(char16_t) * static_cast<size_t>(newCapacity)));
+        auto newFields = static_cast<Field *>(uprv_malloc(sizeof(Field) * static_cast<size_t>(newCapacity)));
         if (newChars == nullptr || newFields == nullptr) {
             uprv_free(newChars);
             uprv_free(newFields);
@@ -315,11 +336,8 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
         fChars.heap.capacity = newCapacity;
         fFields.heap.ptr = newFields;
         fFields.heap.capacity = newCapacity;
-        fZero = newZero;
-        fLength += count;
     } else {
-        int32_t newZero = oldCapacity / 2 - (fLength + count) / 2;
-
+        newZero = (oldCapacity - newLength) / 2;
         // C++ note: memmove is required because src and dest may overlap.
         // First copy the entire string to the location of the prefix, and then move the suffix
         // to make room for the new chars that the caller wants to insert.
@@ -331,18 +349,19 @@ int32_t FormattedStringBuilder::prepareForInsertHelper(int32_t index, int32_t co
         uprv_memmove2(oldFields + newZero + index + count,
                 oldFields + newZero + index,
                 sizeof(Field) * (fLength - index));
-
+        }
         fZero = newZero;
-        fLength += count;
-    }
-    U_ASSERT((fZero + index) >= 0);
+        fLength += newLength;
     return fZero + index;
 }
 
 int32_t FormattedStringBuilder::remove(int32_t index, int32_t count) {
-    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
+    U_ASSERT(0 <= index);
+    U_ASSERT(index <= fLength);
+    U_ASSERT(count <= (fLength - index));
+    U_ASSERT(index <= getCapacity() - fZero);
     int32_t position = index + fZero;
-    U_ASSERT(position >= 0);
+    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
     uprv_memmove2(getCharPtr() + position,
             getCharPtr() + position + count,
             sizeof(char16_t) * (fLength - index - count));
diff --git a/third_party/libwebp/README.chromium b/third_party/libwebp/README.chromium
index fd77980a907cc..4968eaea94686 100644
--- a/third_party/libwebp/README.chromium
+++ b/third_party/libwebp/README.chromium
@@ -1,7 +1,7 @@
 Name: WebP image encoder/decoder
 Short Name: libwebp
 URL: http://developers.google.com/speed/webp
-Version: v1.2.0
+Version: 20ef03ee351d4ff03fc5ff3ec4804a879d1b9d5c
 CPEPrefix: cpe:/a:webmproject:libwebp:1.2.0
 License: BSD
 License File: LICENSE
@@ -9,7 +9,7 @@ Security Critical: Yes
 
 Description:
 Source archive:
-  https://chromium.googlesource.com/webm/libwebp/+archive/v1.2.0.tar.gz
+  https://chromium.googlesource.com/webm/libwebp/+archive/20ef03ee351d4ff03fc5ff3ec4804a879d1b9d5c.tar.gz
 
 WebP is an image format that does both lossy and lossless compression of
 digital photographic images. WebP consists of a codec based on VP8, that Google
diff --git a/third_party/libwebp/src/dsp/alpha_processing_neon.c b/third_party/libwebp/src/dsp/alpha_processing_neon.c
index 9d55421704cc8..27d717507c5fe 100644
--- a/third_party/libwebp/src/dsp/alpha_processing_neon.c
+++ b/third_party/libwebp/src/dsp/alpha_processing_neon.c
@@ -83,7 +83,7 @@ static void ApplyAlphaMultiply_NEON(uint8_t* rgba, int alpha_first,
 static int DispatchAlpha_NEON(const uint8_t* alpha, int alpha_stride,
                               int width, int height,
                               uint8_t* dst, int dst_stride) {
-  uint32_t alpha_mask = 0xffffffffu;
+  uint32_t alpha_mask = 0xffu;
   uint8x8_t mask8 = vdup_n_u8(0xff);
   uint32_t tmp[2];
   int i, j;
@@ -107,6 +107,7 @@ static int DispatchAlpha_NEON(const uint8_t* alpha, int alpha_stride,
     dst += dst_stride;
   }
   vst1_u8((uint8_t*)tmp, mask8);
+  alpha_mask *= 0x01010101;
   alpha_mask &= tmp[0];
   alpha_mask &= tmp[1];
   return (alpha_mask != 0xffffffffu);
@@ -134,7 +135,7 @@ static void DispatchAlphaToGreen_NEON(const uint8_t* alpha, int alpha_stride,
 static int ExtractAlpha_NEON(const uint8_t* argb, int argb_stride,
                              int width, int height,
                              uint8_t* alpha, int alpha_stride) {
-  uint32_t alpha_mask = 0xffffffffu;
+  uint32_t alpha_mask = 0xffu;
   uint8x8_t mask8 = vdup_n_u8(0xff);
   uint32_t tmp[2];
   int i, j;
@@ -156,6 +157,7 @@ static int ExtractAlpha_NEON(const uint8_t* argb, int argb_stride,
     alpha += alpha_stride;
   }
   vst1_u8((uint8_t*)tmp, mask8);
+  alpha_mask *= 0x01010101;
   alpha_mask &= tmp[0];
   alpha_mask &= tmp[1];
   return (alpha_mask == 0xffffffffu);
diff --git a/third_party/libwebp/src/dsp/lossless_enc_mips32.c b/third_party/libwebp/src/dsp/lossless_enc_mips32.c
index 0412a093cf9ab..9963051798eee 100644
--- a/third_party/libwebp/src/dsp/lossless_enc_mips32.c
+++ b/third_party/libwebp/src/dsp/lossless_enc_mips32.c
@@ -347,24 +347,24 @@ static void GetCombinedEntropyUnrefined_MIPS32(const uint32_t X[],
 static void AddVector_MIPS32(const uint32_t* pa, const uint32_t* pb,
                              uint32_t* pout, int size) {
   uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
-  const uint32_t end = ((size) / 4) * 4;
+  const int end = ((size) / 4) * 4;
   const uint32_t* const LoopEnd = pa + end;
   int i;
   ASM_START
   ADD_TO_OUT(0, 4, 8, 12, 1, pa, pb, pout)
   ASM_END_0
-  for (i = end; i < size; ++i) pout[i] = pa[i] + pb[i];
+  for (i = 0; i < size - end; ++i) pout[i] = pa[i] + pb[i];
 }
 
 static void AddVectorEq_MIPS32(const uint32_t* pa, uint32_t* pout, int size) {
   uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
-  const uint32_t end = ((size) / 4) * 4;
+  const int end = ((size) / 4) * 4;
   const uint32_t* const LoopEnd = pa + end;
   int i;
   ASM_START
   ADD_TO_OUT(0, 4, 8, 12, 0, pa, pout, pout)
   ASM_END_1
-  for (i = end; i < size; ++i) pout[i] += pa[i];
+  for (i = 0; i < size - end; ++i) pout[i] += pa[i];
 }
 
 #undef ASM_END_1
diff --git a/third_party/libwebp/src/enc/backward_references_cost_enc.c b/third_party/libwebp/src/enc/backward_references_cost_enc.c
index 516abd73eb45c..5eb24d449953d 100644
--- a/third_party/libwebp/src/enc/backward_references_cost_enc.c
+++ b/third_party/libwebp/src/enc/backward_references_cost_enc.c
@@ -577,7 +577,7 @@ static int BackwardReferencesHashChainDistanceOnly(
       (CostModel*)WebPSafeCalloc(1ULL, cost_model_size);
   VP8LColorCache hashers;
   CostManager* cost_manager =
-      (CostManager*)WebPSafeMalloc(1ULL, sizeof(*cost_manager));
+      (CostManager*)WebPSafeCalloc(1ULL, sizeof(*cost_manager));
   int offset_prev = -1, len_prev = -1;
   double offset_cost = -1;
   int first_offset_is_constant = -1;  // initialized with 'impossible' value
diff --git a/third_party/libwebp/src/enc/backward_references_enc.c b/third_party/libwebp/src/enc/backward_references_enc.c
index 519b36a09153e..d5e931efdd8cf 100644
--- a/third_party/libwebp/src/enc/backward_references_enc.c
+++ b/third_party/libwebp/src/enc/backward_references_enc.c
@@ -976,15 +976,16 @@ static int GetBackwardReferences(int width, int height,
       const VP8LHashChain* const hash_chain_tmp =
           (lz77_types_best[i] == kLZ77Standard) ? hash_chain : &hash_chain_box;
       const int cache_bits = (i == 1) ? 0 : *cache_bits_best;
-      if (VP8LBackwardReferencesTraceBackwards(width, height, argb, cache_bits,
-                                               hash_chain_tmp, &refs[i],
-                                               refs_tmp)) {
-        double bit_cost_trace;
-        VP8LHistogramCreate(histo, refs_tmp, cache_bits);
-        bit_cost_trace = VP8LHistogramEstimateBits(histo);
-        if (bit_cost_trace < bit_costs_best[i]) {
-          BackwardRefsSwap(refs_tmp, &refs[i]);
-        }
+      double bit_cost_trace;
+      if (!VP8LBackwardReferencesTraceBackwards(width, height, argb, cache_bits,
+                                                hash_chain_tmp, &refs[i],
+                                                refs_tmp)) {
+        goto Error;
+      }
+      VP8LHistogramCreate(histo, refs_tmp, cache_bits);
+      bit_cost_trace = VP8LHistogramEstimateBits(histo);
+      if (bit_cost_trace < bit_costs_best[i]) {
+        BackwardRefsSwap(refs_tmp, &refs[i]);
       }
     }
 
diff --git a/third_party/libwebp/src/enc/vp8l_enc.c b/third_party/libwebp/src/enc/vp8l_enc.c
index 0b44ebe46ec54..1875e53552d31 100644
--- a/third_party/libwebp/src/enc/vp8l_enc.c
+++ b/third_party/libwebp/src/enc/vp8l_enc.c
@@ -1706,11 +1706,16 @@ WebPEncodingError VP8LEncodeStream(const WebPConfig* const config,
   const WebPWorkerInterface* const worker_interface = WebPGetWorkerInterface();
   int ok_main;
 
+  if (enc_main == NULL || !VP8LBitWriterInit(&bw_side, 0)) {
+    WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
+    VP8LEncoderDelete(enc_main);
+    return 0;
+  }
+
   // Analyze image (entropy, num_palettes etc)
-  if (enc_main == NULL ||
-      !EncoderAnalyze(enc_main, crunch_configs, &num_crunch_configs_main,
+  if (!EncoderAnalyze(enc_main, crunch_configs, &num_crunch_configs_main,
                       &red_and_blue_always_zero) ||
-      !EncoderInit(enc_main) || !VP8LBitWriterInit(&bw_side, 0)) {
+      !EncoderInit(enc_main)) {
     err = VP8_ENC_ERROR_OUT_OF_MEMORY;
     goto Error;
   }
diff --git a/third_party/pdfium/core/fpdfapi/parser/cpdf_array.cpp b/third_party/pdfium/core/fpdfapi/parser/cpdf_array.cpp
index 422f92b257977..616b6f123a640 100644
--- a/third_party/pdfium/core/fpdfapi/parser/cpdf_array.cpp
+++ b/third_party/pdfium/core/fpdfapi/parser/cpdf_array.cpp
@@ -10,6 +10,7 @@
 #include <utility>
 
 #include "core/fpdfapi/parser/cpdf_boolean.h"
+#include "core/fpdfapi/parser/cpdf_dictionary.h"
 #include "core/fpdfapi/parser/cpdf_name.h"
 #include "core/fpdfapi/parser/cpdf_number.h"
 #include "core/fpdfapi/parser/cpdf_reference.h"
@@ -143,6 +144,10 @@ float CPDF_Array::GetNumberAt(size_t index) const {
   return m_Objects[index]->GetNumber();
 }
 
+RetainPtr<CPDF_Dictionary> CPDF_Array::GetMutableDictAt(size_t index) {
+  return pdfium::WrapRetain(GetDictAt(index));
+}
+
 CPDF_Dictionary* CPDF_Array::GetDictAt(size_t index) {
   CPDF_Object* p = GetDirectObjectAt(index);
   if (!p)
diff --git a/third_party/pdfium/core/fpdfapi/parser/cpdf_array.h b/third_party/pdfium/core/fpdfapi/parser/cpdf_array.h
index 37b1af9592c1e..7945eadb5b08b 100644
--- a/third_party/pdfium/core/fpdfapi/parser/cpdf_array.h
+++ b/third_party/pdfium/core/fpdfapi/parser/cpdf_array.h
@@ -45,7 +45,8 @@ class CPDF_Array final : public CPDF_Object {
   bool GetBooleanAt(size_t index, bool bDefault) const;
   int GetIntegerAt(size_t index) const;
   float GetNumberAt(size_t index) const;
-  CPDF_Dictionary* GetDictAt(size_t index);
+  RetainPtr<CPDF_Dictionary> GetMutableDictAt(size_t index);
+  CPDF_Dictionary* GetDictAt(size_t index);  // prefer previous form.
   const CPDF_Dictionary* GetDictAt(size_t index) const;
   CPDF_Stream* GetStreamAt(size_t index);
   const CPDF_Stream* GetStreamAt(size_t index) const;
diff --git a/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.cpp b/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.cpp
index 0ded422ed3076..045339e8e2142 100644
--- a/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.cpp
+++ b/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.cpp
@@ -147,6 +147,11 @@ float CPDF_Dictionary::GetNumberFor(const ByteString& key) const {
   return p ? p->GetNumber() : 0;
 }
 
+RetainPtr<CPDF_Dictionary> CPDF_Dictionary::GetMutableDictFor(
+    const ByteString& key) {
+  return pdfium::WrapRetain(GetDictFor(key));
+}
+
 const CPDF_Dictionary* CPDF_Dictionary::GetDictFor(
     const ByteString& key) const {
   const CPDF_Object* p = GetDirectObjectFor(key);
@@ -164,6 +169,11 @@ CPDF_Dictionary* CPDF_Dictionary::GetDictFor(const ByteString& key) {
       static_cast<const CPDF_Dictionary*>(this)->GetDictFor(key));
 }
 
+RetainPtr<CPDF_Array> CPDF_Dictionary::GetMutableArrayFor(
+    const ByteString& key) {
+  return pdfium::WrapRetain(GetArrayFor(key));
+}
+
 const CPDF_Array* CPDF_Dictionary::GetArrayFor(const ByteString& key) const {
   return ToArray(GetDirectObjectFor(key));
 }
diff --git a/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.h b/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.h
index cc23730bf874b..65e939c837af4 100644
--- a/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.h
+++ b/third_party/pdfium/core/fpdfapi/parser/cpdf_dictionary.h
@@ -66,9 +66,11 @@ class CPDF_Dictionary final : public CPDF_Object {
   int GetIntegerFor(const ByteString& key, int default_int) const;
   float GetNumberFor(const ByteString& key) const;
   const CPDF_Dictionary* GetDictFor(const ByteString& key) const;
-  CPDF_Dictionary* GetDictFor(const ByteString& key);
+  CPDF_Dictionary* GetDictFor(const ByteString& key);  // Prefer next form.
+  RetainPtr<CPDF_Dictionary> GetMutableDictFor(const ByteString& key);
   const CPDF_Array* GetArrayFor(const ByteString& key) const;
-  CPDF_Array* GetArrayFor(const ByteString& key);
+  CPDF_Array* GetArrayFor(const ByteString& key);  // Prefer next form.
+  RetainPtr<CPDF_Array> GetMutableArrayFor(const ByteString& key);
   const CPDF_Stream* GetStreamFor(const ByteString& key) const;
   CPDF_Stream* GetStreamFor(const ByteString& key);
   CFX_FloatRect GetRectFor(const ByteString& key) const;
diff --git a/third_party/pdfium/core/fpdfdoc/cpdf_nametree.cpp b/third_party/pdfium/core/fpdfdoc/cpdf_nametree.cpp
index 546a57331fba8..512a284b52512 100644
--- a/third_party/pdfium/core/fpdfdoc/cpdf_nametree.cpp
+++ b/third_party/pdfium/core/fpdfdoc/cpdf_nametree.cpp
@@ -39,7 +39,7 @@ std::pair<WideString, WideString> GetNodeLimitsMaybeSwap(CPDF_Array* pLimits) {
 // Get the limit arrays that leaf array |pFind| is under in the tree with root
 // |pNode|. |pLimits| will hold all the limit arrays from the leaf up to before
 // the root. Return true if successful.
-bool GetNodeAncestorsLimits(CPDF_Dictionary* pNode,
+bool GetNodeAncestorsLimits(const RetainPtr<CPDF_Dictionary>& pNode,
                             const CPDF_Array* pFind,
                             int nLevel,
                             std::vector<CPDF_Array*>* pLimits) {
@@ -56,7 +56,7 @@ bool GetNodeAncestorsLimits(CPDF_Dictionary* pNode,
     return false;
 
   for (size_t i = 0; i < pKids->size(); ++i) {
-    CPDF_Dictionary* pKid = pKids->GetDictAt(i);
+    RetainPtr<CPDF_Dictionary> pKid = pKids->GetMutableDictAt(i);
     if (!pKid)
       continue;
 
@@ -156,21 +156,21 @@ bool UpdateNodesAndLimitsUponDeletion(CPDF_Dictionary* pNode,
 // will be the index of |csName| in |ppFind|. If |csName| is not found, |ppFind|
 // will be the leaf array that |csName| should be added to, and |pFindIndex|
 // will be the index that it should be added at.
-CPDF_Object* SearchNameNodeByName(CPDF_Dictionary* pNode,
+CPDF_Object* SearchNameNodeByName(const RetainPtr<CPDF_Dictionary>& pNode,
                                   const WideString& csName,
                                   int nLevel,
                                   size_t* nIndex,
-                                  CPDF_Array** ppFind,
+                                  RetainPtr<CPDF_Array>* ppFind,
                                   int* pFindIndex) {
   if (nLevel > kNameTreeMaxRecursion)
     return nullptr;
 
-  CPDF_Array* pLimits = pNode->GetArrayFor("Limits");
-  CPDF_Array* pNames = pNode->GetArrayFor("Names");
+  RetainPtr<CPDF_Array> pLimits = pNode->GetMutableArrayFor("Limits");
+  RetainPtr<CPDF_Array> pNames = pNode->GetMutableArrayFor("Names");
   if (pLimits) {
     WideString csLeft;
     WideString csRight;
-    std::tie(csLeft, csRight) = GetNodeLimitsMaybeSwap(pLimits);
+    std::tie(csLeft, csRight) = GetNodeLimitsMaybeSwap(pLimits.Get());
     // Skip this node if the name to look for is smaller than its lower limit.
     if (csName.Compare(csLeft) < 0)
       return nullptr;
@@ -210,12 +210,12 @@ CPDF_Object* SearchNameNodeByName(CPDF_Dictionary* pNode,
   }
 
   // Search through the node's children.
-  CPDF_Array* pKids = pNode->GetArrayFor("Kids");
+  RetainPtr<CPDF_Array> pKids = pNode->GetMutableArrayFor("Kids");
   if (!pKids)
     return nullptr;
 
   for (size_t i = 0; i < pKids->size(); i++) {
-    CPDF_Dictionary* pKid = pKids->GetDictAt(i);
+    RetainPtr<CPDF_Dictionary> pKid = pKids->GetMutableDictAt(i);
     if (!pKid)
       continue;
 
@@ -236,7 +236,7 @@ CPDF_Object* SearchNameNodeByIndex(CPDF_Dictionary* pNode,
                                    int nLevel,
                                    size_t* nCurIndex,
                                    WideString* csName,
-                                   CPDF_Array** ppFind,
+                                   RetainPtr<CPDF_Array>* ppFind,
                                    int* pFindIndex) {
   if (nLevel > kNameTreeMaxRecursion)
     return nullptr;
@@ -395,17 +395,17 @@ size_t CPDF_NameTree::GetCount() const {
 bool CPDF_NameTree::AddValueAndName(RetainPtr<CPDF_Object> pObj,
                                     const WideString& name) {
   size_t nIndex = 0;
-  CPDF_Array* pFind = nullptr;
+  RetainPtr<CPDF_Array> pFind;
   int nFindIndex = -1;
   // Handle the corner case where the root node is empty. i.e. No kids and no
   // names. In which case, just insert into it and skip all the searches.
-  CPDF_Array* pNames = m_pRoot->GetArrayFor("Names");
+  RetainPtr<CPDF_Array> pNames = m_pRoot->GetMutableArrayFor("Names");
   if (pNames && pNames->IsEmpty() && !m_pRoot->GetArrayFor("Kids"))
     pFind = pNames;
 
   if (!pFind) {
     // Fail if the tree already contains this name or if the tree is too deep.
-    if (SearchNameNodeByName(m_pRoot.Get(), name, 0, &nIndex, &pFind,
+    if (SearchNameNodeByName(m_pRoot, name, 0, &nIndex, &pFind,
                              &nFindIndex)) {
       return false;
     }
@@ -435,7 +435,7 @@ bool CPDF_NameTree::AddValueAndName(RetainPtr<CPDF_Object> pObj,
   // Expand the limits that the newly added name is under, if the name falls
   // outside of the limits of its leaf array or any arrays above it.
   std::vector<CPDF_Array*> pLimits;
-  GetNodeAncestorsLimits(m_pRoot.Get(), pFind, 0, &pLimits);
+  GetNodeAncestorsLimits(m_pRoot, pFind.Get(), 0, &pLimits);
   for (auto* pLimit : pLimits) {
     if (!pLimit)
       continue;
@@ -452,7 +452,7 @@ bool CPDF_NameTree::AddValueAndName(RetainPtr<CPDF_Object> pObj,
 bool CPDF_NameTree::DeleteValueAndName(int nIndex) {
   size_t nCurIndex = 0;
   WideString csName;
-  CPDF_Array* pFind = nullptr;
+  RetainPtr<CPDF_Array> pFind;
   int nFindIndex = -1;
   // Fail if the tree does not contain |nIndex|.
   if (!SearchNameNodeByIndex(m_pRoot.Get(), nIndex, 0, &nCurIndex, &csName,
@@ -465,7 +465,7 @@ bool CPDF_NameTree::DeleteValueAndName(int nIndex) {
   pFind->RemoveAt(nFindIndex * 2);
 
   // Delete empty nodes and update the limits of |pFind|'s ancestors as needed.
-  UpdateNodesAndLimitsUponDeletion(m_pRoot.Get(), pFind, csName, 0);
+  UpdateNodesAndLimitsUponDeletion(m_pRoot.Get(), pFind.Get(), csName, 0);
   return true;
 }
 
@@ -479,7 +479,7 @@ CPDF_Object* CPDF_NameTree::LookupValueAndName(int nIndex,
 
 CPDF_Object* CPDF_NameTree::LookupValue(const WideString& csName) const {
   size_t nIndex = 0;
-  return SearchNameNodeByName(m_pRoot.Get(), csName, 0, &nIndex, nullptr,
+  return SearchNameNodeByName(m_pRoot, csName, 0, &nIndex, nullptr,
                               nullptr);
 }
 
diff --git a/third_party/pdfium/testing/resources/javascript/bug_1335681.in b/third_party/pdfium/testing/resources/javascript/bug_1335681.in
new file mode 100644
index 0000000000000..254e5964518c4
--- /dev/null
+++ b/third_party/pdfium/testing/resources/javascript/bug_1335681.in
@@ -0,0 +1,38 @@
+{{header}}
+{{object 1 0}} <<
+  /Pages 1 0 R
+  /OpenAction 2 0 R
+  /Names <<
+      /Dests 3 0 R
+  >>
+>>
+endobj
+{{object 2 0}} <<
+  /Type /Action
+  /S /JavaScript
+  /JS (
+    app.alert\("Starting"\);
+    this.gotoNamedDest\(""\);
+  )
+>>
+endobj
+{{object 3 0}} <<
+  /Kids 4 0 R
+>>
+endobj
+{{object 4 0}} [
+  << >>
+  << >>
+  <<
+    /Kids [
+      <<
+        /Limits 4 0 R
+      >>
+    ]
+  >>
+]
+endobj
+{{xref}}
+{{trailer}}
+{{startxref}}
+%%EOF
diff --git a/third_party/pdfium/testing/resources/javascript/bug_1335681_expected.txt b/third_party/pdfium/testing/resources/javascript/bug_1335681_expected.txt
new file mode 100644
index 0000000000000..80a6951c49c8c
--- /dev/null
+++ b/third_party/pdfium/testing/resources/javascript/bug_1335681_expected.txt
@@ -0,0 +1 @@
+Alert: Starting
diff --git a/third_party/skia/src/core/SkTraceEventCommon.h b/third_party/skia/src/core/SkTraceEventCommon.h
index db46692415061..cf6e8c63cd272 100644
--- a/third_party/skia/src/core/SkTraceEventCommon.h
+++ b/third_party/skia/src/core/SkTraceEventCommon.h
@@ -6,6 +6,7 @@
 
 #include "include/core/SkTypes.h"
 #include "include/utils/SkTraceEventPhase.h"
+#include "base/trace_event/trace_event_ohos.h"
 
 // Trace events are for tracking application performance and resource usage.
 // Macros are provided to track:
@@ -59,6 +60,7 @@
 
 #define TRACE_EMPTY do {} while (0)
 
+
 #ifdef SK_DISABLE_TRACING
 
 #define ATRACE_ANDROID_FRAMEWORK(fmt, ...) TRACE_EMPTY
@@ -190,7 +192,108 @@ public:
 #define TRACE_EVENT_CATEGORY_GROUP_ENABLED(category_group, ret)             \
   do { *ret = false; } while (0)
 
-#else // !SK_BUILD_FOR_ANDROID_FRAMEWORK && !SK_DISABLE_TRACING
+#elif defined(ENABLE_OHOS_SKIA_TRACE)  // OHOS skia Trace
+#define ATRACE_ANDROID_FRAMEWORK(fmt, ...) TRACE_EMPTY
+#define ATRACE_ANDROID_FRAMEWORK_ALWAYS(fmt, ...) TRACE_EMPTY
+
+// Records a pair of begin and end events called "name" for the current scope, with 0, 1 or 2
+// associated arguments. If the category is not enabled, then this does nothing.
+#define TRACE_EVENT0(category_group, name) \
+  (void)(category_group);                  \
+  BYTRACE_SCOPED(name);
+
+#define TRACE_EVENT0_ALWAYS(category_group, name) \
+  TRACE_EVENT0(category_group, name)
+
+#define TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
+  TRACE_EVENT0(category_group, GetStringWithArgs(name, arg1_name, arg1_val));
+
+#define TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name, arg2_val) \
+  TRACE_EVENT0(category_group, GetStringWithArgs(name, arg1_name, arg1_val, \
+                                                 arg2_name, arg2_val));
+
+// Records a single event called "name" immediately, with 0, 1 or 2 associated arguments. If the
+// category is not enabled, then this does nothing.
+#define TRACE_EVENT_INSTANT0(category_group, name, scope)                   \
+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
+                           TRACE_EVENT_FLAG_NONE | scope)
+
+#define TRACE_EVENT_INSTANT1(category_group, name, scope, arg1_name, arg1_val) \
+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
+                           TRACE_EVENT_FLAG_NONE | scope, arg1_name, arg1_val)
+
+#define TRACE_EVENT_INSTANT2(category_group, name, scope, arg1_name, arg1_val, \
+                             arg2_name, arg2_val)                              \
+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
+                           TRACE_EVENT_FLAG_NONE | scope, arg1_name, arg1_val, \
+                           arg2_name, arg2_val)
+
+// Records the value of a counter called "name" immediately. Value
+// must be representable as a 32 bit integer.
+#define TRACE_COUNTER1(category_group, name, value)                         \
+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
+                           TRACE_EVENT_FLAG_NONE, "value",                  \
+                           static_cast<int>(value))
+
+// Records the values of a multi-parted counter called "name" immediately.
+// The UI will treat value1 and value2 as parts of a whole, displaying their
+// values as a stacked-bar chart.
+#define TRACE_COUNTER2(category_group, name, value1_name, value1_val,       \
+                       value2_name, value2_val)                             \
+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
+                           TRACE_EVENT_FLAG_NONE, value1_name,              \
+                           static_cast<int>(value1_val), value2_name,       \
+                           static_cast<int>(value2_val))
+
+#define TRACE_EVENT_ASYNC_BEGIN0(category, name, id)                                           \
+    INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                                          \
+        TRACE_EVENT_PHASE_ASYNC_BEGIN, category, name, id, TRACE_EVENT_FLAG_NONE)
+#define TRACE_EVENT_ASYNC_BEGIN1(category, name, id, arg1_name, arg1_val)                      \
+    INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN,                            \
+        category, name, id, TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
+#define TRACE_EVENT_ASYNC_BEGIN2(category, name, id, arg1_name, arg1_val, arg2_name, arg2_val) \
+    INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN,                            \
+        category, name, id, TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
+
+#define TRACE_EVENT_ASYNC_END0(category, name, id)                                           \
+    INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,                            \
+        category, name, id, TRACE_EVENT_FLAG_NONE)
+#define TRACE_EVENT_ASYNC_END1(category, name, id, arg1_name, arg1_val)                      \
+    INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,                            \
+        category, name, id, TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
+#define TRACE_EVENT_ASYNC_END2(category, name, id, arg1_name, arg1_val, arg2_name, arg2_val) \
+    INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,                            \
+        category, name, id, TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
+
+// Macros to track the life time and value of arbitrary client objects.
+#define TRACE_EVENT_OBJECT_CREATED_WITH_ID(category_group, name, id) \
+  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
+      TRACE_EVENT_PHASE_CREATE_OBJECT, category_group, name, id,     \
+      TRACE_EVENT_FLAG_NONE)
+
+#define TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID(category_group, name, id, \
+                                            snapshot)                 \
+  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
+      TRACE_EVENT_PHASE_SNAPSHOT_OBJECT, category_group, name,        \
+      id, TRACE_EVENT_FLAG_NONE, "snapshot", snapshot)
+
+#define TRACE_EVENT_OBJECT_DELETED_WITH_ID(category_group, name, id) \
+  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
+      TRACE_EVENT_PHASE_DELETE_OBJECT, category_group, name, id,     \
+      TRACE_EVENT_FLAG_NONE)
+
+// Macro to efficiently determine if a given category group is enabled.
+#define TRACE_EVENT_CATEGORY_GROUP_ENABLED(category_group, ret)             \
+  do {                                                                      \
+    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                 \
+    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) { \
+      *ret = true;                                                          \
+    } else {                                                                \
+      *ret = false;                                                         \
+    }                                                                       \
+  } while (0)
+
+#else // !SK_BUILD_FOR_ANDROID_FRAMEWORK && !SK_DISABLE_TRACING && !OS_OHOS
 
 #define ATRACE_ANDROID_FRAMEWORK(fmt, ...) TRACE_EMPTY
 #define ATRACE_ANDROID_FRAMEWORK_ALWAYS(fmt, ...) TRACE_EMPTY
diff --git a/third_party/sqlite/src/src/printf.c b/third_party/sqlite/src/src/printf.c
index f78d3bbb178b7..1c9eb53e412fa 100644
--- a/third_party/sqlite/src/src/printf.c
+++ b/third_party/sqlite/src/src/printf.c
@@ -797,8 +797,8 @@ void sqlite3_str_vappendf(
       case etSQLESCAPE:           /* %q: Escape ' characters */
       case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */
       case etSQLESCAPE3: {        /* %w: Escape " characters */
-        int i, j, k, n, isnull;
-        int needQuote;
+        i64 i, j, k, n;
+        int needQuote, isnull;
         char ch;
         char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */
         char *escarg;
diff --git a/third_party/webrtc/pc/peer_connection_simulcast_unittest.cc b/third_party/webrtc/pc/peer_connection_simulcast_unittest.cc
index 8822a980f7a97..3476429811a0e 100644
--- a/third_party/webrtc/pc/peer_connection_simulcast_unittest.cc
+++ b/third_party/webrtc/pc/peer_connection_simulcast_unittest.cc
@@ -556,6 +556,27 @@ TEST_F(PeerConnectionSimulcastTests, NegotiationDoesNotHaveRidExtension) {
   ValidateTransceiverParameters(transceiver, expected_layers);
 }
 
+// Check that modifying the offer to remove simulcast and at the same
+// time leaving in a RID line does not cause an exception.
+TEST_F(PeerConnectionSimulcastTests, SimulcastSldModificationRejected) {
+  auto local = CreatePeerConnectionWrapper();
+  auto remote = CreatePeerConnectionWrapper();
+  auto layers = CreateLayers({"1", "2", "3"}, true);
+  AddTransceiver(local.get(), layers);
+  auto offer = local->CreateOffer();
+  std::string as_string;
+  EXPECT_TRUE(offer->ToString(&as_string));
+  auto simulcast_marker = "a=rid:3 send\r\na=simulcast:send 1;2;3\r\n";
+  auto pos = as_string.find(simulcast_marker);
+  EXPECT_NE(pos, std::string::npos);
+  as_string.erase(pos, strlen(simulcast_marker));
+  SdpParseError parse_error;
+  auto modified_offer =
+      CreateSessionDescription(SdpType::kOffer, as_string, &parse_error);
+  EXPECT_TRUE(modified_offer);
+  EXPECT_TRUE(local->SetLocalDescription(std::move(modified_offer)));
+}
+
 #if RTC_METRICS_ENABLED
 //
 // Checks the logged metrics when simulcast is not used.
diff --git a/third_party/webrtc/pc/rtp_sender.cc b/third_party/webrtc/pc/rtp_sender.cc
index 7026dd9db75f6..e3db51fffbf4a 100644
--- a/third_party/webrtc/pc/rtp_sender.cc
+++ b/third_party/webrtc/pc/rtp_sender.cc
@@ -291,8 +291,8 @@ void RtpSenderBase::SetSsrc(uint32_t ssrc) {
       // we need to copy.
       RtpParameters current_parameters =
           media_channel_->GetRtpSendParameters(ssrc_);
-      RTC_DCHECK_GE(current_parameters.encodings.size(),
-                    init_parameters_.encodings.size());
+      RTC_CHECK_GE(current_parameters.encodings.size(),
+                   init_parameters_.encodings.size());
       for (size_t i = 0; i < init_parameters_.encodings.size(); ++i) {
         init_parameters_.encodings[i].ssrc =
             current_parameters.encodings[i].ssrc;
diff --git a/third_party/webrtc/pc/rtp_sender_receiver_unittest.cc b/third_party/webrtc/pc/rtp_sender_receiver_unittest.cc
index 364e87a89f36e..7a32cb0d9defe 100644
--- a/third_party/webrtc/pc/rtp_sender_receiver_unittest.cc
+++ b/third_party/webrtc/pc/rtp_sender_receiver_unittest.cc
@@ -1120,6 +1120,44 @@ TEST_F(RtpSenderReceiverTest,
   DestroyVideoRtpSender();
 }
 
+#if GTEST_HAS_DEATH_TEST && !defined(WEBRTC_ANDROID)
+using RtpSenderReceiverDeathTest = RtpSenderReceiverTest;
+
+TEST_F(RtpSenderReceiverDeathTest,
+       VideoSenderManualRemoveSimulcastFailsDeathTest) {
+  AddVideoTrack(false);
+
+  std::unique_ptr<MockSetStreamsObserver> set_streams_observer =
+      std::make_unique<MockSetStreamsObserver>();
+  video_rtp_sender_ = VideoRtpSender::Create(worker_thread_, video_track_->id(),
+                                             set_streams_observer.get());
+  ASSERT_TRUE(video_rtp_sender_->SetTrack(video_track_.get()));
+  EXPECT_CALL(*set_streams_observer, OnSetStreams());
+  video_rtp_sender_->SetStreams({local_stream_->id()});
+
+  std::vector<RtpEncodingParameters> init_encodings(2);
+  init_encodings[0].max_bitrate_bps = 60000;
+  init_encodings[1].max_bitrate_bps = 120000;
+  video_rtp_sender_->set_init_send_encodings(init_encodings);
+
+  RtpParameters params = video_rtp_sender_->GetParameters();
+  ASSERT_EQ(2u, params.encodings.size());
+  EXPECT_EQ(params.encodings[0].max_bitrate_bps, 60000);
+
+  // Simulate the setLocalDescription call as if the user used SDP munging
+  // to disable simulcast.
+  std::vector<uint32_t> ssrcs;
+  ssrcs.reserve(2);
+  for (int i = 0; i < 2; ++i)
+    ssrcs.push_back(kVideoSsrcSimulcast + i);
+  cricket::StreamParams stream_params =
+      cricket::StreamParams::CreateLegacy(kVideoSsrc);
+  video_media_channel()->AddSendStream(stream_params);
+  video_rtp_sender_->SetMediaChannel(video_media_channel());
+  EXPECT_DEATH(video_rtp_sender_->SetSsrc(kVideoSsrcSimulcast), "");
+}
+#endif
+
 TEST_F(RtpSenderReceiverTest,
        VideoSenderMustCallGetParametersBeforeSetParametersBeforeNegotiation) {
   video_rtp_sender_ =
diff --git a/third_party/webrtc/pc/webrtc_sdp.cc b/third_party/webrtc/pc/webrtc_sdp.cc
index 26eb4f30fd1aa..b732bc829d722 100644
--- a/third_party/webrtc/pc/webrtc_sdp.cc
+++ b/third_party/webrtc/pc/webrtc_sdp.cc
@@ -3332,7 +3332,6 @@ bool ParseContent(const std::string& message,
 
   // If simulcast is specifed, split the rids into send and receive.
   // Rids that do not appear in simulcast attribute will be removed.
-  // If it is not specified, we assume that all rids are for send layers.
   std::vector<RidDescription> send_rids;
   std::vector<RidDescription> receive_rids;
   if (!simulcast.empty()) {
@@ -3359,7 +3358,11 @@ bool ParseContent(const std::string& message,
 
     media_desc->set_simulcast_description(simulcast);
   } else {
-    send_rids = rids;
+    // RID is specified in RFC 8851, which identifies a lot of usages.
+    // We only support RFC 8853 usage of RID, not anything else.
+    // Ignore all RID parameters when a=simulcast is missing.
+    // In particular do NOT do send_rids = rids;
+    RTC_LOG(LS_VERBOSE) << "Ignoring send_rids without simulcast";
   }
 
   media_desc->set_receive_rids(receive_rids);
diff --git a/tools/cfi/ignores.txt b/tools/cfi/ignores.txt
index e0fe3a658b53e..5e03197f09323 100644
--- a/tools/cfi/ignores.txt
+++ b/tools/cfi/ignores.txt
@@ -1,6 +1,8 @@
 # This file defines which warnings should be ignored while running clang's
 # control flow integrity sanitizer, as run by the cfi_flags build target.
 
+fun:*MemoryBarrier*
+
 [cfi-unrelated-cast|cfi-derived-cast]
 
 # e.g. RolloverProtectedTickClock
diff --git a/tools/gritsettings/resource_ids.spec b/tools/gritsettings/resource_ids.spec
index 0510f27471ea5..a836e4d6ba5c3 100644
--- a/tools/gritsettings/resource_ids.spec
+++ b/tools/gritsettings/resource_ids.spec
@@ -735,6 +735,14 @@
     "includes": [3880],
   },
 
+  # For OHOS_NWEB_EX
+  "ohos_nweb_ex/overrides/ui/resources/ohos_nweb_ex_resources.grd": {
+    "includes": [3900],
+  },
+  "ohos_nweb_ex/overrides/ui/strings/ohos_nweb_ex_strings.grd": {
+    "messages": [3920],
+  },
+
   # END "everything else" section.
   # Everything but chrome/, components/, content/, and ios/
 
diff --git a/tools/metrics/histograms/enums.xml b/tools/metrics/histograms/enums.xml
index 4af899b058a6a..7d7adf6897ec9 100644
--- a/tools/metrics/histograms/enums.xml
+++ b/tools/metrics/histograms/enums.xml
@@ -7144,6 +7144,9 @@ Called by update_bad_message_reasons.py.-->
   <int value="241" label="PAYMENTS_WITHOUT_PERMISSION"/>
   <int value="242" label="WEB_BUNDLE_INVALID_NAVIGATION_URL"/>
   <int value="254" label="RFH_CREATE_CHILD_FRAME_SANDBOX_FLAGS"/>
+  <int value="259" label="PMM_SUBSCRIBE_INVALID_ORIGIN"/>
+  <int value="260" label="PMM_UNSUBSCRIBE_INVALID_ORIGIN"/>
+  <int value="261" label="PMM_GET_SUBSCRIPTION_INVALID_ORIGIN"/>
 </enum>
 
 <enum name="BadMessageReasonExtensions">
diff --git a/ui/aura/gestures/gesture_recognizer_unittest.cc b/ui/aura/gestures/gesture_recognizer_unittest.cc
index fafd5cb6096de..1a53111877625 100644
--- a/ui/aura/gestures/gesture_recognizer_unittest.cc
+++ b/ui/aura/gestures/gesture_recognizer_unittest.cc
@@ -4790,5 +4790,42 @@ TEST_F(GestureRecognizerTest, GestureConsumerCleanupBeforeTouchAck) {
   EXPECT_0_EVENTS(delegate->events());
 }
 
+// Verifies that destructing a `GestureRecognizerImpl` instance with gesture
+// providers works as expected (https://crbug.com/1325256).
+TEST_F(GestureRecognizerTest, ResetGestureRecognizerWithGestureProvider) {
+  TimedEvents tes;
+  const int kTouchId = 4;
+  std::unique_ptr<GestureEventConsumeDelegate> delegate(
+      new GestureEventConsumeDelegate());
+  std::unique_ptr<aura::Window> window(CreateTestWindowWithDelegate(
+      delegate.get(), /*id=*/-2345, /*bounds=*/gfx::Rect(0, 0, 50, 50),
+      /*parent=*/root_window()));
+
+  // Touch press then release on `window`.
+  constexpr gfx::Point touch_location(/*x=*/10, /*y=*/20);
+  ui::TouchEvent press(
+      ui::ET_TOUCH_PRESSED, touch_location, /*time_stamp=*/tes.Now(),
+      ui::PointerDetails(ui::EventPointerType::kTouch, kTouchId));
+  delegate->Reset();
+  DispatchEventUsingWindowDispatcher(&press);
+  EXPECT_TRUE(delegate->tap_down());
+  delegate->Reset();
+  ui::TouchEvent release(
+      ui::ET_TOUCH_RELEASED, touch_location,
+      /*time_stamp=*/press.time_stamp() + base::Milliseconds(50),
+      ui::PointerDetails(ui::EventPointerType::kTouch, kTouchId));
+  DispatchEventUsingWindowDispatcher(&release);
+  EXPECT_FALSE(delegate->tap_down());
+
+  // Check that the gesture recognizer owns one gesture provider.
+  EXPECT_EQ(1u, static_cast<ui::GestureRecognizerImpl*>(
+                    aura::Env::GetInstance()->gesture_recognizer())
+                    ->consumer_gesture_provider_.size());
+
+  // Destroy the current gesture recognizer.
+  aura::Env::GetInstance()->SetGestureRecognizer(
+      std::make_unique<ui::GestureRecognizerImpl>());
+}
+
 }  // namespace test
 }  // namespace aura
diff --git a/ui/base/clipboard/BUILD.gn b/ui/base/clipboard/BUILD.gn
index e710361b70b7c..222c6b7bf7f70 100644
--- a/ui/base/clipboard/BUILD.gn
+++ b/ui/base/clipboard/BUILD.gn
@@ -33,8 +33,9 @@ component("clipboard_types") {
   if (is_win) {
     sources += [ "clipboard_format_type_win.cc" ]
   }
-
-  if (use_aura) {
+  if (is_ohos) {
+    sources += [ "ohos/clipboard_format_type_ohos.cc" ]
+  } else if (use_aura) {
     if ((use_x11 && (is_linux || is_chromeos_lacros)) || !is_win) {
       sources += [ "clipboard_format_type_aura.cc" ]
     }
@@ -127,8 +128,18 @@ component("clipboard") {
     ":file_info",
     "//ui/base/data_transfer_policy",
   ]
-
-  if (use_aura) {
+  if (is_ohos) {
+    sources += [
+      "ohos/clipboard_ohos.cc",
+      "ohos/clipboard_ohos.h",
+       "clipboard_data.cc",
+       "clipboard_data.h"
+    ]
+    import("//build/config/ohos/config.gni")
+    libs = [ "nweb_ohos_adapter.z" ]
+    include_dirs = ohos_src_includes
+    lib_dirs = ohos_libs_dir
+  } else if (use_aura) {
     if (use_ozone) {
       sources += [
         "clipboard_data.cc",
diff --git a/ui/base/clipboard/clipboard_constants.cc b/ui/base/clipboard/clipboard_constants.cc
index 8cc7de6b48e6f..bddd7b7941d97 100644
--- a/ui/base/clipboard/clipboard_constants.cc
+++ b/ui/base/clipboard/clipboard_constants.cc
@@ -32,4 +32,8 @@ const char kMimeTypeWebkitSmartPaste[] = "chromium/x-webkit-paste";
 #if defined(OS_ANDROID)
 const char kMimeTypeImageURI[] = "image-uri";
 #endif  // defined(OS_ANDROID)
+
+#if defined(OS_OHOS)
+const char kMimeTypeOHOSCusteomData[] = "ohos/custom-data";
+#endif  // defined(OS_OHOS)
 }  // namespace ui
diff --git a/ui/base/clipboard/clipboard_constants.h b/ui/base/clipboard/clipboard_constants.h
index 0509ce8d47a8e..abdc7e1530466 100644
--- a/ui/base/clipboard/clipboard_constants.h
+++ b/ui/base/clipboard/clipboard_constants.h
@@ -79,6 +79,11 @@ COMPONENT_EXPORT(UI_BASE_CLIPBOARD_TYPES)
 extern const char kMimeTypeImageURI[];
 #endif  // defined(OS_ANDROID)
 
+#if defined(OS_OHOS)
+COMPONENT_EXPORT(UI_BASE_CLIPBOARD_TYPES)
+extern const char kMimeTypeOHOSCusteomData[];
+#endif  // defined(OS_OHOS)
+
 }  // namespace ui
 
 #endif  // UI_BASE_CLIPBOARD_CLIPBOARD_CONSTANTS_H_
diff --git a/ui/base/clipboard/ohos/clipboard_format_type_ohos.cc b/ui/base/clipboard/ohos/clipboard_format_type_ohos.cc
new file mode 100644
index 0000000000000..b7b1f5cab7531
--- /dev/null
+++ b/ui/base/clipboard/ohos/clipboard_format_type_ohos.cc
@@ -0,0 +1,106 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+
+namespace ui {
+
+// TODO(huangdarwin): Investigate creating a new clipboard_format_type_x11 as a
+// wrapper around an X11 ::Atom. This wasn't possible in the past, because unit
+// tests spawned a new X11 server for each test, meaning Atom numeric values
+// didn't persist across tests.
+ClipboardFormatType::ClipboardFormatType() = default;
+
+ClipboardFormatType::~ClipboardFormatType() = default;
+
+ClipboardFormatType::ClipboardFormatType(const std::string& native_format)
+    : data_(native_format) {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return data_;
+}
+
+// static
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(serialization);
+}
+
+std::string ClipboardFormatType::GetName() const {
+  return Serialize();
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_ < other.data_;
+}
+
+bool ClipboardFormatType::operator==(const ClipboardFormatType& other) const {
+  return data_ == other.data_;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+// static
+ClipboardFormatType ClipboardFormatType::GetType(
+    const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetFilenamesType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeURIList);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetUrlType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeMozillaURL);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetPlainTextType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeText);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetHtmlType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeHTML);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetSvgType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeSvg);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetRtfType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeRTF);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetBitmapType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypePNG);
+  return *type;
+}
+ 
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebKitSmartPasteType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypeWebkitSmartPaste);
+  return *type;
+}
+
+// static
+const ClipboardFormatType& ClipboardFormatType::GetWebCustomDataType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeOHOSCusteomData);
+  return *type;
+}
+
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/base/clipboard/ohos/clipboard_ohos.cc b/ui/base/clipboard/ohos/clipboard_ohos.cc
new file mode 100644
index 0000000000000..94e9610e86c64
--- /dev/null
+++ b/ui/base/clipboard/ohos/clipboard_ohos.cc
@@ -0,0 +1,653 @@
+// Copyright 2022 The Huawei Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/ohos/clipboard_ohos.h"
+
+#include "base/check_op.h"
+#include "base/feature_list.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/ptr_util.h"
+#include "base/no_destructor.h"
+#include "base/notreached.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/synchronization/lock.h"
+#include "skia/ext/skia_utils_base.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_data.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/clipboard/clipboard_metrics.h"
+#include "ui/base/clipboard/clipboard_monitor.h"
+#include "ui/base/clipboard/custom_data_helper.h"
+#include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
+#include "ui/base/data_transfer_policy/data_transfer_policy_controller.h"
+
+#include "base/logging.h"
+#include "ohos_adapter_helper.h"
+
+#include <securec.h>
+
+using namespace OHOS::NWeb;
+
+namespace ui {
+namespace {
+using InstanceRegistry = std::set<const ClipboardOHOS*, std::less<>>;
+InstanceRegistry* GetInstanceRegistry() {
+  static base::NoDestructor<InstanceRegistry> registry;
+  return registry.get();
+}
+
+base::Lock& GetInstanceRegistryLock() {
+  static base::NoDestructor<base::Lock> registry_lock;
+  return *registry_lock;
+}
+
+void RegisterInstance(const ClipboardOHOS* clipboard) {
+  base::AutoLock lock(GetInstanceRegistryLock());
+  GetInstanceRegistry()->insert(clipboard);
+}
+
+void UnregisterInstance(const ClipboardOHOS* clipboard) {
+  base::AutoLock lock(GetInstanceRegistryLock());
+  GetInstanceRegistry()->erase(clipboard);
+}
+
+bool IsRegisteredInstance(const Clipboard* clipboard) {
+  base::AutoLock lock(GetInstanceRegistryLock());
+  return base::Contains(*GetInstanceRegistry(), clipboard);
+}
+}
+
+Clipboard* Clipboard::Create() {
+  return new ClipboardOHOS;
+}
+
+
+class ClipboardOHOSInternal{
+ public:
+  ClipboardOHOSInternal() = default;
+
+  ~ClipboardOHOSInternal() = default;
+
+  void Clear() {
+    ++sequence_number_;
+    data_.reset();
+    OhosAdapterHelper::GetInstance().GetPasteBoard().Clear();
+  }
+
+  uint64_t sequence_number() const { return sequence_number_; }
+
+  // Returns the current clipboard data, which may be nullptr if nothing has
+  // been written since the last Clear().
+  const ClipboardData* GetData() const { return data_.get(); }
+
+  // Returns true if the data on top of the clipboard stack has format |format|
+  // or another format that can be converted to |format|.
+  bool IsFormatAvailable(ClipboardInternalFormat format) const {
+    if (format == ClipboardInternalFormat::kText) {
+      return HasFormatInMisc(ClipboardInternalFormat::kText) ||
+             HasFormatInMisc(ClipboardInternalFormat::kBookmark);
+    }
+    return HasFormatInMisc(format);
+  }
+
+  // Reads text from the ClipboardData.
+  void ReadText(std::u16string* result) const {
+    PasteRecordList resultList;
+    if (!OhosAdapterHelper::GetInstance().GetPasteBoard().GetPasteData(resultList)) {
+      LOG(ERROR) << "get paste data failed when read text";
+      return;
+    }
+    if (resultList.size() > 0) {
+      for (auto& record: resultList) {
+        std::shared_ptr<std::string> text = record->GetPlainText();
+        if (text) {
+          std::string data = *text;
+          *result = base::UTF8ToUTF16(data);
+        }
+      }
+    } else {
+      LOG(ERROR) << "clipboad data is empty";
+    }
+
+  }
+
+  // Reads HTML from the ClipboardData.
+  void ReadHTML(std::u16string* markup,
+                std::string* src_url,
+                uint32_t* fragment_start,
+                uint32_t* fragment_end) const {
+    markup->clear();
+    if (src_url)
+      src_url->clear();
+    *fragment_start = 0;
+    *fragment_end = 0;
+
+    PasteRecordList resultList;
+    if (!OhosAdapterHelper::GetInstance().GetPasteBoard().GetPasteData(resultList)) {
+      LOG(ERROR) << "get paste data failed when read html";
+      return;
+    }
+    if (resultList.size() > 0) {
+      for (auto& record: resultList) {
+        std::string data;
+        std::shared_ptr<std::string> html = record->GetHtmlText();
+        std::shared_ptr<std::string> text = record->GetPlainText();
+        if (html) {
+          std::shared_ptr<std::string> html = record->GetHtmlText();
+          data = *html;                
+          *markup = base::UTF8ToUTF16(data);
+          *fragment_start = 0;
+          *fragment_end = static_cast<uint32_t>(markup->length());
+          return;
+        } else if (text) {
+          std::shared_ptr<std::string> text = record->GetPlainText();
+          data = "<span>" + *text + "</span>";
+          *markup = base::UTF8ToUTF16(data);
+          *fragment_start = 0;
+          *fragment_end = static_cast<uint32_t>(markup->length());
+        } else {
+          continue;
+        }
+      }
+    } else {
+      LOG(ERROR) << "clipboad data is empty";
+    }
+  }
+
+  SkAlphaType AlphaTypeToSkAlphaType(const ClipBoardImageData &imgData) const
+  {
+      switch (imgData.alphaType) {
+          case ClipBoardImageAlphaType::ALPHA_TYPE_UNKNOWN:
+              return SkAlphaType::kUnknown_SkAlphaType;
+          case ClipBoardImageAlphaType::ALPHA_TYPE_OPAQUE:
+              return SkAlphaType::kOpaque_SkAlphaType;
+          case ClipBoardImageAlphaType::ALPHA_TYPE_PREMULTIPLIED:
+              return SkAlphaType::kPremul_SkAlphaType;
+          case ClipBoardImageAlphaType::ALPHA_TYPE_POSTMULTIPLIED:
+              return SkAlphaType::kUnpremul_SkAlphaType;
+          default:
+              return SkAlphaType::kUnknown_SkAlphaType;
+      }
+  }
+
+  SkColorType PixelFormatToSkColorType(const ClipBoardImageData &imgData) const
+  {
+      switch (imgData.colorType) {
+          case ClipBoardImageColorType::COLOR_TYPE_RGBA_8888:
+              return SkColorType::kRGBA_8888_SkColorType;
+          case ClipBoardImageColorType::COLOR_TYPE_BGRA_8888:
+              return SkColorType::kBGRA_8888_SkColorType;
+          default:
+              return SkColorType::kUnknown_SkColorType;
+      }
+  }
+
+  SkImageInfo MakeSkImageInfoFromPixelMap(const ClipBoardImageData &imgData) const
+  {
+      SkColorType colorType = PixelFormatToSkColorType(imgData);
+      SkAlphaType alphaType = AlphaTypeToSkAlphaType(imgData);
+      sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeSRGB();
+      return SkImageInfo::Make(imgData.width, imgData.height, colorType, alphaType, colorSpace);
+  }
+
+  // Reads image from the ClipboardData.
+  SkBitmap ReadImage() const {
+    SkBitmap img;
+    if (!HasFormatInMisc(ClipboardInternalFormat::kBitmap)) {
+      LOG(ERROR) << "no bitMap format in pasteboard";
+      return img;
+    }
+    PasteRecordList recordList;
+    if (OhosAdapterHelper::GetInstance().GetPasteBoard().GetPasteData(recordList) &&
+      (recordList.size() > 0)) {
+      for (auto& r: recordList) {
+        ClipBoardImageData imgData;
+        bool imageFlag = r->GetImgData(imgData);
+        if (imageFlag) {
+          LOG(INFO) << "get image from record success";
+        } else {
+          LOG(ERROR) << "get image from record failed";
+          return img;
+        }
+        SkImageInfo skImageInfo = MakeSkImageInfoFromPixelMap(imgData);
+        SkPixmap pixmap(skImageInfo, imgData.data, imgData.rowBytes);
+        if (!img.installPixels(pixmap)) {
+          LOG(ERROR) << "installPixels failed";
+        }
+      }
+    } else {
+      LOG(ERROR) << "get image from pasteboard failed";
+    }
+    return img;
+  }
+
+  // Writes |data| to the ClipboardData and returns the previous data.
+  std::unique_ptr<ClipboardData> WriteData(
+      std::unique_ptr<ClipboardData> data) {
+    DCHECK(data);
+    std::unique_ptr<ClipboardData> previous_data = std::move(data_);
+    data_ = std::move(data);
+    const ClipboardData* currentData = GetData();
+    if (!currentData)
+      return nullptr;
+    PasteRecordList recordList;
+    std::shared_ptr<PasteDataRecordAdapter> record =
+        PasteDataRecordAdapter::NewRecord("text/html");
+    if (HasFormat(ClipboardInternalFormat::kHtml)) {
+      std::shared_ptr<std::string> html = std::make_shared<std::string>(currentData->markup_data());
+      if (record->SetHtmlText(html)) {
+        LOG(INFO) << "set html to record success";
+      } else {
+        LOG(ERROR) << "set html to record failed";
+      }
+    }
+
+    if (HasFormat(ClipboardInternalFormat::kText)) {
+      std::shared_ptr<std::string> text = std::make_shared<std::string>(currentData->text());
+      if (record->SetPlainText(text)) {
+        LOG(INFO) << "set text to record success";
+      } else {
+        LOG(ERROR) << "set text to record failed";
+      }
+    }
+    recordList.push_back(record);
+    OhosAdapterHelper::GetInstance().GetPasteBoard().SetPasteData(recordList);
+    ++sequence_number_;
+    return previous_data;
+  }
+
+  bool IsReadAllowed(const DataTransferEndpoint* data_dst) const {
+    DataTransferPolicyController* policy_controller =
+        DataTransferPolicyController::Get();
+    auto* data = GetData();
+    if (!policy_controller || !data)
+      return true;
+    bool allow = policy_controller->IsClipboardReadAllowed(data->source(), data_dst);
+    return allow;
+  }
+
+ private:
+  // True if the ClipboardData has format |format|.
+  bool HasFormat(ClipboardInternalFormat format) const {
+    const ClipboardData* data = GetData();
+    return data ? data->format() & static_cast<int>(format) : false;
+  }
+
+  bool HasFormatInMisc(ClipboardInternalFormat format) const {
+    PasteRecordList resultList;
+    int allFormat = 0;
+    if (!OhosAdapterHelper::GetInstance().GetPasteBoard().GetPasteData(resultList)) {
+      LOG(ERROR) << "get paste data failed when read html";
+      return false;
+    }
+    if (resultList.size() > 0) {
+      for (auto& record: resultList) {
+        std::shared_ptr<std::string> html = record->GetHtmlText();
+        std::shared_ptr<std::string> text = record->GetPlainText();
+        ClipBoardImageData imgData;
+        bool imgFlag = false;
+        imgFlag = record->GetImgData(imgData);
+        if (html) {
+          allFormat |= static_cast<int>(ClipboardInternalFormat::kHtml);
+        }
+        if (text) {
+          allFormat |= static_cast<int>(ClipboardInternalFormat::kText);
+        }
+        if (imgFlag) {
+          allFormat |= static_cast<int>(ClipboardInternalFormat::kBitmap);
+        }
+      }
+    }
+    return allFormat & static_cast<int>(format);
+  }
+
+  // Current ClipboardData.
+  std::unique_ptr<ClipboardData> data_;
+
+  // Sequence number uniquely identifying clipboard state.
+  uint64_t sequence_number_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(ClipboardOHOSInternal);
+};
+
+class ClipboardDataBuilder {
+ public:
+  // If |data_src| is nullptr, this means that the data source isn't
+  // confidential and the data can be pasted in any document.
+  static void CommitToClipboard(
+      ClipboardOHOSInternal* clipboard,
+      std::unique_ptr<DataTransferEndpoint> data_src) {
+    ClipboardData* data = GetCurrentData();
+    data->set_source(std::move(data_src));
+    clipboard->WriteData(TakeCurrentData());
+  }
+
+  static void WriteText(const char* text_data, size_t text_len) {
+    ClipboardData* data = GetCurrentData();
+    data->set_text(std::string(text_data, text_len));
+  }
+
+  static void WriteHTML(const char* markup_data,
+                        size_t markup_len,
+                        const char* url_data,
+                        size_t url_len) {
+    ClipboardData* data = GetCurrentData();
+    data->set_markup_data(std::string(markup_data, markup_len));
+    data->set_url(std::string(url_data, url_len));
+  }
+
+  static void WriteData(const std::string& format,
+                        const char* data_data,
+                        size_t data_len) {
+    ClipboardData* data = GetCurrentData();
+    data->SetCustomData(format, std::string(data_data, data_len));
+  }
+
+ private:
+  static ClipboardData* GetCurrentData() {
+    if (!current_data_) {
+      current_data_ = new ClipboardData;
+    }
+    return current_data_;
+  }
+
+  static std::unique_ptr<ClipboardData> TakeCurrentData() {
+    std::unique_ptr<ClipboardData> data = base::WrapUnique(GetCurrentData());
+    current_data_ = nullptr;
+    return data;
+  }
+  // This is a raw pointer instead of a std::unique_ptr to avoid adding a
+  // static initializer.
+  static ClipboardData* current_data_;
+};
+
+ClipboardData* ClipboardDataBuilder::current_data_ = nullptr;
+// static
+ClipboardOHOS* ClipboardOHOS::GetForCurrentThread() {
+  auto* clipboard = Clipboard::GetForCurrentThread();
+
+  // Ensure type safety. In tests the instance may not be registered.
+  if (!IsRegisteredInstance(clipboard))
+    return nullptr;
+
+  return static_cast<ClipboardOHOS*>(clipboard);
+}
+
+// ClipboardOHOS implementation.
+ClipboardOHOS::ClipboardOHOS()
+    : clipboard_internal_(std::make_unique<ClipboardOHOSInternal>()) {
+  DCHECK(CalledOnValidThread());
+  RegisterInstance(this);
+}
+
+ClipboardOHOS::~ClipboardOHOS() {
+  DCHECK(CalledOnValidThread());
+  UnregisterInstance(this);
+}
+
+std::unique_ptr<ClipboardData> ClipboardOHOS::WriteClipboardData(
+    std::unique_ptr<ClipboardData> data) {
+  DCHECK(CalledOnValidThread());
+  return clipboard_internal_->WriteData(std::move(data));
+}
+
+void ClipboardOHOS::OnPreShutdown() {}
+
+DataTransferEndpoint* ClipboardOHOS::GetSource(
+    ClipboardBuffer buffer) const {
+  const ClipboardData* data = clipboard_internal_->GetData();
+  return data ? data->source() : nullptr;
+}
+
+uint64_t ClipboardOHOS::GetSequenceNumber(ClipboardBuffer buffer) const {
+  DCHECK(CalledOnValidThread());
+  return clipboard_internal_->sequence_number();
+}
+
+bool ClipboardOHOS::IsFormatAvailable(
+    const ClipboardFormatType& format,
+    ClipboardBuffer buffer,
+    const DataTransferEndpoint* data_dst) const {
+  DCHECK(CalledOnValidThread());
+  DCHECK(IsSupportedClipboardBuffer(buffer));
+  if (!clipboard_internal_->IsReadAllowed(data_dst)) {
+    return false;
+  }
+  if (format == ClipboardFormatType::GetPlainTextType() ||
+      format == ClipboardFormatType::GetUrlType()) {
+        return clipboard_internal_->IsFormatAvailable(
+          ClipboardInternalFormat::kText);
+      }
+  if (format == ClipboardFormatType::GetHtmlType())
+    return clipboard_internal_->IsFormatAvailable(
+        ClipboardInternalFormat::kHtml);
+  if (format == ClipboardFormatType::GetBitmapType())
+    return clipboard_internal_->IsFormatAvailable(
+        ClipboardInternalFormat::kBitmap);
+  if (format == ClipboardFormatType::GetWebKitSmartPasteType())
+    return clipboard_internal_->IsFormatAvailable(
+        ClipboardInternalFormat::kWeb);
+  const ClipboardData* data = clipboard_internal_->GetData();
+  return data && data->custom_data_format() == format.GetName();
+}
+
+void ClipboardOHOS::Clear(ClipboardBuffer buffer) {
+  DCHECK(CalledOnValidThread());
+  DCHECK(IsSupportedClipboardBuffer(buffer));
+  clipboard_internal_->Clear();
+}
+
+void ClipboardOHOS::ReadAvailableTypes(
+    ClipboardBuffer buffer,
+    const DataTransferEndpoint* data_dst,
+    std::vector<std::u16string>* types) const {
+  DCHECK(CalledOnValidThread());
+  DCHECK(types);
+
+  if (!clipboard_internal_->IsReadAllowed(data_dst))
+    return;
+  types->clear();
+  if (IsFormatAvailable(ClipboardFormatType::GetPlainTextType(), buffer,
+                        data_dst))
+    types->push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetPlainTextType().GetName()));
+  if (IsFormatAvailable(ClipboardFormatType::GetHtmlType(), buffer, data_dst))
+    types->push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetHtmlType().GetName()));
+  if (IsFormatAvailable(ClipboardFormatType::GetBitmapType(), buffer, data_dst))
+    types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
+  if (clipboard_internal_->IsFormatAvailable(
+          ClipboardInternalFormat::kCustom) &&
+      clipboard_internal_->GetData()) {
+    ReadCustomDataTypes(
+        clipboard_internal_->GetData()->custom_data_data().c_str(),
+        clipboard_internal_->GetData()->custom_data_data().size(), types);
+  }
+}
+
+std::vector<std::u16string>
+ClipboardOHOS::ReadAvailablePlatformSpecificFormatNames(
+    ClipboardBuffer buffer,
+    const DataTransferEndpoint* data_dst) const {
+  DCHECK(CalledOnValidThread());
+
+  std::vector<std::u16string> types;
+
+  if (!clipboard_internal_->IsReadAllowed(data_dst))
+    return types;
+  // Includes all non-pickled AvailableTypes.
+  if (IsFormatAvailable(ClipboardFormatType::GetPlainTextType(), buffer,
+                        data_dst)) {
+    types.push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetPlainTextType().GetName()));
+  }
+  if (IsFormatAvailable(ClipboardFormatType::GetHtmlType(), buffer, data_dst)) {
+    types.push_back(
+        base::UTF8ToUTF16(ClipboardFormatType::GetHtmlType().GetName()));
+  }
+  if (IsFormatAvailable(ClipboardFormatType::GetBitmapType(), buffer,
+                        data_dst)) {
+    types.push_back(base::UTF8ToUTF16(kMimeTypePNG));
+  }
+
+  return types;
+}
+
+void ClipboardOHOS::ReadText(ClipboardBuffer buffer,
+                                  const DataTransferEndpoint* data_dst,
+                                  std::u16string* result) const {
+  DCHECK(CalledOnValidThread());
+  if (!clipboard_internal_->IsReadAllowed(data_dst)) {
+    LOG(ERROR) << "not allow to read when read text";
+    return;
+  }
+  RecordRead(ClipboardFormatMetric::kText);
+  clipboard_internal_->ReadText(result);
+}
+
+void ClipboardOHOS::ReadAsciiText(ClipboardBuffer buffer,
+                                       const DataTransferEndpoint* data_dst,
+                                       std::string* result) const {
+  DCHECK(CalledOnValidThread());
+}
+
+void ClipboardOHOS::ReadHTML(ClipboardBuffer buffer,
+                                  const DataTransferEndpoint* data_dst,
+                                  std::u16string* markup,
+                                  std::string* src_url,
+                                  uint32_t* fragment_start,
+                                  uint32_t* fragment_end) const {
+  DCHECK(CalledOnValidThread());
+ 
+  if (!clipboard_internal_->IsReadAllowed(data_dst)) {
+    LOG(ERROR) << "not allow to read when read html";
+    return;
+  }
+
+  RecordRead(ClipboardFormatMetric::kHtml);
+  clipboard_internal_->ReadHTML(markup, src_url, fragment_start, fragment_end);
+  
+}
+
+void ClipboardOHOS::ReadSvg(ClipboardBuffer buffer,
+                                 const DataTransferEndpoint* data_dst,
+                                 std::u16string* result) const {
+  DCHECK(CalledOnValidThread());
+}
+
+void ClipboardOHOS::ReadRTF(ClipboardBuffer buffer,
+                                 const DataTransferEndpoint* data_dst,
+                                 std::string* result) const {
+  DCHECK(CalledOnValidThread());
+}
+
+void ClipboardOHOS::ReadImage(ClipboardBuffer buffer,
+                                   const DataTransferEndpoint* data_dst,
+                                   ReadImageCallback callback) const {
+  LOG(INFO) << "start read image";
+  DCHECK(CalledOnValidThread());
+  if (!clipboard_internal_->IsReadAllowed(data_dst)) {
+    std::move(callback).Run(SkBitmap());
+    return;
+  }
+  RecordRead(ClipboardFormatMetric::kImage);
+  std::move(callback).Run(clipboard_internal_->ReadImage());
+}
+
+void ClipboardOHOS::ReadCustomData(ClipboardBuffer buffer,
+                                        const std::u16string& type,
+                                        const DataTransferEndpoint* data_dst,
+                                        std::u16string* result) const {
+  DCHECK(CalledOnValidThread());
+}
+
+void ClipboardOHOS::ReadFilenames(
+    ClipboardBuffer buffer,
+    const DataTransferEndpoint* data_dst,
+    std::vector<ui::FileInfo>* result) const {
+  DCHECK(CalledOnValidThread());
+}
+
+void ClipboardOHOS::ReadBookmark(const DataTransferEndpoint* data_dst,
+                                      std::u16string* title,
+                                      std::string* url) const {
+  DCHECK(CalledOnValidThread());
+}
+
+void ClipboardOHOS::ReadData(const ClipboardFormatType& format,
+                                  const DataTransferEndpoint* data_dst,
+                                  std::string* result) const {
+  DCHECK(CalledOnValidThread());
+}
+
+bool ClipboardOHOS::IsSelectionBufferAvailable() const {
+  return true;
+}
+
+void ClipboardOHOS::WritePortableRepresentations(
+    ClipboardBuffer buffer,
+    const ObjectMap& objects,
+    std::unique_ptr<DataTransferEndpoint> data_src) {
+  DCHECK(CalledOnValidThread());
+  DCHECK(IsSupportedClipboardBuffer(buffer));
+  for (const auto& object : objects) {
+      DispatchPortableRepresentation(object.first, object.second);
+  }
+  ClipboardDataBuilder::CommitToClipboard(clipboard_internal_.get(),
+                                          std::move(data_src));
+}
+
+void ClipboardOHOS::WritePlatformRepresentations(
+    ClipboardBuffer buffer,
+    std::vector<Clipboard::PlatformRepresentation> platform_representations,
+    std::unique_ptr<DataTransferEndpoint> data_src) {
+  DCHECK(CalledOnValidThread());
+  DCHECK(IsSupportedClipboardBuffer(buffer));
+
+  DispatchPlatformRepresentations(std::move(platform_representations));
+
+  ClipboardDataBuilder::CommitToClipboard(clipboard_internal_.get(),
+                                          std::move(data_src));
+}
+
+void ClipboardOHOS::WriteText(const char* text_data, size_t text_len) {
+  ClipboardDataBuilder::WriteText(text_data, text_len);
+}
+
+void ClipboardOHOS::WriteHTML(const char* markup_data,
+                                size_t markup_len,
+                                const char* url_data,
+                                size_t url_len) {
+  ClipboardDataBuilder::WriteHTML(markup_data, markup_len, url_data, url_len);
+}
+
+void ClipboardOHOS::WriteSvg(const char* markup_data, size_t markup_len) {
+}
+
+void ClipboardOHOS::WriteRTF(const char* rtf_data, size_t data_len) {
+}
+
+void ClipboardOHOS::WriteFilenames(std::vector<ui::FileInfo> filenames) {
+}
+
+void ClipboardOHOS::WriteBookmark(const char* title_data,
+                                       size_t title_len,
+                                       const char* url_data,
+                                       size_t url_len) {
+}
+
+void ClipboardOHOS::WriteWebSmartPaste() {
+}
+
+void ClipboardOHOS::WriteBitmap(const SkBitmap& bitmap) {
+}
+
+void ClipboardOHOS::WriteData(const ClipboardFormatType& format,
+                                   const char* data_data,
+                                   size_t data_len) {
+}
+
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/base/clipboard/ohos/clipboard_ohos.h b/ui/base/clipboard/ohos/clipboard_ohos.h
new file mode 100644
index 0000000000000..c6038027ffb2d
--- /dev/null
+++ b/ui/base/clipboard/ohos/clipboard_ohos.h
@@ -0,0 +1,120 @@
+// Copyright 2022 The Huawei Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_OHOS_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_OHOS_H_
+
+#include "ui/base/clipboard/clipboard.h"
+
+namespace ui {
+class ClipboardData;
+class ClipboardOHOSInternal;
+
+// In-memory clipboard implementation not backed by an underlying platform.
+// This clipboard can be used where there's no need to sync the clipboard with
+// an underlying platform, and can substitute platform clipboards like
+// ClipboardWin on Windows or ClipboardMac on MacOS. As this isn't backed by an
+// underlying platform, the clipboard data isn't persisted after an instance
+// goes away.
+class COMPONENT_EXPORT(UI_BASE_CLIPBOARD) ClipboardOHOS
+    : public Clipboard {
+ public:
+  // Returns the in-memory clipboard for the current thread. This
+  // method must *only* be used when the caller is sure that the clipboard for
+  // the current thread is in fact an instance of ClipboardOHOS.
+  static ClipboardOHOS* GetForCurrentThread();
+
+  // Writes the current ClipboardData and returns the previous data.
+  // The data source is expected to be set in `data`.
+  std::unique_ptr<ClipboardData> WriteClipboardData(
+      std::unique_ptr<ClipboardData> data);
+
+  // Clipboard overrides:
+  DataTransferEndpoint* GetSource(ClipboardBuffer buffer) const override;
+  uint64_t GetSequenceNumber(ClipboardBuffer buffer) const override;
+
+ private:
+  friend class Clipboard;
+  ClipboardOHOS();
+  ~ClipboardOHOS() override;
+
+  // Clipboard overrides:
+  void OnPreShutdown() override;
+  bool IsFormatAvailable(const ClipboardFormatType& format,
+                         ClipboardBuffer buffer,
+                         const DataTransferEndpoint* data_dst) const override;
+  void Clear(ClipboardBuffer buffer) override;
+  void ReadAvailableTypes(ClipboardBuffer buffer,
+                          const DataTransferEndpoint* data_dst,
+                          std::vector<std::u16string>* types) const override;
+  std::vector<std::u16string> ReadAvailablePlatformSpecificFormatNames(
+      ClipboardBuffer buffer,
+      const DataTransferEndpoint* data_dst) const override;
+  void ReadText(ClipboardBuffer buffer,
+                const DataTransferEndpoint* data_dst,
+                std::u16string* result) const override;
+  void ReadAsciiText(ClipboardBuffer buffer,
+                     const DataTransferEndpoint* data_dst,
+                     std::string* result) const override;
+  void ReadHTML(ClipboardBuffer buffer,
+                const DataTransferEndpoint* data_dst,
+                std::u16string* markup,
+                std::string* src_url,
+                uint32_t* fragment_start,
+                uint32_t* fragment_end) const override;
+  void ReadSvg(ClipboardBuffer buffer,
+               const DataTransferEndpoint* data_dst,
+               std::u16string* result) const override;
+  void ReadRTF(ClipboardBuffer buffer,
+               const DataTransferEndpoint* data_dst,
+               std::string* result) const override;
+  void ReadImage(ClipboardBuffer buffer,
+                 const DataTransferEndpoint* data_dst,
+                 ReadImageCallback callback) const override;
+  void ReadCustomData(ClipboardBuffer buffer,
+                      const std::u16string& type,
+                      const DataTransferEndpoint* data_dst,
+                      std::u16string* result) const override;
+  void ReadFilenames(ClipboardBuffer buffer,
+                     const DataTransferEndpoint* data_dst,
+                     std::vector<ui::FileInfo>* result) const override;
+  void ReadBookmark(const DataTransferEndpoint* data_dst,
+                    std::u16string* title,
+                    std::string* url) const override;
+  void ReadData(const ClipboardFormatType& format,
+                const DataTransferEndpoint* data_dst,
+                std::string* result) const override;
+  bool IsSelectionBufferAvailable() const override;
+  void WritePortableRepresentations(
+      ClipboardBuffer buffer,
+      const ObjectMap& objects,
+      std::unique_ptr<DataTransferEndpoint> data_src) override;
+  void WritePlatformRepresentations(
+      ClipboardBuffer buffer,
+      std::vector<Clipboard::PlatformRepresentation> platform_representations,
+      std::unique_ptr<DataTransferEndpoint> data_src) override;
+  void WriteText(const char* text_data, size_t text_len) override;
+  void WriteHTML(const char* markup_data,
+                 size_t markup_len,
+                 const char* url_data,
+                 size_t url_len) override;
+  void WriteSvg(const char* markup_data, size_t markup_len) override;
+  void WriteRTF(const char* rtf_data, size_t data_len) override;
+  void WriteFilenames(std::vector<ui::FileInfo> filenames) override;
+  void WriteBookmark(const char* title_data,
+                     size_t title_len,
+                     const char* url_data,
+                     size_t url_len) override;
+  void WriteWebSmartPaste() override;
+  void WriteBitmap(const SkBitmap& bitmap) override;
+  void WriteData(const ClipboardFormatType& format,
+                 const char* data_data,
+                 size_t data_len) override;
+
+  const std::unique_ptr<ClipboardOHOSInternal> clipboard_internal_;
+  DISALLOW_COPY_AND_ASSIGN(ClipboardOHOS);
+};
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_OHOS_H_
\ No newline at end of file
diff --git a/ui/base/ime/fuchsia/keyboard_client.cc b/ui/base/ime/fuchsia/keyboard_client.cc
index d00b2d89a8a0e..0607c9c499c9b 100644
--- a/ui/base/ime/fuchsia/keyboard_client.cc
+++ b/ui/base/ime/fuchsia/keyboard_client.cc
@@ -75,8 +75,7 @@ bool KeyboardClient::ProcessKeyEvent(
     return true;
 
   // Convert |key_event| to a ui::KeyEvent.
-  DomCode dom_code =
-      KeycodeConverter::UsbKeycodeToDomCode(static_cast<int>(key_event.key()));
+  DomCode dom_code = KeycodeConverter::UsbKeycodeToDomCode(key_event.key());
   DomKey dom_key;
   KeyboardCode key_code;
   int flags =
@@ -86,7 +85,7 @@ bool KeyboardClient::ProcessKeyEvent(
   // as the default.
   if (!DomCodeToUsLayoutDomKey(dom_code, flags, &dom_key, &key_code)) {
     LOG(ERROR) << "DomCodeToUsLayoutDomKey() failed for key: "
-               << static_cast<int>(key_event.key());
+               << key_event.key();
   }
 
   ui::KeyEvent ui_key_event(event_type, key_code, dom_code, flags, dom_key,
diff --git a/ui/events/gestures/gesture_recognizer_impl.cc b/ui/events/gestures/gesture_recognizer_impl.cc
index 344412f1c2993..4fa9297a51abf 100644
--- a/ui/events/gestures/gesture_recognizer_impl.cc
+++ b/ui/events/gestures/gesture_recognizer_impl.cc
@@ -62,7 +62,13 @@ bool RemoveValueFromMap(std::map<Key, T>* map, const Value& value) {
 
 GestureRecognizerImpl::GestureRecognizerImpl() = default;
 
-GestureRecognizerImpl::~GestureRecognizerImpl() = default;
+GestureRecognizerImpl::~GestureRecognizerImpl() {
+  // The gesture recognizer impl observes the gesture providers that are owned
+  // by `consumer_gesture_provider_`. Clear `consumer_gesture_provider_`
+  // explicitly so that the notifications sent by gesture providers during
+  // destruction are handled properly.
+  consumer_gesture_provider_.clear();
+}
 
 // Checks if this finger is already down, if so, returns the current target.
 // Otherwise, returns NULL.
diff --git a/ui/events/gestures/gesture_recognizer_impl.h b/ui/events/gestures/gesture_recognizer_impl.h
index b2a24c0fbdfba..a522b46388d4d 100644
--- a/ui/events/gestures/gesture_recognizer_impl.h
+++ b/ui/events/gestures/gesture_recognizer_impl.h
@@ -22,6 +22,8 @@
 namespace aura::test {
 FORWARD_DECLARE_TEST(GestureRecognizerTest,
                      DestroyGestureProviderAuraBeforeAck);
+FORWARD_DECLARE_TEST(GestureRecognizerTest,
+                     ResetGestureRecognizerWithGestureProvider);
 }  // namespace aura::test
 
 namespace ui {
@@ -80,6 +82,8 @@ class EVENTS_EXPORT GestureRecognizerImpl : public GestureRecognizer,
  private:
   FRIEND_TEST_ALL_PREFIXES(aura::test::GestureRecognizerTest,
                            DestroyGestureProviderAuraBeforeAck);
+  FRIEND_TEST_ALL_PREFIXES(aura::test::GestureRecognizerTest,
+                           ResetGestureRecognizerWithGestureProvider);
 
   // Sets up the target consumer for gestures based on the touch-event.
   void SetupTargets(const TouchEvent& event, GestureConsumer* consumer);
diff --git a/ui/events/keycodes/dom/keycode_converter.cc b/ui/events/keycodes/dom/keycode_converter.cc
index 79c91342d9e00..a2e121c98e01f 100644
--- a/ui/events/keycodes/dom/keycode_converter.cc
+++ b/ui/events/keycodes/dom/keycode_converter.cc
@@ -5,6 +5,7 @@
 #include "ui/events/keycodes/dom/keycode_converter.h"
 
 #include "base/logging.h"
+#include "base/strings/stringprintf.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversion_utils.h"
 #include "build/build_config.h"
@@ -179,7 +180,7 @@ int KeycodeConverter::DomCodeToEvdevCode(DomCode code) {
 #endif
 
 // static
-DomCode KeycodeConverter::CodeStringToDomCode(const std::string& code) {
+DomCode KeycodeConverter::CodeStringToDomCode(base::StringPiece code) {
   if (code.empty())
     return DomCode::NONE;
   for (auto& mapping : kDomCodeMappings) {
@@ -192,9 +193,29 @@ DomCode KeycodeConverter::CodeStringToDomCode(const std::string& code) {
 }
 
 // static
-const char* KeycodeConverter::DomCodeToCodeString(DomCode dom_code) {
+std::string KeycodeConverter::DomCodeToCodeString(DomCode dom_code) {
+  const auto usb_keycode = static_cast<uint32_t>(dom_code);
+
+  // Generate some continuous runs of codes, rather than looking them up.
+  if (dom_code >= DomCode::US_A && dom_code <= DomCode::US_Z) {
+    const int index = usb_keycode - static_cast<uint32_t>(DomCode::US_A);
+    return base::StringPrintf("Key%c", 'A' + index);
+  } else if (dom_code >= DomCode::DIGIT1 && dom_code <= DomCode::DIGIT0) {
+    const int index = usb_keycode - static_cast<uint32_t>(DomCode::DIGIT1);
+    return base::StringPrintf("Digit%d", (index + 1) % 10);
+  } else if (dom_code >= DomCode::NUMPAD1 && dom_code <= DomCode::NUMPAD0) {
+    const int index = usb_keycode - static_cast<uint32_t>(DomCode::NUMPAD1);
+    return base::StringPrintf("Numpad%d", (index + 1) % 10);
+  } else if (dom_code >= DomCode::F1 && dom_code <= DomCode::F12) {
+    const int index = usb_keycode - static_cast<uint32_t>(DomCode::F1);
+    return base::StringPrintf("F%d", index + 1);
+  } else if (dom_code >= DomCode::F13 && dom_code <= DomCode::F24) {
+    const int index = usb_keycode - static_cast<uint32_t>(DomCode::F13);
+    return base::StringPrintf("F%d", index + 13);
+  }
+
   for (auto& mapping : kDomCodeMappings) {
-    if (mapping.usb_keycode == static_cast<uint32_t>(dom_code)) {
+    if (mapping.usb_keycode == usb_keycode) {
       if (mapping.code)
         return mapping.code;
       break;
@@ -253,7 +274,7 @@ DomKeyLocation KeycodeConverter::DomCodeToLocation(DomCode dom_code) {
 }
 
 // static
-DomKey KeycodeConverter::KeyStringToDomKey(const std::string& key) {
+DomKey KeycodeConverter::KeyStringToDomKey(base::StringPiece key) {
   if (key.empty())
     return DomKey::NONE;
   // Check for standard key names.
@@ -271,12 +292,12 @@ DomKey KeycodeConverter::KeyStringToDomKey(const std::string& key) {
   }
   // Otherwise, if the string contains a single Unicode character,
   // the key value is that character.
+  const auto key_length = static_cast<int32_t>(key.length());
   int32_t char_index = 0;
   uint32_t character;
-  if (base::ReadUnicodeCharacter(key.c_str(),
-                                 static_cast<int32_t>(key.length()),
-                                 &char_index, &character) &&
-      key[++char_index] == 0) {
+  if (base::ReadUnicodeCharacter(key.data(), key_length, &char_index,
+                                 &character) &&
+      ++char_index == key_length) {
     return DomKey::FromCharacter(character);
   }
   return DomKey::NONE;
@@ -382,22 +403,4 @@ uint32_t KeycodeConverter::DomCodeToUsbKeycode(DomCode dom_code) {
   return InvalidUsbKeycode();
 }
 
-// static
-uint32_t KeycodeConverter::CodeStringToUsbKeycode(const std::string& code) {
-  if (code.empty())
-    return InvalidUsbKeycode();
-
-  for (auto& mapping : kDomCodeMappings) {
-    if (mapping.code && code == mapping.code) {
-      return mapping.usb_keycode;
-    }
-  }
-  return InvalidUsbKeycode();
-}
-
-// static
-int KeycodeConverter::CodeStringToNativeKeycode(const std::string& code) {
-  return UsbKeycodeToNativeKeycode(CodeStringToUsbKeycode(code));
-}
-
 }  // namespace ui
diff --git a/ui/events/keycodes/dom/keycode_converter.h b/ui/events/keycodes/dom/keycode_converter.h
index b6d0f12539bbe..8da75ec097f47 100644
--- a/ui/events/keycodes/dom/keycode_converter.h
+++ b/ui/events/keycodes/dom/keycode_converter.h
@@ -9,6 +9,7 @@
 #include <stdint.h>
 #include <string>
 
+#include "base/strings/string_piece.h"
 #include "build/build_config.h"
 #include "ui/events/keycodes/dom/dom_key.h"
 
@@ -73,11 +74,11 @@ class KeycodeConverter {
   static int DomCodeToEvdevCode(DomCode code);
 #endif
 
-  // Convert a UI Events |code| string value into a DomCode.
-  static DomCode CodeStringToDomCode(const std::string& code);
-
-  // Convert a DomCode into a UI Events |code| string value.
-  static const char* DomCodeToCodeString(DomCode dom_code);
+  // Conversion between DOM Code string and DomCode enum values.
+  // Returns the invalid value if the supplied code is not recognized,
+  // or has no mapping.
+  static DomCode CodeStringToDomCode(base::StringPiece code);
+  static std::string DomCodeToCodeString(DomCode dom_code);
 
   // Return the DomKeyLocation of a DomCode. The DomKeyLocation distinguishes
   // keys with the same meaning, and therefore the same DomKey or non-located
@@ -90,10 +91,10 @@ class KeycodeConverter {
   // - a key name from http://www.w3.org/TR/DOM-Level-3-Events-key/, or
   // - a single Unicode character (represented in UTF-8).
   // Returns DomKey::NONE for other inputs, including |nullptr|.
-  static DomKey KeyStringToDomKey(const std::string& key);
+  static DomKey KeyStringToDomKey(base::StringPiece key);
 
   // Convert a DomKey into a UI Events |key| string value.
-  // For an invalid DomKey, returns an empty string.
+  // Returns an empty string for invalid DomKey values.
   static std::string DomKeyToKeyString(DomKey dom_key);
 
   // Returns true if the DomKey is a modifier.
@@ -106,24 +107,18 @@ class KeycodeConverter {
   // Return the value that identifies an invalid USB keycode.
   static uint32_t InvalidUsbKeycode();
 
-  // Convert a USB keycode into an equivalent platform native keycode.
+  // Conversion between USB keycode and native keycode values.
+  // Returns the invalid value if the supplied code is not recognized,
+  // or has no mapping.
   static int UsbKeycodeToNativeKeycode(uint32_t usb_keycode);
-
-  // Convert a platform native keycode into an equivalent USB keycode.
   static uint32_t NativeKeycodeToUsbKeycode(int native_keycode);
 
-  // Convert a USB keycode into a DomCode.
+  // Conversion between USB keycode and DomCode values.
+  // Returns the "invalid" value if the supplied key code is not
+  // recognized.
   static DomCode UsbKeycodeToDomCode(uint32_t usb_keycode);
-
-  // Convert a DomCode into a USB keycode.
   static uint32_t DomCodeToUsbKeycode(DomCode dom_code);
 
-  // Convert a UI Event |code| string into a USB keycode value.
-  static uint32_t CodeStringToUsbKeycode(const std::string& code);
-
-  // Convert a UI Event |code| string into a native keycode.
-  static int CodeStringToNativeKeycode(const std::string& code);
-
   // Static methods to support testing.
   static size_t NumKeycodeMapEntriesForTest();
   static const KeycodeMapEntry* GetKeycodeMapForTest();
diff --git a/ui/events/keycodes/dom/keycode_converter_unittest.cc b/ui/events/keycodes/dom/keycode_converter_unittest.cc
index 8080b1862df48..946ba97364fa9 100644
--- a/ui/events/keycodes/dom/keycode_converter_unittest.cc
+++ b/ui/events/keycodes/dom/keycode_converter_unittest.cc
@@ -170,7 +170,7 @@ TEST(KeycodeConverter, DomCode) {
     if (entry->code) {
       ui::DomCode code = ui::KeycodeConverter::CodeStringToDomCode(entry->code);
       EXPECT_STREQ(entry->code,
-                   ui::KeycodeConverter::DomCodeToCodeString(code));
+                   ui::KeycodeConverter::DomCodeToCodeString(code).c_str());
     }
     ui::DomCode code =
         ui::KeycodeConverter::NativeKeycodeToDomCode(entry->native_keycode);
diff --git a/ui/events/keycodes/keyboard_code_conversion_unittest.cc b/ui/events/keycodes/keyboard_code_conversion_unittest.cc
index 1fec4ed44b284..b17069c9d3b5c 100644
--- a/ui/events/keycodes/keyboard_code_conversion_unittest.cc
+++ b/ui/events/keycodes/keyboard_code_conversion_unittest.cc
@@ -36,10 +36,10 @@ void CheckDomCodeToMeaning(const char* label,
   ui::DomKey result_dom_key = ui::DomKey::NONE;
   ui::KeyboardCode result_key_code = ui::VKEY_UNKNOWN;
   bool success = f(dom_code, event_flags, &result_dom_key, &result_key_code);
-  SCOPED_TRACE(
-      base::StringPrintf("%s %s %06X:%04X", label,
-                         ui::KeycodeConverter::DomCodeToCodeString(dom_code),
-                         static_cast<int>(dom_code), event_flags));
+  SCOPED_TRACE(base::StringPrintf(
+      "%s %s %06X:%04X", label,
+      ui::KeycodeConverter::DomCodeToCodeString(dom_code).c_str(),
+      static_cast<int>(dom_code), event_flags));
   EXPECT_EQ(result.defined, success);
   if (success) {
     EXPECT_EQ(result.dom_key, result_dom_key)
diff --git a/ui/events/ozone/layout/keyboard_layout_engine_unittest.cc b/ui/events/ozone/layout/keyboard_layout_engine_unittest.cc
index cc0c54f8f25ea..d52acd96bff28 100644
--- a/ui/events/ozone/layout/keyboard_layout_engine_unittest.cc
+++ b/ui/events/ozone/layout/keyboard_layout_engine_unittest.cc
@@ -201,7 +201,7 @@ void TestLookup(const char* name, KeyboardLayoutEngine* engine) {
     KeyboardCode keycode;
     SCOPED_TRACE(base::StringPrintf(
         "%s(%s, 0x%X)", name,
-        KeycodeConverter::DomCodeToCodeString(t.input_dom_code),
+        KeycodeConverter::DomCodeToCodeString(t.input_dom_code).c_str(),
         t.input_flags));
     EXPECT_TRUE(
         engine->Lookup(t.input_dom_code, t.input_flags, &dom_key, &keycode));
diff --git a/ui/native_theme/native_theme_features.cc b/ui/native_theme/native_theme_features.cc
index 8bd081919bdd9..57ab22afeb45b 100644
--- a/ui/native_theme/native_theme_features.cc
+++ b/ui/native_theme/native_theme_features.cc
@@ -10,7 +10,7 @@
 namespace features {
 
 #if defined(OS_ANDROID) || BUILDFLAG(IS_CHROMEOS_ASH) || \
-    defined(OS_FUCHSIA) || BUILDFLAG(IS_CHROMEOS_LACROS)
+    defined(OS_FUCHSIA) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 constexpr base::FeatureState kOverlayScrollbarFeatureState =
     base::FEATURE_ENABLED_BY_DEFAULT;
 #else
diff --git a/ui/touch_selection/touch_handle.cc b/ui/touch_selection/touch_handle.cc
index 579f998ac9794..03cbfcbf4c35f 100644
--- a/ui/touch_selection/touch_handle.cc
+++ b/ui/touch_selection/touch_handle.cc
@@ -11,7 +11,7 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
 #include "base/numerics/ranges.h"
-
+#include "base/logging.h"
 namespace ui {
 
 namespace {
@@ -256,6 +256,12 @@ gfx::RectF TouchHandle::GetVisibleBounds() const {
   return drawable_->GetVisibleBounds();
 }
 
+#if defined(OS_OHOS)
+void TouchHandle::SetEdge(const gfx::PointF& top, const gfx::PointF& bottom) {
+  drawable_->SetEdge(top, bottom);
+}
+#endif
+
 void TouchHandle::UpdateHandleLayout() {
   // Suppress repositioning a handle while invisible or fading out to prevent it
   // from "ghosting" outside the visible bounds. The position will be pushed to
@@ -330,6 +336,9 @@ void TouchHandle::UpdateHandleLayout() {
   }
 
   drawable_->SetOrientation(orientation_, mirror_vertical_, mirror_horizontal_);
+#if defined(OS_OHOS)
+  drawable_->SetEdge(focus_top_, focus_bottom_);
+#endif
   drawable_->SetOrigin(ComputeHandleOrigin());
 }
 
@@ -348,10 +357,17 @@ gfx::PointF TouchHandle::ComputeHandleOrigin() const {
   int focal_offset_y = mirror_vertical_ ? drawable_bounds.height() : 0;
   switch (orientation_) {
     case ui::TouchHandleOrientation::LEFT:
+#if defined(OS_OHOS)
+      focal_offset_x =
+          mirror_horizontal_
+              ? drawable_width * (1.0f - handle_horizontal_padding_)
+              : drawable_width * handle_horizontal_padding_;
+#else
       focal_offset_x =
           mirror_horizontal_
               ? drawable_width * handle_horizontal_padding_
               : drawable_width * (1.0f - handle_horizontal_padding_);
+#endif
       break;
     case ui::TouchHandleOrientation::RIGHT:
       focal_offset_x =
diff --git a/ui/touch_selection/touch_handle.h b/ui/touch_selection/touch_handle.h
index a6a3263432014..3ee04f58cbe6b 100644
--- a/ui/touch_selection/touch_handle.h
+++ b/ui/touch_selection/touch_handle.h
@@ -50,6 +50,11 @@ class UI_TOUCH_SELECTION_EXPORT TouchHandleDrawable {
 
   // Returns the transparent horizontal padding ratio of the handle drawable.
   virtual float GetDrawableHorizontalPaddingRatio() const = 0;
+
+#if defined(OS_OHOS)
+  // Sets the Selection left-handle-start or right-handle-end's edge.
+  virtual void SetEdge(const gfx::PointF& top, const gfx::PointF& bottom) = 0;
+#endif
 };
 
 // Interface through which |TouchHandle| communicates handle manipulation and
@@ -127,6 +132,12 @@ class UI_TOUCH_SELECTION_EXPORT TouchHandle : public TouchSelectionDraggable {
   TouchHandleOrientation orientation() const { return orientation_; }
   float alpha() const { return alpha_; }
 
+#if defined(OS_OHOS)
+  void SetEdge(const gfx::PointF& top, const gfx::PointF& bottom);
+  const gfx::PointF& focus_top() const { return focus_top_; }
+  bool GetEnabled() const { return enabled_; };
+#endif
+
  private:
   gfx::PointF ComputeHandleOrigin() const;
   void BeginDrag();
diff --git a/ui/touch_selection/touch_handle_drawable_aura.cc b/ui/touch_selection/touch_handle_drawable_aura.cc
index fb2e8f88b7278..f65715de80507 100644
--- a/ui/touch_selection/touch_handle_drawable_aura.cc
+++ b/ui/touch_selection/touch_handle_drawable_aura.cc
@@ -148,6 +148,11 @@ gfx::RectF TouchHandleDrawableAura::GetVisibleBounds() const {
   return bounds;
 }
 
+#ifdef OS_OHOS
+void TouchHandleDrawableAura::SetEdge(
+    const gfx::PointF& top, const gfx::PointF& bottom) {}
+#endif
+
 float TouchHandleDrawableAura::GetDrawableHorizontalPaddingRatio() const {
   // Aura does not have any transparent padding for its handle drawable.
   return 0.0f;
diff --git a/ui/touch_selection/touch_handle_drawable_aura.h b/ui/touch_selection/touch_handle_drawable_aura.h
index 222d2ff564d25..f170bde16ded3 100644
--- a/ui/touch_selection/touch_handle_drawable_aura.h
+++ b/ui/touch_selection/touch_handle_drawable_aura.h
@@ -39,6 +39,9 @@ class UI_TOUCH_SELECTION_EXPORT TouchHandleDrawableAura
   void SetOrigin(const gfx::PointF& position) override;
   void SetAlpha(float alpha) override;
   gfx::RectF GetVisibleBounds() const override;
+#ifdef OS_OHOS
+  void SetEdge(const gfx::PointF& top, const gfx::PointF& bottom) override;
+#endif
   float GetDrawableHorizontalPaddingRatio() const override;
 
   aura_extra::ImageWindowDelegate* window_delegate_;
diff --git a/ui/touch_selection/touch_selection_controller.cc b/ui/touch_selection/touch_selection_controller.cc
index 54a85202d219b..0f54d8e371e92 100644
--- a/ui/touch_selection/touch_selection_controller.cc
+++ b/ui/touch_selection/touch_selection_controller.cc
@@ -10,6 +10,8 @@
 #include "base/metrics/user_metrics.h"
 #include "base/notreached.h"
 
+#include "base/logging.h"
+
 namespace ui {
 namespace {
 
@@ -112,7 +114,7 @@ void TouchSelectionController::OnSelectionBoundsChanged(
                  (end_selection_handle_->IsActive() &&
                   end.edge_end() == start_.edge_start());
 
-    if (need_swap)
+    if (need_swap) 
       start_selection_handle_.swap(end_selection_handle_);
   }
 
@@ -527,6 +529,9 @@ void TouchSelectionController::OnInsertionChanged() {
   const bool activated = ActivateInsertionIfNecessary();
 
   const TouchHandle::AnimationStyle animation = GetAnimationStyle(!activated);
+#if defined(OS_OHOS)
+  insertion_handle_->SetEdge(start_.edge_start(), start_.edge_end());
+#endif
   insertion_handle_->SetFocus(start_.edge_start(), start_.edge_end());
   insertion_handle_->SetVisible(GetStartVisible(), animation);
 
@@ -542,6 +547,10 @@ void TouchSelectionController::OnSelectionChanged() {
   const bool activated = ActivateSelectionIfNecessary();
 
   const TouchHandle::AnimationStyle animation = GetAnimationStyle(!activated);
+#if defined(OS_OHOS)
+  start_selection_handle_->SetEdge(start_.edge_start(), start_.edge_end());
+  end_selection_handle_->SetEdge(end_.edge_start(), end_.edge_end());
+#endif
 
   start_selection_handle_->SetFocus(start_.edge_start(), start_.edge_end());
   end_selection_handle_->SetFocus(end_.edge_start(), end_.edge_end());
diff --git a/ui/touch_selection/touch_selection_controller.h b/ui/touch_selection/touch_selection_controller.h
index 4e203ab6dc2be..6d0ea2279a280 100644
--- a/ui/touch_selection/touch_selection_controller.h
+++ b/ui/touch_selection/touch_selection_controller.h
@@ -148,6 +148,20 @@ class UI_TOUCH_SELECTION_EXPORT TouchSelectionController
   const gfx::SelectionBound& start() const { return start_; }
   const gfx::SelectionBound& end() const { return end_; }
 
+#ifdef OS_OHOS
+  const std::unique_ptr<TouchHandle>& GetInsertHandle() {
+    return insertion_handle_;
+  }
+
+  const std::unique_ptr<TouchHandle>& GetStartSelectionHandle() {
+    return start_selection_handle_;
+  }
+
+  const std::unique_ptr<TouchHandle>& GetEndSelectionHandle() {
+    return end_selection_handle_;
+  }
+#endif
+
   ActiveStatus active_status() const { return active_status_; }
 
  private:
diff --git a/v8/gni/v8.gni b/v8/gni/v8.gni
index 9325baf996e66..6f17e1403d439 100644
--- a/v8/gni/v8.gni
+++ b/v8/gni/v8.gni
@@ -192,6 +192,12 @@ if (!build_with_chromium && is_clang) {
   v8_remove_configs += [ "//build/config/clang:find_bad_constructs" ]
 }
 
+# ifdef OHOS_NWEB_EX
+if (ohos_nweb_ex_config_name != "") {
+  v8_remove_configs += [ "//build/config:ohos_nweb_ex_def_main" ]
+  v8_add_configs += [ "//build/config:ohos_nweb_ex_def_other" ]
+}  #endif  // OHOS_NWEB_EX
+
 # All templates should be kept in sync.
 template("v8_source_set") {
   if (defined(invoker.split_count) && invoker.split_count > 1 &&
