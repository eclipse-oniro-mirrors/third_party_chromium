diff --git a/BUILD.gn b/BUILD.gn
index 2c674a5784..e1f11bc6e2 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -33,7 +33,7 @@ import("//ui/gl/features.gni")
 import("//v8/gni/snapshot_toolchain.gni")
 import("//v8/gni/v8.gni")
 
-if (is_android) {
+if (is_android || is_ohos) {
   import("//build/config/android/config.gni")
 }
 
@@ -100,7 +100,7 @@ group("gn_all") {
     deps += [ "//third_party/abseil-cpp:absl_tests" ]
   }
 
-  if (!is_android && !is_chromecast) {
+  if (!is_android && !is_chromecast && !is_ohos) {
     deps += [
       "//crypto:crypto_unittests",
       "//google_apis/gcm:gcm_unit_tests",
@@ -111,7 +111,7 @@ group("gn_all") {
     deps += [ ":webui_closure_compile" ]
   }
 
-  if (!is_ios && !is_android && !is_chromecast && !is_fuchsia) {
+  if (!is_ios && !is_android && !is_chromecast && !is_fuchsia && !is_ohos) {
     deps += [
       "//chrome",
       "//chrome/browser/ui/color:dump_colors",
@@ -172,7 +172,7 @@ group("gn_all") {
     ]
   }
 
-  if (!is_ios) {
+  if (!is_ios && !is_ohos) {
     deps += [
       "//cc:cc_unittests",
       "//components/policy:policy_templates",
@@ -225,7 +225,7 @@ group("gn_all") {
     }
   }
 
-  if (!is_ios && !is_android) {
+  if (!is_ios && !is_android && !is_ohos) {
     deps += [
       "//components/cronet:cronet_tests",
       "//components/cronet:cronet_unittests",
@@ -238,16 +238,18 @@ group("gn_all") {
   }
 
   if (!is_ios && !is_fuchsia) {
-    deps += [
-      "//chrome/test:telemetry_perf_unittests",
-      "//chrome/test:unit_tests",
-      "//components:components_browsertests",
-      "//device:device_unittests",
-      "//google_apis/gcm:mcs_probe",
-      "//media/capture:capture_unittests",
-      "//media/cast:cast_unittests",
-      "//third_party/catapult/telemetry:bitmaptools($host_toolchain)",
-    ]
+    if (!is_ohos) {
+      deps += [
+        "//chrome/test:telemetry_perf_unittests",
+        "//chrome/test:unit_tests",
+        "//components:components_browsertests",
+        "//device:device_unittests",
+        "//google_apis/gcm:mcs_probe",
+        "//media/capture:capture_unittests",
+        "//media/cast:cast_unittests",
+        "//third_party/catapult/telemetry:bitmaptools($host_toolchain)",
+      ]
+    }
     if (enable_cef) {
       deps += [ "//cef" ]
     }
@@ -507,7 +509,7 @@ group("gn_all") {
 
   # TODO(GYP): Figure out which of these should (and can) build
   # for chromeos/ios.
-  if (!is_chromeos_ash && !is_ios && !is_fuchsia) {
+  if (!is_chromeos_ash && !is_ios && !is_fuchsia && !is_ohos) {
     deps += [
       "//base:build_utf8_validator_tables",
       "//base:check_example",
@@ -526,7 +528,7 @@ group("gn_all") {
       "//ui/compositor:compositor_unittests",
     ]
 
-    if (!is_android) {
+    if (!is_android && !is_ohos) {
       deps += [
         "//chrome/test:load_library_perf_tests",
         "//chrome/test:sync_performance_tests",
@@ -586,7 +588,7 @@ group("gn_all") {
     deps += [ "//chrome/test/chromedriver:chromedriver($host_toolchain)" ]
   }
 
-  if (is_android || (is_linux || is_chromeos_lacros)) {
+  if (is_android || (is_linux || is_chromeos_lacros) || is_ohos) {
     deps += [
       "//components/network_hints/browser",
       "//content/public/app",
@@ -599,7 +601,7 @@ group("gn_all") {
       "//third_party/breakpad:minidump_stackwalk($host_toolchain)",
     ]
 
-    if (!is_android) {
+    if (!is_android && !is_ohos) {
       deps += [
         "//chrome/test:chrome_app_unittests",
         "//gpu/khronos_glcts_support:khronos_glcts_test",
@@ -689,7 +691,7 @@ group("gn_all") {
     }
   }
 
-  if (is_mac || is_win || is_android || is_linux || is_chromeos) {
+  if (is_mac || is_win || is_android || is_linux || is_chromeos || is_ohos) {
     deps += [
       "//third_party/crashpad/crashpad:crashpad_tests",
       "//third_party/crashpad/crashpad/handler:crashpad_handler",
@@ -1013,7 +1015,7 @@ if (!is_ios) {
     deps = [ ":blink_web_tests" ]
   }
 
-  if (!is_chromeos_ash && !is_ios && !is_fuchsia && !is_android) {
+  if (!is_chromeos_ash && !is_ios && !is_fuchsia && !is_android && !is_ohos) {
     # WPT Webdriver tests runner
     # chrome/test/chromedriver/test/run_webdriver_tests.py
     script_test("webdriver_wpt_tests") {
@@ -1310,7 +1312,7 @@ if (!is_ios) {
 group("chromium_builder_perf") {
   testonly = true
 
-  if (!is_ios && !is_android && !is_chromecast && !is_fuchsia) {
+  if (!is_ios && !is_android && !is_chromecast && !is_fuchsia && !is_ohos) {
     data_deps = [
       "//cc:cc_perftests",
       "//chrome/test:load_library_perf_tests",
@@ -1355,7 +1357,7 @@ group("chromium_builder_perf") {
   }
 }
 
-if (!is_ios && !is_android && !is_chromecast && !is_fuchsia) {
+if (!is_ios && !is_android && !is_chromecast && !is_fuchsia && !is_ohos) {
   group("chromium_builder_asan") {
     testonly = true
 
@@ -1387,7 +1389,7 @@ if (!is_ios && !is_android && !is_chromecast && !is_fuchsia) {
   }
 }
 
-if (is_android) {
+if (is_android || is_ohos) {
   group("optimize_gn_gen") {
     deps = [
       # These run expensive scripts in non-default toolchains. Generally, host
diff --git a/android_webview/browser/lifecycle/aw_contents_lifecycle_notifier.h b/android_webview/browser/lifecycle/aw_contents_lifecycle_notifier.h
index ec69d719a5..9039b189dd 100644
--- a/android_webview/browser/lifecycle/aw_contents_lifecycle_notifier.h
+++ b/android_webview/browser/lifecycle/aw_contents_lifecycle_notifier.h
@@ -68,7 +68,7 @@ class AwContentsLifecycleNotifier {
     AwContentsState aw_content_state = AwContentsState::kDetached;
 
    private:
-    DISALLOW_COPY(AwContentsData);
+    DISALLOW_COPY_BASE(AwContentsData);
   };
 
   friend class TestAwContentsLifecycleNotifier;
diff --git a/base/BUILD.gn b/base/BUILD.gn
index c7bed2c7ea..9d9900844e 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -90,6 +90,9 @@ declare_args() {
   # Ensure that a non-GigaCage memory region can't be reused for GigaCage while
   # there are associated CheckedPtr instances left.
   use_gigacage_blocklist = false
+
+  # Dump symbols for stack trace, default disable, add gn file to enable it
+  use_symbolize = false
 }
 
 # Mutex priority inheritance is disabled by default due to security
@@ -182,6 +185,20 @@ if (is_android) {
   }
 }
 
+if (is_ohos) {
+  import("//build/config/ohos/config.gni")
+  config("ohos_system_libs") {
+    libs = [
+      "hilog",
+      "utils.z",
+      "eventhandler.z",
+    ]
+
+    include_dirs = ohos_src_includes
+    lib_dirs = ohos_libs_dir
+  }
+}
+
 config("perfetto_config") {
   if (use_perfetto_client_library) {
     defines = [
@@ -1265,7 +1282,16 @@ component("base") {
     ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_ohos) {
+    sources += [
+      "debug/stack_trace_ohos.cc",
+      "profiler/stack_sampler_android.cc",
+      "message_loop/message_pump_ohos.cc",
+    ]
+    public_configs = [ ":ohos_system_libs" ]
+  }
+
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "debug/proc_maps_linux.cc",
       "debug/proc_maps_linux.h",
@@ -1313,6 +1339,13 @@ component("base") {
       ]
     }
 
+    if (is_ohos) {
+      sources += [
+        "base_paths_ohos.cc",
+        "base_paths_ohos.h",
+      ]
+    }
+
     if (is_posix) {
       sources += [ "base_paths_posix.h" ]
     }
@@ -1391,7 +1424,7 @@ component("base") {
       "allocator/allocator_shim_default_dispatch_to_partition_alloc.h",
       "allocator/allocator_shim_internals.h",
     ]
-    if (is_android) {
+    if (is_android || is_ohos) {
       sources += [
         "allocator/allocator_shim_override_cpp_symbols.h",
         "allocator/allocator_shim_override_linker_wrapped_symbols.h",
@@ -1420,7 +1453,7 @@ component("base") {
       sources += [ "allocator/allocator_shim_default_dispatch_to_tcmalloc.cc" ]
       deps += [ "//base/allocator:tcmalloc" ]
     } else if (use_allocator == "none") {
-      if (is_android) {
+      if (is_android || is_ohos) {
         sources += [ "allocator/allocator_shim_default_dispatch_to_linker_wrapped_symbols.cc" ]
       }
       if (is_apple) {
@@ -1452,6 +1485,36 @@ component("base") {
     defines += [ "SYSTEM_NATIVE_UTF8" ]
   }
 
+  if (is_ohos) {
+    sources -= [
+      "debug/stack_trace_posix.cc",
+      "profiler/stack_sampler_posix.cc",
+    ]
+    sources += [
+      "android/build_info.cc",
+      "android/build_info.h",
+      "debug/elf_reader.cc",
+      "debug/elf_reader.h",
+      "nix/mime_util_xdg.cc",
+      "nix/mime_util_xdg.h",
+      "nix/xdg_util.cc",
+      "nix/xdg_util.h",
+      "system/sys_info_linux.cc",
+    ]
+    deps += [
+      "//base/third_party/symbolize",
+      "//base/third_party/xdg_mime",
+      "//base/third_party/xdg_user_dirs",
+    ]
+    # Add this build flag in gn file to enable stack trace dump
+    if (use_symbolize) {
+      defines += [ "USE_SYMBOLIZE" ]
+      deps += [
+        "//base/third_party/symbolize",
+      ]
+    }
+  }
+
   # Android.
   if (is_android) {
     sources -= [
@@ -2062,7 +2125,7 @@ component("base") {
       "//base/third_party/xdg_user_dirs",
     ]
   } else {
-    if (!is_android) {
+    if (!is_android && !is_ohos) {
       sources -= [
         "linux_util.cc",
         "linux_util.h",
diff --git a/base/allocator/BUILD.gn b/base/allocator/BUILD.gn
index 9348e2dc7c..6fb5b05699 100644
--- a/base/allocator/BUILD.gn
+++ b/base/allocator/BUILD.gn
@@ -63,7 +63,7 @@ config("tcmalloc_flags") {
     cflags = []
   }
 
-  if (is_linux || is_chromeos || is_android) {
+  if (is_linux || is_chromeos || is_android || is_ohos) {
     # We enable all warnings by default, but upstream disables a few.
     # Keep "-Wno-*" flags in sync with upstream by comparing against:
     # http://code.google.com/p/google-perftools/source/browse/trunk/Makefile.am
@@ -176,7 +176,7 @@ if (use_allocator == "tcmalloc") {
       #"win_allocator.cc",
     ]
 
-    if (is_android) {
+    if (is_android || is_ohos) {
       sources += [ "$tcmalloc_dir/src/config_android.h" ]
     }
 
@@ -244,7 +244,7 @@ if (use_allocator == "tcmalloc") {
       defines += [ "ENABLE_PROFILING=1" ]
     }
 
-    if (is_linux || is_chromeos || is_android) {
+    if (is_linux || is_chromeos || is_android || is_ohos) {
       sources -= [
         "$tcmalloc_dir/src/system-alloc.h",
         "$tcmalloc_dir/src/windows/port.cc",
diff --git a/base/allocator/allocator.gni b/base/allocator/allocator.gni
index 1b8150c150..3f355de134 100644
--- a/base/allocator/allocator.gni
+++ b/base/allocator/allocator.gni
@@ -15,13 +15,13 @@ _is_using_sanitizers = is_asan || is_hwasan || is_lsan || is_tsan || is_msan
 _disable_partition_alloc =
     (is_win && (is_component_build || is_debug)) ||
     (is_android && is_component_build) || (is_android && is_chromecast) ||
-    (is_linux && is_component_build)
-_is_partition_alloc_platform = is_android || is_win || is_linux
+    (is_linux && is_component_build) || (is_ohos && is_component_build)
+_is_partition_alloc_platform = is_android || is_win || is_linux || is_ohos
 
 # The debug CRT on Windows has some debug features that are incompatible with
 # the shim. NaCl in particular does seem to link some binaries statically
 # against the debug CRT with "is_nacl=false".
-if ((is_linux || is_chromeos || is_android || is_apple ||
+if ((is_linux || is_chromeos || is_android || is_apple || is_ohos ||
      (is_win && !is_component_build && !is_debug)) && !_is_using_sanitizers) {
   _default_use_allocator_shim = true
 } else {
@@ -31,7 +31,7 @@ if ((is_linux || is_chromeos || is_android || is_apple ||
 if (_default_use_allocator_shim && _is_partition_alloc_platform &&
     !_disable_partition_alloc) {
   _default_allocator = "partition"
-} else if (is_android || is_apple || _is_using_sanitizers || is_win ||
+} else if (is_android || is_apple || _is_using_sanitizers || is_win || is_ohos ||
            is_fuchsia || ((is_linux || is_chromeos) && target_cpu == "arm64") ||
            (is_cast_audio_only && target_cpu == "arm")) {
   # Temporarily disable tcmalloc on arm64 linux to get rid of compilation
@@ -79,7 +79,7 @@ assert(!is_mac || use_allocator != "tcmalloc",
 assert(!is_ios || use_allocator != "tcmalloc", "Tcmalloc doesn't work on iOS.")
 
 assert(
-    !use_allocator_shim || is_linux || is_chromeos || is_android || is_win ||
+    !use_allocator_shim || is_linux || is_chromeos || is_android || is_win || is_ohos ||
         is_apple,
     "use_allocator_shim works only on Android, iOS, Linux, macOS, and Windows.")
 
diff --git a/base/allocator/allocator_shim.cc b/base/allocator/allocator_shim.cc
index e085adfe59..6a56b75b72 100644
--- a/base/allocator/allocator_shim.cc
+++ b/base/allocator/allocator_shim.cc
@@ -330,7 +330,7 @@ ALWAYS_INLINE void ShimAlignedFree(void* address, void* context) {
 #include "base/allocator/allocator_shim_override_cpp_symbols.h"
 #endif
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 // Android does not support symbol interposition. The way malloc symbols are
 // intercepted on Android is by using link-time -wrap flags.
 #include "base/allocator/allocator_shim_override_linker_wrapped_symbols.h"
diff --git a/base/allocator/allocator_shim_internals.h b/base/allocator/allocator_shim_internals.h
index da1e5a6f92..d5b9945273 100644
--- a/base/allocator/allocator_shim_internals.h
+++ b/base/allocator/allocator_shim_internals.h
@@ -9,7 +9,9 @@
 
 #if defined(__GNUC__)
 
+#if !defined(__MUSL__)
 #include <sys/cdefs.h>  // for __THROW
+#endif
 
 #ifndef __THROW  // Not a glibc system
 #ifdef _NOEXCEPT  // LLVM libc++ uses noexcept instead
diff --git a/base/android/build_info.cc b/base/android/build_info.cc
index 12597e6908..2672b63839 100644
--- a/base/android/build_info.cc
+++ b/base/android/build_info.cc
@@ -5,11 +5,12 @@
 #include "base/android/build_info.h"
 
 #include <string>
-
+#if !defined(OS_OHOS)
 #include "base/android/jni_android.h"
 #include "base/android/jni_array.h"
 #include "base/android/scoped_java_ref.h"
 #include "base/base_jni_headers/BuildInfo_jni.h"
+#endif
 #include "base/check_op.h"
 #include "base/memory/singleton.h"
 #include "base/notreached.h"
@@ -36,11 +37,17 @@ int GetIntParam(const std::vector<std::string>& params, int index) {
 
 struct BuildInfoSingletonTraits {
   static BuildInfo* New() {
+  #if !defined(OS_OHOS)
     JNIEnv* env = AttachCurrentThread();
     ScopedJavaLocalRef<jobjectArray> params_objs = Java_BuildInfo_getAll(env);
     std::vector<std::string> params;
     AppendJavaStringArrayToStringVector(env, params_objs, &params);
     return new BuildInfo(params);
+  #else
+    std::vector<std::string> params;
+    return new BuildInfo(params);
+  #endif
+
   }
 
   static void Delete(BuildInfo* x) {
diff --git a/base/android/build_info.h b/base/android/build_info.h
index cb9f2fe790..a431773650 100644
--- a/base/android/build_info.h
+++ b/base/android/build_info.h
@@ -5,7 +5,9 @@
 #ifndef BASE_ANDROID_BUILD_INFO_H_
 #define BASE_ANDROID_BUILD_INFO_H_
 
+#if !defined(OSOHOS)
 #include <jni.h>
+#endif
 
 #include <string>
 #include <vector>
diff --git a/base/base_paths.h b/base/base_paths.h
index 5504336182..b0ad12dcc9 100644
--- a/base/base_paths.h
+++ b/base/base_paths.h
@@ -16,6 +16,8 @@
 #include "base/base_paths_mac.h"
 #elif defined(OS_ANDROID)
 #include "base/base_paths_android.h"
+#elif defined(OS_OHOS)
+#include "base/base_paths_ohos.h"
 #endif
 
 #if defined(OS_POSIX) || defined(OS_FUCHSIA)
diff --git a/base/base_paths_ohos.cc b/base/base_paths_ohos.cc
new file mode 100644
index 0000000000..2e507f8c9d
--- /dev/null
+++ b/base/base_paths_ohos.cc
@@ -0,0 +1,66 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Defines base::PathProviderOHOS which replaces base::PathProviderPosix for
+// OHOS in base/path_service.cc.
+#include "base/base_paths_ohos.h"
+
+#include <limits.h>
+#include <unistd.h>
+
+#include "base/base_paths.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/notreached.h"
+#include "base/process/process_metrics.h"
+
+namespace base {
+
+bool PathProviderOHOS(int key, FilePath* result) {
+  FilePath bin_dir;
+  switch (key) {
+    case base::FILE_EXE: {
+      if (!ReadSymbolicLink(FilePath(kProcSelfExe), &bin_dir)) {
+        NOTREACHED() << "Unable to resolve " << kProcSelfExe << ".";
+        return false;
+      }
+      *result = bin_dir;
+      return true;
+    }
+    case base::FILE_MODULE:
+      NOTIMPLEMENTED();
+      return false;
+    case base::DIR_MODULE: {
+      if (!ReadSymbolicLink(FilePath(kProcSelfExe), &bin_dir)) {
+        NOTREACHED() << "Unable to resolve " << kProcSelfExe << ".";
+        return false;
+      }
+      *result = bin_dir.DirName();
+      return true;
+    }
+    case base::DIR_SOURCE_ROOT:
+      NOTIMPLEMENTED();
+      return false;
+    case base::DIR_USER_DESKTOP:
+      NOTIMPLEMENTED();
+      return false;
+    case base::DIR_CACHE:
+      // set to /data/local directory for W|X permission.
+      *result = FilePath("/data/local");
+      return true;
+    case base::DIR_ASSETS:
+      // resource file packed to system images
+      *result = FilePath("/system/etc/webview");
+      return true;
+    case base::DIR_OHOS_APP_DATA:
+      *result = FilePath("/data/local");
+      return true;
+    case base::DIR_OHOS_EXTERNAL_STORAGE:
+      return false;
+    default:
+      return false;
+  }
+}
+
+}  // namespace base
diff --git a/base/base_paths_ohos.h b/base/base_paths_ohos.h
new file mode 100644
index 0000000000..b85158a319
--- /dev/null
+++ b/base/base_paths_ohos.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_BASE_PATHS_OHOS_H_
+#define BASE_BASE_PATHS_OHOS_H_
+
+namespace base {
+
+enum {
+  PATH_OHOS_START = 500,
+
+  DIR_OHOS_APP_DATA,
+  DIR_OHOS_EXTERNAL_STORAGE,
+
+  PATH_OHOS_END
+};
+
+}  // namespace base
+
+#endif  // BASE_BASE_PATHS_OHOS_H_
diff --git a/base/base_switches.cc b/base/base_switches.cc
index 9bc2bb3356..8afdcb7e76 100644
--- a/base/base_switches.cc
+++ b/base/base_switches.cc
@@ -125,8 +125,8 @@ const char kDisableUsbKeyboardDetect[]      = "disable-usb-keyboard-detect";
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_ASH) && \
-    !BUILDFLAG(IS_CHROMEOS_LACROS)
+#if (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_ASH) && \
+    !BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 // The /dev/shm partition is too small in certain VM environments, causing
 // Chrome to fail or crash (see http://crbug.com/715363). Use this flag to
 // work-around this issue (a temporary directory will always be used to create
@@ -161,7 +161,7 @@ const char kForceFieldTrialParams[] = "force-fieldtrial-params";
 
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Controls whether or not retired instruction counts are surfaced for threads
 // in trace events on Linux.
 //
diff --git a/base/base_switches.h b/base/base_switches.h
index 2a71415f0a..1a026ec51a 100644
--- a/base/base_switches.h
+++ b/base/base_switches.h
@@ -42,8 +42,8 @@ extern const char kDisableUsbKeyboardDetect[];
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_ASH) && \
-    !BUILDFLAG(IS_CHROMEOS_LACROS)
+#if (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_ASH) && \
+    !BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 extern const char kDisableDevShmUsage[];
 #endif
 
@@ -59,7 +59,7 @@ extern const char kEnableIdleTracing[];
 extern const char kForceFieldTrialParams[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const char kEnableThreadInstructionCount[];
 
 // TODO(crbug.com/1176772): Remove kEnableCrashpad and IsCrashpadEnabled() when
diff --git a/base/containers/checked_iterators.h b/base/containers/checked_iterators.h
index 89a0d10b55..0a6113793e 100644
--- a/base/containers/checked_iterators.h
+++ b/base/containers/checked_iterators.h
@@ -237,6 +237,17 @@ using CheckedContiguousConstIterator = CheckedContiguousIterator<const T>;
 // [3] https://wg21.link/pointer.traits.optmem
 namespace std {
 
+// OHOS build toolchain use c++ 17
+#if defined(OS_OHOS) && !defined(__MUSL__)
+#if _LIBCPP_STD_VER > 17
+template <class _Tp>
+struct __is_cpp17_contiguous_iterator : public __has_iterator_category_convertible_to<_Tp, contiguous_iterator_tag> {};
+#else
+template <class _Tp>
+struct __is_cpp17_contiguous_iterator : public false_type {};
+#endif
+#endif
+
 template <typename T>
 struct __is_cpp17_contiguous_iterator<::base::CheckedContiguousIterator<T>>
     : true_type {};
diff --git a/base/cpu.cc b/base/cpu.cc
index 5a084660f2..2f18425157 100644
--- a/base/cpu.cc
+++ b/base/cpu.cc
@@ -17,7 +17,7 @@
 #include "base/stl_util.h"
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
 #include "base/containers/flat_set.h"
 #include "base/files/file_util.h"
 #include "base/no_destructor.h"
@@ -31,7 +31,7 @@
 #endif
 
 #if defined(ARCH_CPU_ARM_FAMILY) && \
-    (defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS))
+    (defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS))
 #include <asm/hwcap.h>
 #include <sys/auxv.h>
 #include "base/files/file_util.h"
@@ -150,7 +150,7 @@ uint64_t xgetbv(uint32_t xcr) {
 #endif  // ARCH_CPU_X86_FAMILY
 
 #if defined(ARCH_CPU_ARM_FAMILY) && \
-    (defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS))
+    (defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS))
 StringPairs::const_iterator FindFirstProcCpuKey(const StringPairs& pairs,
                                                 StringPiece key) {
   return ranges::find_if(pairs, [key](const StringPairs::value_type& pair) {
@@ -337,7 +337,7 @@ void CPU::Initialize(bool require_branding) {
     }
   }
 #elif defined(ARCH_CPU_ARM_FAMILY)
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   if (require_branding) {
     const ProcCpuInfo& info = ParseProcCpu();
     cpu_brand_ = info.brand;
@@ -373,7 +373,7 @@ CPU::IntelMicroArchitecture CPU::GetIntelMicroArchitecture() const {
 }
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-  defined(OS_AIX)
+  defined(OS_AIX) || defined(OS_OHOS)
 namespace {
 
 constexpr char kTimeInStatePath[] =
diff --git a/base/cpu.h b/base/cpu.h
index dbc92dddde..2d514bc698 100644
--- a/base/cpu.h
+++ b/base/cpu.h
@@ -93,7 +93,7 @@ class BASE_EXPORT CPU final {
   const std::string& cpu_brand() const { return cpu_brand_; }
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   enum class CoreType {
     kUnknown = 0,
     kOther,
diff --git a/base/debug/debugger_posix.cc b/base/debug/debugger_posix.cc
index b2e8ae3ba6..68aefddde6 100644
--- a/base/debug/debugger_posix.cc
+++ b/base/debug/debugger_posix.cc
@@ -154,7 +154,7 @@ void VerifyDebugger() {
 }
 
 #elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
 
 // We can look in /proc/self/status for TracerPid.  We are likely used in crash
 // handling, so we are careful not to use the heap or have side effects.
diff --git a/base/debug/proc_maps_linux.cc b/base/debug/proc_maps_linux.cc
index ed47c58f08..588394ac46 100644
--- a/base/debug/proc_maps_linux.cc
+++ b/base/debug/proc_maps_linux.cc
@@ -13,7 +13,7 @@
 #include "base/strings/string_split.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include <inttypes.h>
 #endif
 
diff --git a/base/debug/stack_trace_ohos.cc b/base/debug/stack_trace_ohos.cc
new file mode 100644
index 0000000000..199b6d679a
--- /dev/null
+++ b/base/debug/stack_trace_ohos.cc
@@ -0,0 +1,323 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/debug/stack_trace.h"
+
+#include <stddef.h>
+#include <unwind.h>
+
+#include <algorithm>
+#include <ostream>
+
+#include "base/debug/proc_maps_linux.h"
+#include "base/stl_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/threading/thread_restrictions.h"
+
+#if defined(USE_SYMBOLIZE)
+#include "base/posix/eintr_wrapper.h"
+#include "base/third_party/symbolize/symbolize.h"
+#endif
+
+#ifdef __LP64__
+#define FMT_ADDR "0x%016lx"
+#else
+#define FMT_ADDR "0x%08x"
+#endif
+
+namespace {
+
+struct StackCrawlState {
+  StackCrawlState(uintptr_t* frames, size_t max_depth)
+      : frames(frames),
+        frame_count(0),
+        max_depth(max_depth),
+        have_skipped_self(false) {}
+
+  uintptr_t* frames;
+  size_t frame_count;
+  size_t max_depth;
+  bool have_skipped_self;
+};
+
+_Unwind_Reason_Code TraceStackFrame(_Unwind_Context* context, void* arg) {
+  StackCrawlState* state = static_cast<StackCrawlState*>(arg);
+  uintptr_t ip = _Unwind_GetIP(context);
+
+  // The first stack frame is this function itself.  Skip it.
+  if (ip != 0 && !state->have_skipped_self) {
+    state->have_skipped_self = true;
+    return _URC_NO_REASON;
+  }
+
+  state->frames[state->frame_count++] = ip;
+  if (state->frame_count >= state->max_depth)
+    return _URC_END_OF_STACK;
+  return _URC_NO_REASON;
+}
+
+#if !defined(USE_SYMBOLIZE)
+bool EndsWith(const std::string& s, const std::string& suffix) {
+  return s.size() >= suffix.size() &&
+         s.substr(s.size() - suffix.size(), suffix.size()) == suffix;
+}
+#endif
+
+}  // namespace
+
+namespace base {
+namespace debug {
+
+#if defined(USE_SYMBOLIZE)
+namespace internal {
+char* itoa_r(intptr_t i, char* buf, size_t sz, int base, size_t padding) {
+  // Make sure we can write at least one NUL byte.
+  size_t n = 1;
+  if (n > sz)
+    return nullptr;
+
+  if (base < 2 || base > 16) {
+    buf[0] = '\000';
+    return nullptr;
+  }
+
+  char* start = buf;
+
+  uintptr_t j = i;
+
+  // Handle negative numbers (only for base 10).
+  if (i < 0 && base == 10) {
+    // This does "j = -i" while avoiding integer overflow.
+    j = static_cast<uintptr_t>(-(i + 1)) + 1;
+
+    // Make sure we can write the '-' character.
+    if (++n > sz) {
+      buf[0] = '\000';
+      return nullptr;
+    }
+    *start++ = '-';
+  }
+
+  // Loop until we have converted the entire number. Output at least one
+  // character (i.e. '0').
+  char* ptr = start;
+  do {
+    // Make sure there is still enough space left in our output buffer.
+    if (++n > sz) {
+      buf[0] = '\000';
+      return nullptr;
+    }
+
+    // Output the next digit.
+    *ptr++ = "0123456789abcdef"[j % base];
+    j /= base;
+
+    if (padding > 0)
+      padding--;
+  } while (j > 0 || padding > 0);
+
+  // Terminate the output with a NUL character.
+  *ptr = '\000';
+
+  // Conversion to ASCII actually resulted in the digits being in reverse
+  // order. We can't easily generate them in forward order, as we can't tell
+  // the number of characters needed until we are done converting.
+  // So, now, we reverse the string (except for the possible "-" sign).
+  while (--ptr > start) {
+    char ch = *ptr;
+    *ptr = *start;
+    *start++ = ch;
+  }
+  return buf;
+}
+} //namespace internal
+
+class BacktraceOutputHandler {
+ public:
+  virtual void HandleOutput(const char* output) = 0;
+
+ protected:
+  virtual ~BacktraceOutputHandler() = default;
+};
+
+void OutputPointer(void* pointer, BacktraceOutputHandler* handler) {
+  // This should be more than enough to store a 64-bit number in hex:
+  // 16 hex digits + 1 for null-terminator.
+  char buf[17] = { '\0' };
+  handler->HandleOutput("0x");
+  internal::itoa_r(reinterpret_cast<intptr_t>(pointer),
+                   buf, sizeof(buf), 16, 12);
+  handler->HandleOutput(buf);
+}
+
+void OutputFrameId(intptr_t frame_id, BacktraceOutputHandler* handler) {
+  // Max unsigned 64-bit number in decimal has 20 digits (18446744073709551615).
+  // Hence, 30 digits should be more than enough to represent it in decimal
+  // (including the null-terminator).
+  char buf[30] = { '\0' };
+  handler->HandleOutput("#");
+  internal::itoa_r(frame_id, buf, sizeof(buf), 10, 1);
+  handler->HandleOutput(buf);
+}
+
+void PrintToStderr(const char* output) {
+  // NOTE: This code MUST be async-signal safe (it's used by in-process
+  // stack dumping signal handler). NO malloc or stdio is allowed here.
+  ignore_result(HANDLE_EINTR(write(STDERR_FILENO, output, strlen(output))));
+  //LOG(ERROR) << output;
+}
+
+class PrintBacktraceOutputHandler : public BacktraceOutputHandler {
+ public:
+  PrintBacktraceOutputHandler() = default;
+
+  void HandleOutput(const char* output) override {
+    // NOTE: This code MUST be async-signal safe (it's used by in-process
+    // stack dumping signal handler). NO malloc or stdio is allowed here.
+    PrintToStderr(output);
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(PrintBacktraceOutputHandler);
+};
+
+class StreamBacktraceOutputHandler : public BacktraceOutputHandler {
+ public:
+  explicit StreamBacktraceOutputHandler(std::ostream* os) : os_(os) {
+  }
+
+  void HandleOutput(const char* output) override { (*os_) << output; }
+
+ private:
+  std::ostream* os_;
+
+  DISALLOW_COPY_AND_ASSIGN(StreamBacktraceOutputHandler);
+};
+
+void ProcessBacktrace(void* const* trace,
+                      size_t size,
+                      const char* prefix_string,
+                      BacktraceOutputHandler* handler) {
+// NOTE: This code MUST be async-signal safe (it's used by in-process
+// stack dumping signal handler). NO malloc or stdio is allowed here.
+
+  for (size_t i = 0; i < size; ++i) {
+    if (prefix_string)
+      handler->HandleOutput(prefix_string);
+
+    OutputFrameId(i, handler);
+    handler->HandleOutput(" ");
+    OutputPointer(trace[i], handler);
+    handler->HandleOutput(" ");
+
+    char buf[1024] = { '\0' };
+
+    // Subtract by one as return address of function may be in the next
+    // function when a function is annotated as noreturn.
+    void* address = static_cast<char*>(trace[i]) - 1;
+    if (google::Symbolize(address, buf, sizeof(buf)))
+      handler->HandleOutput(buf);
+    else
+      handler->HandleOutput("<unknown>");
+
+    handler->HandleOutput("\n");
+  }
+}
+
+#endif // defined (USE_SYMBOLIZE)
+
+bool EnableInProcessStackDumping() {
+  // When running in an application, our code typically expects SIGPIPE
+  // to be ignored.  Therefore, when testing that same code, it should run
+  // with SIGPIPE ignored as well.
+  // TODO(phajdan.jr): De-duplicate this SIGPIPE code.
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIG_IGN;
+  sigemptyset(&action.sa_mask);
+  return (sigaction(SIGPIPE, &action, NULL) == 0);
+}
+
+size_t CollectStackTrace(void** trace, size_t count) {
+  StackCrawlState state(reinterpret_cast<uintptr_t*>(trace), count);
+  _Unwind_Backtrace(&TraceStackFrame, &state);
+  return state.frame_count;
+}
+
+void StackTrace::PrintWithPrefix(const char* prefix_string) const {
+#if !defined(USE_SYMBOLIZE)
+  std::string backtrace = ToStringWithPrefix(prefix_string);
+  LOG(WARNING) << "backtrace:\n" << backtrace.c_str();
+#else
+  PrintBacktraceOutputHandler handler;
+  ProcessBacktrace(trace_, count_, prefix_string, &handler);
+#endif // !defined(USE_SYMBOLIZE)
+}
+
+// NOTE: Native libraries in APKs are stripped before installing. Print out the
+// relocatable address and library names so host computers can use tools to
+// symbolize and demangle (e.g., addr2line, c++filt).
+void StackTrace::OutputToStreamWithPrefix(std::ostream* os,
+                                          const char* prefix_string) const {
+  std::string proc_maps;
+  std::vector<MappedMemoryRegion> regions;
+#if defined(USE_SYMBOLIZE)
+  StreamBacktraceOutputHandler handler(os);
+  ProcessBacktrace(trace_, count_, prefix_string, &handler);
+#else
+  // Allow IO to read /proc/self/maps. Reading this file doesn't hit the disk
+  // since it lives in procfs, and this is currently used to print a stack trace
+  // on fatal log messages in debug builds only. If the restriction is enabled
+  // then it will recursively trigger fatal failures when this enters on the
+  // UI thread.
+  base::ThreadRestrictions::ScopedAllowIO allow_io;
+  if (!ReadProcMaps(&proc_maps)) {
+    LOG(ERROR) << "Failed to read /proc/self/maps";
+  } else if (!ParseProcMaps(proc_maps, &regions)) {
+    LOG(ERROR) << "Failed to parse /proc/self/maps";
+  }
+
+  for (size_t i = 0; i < count_; ++i) {
+    // Subtract one as return address of function may be in the next
+    // function when a function is annotated as noreturn.
+    uintptr_t address = reinterpret_cast<uintptr_t>(trace_[i]) - 1;
+
+    std::vector<MappedMemoryRegion>::iterator iter = regions.begin();
+    while (iter != regions.end()) {
+      if (address >= iter->start && address < iter->end &&
+          !iter->path.empty()) {
+        break;
+      }
+      ++iter;
+    }
+
+    if (prefix_string)
+      *os << prefix_string;
+
+    // Adjust absolute address to be an offset within the mapped region, to
+    // match the format dumped by Android's crash output.
+    if (iter != regions.end()) {
+      address -= iter->start;
+    }
+
+    // The format below intentionally matches that of Android's debuggerd
+    // output. This simplifies decoding by scripts such as stack.py.
+    *os << base::StringPrintf("#%02zd pc " FMT_ADDR " ", i, address);
+
+    if (iter != regions.end()) {
+      *os << base::StringPrintf("%s", iter->path.c_str());
+      if (EndsWith(iter->path, ".apk")) {
+        *os << base::StringPrintf(" (offset 0x%llx)", iter->offset);
+      }
+    } else {
+      *os << "<unknown>";
+    }
+
+    *os << "\n";
+  }
+#endif // defined(USE_SYMBOLIZE)
+}
+
+}  // namespace debug
+}  // namespace base
diff --git a/base/files/file.h b/base/files/file.h
index 79fd844ee5..b29a0eb5b8 100644
--- a/base/files/file.h
+++ b/base/files/file.h
@@ -25,7 +25,7 @@
 namespace base {
 
 #if defined(OS_BSD) || defined(OS_APPLE) || defined(OS_NACL) || \
-    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21)
+    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21) || defined(OS_OHOS)
 typedef struct stat stat_wrapper_t;
 #elif defined(OS_POSIX)
 typedef struct stat64 stat_wrapper_t;
diff --git a/base/files/file_posix.cc b/base/files/file_posix.cc
index 85603986db..2637e42119 100644
--- a/base/files/file_posix.cc
+++ b/base/files/file_posix.cc
@@ -18,7 +18,7 @@
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 #include "base/os_compat_android.h"
 #endif
 
@@ -125,14 +125,14 @@ void File::Info::FromStat(const stat_wrapper_t& stat_info) {
   // creation time. However, other than on Mac & iOS where the actual file
   // creation time is included as st_birthtime, the rest of POSIX platforms have
   // no portable way to get the creation time.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(__MUSL__)
   time_t last_modified_sec = stat_info.st_mtim.tv_sec;
   int64_t last_modified_nsec = stat_info.st_mtim.tv_nsec;
   time_t last_accessed_sec = stat_info.st_atim.tv_sec;
   int64_t last_accessed_nsec = stat_info.st_atim.tv_nsec;
   time_t creation_time_sec = stat_info.st_ctim.tv_sec;
   int64_t creation_time_nsec = stat_info.st_ctim.tv_nsec;
-#elif defined(OS_ANDROID)
+#elif defined(OS_ANDROID) || defined(OS_OHOS)
   time_t last_modified_sec = stat_info.st_mtime;
   int64_t last_modified_nsec = stat_info.st_mtime_nsec;
   time_t last_accessed_sec = stat_info.st_atime;
@@ -205,7 +205,7 @@ int64_t File::Seek(Whence whence, int64_t offset) {
 
   SCOPED_FILE_TRACE_WITH_SIZE("Seek", offset);
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   static_assert(sizeof(int64_t) == sizeof(off64_t), "off64_t must be 64 bits");
   return lseek64(file_.get(), static_cast<off64_t>(offset),
                  static_cast<int>(whence));
@@ -291,7 +291,7 @@ int File::Write(int64_t offset, const char* data, int size) {
   int bytes_written = 0;
   int rv;
   do {
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
     // In case __USE_FILE_OFFSET64 is not used, we need to call pwrite64()
     // instead of pwrite().
     static_assert(sizeof(int64_t) == sizeof(off64_t),
@@ -550,7 +550,7 @@ bool File::Flush() {
   NOTIMPLEMENTED();  // NaCl doesn't implement fsync.
   return true;
 #elif defined(OS_ANDROID) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || \
-    defined(OS_LINUX)
+    defined(OS_LINUX) || defined(OS_OHOS)
   return !HANDLE_EINTR(fdatasync(file_.get()));
 #elif defined(OS_APPLE)
   // On macOS and iOS, fsync() is guaranteed to send the file's data to the
@@ -585,7 +585,7 @@ File::Error File::GetLastFileError() {
 }
 
 #if defined(OS_BSD) || defined(OS_APPLE) || defined(OS_NACL) || \
-    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21)
+    defined(OS_FUCHSIA) || (defined(OS_ANDROID) && __ANDROID_API__ < 21) || defined(OS_OHOS)
 int File::Stat(const char* path, stat_wrapper_t* sb) {
   ScopedBlockingCall scoped_blocking_call(FROM_HERE, BlockingType::MAY_BLOCK);
   return stat(path, sb);
diff --git a/base/files/file_util.h b/base/files/file_util.h
index 5983de2191..0ec2e1819a 100644
--- a/base/files/file_util.h
+++ b/base/files/file_util.h
@@ -283,7 +283,7 @@ BASE_EXPORT bool SetPosixFilePermissions(const FilePath& path, int mode);
 BASE_EXPORT bool ExecutableExistsInPath(Environment* env,
                                         const FilePath::StringType& executable);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_OHOS)
 // Determine if files under a given |path| can be mapped and then mprotect'd
 // PROT_EXEC. This depends on the mount options used for |path|, which vary
 // among different Linux distributions and possibly local configuration. It also
@@ -602,7 +602,7 @@ BASE_EXPORT bool VerifyPathControlledByAdmin(const base::FilePath& path);
 // the directory |path|, in the number of FilePath::CharType, or -1 on failure.
 BASE_EXPORT int GetMaximumPathComponentLength(const base::FilePath& path);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_OHOS)
 // Broad categories of file systems as returned by statfs() on Linux.
 enum FileSystemType {
   FILE_SYSTEM_UNKNOWN,  // statfs failed.
diff --git a/base/files/file_util_posix.cc b/base/files/file_util_posix.cc
index 57c3cb8e68..b5fb3d620d 100644
--- a/base/files/file_util_posix.cc
+++ b/base/files/file_util_posix.cc
@@ -586,7 +586,7 @@ bool GetTempDir(FilePath* path) {
     return true;
   }
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   return PathService::Get(DIR_CACHE, path);
 #else
   *path = FilePath("/tmp");
@@ -1224,7 +1224,7 @@ bool MoveUnsafe(const FilePath& from_path, const FilePath& to_path) {
 
 #endif  // !defined(OS_NACL_NONSFI)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_OHOS)
 BASE_EXPORT bool IsPathExecutable(const FilePath& path) {
   bool result = false;
   FilePath tmp_file_path;
diff --git a/base/linux_util.cc b/base/linux_util.cc
index c1512b8418..7c87dee6ec 100644
--- a/base/linux_util.cc
+++ b/base/linux_util.cc
@@ -19,6 +19,7 @@
 #include "base/files/dir_reader_posix.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_file.h"
+#include "base/logging.h"
 #include "base/no_destructor.h"
 #include "base/strings/safe_sprintf.h"
 #include "base/strings/string_number_conversions.h"
@@ -100,6 +101,8 @@ char g_linux_distro[kDistroSize] =
     "CrOS";
 #elif defined(OS_ANDROID)
     "Android";
+#elif defined(OS_OHOS)
+    "OhOS";
 #else
     "Unknown";
 #endif
diff --git a/base/logging.cc b/base/logging.cc
index 7722d37296..8326bc2c63 100644
--- a/base/logging.cc
+++ b/base/logging.cc
@@ -80,6 +80,10 @@ typedef HANDLE FileHandle;
 #include <android/log.h>
 #endif
 
+#if defined(OS_OHOS)
+#include "hilog/log.h"
+#endif
+
 #if defined(OS_POSIX) || defined(OS_FUCHSIA)
 #include <errno.h>
 #include <paths.h>
@@ -556,6 +560,22 @@ LogMessage::LogMessage(const char* file, int line, const char* condition)
   stream_ << "Check failed: " << condition << ". ";
 }
 
+#if defined(OS_OHOS)
+extern "C" {
+    int HiLogPrintArgs(LogType type, LogLevel level, unsigned int domain, const char* tag, const char* fmt, va_list ap);
+}
+
+int HiLogPrintOHOS(LogType type, LogLevel level, unsigned int domain, const char *tag, const char *fmt, ...)
+{
+    int ret;
+    va_list ap;
+    va_start(ap, fmt);
+    ret = HiLogPrintArgs(type, level, domain, tag, fmt, ap);
+    va_end(ap);
+    return ret;
+}
+#endif
+
 LogMessage::~LogMessage() {
   size_t stack_start = stream_.tellp();
 #if !defined(OFFICIAL_BUILD) && !defined(OS_NACL) && !defined(__UCLIBC__) && \
@@ -777,6 +797,25 @@ LogMessage::~LogMessage() {
     // The Android system may truncate the string if it's too long.
     __android_log_write(priority, kAndroidLogTag, str_newline.c_str());
 #endif
+#elif defined(OS_OHOS)
+    LogLevel priority =
+        (severity_ < 0) ? LogLevel::LOG_DEBUG : LogLevel::LOG_LEVEL_MAX;
+    switch (severity_) {
+      case LOGGING_INFO:
+        priority = LogLevel::LOG_INFO;
+        break;
+      case LOGGING_WARNING:
+        priority = LogLevel::LOG_WARN;
+        break;
+      case LOGGING_ERROR:
+        priority = LogLevel::LOG_ERROR;
+        break;
+      case LOGGING_FATAL:
+        priority = LogLevel::LOG_FATAL;
+        break;
+    }
+    const char kOHOSLogTag[] = "chromium";
+    HiLogPrintOHOS(LOG_APP, priority, 0, kOHOSLogTag, str_newline.c_str());
 #elif defined(OS_FUCHSIA)
     fx_log_severity_t severity = FX_LOG_INFO;
     switch (severity_) {
diff --git a/base/macros.h b/base/macros.h
index 19d15ca713..2eee1ae626 100644
--- a/base/macros.h
+++ b/base/macros.h
@@ -15,7 +15,8 @@
 // //styleguide/c++/c++-dos-and-donts.md for more information.
 
 // DEPRECATED: See above. Makes a class uncopyable.
-#define DISALLOW_COPY(TypeName) \
+// Add BASE for confliction with ohos base library
+#define DISALLOW_COPY_BASE(TypeName) \
   TypeName(const TypeName&) = delete
 
 // DEPRECATED: See above. Makes a class unassignable.
@@ -23,7 +24,7 @@
 
 // DEPRECATED: See above. Makes a class uncopyable and unassignable.
 #define DISALLOW_COPY_AND_ASSIGN(TypeName) \
-  DISALLOW_COPY(TypeName);                 \
+  DISALLOW_COPY_BASE(TypeName);            \
   DISALLOW_ASSIGN(TypeName)
 
 // DEPRECATED: See above. Disallow all implicit constructors, namely the
diff --git a/base/memory/platform_shared_memory_region.h b/base/memory/platform_shared_memory_region.h
index 9b67c0e929..b2f7be4048 100644
--- a/base/memory/platform_shared_memory_region.h
+++ b/base/memory/platform_shared_memory_region.h
@@ -27,7 +27,7 @@
 #include "base/files/scoped_file.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 namespace content {
 class SandboxIPCHandler;
 }
@@ -120,7 +120,7 @@ class BASE_EXPORT PlatformSharedMemoryRegion {
     kMaxValue = GET_SHMEM_TEMP_DIR_FAILURE
   };
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Structure to limit access to executable region creation.
   struct ExecutableRegion {
    private:
@@ -264,7 +264,7 @@ class BASE_EXPORT PlatformSharedMemoryRegion {
                            CheckPlatformHandlePermissionsCorrespondToMode);
   static PlatformSharedMemoryRegion Create(Mode mode,
                                            size_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
                                            ,
                                            bool executable = false
 #endif
diff --git a/base/memory/platform_shared_memory_region_posix.cc b/base/memory/platform_shared_memory_region_posix.cc
index f62a7d6a9c..c8e488667b 100644
--- a/base/memory/platform_shared_memory_region_posix.cc
+++ b/base/memory/platform_shared_memory_region_posix.cc
@@ -70,7 +70,7 @@ FDPair ScopedFDPair::get() const {
   return {fd.get(), readonly_fd.get()};
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // static
 ScopedFD PlatformSharedMemoryRegion::ExecutableRegion::CreateFD(size_t size) {
   PlatformSharedMemoryRegion region =
@@ -204,7 +204,7 @@ bool PlatformSharedMemoryRegion::MapAtInternal(off_t offset,
 // static
 PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
                                                               size_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
                                                               ,
                                                               bool executable
 #endif
@@ -233,7 +233,7 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   // flag.
   FilePath directory;
   if (!GetShmemTempDir(
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
           executable,
 #else
           false /* executable */,
diff --git a/base/message_loop/message_pump_for_ui.h b/base/message_loop/message_pump_for_ui.h
index 1eb7da02ee..12b22e5ba7 100644
--- a/base/message_loop/message_pump_for_ui.h
+++ b/base/message_loop/message_pump_for_ui.h
@@ -14,6 +14,8 @@
 #include "base/message_loop/message_pump_win.h"
 #elif defined(OS_ANDROID)
 #include "base/message_loop/message_pump_android.h"
+#elif defined(OS_OHOS)
+#include "base/message_loop/message_pump_ohos.h"
 #elif defined(OS_APPLE)
 #include "base/message_loop/message_pump.h"
 #elif defined(OS_NACL) || defined(OS_AIX)
@@ -34,6 +36,8 @@ using MessagePumpForUI = MessagePumpForUI;
 #elif defined(OS_ANDROID)
 // Android defines it as-is.
 using MessagePumpForUI = MessagePumpForUI;
+#elif defined(OS_OHOS)
+using MessagePumpForUI = MessagePumpForUI;
 #elif defined(OS_APPLE)
 // MessagePumpForUI isn't bound to a specific impl on Mac. While each impl can
 // be represented by a plain MessagePump: MessagePumpMac::Create() must be used
diff --git a/base/message_loop/message_pump_ohos.cc b/base/message_loop/message_pump_ohos.cc
new file mode 100644
index 0000000000..b705919891
--- /dev/null
+++ b/base/message_loop/message_pump_ohos.cc
@@ -0,0 +1,300 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/message_loop/message_pump_ohos.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/eventfd.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <utility>
+
+#include <event_handler.h>
+#include <file_descriptor_listener.h>
+
+#include "base/callback_helpers.h"
+#include "base/check_op.h"
+#include "base/lazy_instance.h"
+#include "base/logging.h"
+#include "base/notreached.h"
+#include "base/run_loop.h"
+#include "build/build_config.h"
+
+#ifndef __NR_timerfd_create
+#error "Unable to find syscall for __NR_timerfd_create"
+#endif
+
+#ifndef TFD_TIMER_ABSTIME
+#define TFD_TIMER_ABSTIME (1 << 0)
+#endif
+
+namespace base {
+
+namespace {
+
+class EventHandlerFileDescriptorListener : public OHOS::AppExecFwk::FileDescriptorListener {
+ public:
+  explicit EventHandlerFileDescriptorListener(MessagePumpForUI* pump,
+                                              int non_delay_fd, int delay_fd)
+      : message_pump_(pump), non_delayed_fd_(non_delay_fd), delayed_fd_(delay_fd) {
+  }
+
+  ~EventHandlerFileDescriptorListener() {
+    message_pump_ = nullptr;
+    non_delayed_fd_ = -1;
+    delayed_fd_ = -1;
+  }
+
+  void OnReadable(int32_t fileDescriptor) override {
+    if (fileDescriptor < 0) {
+        LOG(ERROR) << "EventHandlerFileDescriptorListener error fd";
+        return;
+    }
+
+    if (fileDescriptor == non_delayed_fd_) {
+      message_pump_->OnNonDelayedLooperCallback();
+    } else if (fileDescriptor == delayed_fd_) {
+      message_pump_->OnDelayedLooperCallback();
+    } else {
+      LOG(ERROR) << "EventHandlerFileDescriptorListener invalid fd: " << fileDescriptor;
+    }
+  }
+
+ private:
+  MessagePumpForUI* message_pump_;
+  int non_delayed_fd_;
+  int delayed_fd_;
+};
+
+// See sys/timerfd.h
+int timerfd_create(int clockid, int flags) {
+  return syscall(__NR_timerfd_create, clockid, flags);
+}
+
+// See sys/timerfd.h
+int timerfd_settime(int ufc,
+                    int flags,
+                    const struct itimerspec* utmr,
+                    struct itimerspec* otmr) {
+#if defined(__MUSL__)
+  return syscall(__NR_timerfd_settime32, ufc, flags, utmr, otmr);
+#else
+  return syscall(__NR_timerfd_settime, ufc, flags, utmr, otmr);
+#endif
+}
+
+// A bit added to the |non_delayed_fd_| to keep it signaled when we yield to
+// native tasks below.
+constexpr uint64_t kTryNativeTasksBeforeIdleBit = uint64_t(1) << 32;
+}  // namespace
+
+MessagePumpForUI::MessagePumpForUI() {
+  non_delayed_fd_ = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
+  CHECK_NE(non_delayed_fd_, -1);
+  DCHECK_EQ(TimeTicks::GetClock(), TimeTicks::Clock::LINUX_CLOCK_MONOTONIC);
+
+  // We can't create the timerfd with TFD_NONBLOCK | TFD_CLOEXEC as we can't
+  // include timerfd.h. See comments above on __NR_timerfd_create. It looks like
+  // they're just aliases to O_NONBLOCK and O_CLOEXEC anyways, so this should be
+  // fine.
+  delayed_fd_ = timerfd_create(CLOCK_MONOTONIC, O_NONBLOCK | O_CLOEXEC);
+  CHECK_NE(delayed_fd_, -1);
+
+  ohos_event_handler_ = OHOS::AppExecFwk::EventHandler::Current();
+  DCHECK(ohos_event_handler_);
+  ohos_listener = std::make_shared<EventHandlerFileDescriptorListener>(
+      this, non_delayed_fd_, delayed_fd_);
+  ohos_event_handler_->AddFileDescriptorListener(
+      non_delayed_fd_, OHOS::AppExecFwk::FILE_DESCRIPTOR_INPUT_EVENT, ohos_listener);
+  ohos_event_handler_->AddFileDescriptorListener(
+      delayed_fd_, OHOS::AppExecFwk::FILE_DESCRIPTOR_INPUT_EVENT, ohos_listener);
+}
+
+MessagePumpForUI::~MessagePumpForUI() {
+  ohos_event_handler_->RemoveFileDescriptorListener(non_delayed_fd_);
+  ohos_event_handler_->RemoveFileDescriptorListener(delayed_fd_);
+
+  close(non_delayed_fd_);
+  close(delayed_fd_);
+}
+
+void MessagePumpForUI::OnDelayedLooperCallback() {
+  if (ShouldQuit()) {
+    return;
+  }
+
+  // Clear the fd.
+  uint64_t value;
+  int ret = read(delayed_fd_, &value, sizeof(value));
+
+  DPCHECK(ret >= 0 || errno == EAGAIN);
+  DoDelayedLooperWork();
+}
+
+void MessagePumpForUI::DoDelayedLooperWork() {
+  delayed_scheduled_time_.reset();
+
+  Delegate::NextWorkInfo next_work_info = delegate_->DoWork();
+
+  if (ShouldQuit()) {
+    return;
+  }
+
+  if (next_work_info.is_immediate()) {
+    ScheduleWork();
+    return;
+  }
+
+  DoIdleWork();
+  if (!next_work_info.delayed_run_time.is_max()) {
+    ScheduleDelayedWork(next_work_info.delayed_run_time);
+  }
+}
+
+void MessagePumpForUI::OnNonDelayedLooperCallback() {
+  if (ShouldQuit()) {
+    return;
+  }
+
+  uint64_t value = 0;
+  int ret = read(non_delayed_fd_, &value, sizeof(value));
+  DPCHECK(ret >= 0);
+  DCHECK_GT(value, 0U);
+  bool do_idle_work = value == kTryNativeTasksBeforeIdleBit;
+  DoNonDelayedLooperWork(do_idle_work);
+}
+
+void MessagePumpForUI::DoNonDelayedLooperWork(bool do_idle_work) {
+  // Runs all application tasks scheduled to run.
+  Delegate::NextWorkInfo next_work_info;
+  do {
+    if (ShouldQuit()) {
+      return;
+    }
+
+    next_work_info = delegate_->DoWork();
+  } while (next_work_info.is_immediate());
+
+  // Do not resignal |non_delayed_fd_| if we're quitting (this pump doesn't
+  // allow nesting so needing to resume in an outer loop is not an issue
+  // either).
+  if (ShouldQuit()) {
+    return;
+  }
+
+  // Before declaring this loop idle, yield to native tasks and arrange to be
+  // called again (unless we're already in that second call).
+  if (!do_idle_work) {
+    ScheduleWorkInternal(/*do_idle_work=*/true);
+    return;
+  }
+
+  DCHECK(do_idle_work);
+
+  if (ShouldQuit()) {
+    return;
+  }
+
+  DoIdleWork();
+  if (!next_work_info.delayed_run_time.is_max()) {
+    ScheduleDelayedWork(next_work_info.delayed_run_time);
+  }
+}
+
+void MessagePumpForUI::DoIdleWork() {
+  if (delegate_->DoIdleWork()) {
+    // If DoIdleWork() resulted in any work, we're not idle yet. We need to pump
+    // the loop here because we may in fact be idle after doing idle work
+    // without any new tasks being queued.
+    ScheduleWork();
+  }
+}
+
+void MessagePumpForUI::Run(Delegate* delegate) {
+  CHECK(false) << "Unexpected call to Run()";
+}
+
+void MessagePumpForUI::Attach(Delegate* delegate) {
+  DCHECK(!quit_);
+  SetDelegate(delegate);
+  run_loop_ = std::make_unique<RunLoop>();
+  if (!run_loop_->BeforeRun()) {
+    NOTREACHED();
+  }
+}
+
+void MessagePumpForUI::Quit() {
+  if (quit_) {
+    return;
+  }
+
+  quit_ = true;
+
+  int64_t value;
+  // Clear any pending timer.
+  read(delayed_fd_, &value, sizeof(value));
+  // Clear the eventfd.
+  read(non_delayed_fd_, &value, sizeof(value));
+
+  if (run_loop_) {
+    run_loop_->AfterRun();
+    run_loop_ = nullptr;
+  }
+  if (on_quit_callback_) {
+    std::move(on_quit_callback_).Run();
+  }
+}
+
+void MessagePumpForUI::ScheduleWork() {
+  ScheduleWorkInternal(/*do_idle_work=*/false);
+}
+
+void MessagePumpForUI::ScheduleWorkInternal(bool do_idle_work) {
+  uint64_t value = do_idle_work ? kTryNativeTasksBeforeIdleBit : 1;
+  int ret = write(non_delayed_fd_, &value, sizeof(value));
+  DPCHECK(ret >= 0);
+}
+
+void MessagePumpForUI::ScheduleDelayedWork(const TimeTicks& delayed_work_time) {
+  if (ShouldQuit()) {
+    return;
+  }
+
+  if (delayed_scheduled_time_ && *delayed_scheduled_time_ == delayed_work_time) {
+    return;
+  }
+
+  DCHECK(!delayed_work_time.is_null());
+  delayed_scheduled_time_ = delayed_work_time;
+  int64_t nanos = delayed_work_time.since_origin().InNanoseconds();
+  struct itimerspec ts;
+  ts.it_interval.tv_sec = 0;  // Don't repeat.
+  ts.it_interval.tv_nsec = 0;
+  ts.it_value.tv_sec = nanos / TimeTicks::kNanosecondsPerSecond;
+  ts.it_value.tv_nsec = nanos % TimeTicks::kNanosecondsPerSecond;
+
+  int ret = timerfd_settime(delayed_fd_, TFD_TIMER_ABSTIME, &ts, nullptr);
+  DPCHECK(ret >= 0);
+}
+
+void MessagePumpForUI::QuitWhenIdle(base::OnceClosure callback) {
+  DCHECK(!on_quit_callback_);
+  DCHECK(run_loop_);
+  on_quit_callback_ = std::move(callback);
+  run_loop_->QuitWhenIdle();
+  // Pump the loop in case we're already idle.
+  ScheduleWork();
+}
+
+MessagePump::Delegate* MessagePumpForUI::SetDelegate(Delegate* delegate) {
+  return std::exchange(delegate_, delegate);
+}
+
+bool MessagePumpForUI::SetQuit(bool quit) {
+  return std::exchange(quit_, quit);
+}
+
+}  // namespace base
diff --git a/base/message_loop/message_pump_ohos.h b/base/message_loop/message_pump_ohos.h
new file mode 100644
index 0000000000..e1a1c70c73
--- /dev/null
+++ b/base/message_loop/message_pump_ohos.h
@@ -0,0 +1,95 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_MESSAGE_LOOP_MESSAGE_PUMP_OHOS_H_
+#define BASE_MESSAGE_LOOP_MESSAGE_PUMP_OHOS_H_
+
+#include <memory>
+#include <event_handler.h>
+
+#include "base/base_export.h"
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/message_loop/message_pump.h"
+#include "base/time/time.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+namespace base {
+
+class RunLoop;
+
+class BASE_EXPORT MessagePumpForUI : public MessagePump {
+ public:
+  MessagePumpForUI();
+
+  MessagePumpForUI(const MessagePumpForUI&) = delete;
+  MessagePumpForUI& operator=(const MessagePumpForUI&) = delete;
+
+  ~MessagePumpForUI() override;
+
+  void Run(Delegate* delegate) override;
+  void Quit() override;
+  void ScheduleWork() override;
+  void ScheduleDelayedWork(const TimeTicks& delayed_work_time) override;
+
+  // Attaches |delegate| to this native MessagePump. |delegate| will from then
+  // on be invoked by the native loop to process application tasks.
+  void Attach(Delegate* delegate);
+
+  void Abort() { should_abort_ = true; }
+  bool IsAborted() { return should_abort_; }
+  bool ShouldQuit() const { return should_abort_ || quit_; }
+
+  // Tells the RunLoop to quit when idle, calling the callback when it's safe
+  // for the Thread to stop.
+  void QuitWhenIdle(base::OnceClosure callback);
+
+  // These functions are only public so that the looper callbacks can call them,
+  // and should not be called from outside this class.
+  void OnDelayedLooperCallback();
+  void OnNonDelayedLooperCallback();
+
+ protected:
+  Delegate* SetDelegate(Delegate* delegate);
+  bool SetQuit(bool quit);
+  void DoDelayedLooperWork();
+  void DoNonDelayedLooperWork(bool do_idle_work);
+
+ private:
+  void ScheduleWorkInternal(bool do_idle_work);
+  void DoIdleWork();
+
+  std::unique_ptr<RunLoop> run_loop_;
+
+  // See Abort().
+  bool should_abort_ = false;
+
+  // Whether this message pump is quitting, or has quit.
+  bool quit_ = false;
+
+  // The MessageLoop::Delegate for this pump.
+  Delegate* delegate_ = nullptr;
+
+  // The time at which we are currently scheduled to wake up and perform a
+  // delayed task. This avoids redundantly scheduling |delayed_fd_| with the
+  // same timeout when subsequent work phases all go idle on the same pending
+  // delayed task; nullopt if no wakeup is currently scheduled.
+  absl::optional<TimeTicks> delayed_scheduled_time_;
+
+  // If set, a callback to fire when the message pump is quit.
+  base::OnceClosure on_quit_callback_;
+
+  // The file descriptor used to signal that non-delayed work is available.
+  int non_delayed_fd_;
+
+  // The file descriptor used to signal that delayed work is available.
+  int delayed_fd_;
+
+  std::shared_ptr<OHOS::AppExecFwk::EventHandler> ohos_event_handler_;
+  std::shared_ptr<OHOS::AppExecFwk::FileDescriptorListener> ohos_listener;
+};
+
+}  // namespace base
+
+#endif  // BASE_MESSAGE_LOOP_MESSAGE_PUMP_OHOS_H_
diff --git a/base/path_service.cc b/base/path_service.cc
index d1c9bb1045..44aa032ef2 100644
--- a/base/path_service.cc
+++ b/base/path_service.cc
@@ -31,6 +31,8 @@ bool PathProviderMac(int key, FilePath* result);
 bool PathProviderAndroid(int key, FilePath* result);
 #elif defined(OS_FUCHSIA)
 bool PathProviderFuchsia(int key, FilePath* result);
+#elif defined(OS_OHOS)
+bool PathProviderOHOS(int key, FilePath* result);
 #elif defined(OS_POSIX)
 // PathProviderPosix is the default path provider on POSIX OSes other than
 // Mac and Android.
@@ -95,6 +97,18 @@ Provider base_provider_android = {
 };
 #endif
 
+#if defined(OS_OHOS)
+Provider base_provider_ohos = {
+  PathProviderOHOS,
+  &base_provider,
+#ifndef NDEBUG
+  PATH_OHOS_START,
+  PATH_OHOS_END,
+#endif
+  true
+};
+#endif
+
 #if defined(OS_FUCHSIA)
 Provider base_provider_fuchsia = {PathProviderFuchsia, &base_provider,
 #ifndef NDEBUG
@@ -104,7 +118,7 @@ Provider base_provider_fuchsia = {PathProviderFuchsia, &base_provider,
 #endif
 
 #if defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_ANDROID) && \
-    !defined(OS_FUCHSIA)
+    !defined(OS_FUCHSIA) && !defined(OS_OHOS)
 Provider base_provider_posix = {
   PathProviderPosix,
   &base_provider,
@@ -133,6 +147,8 @@ struct PathData {
     providers = &base_provider_android;
 #elif defined(OS_FUCHSIA)
     providers = &base_provider_fuchsia;
+#elif defined(OS_OHOS)
+    providers = &base_provider_ohos;
 #elif defined(OS_POSIX)
     providers = &base_provider_posix;
 #endif
diff --git a/base/process/kill.h b/base/process/kill.h
index d66a0a994f..9da1826f0a 100644
--- a/base/process/kill.h
+++ b/base/process/kill.h
@@ -113,7 +113,7 @@ BASE_EXPORT TerminationStatus GetTerminationStatus(ProcessHandle handle,
 BASE_EXPORT TerminationStatus GetKnownDeadTerminationStatus(
     ProcessHandle handle, int* exit_code);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Spawns a thread to wait asynchronously for the child |process| to exit
 // and then reaps it.
 BASE_EXPORT void EnsureProcessGetsReaped(Process process);
diff --git a/base/process/kill_posix.cc b/base/process/kill_posix.cc
index fc2bf5cac5..4b7d68236a 100644
--- a/base/process/kill_posix.cc
+++ b/base/process/kill_posix.cc
@@ -160,7 +160,7 @@ void EnsureProcessTerminated(Process process) {
       0, new BackgroundReaper(std::move(process), TimeDelta::FromSeconds(2)));
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 void EnsureProcessGetsReaped(Process process) {
   DCHECK(!process.is_current());
 
diff --git a/base/process/launch.h b/base/process/launch.h
index 2d7425f56e..f5438e89ee 100644
--- a/base/process/launch.h
+++ b/base/process/launch.h
@@ -190,7 +190,7 @@ struct BASE_EXPORT LaunchOptions {
   bool clear_environment = false;
 #endif  // OS_WIN || OS_POSIX || OS_FUCHSIA
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // If non-zero, start the process using clone(), using flags as provided.
   // Unlike in clone, clone_flags may not contain a custom termination signal
   // that is sent to the parent when the child dies. The termination signal will
@@ -422,7 +422,7 @@ BASE_EXPORT void RaiseProcessToHighPriority();
 // binary. This should not be called in production/released code.
 BASE_EXPORT LaunchOptions LaunchOptionsForTest();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_NACL_NONSFI)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_NACL_NONSFI) || defined(OS_OHOS)
 // A wrapper for clone with fork-like behavior, meaning that it returns the
 // child's pid in the parent and 0 in the child. |flags|, |ptid|, and |ctid| are
 // as in the clone system call (the CLONE_VM flag is not supported).
diff --git a/base/process/launch_posix.cc b/base/process/launch_posix.cc
index 77d15c3953..321edd183f 100644
--- a/base/process/launch_posix.cc
+++ b/base/process/launch_posix.cc
@@ -89,7 +89,7 @@ void SetEnvironment(char** env) {
 // the previous signal mask.
 sigset_t SetSignalMask(const sigset_t& new_sigmask) {
   sigset_t old_sigmask;
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   // POSIX says pthread_sigmask() must be used in multi-threaded processes,
   // but Android's pthread_sigmask() was broken until 4.1:
   // https://code.google.com/p/android/issues/detail?id=15337
@@ -199,7 +199,7 @@ struct ScopedDIRClose {
 // Automatically closes |DIR*|s.
 typedef std::unique_ptr<DIR, ScopedDIRClose> ScopedDIR;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_OHOS)
 static const char kFDDir[] = "/proc/self/fd";
 #elif defined(OS_SOLARIS)
 static const char kFDDir[] = "/dev/fd";
@@ -310,7 +310,7 @@ Process LaunchProcess(const std::vector<std::string>& argv,
 
   pid_t pid;
   base::TimeTicks before_fork = TimeTicks::Now();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_OHOS)
   if (options.clone_flags) {
     // Signal handling in this function assumes the creation of a new
     // process, so we check that a thread is not being created by mistake
@@ -662,7 +662,7 @@ bool GetAppOutputWithExitCode(const CommandLine& cl,
 #endif  // !defined(OS_NACL_NONSFI)
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_NACL_NONSFI) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
 namespace {
 
 // This function runs on the stack specified on the clone call. It uses longjmp
diff --git a/base/process/memory.h b/base/process/memory.h
index fb6f3a54ec..b0d18921e4 100644
--- a/base/process/memory.h
+++ b/base/process/memory.h
@@ -32,7 +32,7 @@ BASE_EXPORT void TerminateBecauseOutOfMemory(size_t size);
 BASE_EXPORT extern size_t g_oom_size;
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
 // The maximum allowed value for the OOM score.
 const int kMaxOomScore = 1000;
 
diff --git a/base/process/process_handle.cc b/base/process/process_handle.cc
index 7212a49cb3..13d19b98ff 100644
--- a/base/process/process_handle.cc
+++ b/base/process/process_handle.cc
@@ -30,7 +30,7 @@ UniqueProcId GetUniqueIdForProcess() {
              : UniqueProcId(GetCurrentProcId());
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_AIX) || defined(OS_OHOS)
 
 void InitUniqueIdForProcessInPidNamespace(ProcessId pid_outside_of_namespace) {
   DCHECK(pid_outside_of_namespace != kNullProcessId);
diff --git a/base/process/process_handle.h b/base/process/process_handle.h
index 3640351398..e610b5e6fb 100644
--- a/base/process/process_handle.h
+++ b/base/process/process_handle.h
@@ -103,7 +103,7 @@ BASE_EXPORT ProcessId GetCurrentProcId();
 // processes may be reused.
 BASE_EXPORT UniqueProcId GetUniqueIdForProcess();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // When a process is started in a different PID namespace from the browser
 // process, this function must be called with the process's PID in the browser's
 // PID namespace in order to initialize its unique ID. Not thread safe.
diff --git a/base/process/process_metrics.cc b/base/process/process_metrics.cc
index 34ee8add80..875b0f1c00 100644
--- a/base/process/process_metrics.cc
+++ b/base/process/process_metrics.cc
@@ -50,7 +50,7 @@ SystemMetrics SystemMetrics::Sample() {
   SystemMetrics system_metrics;
 
   system_metrics.committed_memory_ = GetSystemCommitCharge();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   GetSystemMemoryInfo(&system_metrics.memory_info_);
   GetVmStatInfo(&system_metrics.vmstat_info_);
   GetSystemDiskInfo(&system_metrics.disk_info_);
@@ -69,7 +69,7 @@ std::unique_ptr<Value> SystemMetrics::ToValue() const {
   std::unique_ptr<DictionaryValue> res(new DictionaryValue());
 
   res->SetIntKey("committed_memory", static_cast<int>(committed_memory_));
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   std::unique_ptr<DictionaryValue> meminfo = memory_info_.ToValue();
   std::unique_ptr<DictionaryValue> vmstat = vmstat_info_.ToValue();
   meminfo->MergeDictionary(vmstat.get());
diff --git a/base/process/process_metrics.h b/base/process/process_metrics.h
index b291915645..3219922ab9 100644
--- a/base/process/process_metrics.h
+++ b/base/process/process_metrics.h
@@ -47,7 +47,7 @@ namespace base {
 // Full declaration is in process_metrics_iocounters.h.
 struct IoCounters;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 // Minor and major page fault counts since the process creation.
 // Both counts are process-wide, and exclude child processes.
 //
@@ -98,7 +98,7 @@ class BASE_EXPORT ProcessMetrics {
   // convenience wrapper for CreateProcessMetrics().
   static std::unique_ptr<ProcessMetrics> CreateCurrentProcessMetrics();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   // Resident Set Size is a Linux/Android specific memory concept. Do not
   // attempt to extend this to other platforms.
   BASE_EXPORT size_t GetResidentSetSize() const;
@@ -125,7 +125,7 @@ class BASE_EXPORT ProcessMetrics {
   TimeDelta GetCumulativeCPUUsage();
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   // Emits the cumulative CPU usage for all currently active threads since they
   // were started into the output parameter (replacing its current contents).
   // Threads that have already terminated will not be reported. Thus, the sum of
@@ -216,7 +216,7 @@ class BASE_EXPORT ProcessMetrics {
   int GetOpenFdSoftLimit() const;
 #endif  // defined(OS_POSIX)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   // Bytes of swap as reported by /proc/[pid]/status.
   uint64_t GetVmSwapBytes() const;
 
@@ -236,7 +236,7 @@ class BASE_EXPORT ProcessMetrics {
 #endif  // !defined(OS_MAC)
 
 #if defined(OS_APPLE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   int CalculateIdleWakeupsPerSecond(uint64_t absolute_idle_wakeups);
 #endif
 #if defined(OS_APPLE)
@@ -247,7 +247,7 @@ class BASE_EXPORT ProcessMetrics {
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   CPU::CoreType GetCoreType(int core_index);
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) ||
         // defined(OS_AIX)
@@ -272,7 +272,7 @@ class BASE_EXPORT ProcessMetrics {
   uint64_t last_cumulative_disk_usage_ = 0;
 
 #if defined(OS_APPLE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   // Same thing for idle wakeups.
   TimeTicks last_idle_wakeups_time_;
   uint64_t last_absolute_idle_wakeups_;
@@ -325,7 +325,7 @@ BASE_EXPORT void IncreaseFdLimitTo(unsigned int max_descriptors);
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) ||      \
     defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_AIX) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
 // Data about system-wide memory consumption. Values are in KB. Available on
 // Windows, Mac, Linux, Android and Chrome OS.
 //
@@ -359,7 +359,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   // This provides an estimate of available memory as described here:
   // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773
   // NOTE: this is ONLY valid in kernels 3.14 and up.  Its value will always
@@ -374,7 +374,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
 #endif
 
 #if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_AIX) || defined(OS_FUCHSIA)
+    defined(OS_AIX) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   int buffers = 0;
   int cached = 0;
   int active_anon = 0;
@@ -411,7 +411,7 @@ BASE_EXPORT bool GetSystemMemoryInfo(SystemMemoryInfoKB* meminfo);
         // defined(OS_FUCHSIA)
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
 // Parse the data found in /proc/<pid>/stat and return the sum of the
 // CPU-related ticks.  Returns -1 on parse error.
 // Exposed for testing.
@@ -597,7 +597,7 @@ class BASE_EXPORT SystemMetrics {
   FRIEND_TEST_ALL_PREFIXES(SystemMetricsTest, SystemMetrics);
 
   size_t committed_memory_;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   SystemMemoryInfoKB memory_info_;
   VmStatInfo vmstat_info_;
   SystemDiskInfo disk_info_;
diff --git a/base/process/process_metrics_linux.cc b/base/process/process_metrics_linux.cc
index 07b0ceb965..1b6202cd4c 100644
--- a/base/process/process_metrics_linux.cc
+++ b/base/process/process_metrics_linux.cc
@@ -262,7 +262,7 @@ bool ProcessMetrics::GetIOCounters(IoCounters* io_counters) const {
   return true;
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 uint64_t ProcessMetrics::GetVmSwapBytes() const {
   return ReadProcStatusAndGetFieldAsSizeT(process_, "VmSwap") * 1024;
 }
diff --git a/base/process/process_metrics_posix.cc b/base/process/process_metrics_posix.cc
index 9d12c427bb..824f4b3aba 100644
--- a/base/process/process_metrics_posix.cc
+++ b/base/process/process_metrics_posix.cc
@@ -49,7 +49,7 @@ static const rlim_t kSystemDefaultMaxFds = 8192;
 static const rlim_t kSystemDefaultMaxFds = 1024;
 #elif defined(OS_OPENBSD)
 static const rlim_t kSystemDefaultMaxFds = 256;
-#elif defined(OS_ANDROID)
+#elif defined(OS_ANDROID) || defined(OS_OHOS)
 static const rlim_t kSystemDefaultMaxFds = 1024;
 #elif defined(OS_AIX)
 static const rlim_t kSystemDefaultMaxFds = 8192;
@@ -119,7 +119,10 @@ size_t ProcessMetrics::GetMallocUsage() {
   malloc_statistics_t stats = {0};
   malloc_zone_statistics(nullptr, &stats);
   return stats.size_in_use;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(__MUSL__)
+  // TODO: same as https://crbug.com/735087, no mallinfo for musl
+  return 0;
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   struct mallinfo minfo = mallinfo();
 #if BUILDFLAG(USE_TCMALLOC)
   return minfo.uordblks;
diff --git a/base/profiler/register_context.h b/base/profiler/register_context.h
index 36b2ca24da..fbe66bfe40 100644
--- a/base/profiler/register_context.h
+++ b/base/profiler/register_context.h
@@ -17,7 +17,7 @@
 #include <windows.h>
 #elif defined(OS_APPLE)
 #include <mach/machine/thread_status.h>
-#elif defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include <sys/ucontext.h>
 #endif
 
@@ -111,7 +111,7 @@ inline uintptr_t& RegisterContextInstructionPointer(
 #endif
 
 #elif defined(OS_ANDROID) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)  // #if defined(OS_WIN)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)  // #if defined(OS_WIN)
 
 using RegisterContext = mcontext_t;
 
diff --git a/base/profiler/sampling_profiler_thread_token.h b/base/profiler/sampling_profiler_thread_token.h
index 8a2d23f18f..1cbbb17a60 100644
--- a/base/profiler/sampling_profiler_thread_token.h
+++ b/base/profiler/sampling_profiler_thread_token.h
@@ -9,7 +9,7 @@
 #include "base/threading/platform_thread.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include <pthread.h>
 #endif
 
@@ -21,7 +21,7 @@ namespace base {
 // functions used to obtain the stack base address.
 struct SamplingProfilerThreadToken {
   PlatformThreadId id;
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   pthread_t pthread_id;
 #endif
 };
diff --git a/base/run_loop.h b/base/run_loop.h
index 730bf19819..177dc88c77 100644
--- a/base/run_loop.h
+++ b/base/run_loop.h
@@ -289,7 +289,7 @@ class BASE_EXPORT RunLoop {
   FRIEND_TEST_ALL_PREFIXES(SingleThreadTaskExecutorTypedTest,
                            RunLoopQuitOrderAfter);
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   // Android doesn't support the blocking RunLoop::Run, so it calls
   // BeforeRun and AfterRun directly.
   friend class MessagePumpForUI;
diff --git a/base/synchronization/lock_impl_posix.cc b/base/synchronization/lock_impl_posix.cc
index 0793661d62..0bbcf2ff8f 100644
--- a/base/synchronization/lock_impl_posix.cc
+++ b/base/synchronization/lock_impl_posix.cc
@@ -48,7 +48,7 @@ std::string SystemErrorCodeToString(int error_code) {
 // Lock::PriorityInheritanceAvailable still must be checked as the code may
 // compile but the underlying platform still may not correctly support priority
 // inheritance locks.
-#if defined(OS_NACL) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_NACL) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_OHOS)
 #define PRIORITY_INHERITANCE_LOCKS_POSSIBLE() 0
 #else
 #define PRIORITY_INHERITANCE_LOCKS_POSSIBLE() 1
diff --git a/base/system/sys_info.h b/base/system/sys_info.h
index 46d49ccdf1..a2af75b6a0 100644
--- a/base/system/sys_info.h
+++ b/base/system/sys_info.h
@@ -219,7 +219,7 @@ class BASE_EXPORT SysInfo {
   static HardwareInfo GetHardwareInfoSync();
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_AIX)
+    defined(OS_AIX) || defined(OS_OHOS)
   static int64_t AmountOfAvailablePhysicalMemory(
       const SystemMemoryInfoKB& meminfo);
 #endif
diff --git a/base/task/current_thread.cc b/base/task/current_thread.cc
index 51cc852fcc..e4fcbefb26 100644
--- a/base/task/current_thread.cc
+++ b/base/task/current_thread.cc
@@ -153,7 +153,7 @@ MessagePumpForUI* CurrentUIThread::GetMessagePumpForUI() const {
   return static_cast<MessagePumpForUI*>(current_->GetMessagePump());
 }
 
-#if defined(USE_OZONE) && !defined(OS_FUCHSIA) && !defined(OS_WIN)
+#if defined(USE_OZONE) && !defined(OS_FUCHSIA) && !defined(OS_WIN) && !defined(OS_OHOS)
 bool CurrentUIThread::WatchFileDescriptor(
     int fd,
     bool persistent,
diff --git a/base/task/current_thread.h b/base/task/current_thread.h
index 823a1d02ca..f5a21a624e 100644
--- a/base/task/current_thread.h
+++ b/base/task/current_thread.h
@@ -221,7 +221,7 @@ class BASE_EXPORT CurrentUIThread : public CurrentThread {
 
   CurrentUIThread* operator->() { return this; }
 
-#if defined(USE_OZONE) && !defined(OS_FUCHSIA) && !defined(OS_WIN)
+#if defined(USE_OZONE) && !defined(OS_FUCHSIA) && !defined(OS_WIN) && !defined(OS_OHOS)
   static_assert(
       std::is_base_of<WatchableIOMessagePumpPosix, MessagePumpForUI>::value,
       "CurrentThreadForUI::WatchFileDescriptor is supported only"
diff --git a/base/task/sequence_manager/sequence_manager_impl.cc b/base/task/sequence_manager/sequence_manager_impl.cc
index 228489157e..d34064c3a8 100644
--- a/base/task/sequence_manager/sequence_manager_impl.cc
+++ b/base/task/sequence_manager/sequence_manager_impl.cc
@@ -308,6 +308,10 @@ void SequenceManagerImpl::BindToMessagePump(std::unique_ptr<MessagePump> pump) {
       settings_.message_loop_type == MessagePumpType::JAVA) {
     controller_->AttachToMessagePump();
   }
+#elif defined(OS_OHOS)
+  if (settings_.message_loop_type == MessagePumpType::UI) {
+    controller_->AttachToMessagePump();
+  }
 #endif
 
   // On iOS attach to the native loop when there is one.
diff --git a/base/task/sequence_manager/thread_controller.h b/base/task/sequence_manager/thread_controller.h
index 229bf222de..4e01e5370f 100644
--- a/base/task/sequence_manager/thread_controller.h
+++ b/base/task/sequence_manager/thread_controller.h
@@ -93,7 +93,7 @@ class ThreadController {
   // Returns true if the current run loop should quit when idle.
   virtual bool ShouldQuitRunLoopWhenIdle() = 0;
 
-#if defined(OS_IOS) || defined(OS_ANDROID)
+#if defined(OS_IOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   // On iOS, the main message loop cannot be Run().  Instead call
   // AttachToMessagePump(), which connects this ThreadController to the
   // UI thread's CFRunLoop and allows PostTask() to work.
diff --git a/base/task/sequence_manager/thread_controller_impl.cc b/base/task/sequence_manager/thread_controller_impl.cc
index bfc66bd8be..13cdad6672 100644
--- a/base/task/sequence_manager/thread_controller_impl.cc
+++ b/base/task/sequence_manager/thread_controller_impl.cc
@@ -332,7 +332,7 @@ MessagePump* ThreadControllerImpl::GetBoundMessagePump() const {
   return nullptr;
 }
 
-#if defined(OS_IOS) || defined(OS_ANDROID)
+#if defined(OS_IOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 void ThreadControllerImpl::AttachToMessagePump() {
   NOTREACHED();
 }
diff --git a/base/task/sequence_manager/thread_controller_impl.h b/base/task/sequence_manager/thread_controller_impl.h
index 0276b039ed..c491e9095e 100644
--- a/base/task/sequence_manager/thread_controller_impl.h
+++ b/base/task/sequence_manager/thread_controller_impl.h
@@ -61,7 +61,7 @@ class BASE_EXPORT ThreadControllerImpl : public ThreadController,
   void SetTaskExecutionAllowed(bool allowed) override;
   bool IsTaskExecutionAllowed() const override;
   MessagePump* GetBoundMessagePump() const override;
-#if defined(OS_IOS) || defined(OS_ANDROID)
+#if defined(OS_IOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   void AttachToMessagePump() override;
 #endif
 #if defined(OS_IOS)
diff --git a/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc b/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc
index e2322c8cf0..1bda48dd13 100644
--- a/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc
+++ b/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc
@@ -532,7 +532,7 @@ void ThreadControllerWithMessagePumpImpl::AttachToMessagePump() {
 void ThreadControllerWithMessagePumpImpl::DetachFromMessagePump() {
   static_cast<MessagePumpCFRunLoopBase*>(pump_.get())->Detach();
 }
-#elif defined(OS_ANDROID)
+#elif defined(OS_ANDROID) || defined(OS_OHOS)
 void ThreadControllerWithMessagePumpImpl::AttachToMessagePump() {
   static_cast<MessagePumpForUI*>(pump_.get())->Attach(this);
 }
diff --git a/base/task/sequence_manager/thread_controller_with_message_pump_impl.h b/base/task/sequence_manager/thread_controller_with_message_pump_impl.h
index 8ef4a51437..f7254eb61a 100644
--- a/base/task/sequence_manager/thread_controller_with_message_pump_impl.h
+++ b/base/task/sequence_manager/thread_controller_with_message_pump_impl.h
@@ -72,7 +72,7 @@ class BASE_EXPORT ThreadControllerWithMessagePumpImpl
   void SetTaskExecutionAllowed(bool allowed) override;
   bool IsTaskExecutionAllowed() const override;
   MessagePump* GetBoundMessagePump() const override;
-#if defined(OS_IOS) || defined(OS_ANDROID)
+#if defined(OS_IOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   void AttachToMessagePump() override;
 #endif
 #if defined(OS_IOS)
diff --git a/base/third_party/libevent/BUILD.gn b/base/third_party/libevent/BUILD.gn
index abd3901d15..5ae9fd1768 100644
--- a/base/third_party/libevent/BUILD.gn
+++ b/base/third_party/libevent/BUILD.gn
@@ -73,6 +73,17 @@ static_library("libevent") {
       "nacl_nonsfi/signal_stub.c",
     ]
     include_dirs = [ "nacl_nonsfi" ]
+  } else if (is_ohos) {
+    sources += [
+       "epoll.c",
+       "ohos/config.h",
+       "ohos/event-config.h",
+    ]
+    include_dirs = [ "ohos" ]
+    if (use_musl) {
+      defines += [ "USE_MUSL" ]
+      include_dirs += [ "compat" ]
+    }
   }
 
   if (!is_debug) {
diff --git a/base/third_party/libevent/event_tagging.c b/base/third_party/libevent/event_tagging.c
index d436e3fd65..6dcc8c2fa0 100644
--- a/base/third_party/libevent/event_tagging.c
+++ b/base/third_party/libevent/event_tagging.c
@@ -45,7 +45,9 @@
 #include <sys/ioctl.h>
 #endif
 
+#ifdef HAVE_SYS_QUEUE_H
 #include <sys/queue.h>
+#endif
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
diff --git a/base/third_party/libevent/ohos/config.h b/base/third_party/libevent/ohos/config.h
new file mode 100644
index 0000000000..8c540883ef
--- /dev/null
+++ b/base/third_party/libevent/ohos/config.h
@@ -0,0 +1,268 @@
+/* Copied from Linux version and changed the features according Android, which
+ * is close to Linux */
+
+/* Define if clock_gettime is available in libc */
+#define DNS_USE_CPU_CLOCK_FOR_ID 1
+
+/* Define is no secure id variant is available */
+/* #undef DNS_USE_GETTIMEOFDAY_FOR_ID */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Define if /dev/poll is available */
+/* #undef HAVE_DEVPOLL */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if your system supports the epoll system calls */
+#define HAVE_EPOLL 1
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+#define HAVE_EPOLL_CTL 1
+
+/* Define if your system supports event ports */
+/* #undef HAVE_EVENT_PORTS */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if the system has the type `fd_mask'. */
+/* #undef HAVE_FD_MASK */
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getegid' function. */
+#define HAVE_GETEGID 1
+
+/* Define to 1 if you have the `geteuid' function. */
+#define HAVE_GETEUID 1
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `issetugid' function. */
+/* #undef HAVE_ISSETUGID */
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef HAVE_KQUEUE */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#define HAVE_LIBNSL 1
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+#define HAVE_LIBRESOLV 1
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+#define HAVE_LIBRT 1
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in6.h> header file. */
+/* #undef HAVE_NETINET_IN6_H */
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the `port_create' function. */
+/* #undef HAVE_PORT_CREATE */
+
+/* Define to 1 if you have the <port.h> header file. */
+/* #undef HAVE_PORT_H */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define if F_SETFD is defined in <fcntl.h> */
+#define HAVE_SETFD 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `signal' function. */
+#define HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+#define HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define HAVE_STRSEP 1
+
+/* Define to 1 if you have the `strtok_r' function. */
+#define HAVE_STRTOK_R 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define to 1 if the system has the type `struct in6_addr'. */
+#define HAVE_STRUCT_IN6_ADDR 1
+
+/* Define to 1 if you have the <sys/devpoll.h> header file. */
+/* #undef HAVE_SYS_DEVPOLL_H */
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+#define HAVE_SYS_EPOLL_H 1
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+/* #undef HAVE_SYS_EVENT_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#if !defined(USE_MUSL)
+#define HAVE_SYS_QUEUE_H 1
+#endif
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
+#define HAVE_TAILQFOREACH 1
+
+/* Define if timeradd is defined in <sys/time.h> */
+#define HAVE_TIMERADD 1
+
+/* Define if timerclear is defined in <sys/time.h> */
+#define HAVE_TIMERCLEAR 1
+
+/* Define if timercmp is defined in <sys/time.h> */
+#define HAVE_TIMERCMP 1
+
+/* Define if timerisset is defined in <sys/time.h> */
+#define HAVE_TIMERISSET 1
+
+/* Define to 1 if the system has the type `uint16_t'. */
+#define HAVE_UINT16_T 1
+
+/* Define to 1 if the system has the type `uint32_t'. */
+#define HAVE_UINT32_T 1
+
+/* Define to 1 if the system has the type `uint64_t'. */
+#define HAVE_UINT64_T 1
+
+/* Define to 1 if the system has the type `uint8_t'. */
+#define HAVE_UINT8_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define if kqueue works correctly with pipes */
+/* #undef HAVE_WORKING_KQUEUE */
+
+/* Name of package */
+#define PACKAGE "libevent"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "1.4.13-stable"
+
+/* Define to appropriate substitue if compiler doesnt have __func__ */
+/* #undef __func__ */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to unsigned int if you dont have it */
+/* #undef socklen_t */
diff --git a/base/third_party/libevent/ohos/event-config.h b/base/third_party/libevent/ohos/event-config.h
new file mode 100644
index 0000000000..6563cb78d8
--- /dev/null
+++ b/base/third_party/libevent/ohos/event-config.h
@@ -0,0 +1,281 @@
+/* Copied from Linux version and changed the features according Android, which
+ * is close to Linux */
+#ifndef _EVENT_CONFIG_H_
+#define _EVENT_CONFIG_H_
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if clock_gettime is available in libc */
+#define _EVENT_DNS_USE_CPU_CLOCK_FOR_ID 1
+
+/* Define is no secure id variant is available */
+/* #undef _EVENT_DNS_USE_GETTIMEOFDAY_FOR_ID */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define _EVENT_HAVE_CLOCK_GETTIME 1
+
+/* Define if /dev/poll is available */
+/* #undef _EVENT_HAVE_DEVPOLL */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define _EVENT_HAVE_DLFCN_H 1
+
+/* Define if your system supports the epoll system calls */
+#define _EVENT_HAVE_EPOLL 1
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+#define _EVENT_HAVE_EPOLL_CTL 1
+
+/* Define if your system supports event ports */
+/* #undef _EVENT_HAVE_EVENT_PORTS */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define _EVENT_HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define _EVENT_HAVE_FCNTL_H 1
+
+/* Define to 1 if the system has the type `fd_mask'. */
+/* #undef _EVENT_HAVE_FD_MASK 1 */
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define _EVENT_HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getegid' function. */
+#define _EVENT_HAVE_GETEGID 1
+
+/* Define to 1 if you have the `geteuid' function. */
+#define _EVENT_HAVE_GETEUID 1
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define _EVENT_HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define _EVENT_HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define _EVENT_HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define _EVENT_HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `issetugid' function. */
+/* #undef _EVENT_HAVE_ISSETUGID */
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef _EVENT_HAVE_KQUEUE */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#define _EVENT_HAVE_LIBNSL 1
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+#define _EVENT_HAVE_LIBRESOLV 1
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+#define _EVENT_HAVE_LIBRT 1
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef _EVENT_HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define _EVENT_HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in6.h> header file. */
+/* #undef _EVENT_HAVE_NETINET_IN6_H */
+
+/* Define to 1 if you have the `poll' function. */
+#define _EVENT_HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define _EVENT_HAVE_POLL_H 1
+
+/* Define to 1 if you have the `port_create' function. */
+/* #undef _EVENT_HAVE_PORT_CREATE */
+
+/* Define to 1 if you have the <port.h> header file. */
+/* #undef _EVENT_HAVE_PORT_H */
+
+/* Define to 1 if you have the `select' function. */
+#define _EVENT_HAVE_SELECT 1
+
+/* Define if F_SETFD is defined in <fcntl.h> */
+#define _EVENT_HAVE_SETFD 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define _EVENT_HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `signal' function. */
+#define _EVENT_HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define _EVENT_HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define _EVENT_HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define _EVENT_HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define _EVENT_HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define _EVENT_HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define _EVENT_HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+#define _EVENT_HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define _EVENT_HAVE_STRSEP 1
+
+/* Define to 1 if you have the `strtok_r' function. */
+#define _EVENT_HAVE_STRTOK_R 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define _EVENT_HAVE_STRTOLL 1
+
+/* Define to 1 if the system has the type `struct in6_addr'. */
+#define _EVENT_HAVE_STRUCT_IN6_ADDR 1
+
+/* Define to 1 if you have the <sys/devpoll.h> header file. */
+/* #undef _EVENT_HAVE_SYS_DEVPOLL_H */
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+#define _EVENT_HAVE_SYS_EPOLL_H 1
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+/* #undef _EVENT_HAVE_SYS_EVENT_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define _EVENT_HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define _EVENT_HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#define _EVENT_HAVE_SYS_QUEUE_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define _EVENT_HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define _EVENT_HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define _EVENT_HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define _EVENT_HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define _EVENT_HAVE_SYS_TYPES_H 1
+
+/* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
+#define _EVENT_HAVE_TAILQFOREACH 1
+
+/* Define if timeradd is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERADD 1
+
+/* Define if timerclear is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERCLEAR 1
+
+/* Define if timercmp is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERCMP 1
+
+/* Define if timerisset is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERISSET 1
+
+/* Define to 1 if the system has the type `uint16_t'. */
+#define _EVENT_HAVE_UINT16_T 1
+
+/* Define to 1 if the system has the type `uint32_t'. */
+#define _EVENT_HAVE_UINT32_T 1
+
+/* Define to 1 if the system has the type `uint64_t'. */
+#define _EVENT_HAVE_UINT64_T 1
+
+/* Define to 1 if the system has the type `uint8_t'. */
+#define _EVENT_HAVE_UINT8_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define _EVENT_HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define _EVENT_HAVE_VASPRINTF 1
+
+/* Define if kqueue works correctly with pipes */
+/* #undef _EVENT_HAVE_WORKING_KQUEUE */
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define _EVENT_LT_OBJDIR ".libs/"
+
+/* Numeric representation of the version */
+#define _EVENT_NUMERIC_VERSION 0x01040f00
+
+/* Name of package */
+#define _EVENT_PACKAGE "libevent"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define _EVENT_PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define _EVENT_PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define _EVENT_PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define _EVENT_PACKAGE_TARNAME ""
+
+/* Define to the home page for this package. */
+#define _EVENT_PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define _EVENT_PACKAGE_VERSION ""
+
+/* The size of `int', as computed by sizeof. */
+#define _EVENT_SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define _EVENT_SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define _EVENT_SIZEOF_LONG_LONG 8
+
+/* The size of `short', as computed by sizeof. */
+#define _EVENT_SIZEOF_SHORT 2
+
+/* Define to 1 if you have the ANSI C header files. */
+#define _EVENT_STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define _EVENT_TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define _EVENT_VERSION "1.4.15"
+
+/* Define to appropriate substitue if compiler doesnt have __func__ */
+/* #undef _EVENT___func__ */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef _EVENT_const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef _EVENT___cplusplus
+/* #undef _EVENT_inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef _EVENT_pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef _EVENT_size_t */
+
+/* Define to unsigned int if you dont have it */
+/* #undef _EVENT_socklen_t */
+#endif
diff --git a/base/threading/platform_thread.h b/base/threading/platform_thread.h
index eb0428f64d..8f74bf35b1 100644
--- a/base/threading/platform_thread.h
+++ b/base/threading/platform_thread.h
@@ -231,7 +231,7 @@ class BASE_EXPORT PlatformThread {
   // Returns a realtime period provided by |delegate|.
   static TimeDelta GetRealtimePeriod(Delegate* delegate);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Toggles a specific thread's priority at runtime. This can be used to
   // change the priority of a thread in a different process and will fail
   // if the calling process does not have proper permissions. The
diff --git a/base/threading/platform_thread_posix.cc b/base/threading/platform_thread_posix.cc
index f704249f79..7afbd6adc9 100644
--- a/base/threading/platform_thread_posix.cc
+++ b/base/threading/platform_thread_posix.cc
@@ -192,7 +192,7 @@ PlatformThreadId PlatformThread::CurrentId() {
            "through fork().";
   }
   return g_thread_id;
-#elif defined(OS_ANDROID)
+#elif defined(OS_ANDROID) || defined(OS_OHOS)
   return gettid();
 #elif defined(OS_FUCHSIA)
   return zx_thread_self();
diff --git a/base/trace_event/malloc_dump_provider.cc b/base/trace_event/malloc_dump_provider.cc
index 38811b03f9..22109b6ee9 100644
--- a/base/trace_event/malloc_dump_provider.cc
+++ b/base/trace_event/malloc_dump_provider.cc
@@ -199,6 +199,9 @@ bool MallocDumpProvider::OnMemoryDump(const MemoryDumpArgs& args,
   }
 #elif defined(OS_FUCHSIA)
 // TODO(fuchsia): Port, see https://crbug.com/706592.
+#elif defined(__MUSL__)
+// TODO(OS_OHOS for musl):
+// same as https://crbug.com/706592, no mallinfo for musl
 #else
   struct mallinfo info = mallinfo();
   // In case of Android's jemalloc |arena| is 0 and the outer pages size is
diff --git a/base/trace_event/tracing.gni b/base/trace_event/tracing.gni
index b452b02b5f..b62dbc570b 100644
--- a/base/trace_event/tracing.gni
+++ b/base/trace_event/tracing.gni
@@ -17,5 +17,5 @@ declare_args() {
   # Disabled by default on Android and ChromeOS due to binary size impact,
   # enabled everywhere else.
   optional_trace_events_enabled =
-      (!is_android && !is_chromeos_ash) || extended_tracing_enabled
+      (!is_android && !is_chromeos_ash && !is_ohos) || extended_tracing_enabled
 }
diff --git a/build/build_config.h b/build/build_config.h
index 0f1cd5706c..87972c893c 100644
--- a/build/build_config.h
+++ b/build/build_config.h
@@ -50,6 +50,8 @@
 #endif
 #elif defined(ANDROID)
 #define OS_ANDROID 1
+#elif defined(OSOHOS)
+#define OS_OHOS 1
 #elif defined(__APPLE__)
 // Only include TargetConditionals after testing ANDROID as some Android builds
 // on the Mac have this header available and it's not needed unless the target
@@ -112,7 +114,7 @@
     defined(OS_FREEBSD) || defined(OS_IOS) || defined(OS_LINUX) ||  \
     defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_NACL) ||  \
     defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_QNX) || \
-    defined(OS_SOLARIS)
+    defined(OS_SOLARIS) || defined(OS_OHOS)
 #define OS_POSIX 1
 #endif
 
@@ -220,7 +222,7 @@
 #error Please add support for your compiler in build/build_config.h
 #endif
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 // The compiler thinks std::string::const_iterator and "const char*" are
 // equivalent types.
 #define STD_STRING_ITERATOR_IS_CHAR_POINTER
diff --git a/build/config/BUILD.gn b/build/config/BUILD.gn
index aa530a249d..631caef2db 100644
--- a/build/config/BUILD.gn
+++ b/build/config/BUILD.gn
@@ -20,7 +20,7 @@ import("//build/config/pch.gni")
 import("//build/config/sanitizers/sanitizers.gni")
 import("//build/config/ui.gni")
 import("//build/toolchain/goma.gni")
-if (is_android) {
+if (is_android || is_ohos) {
   import("//build/config/android/abi.gni")
 }
 
@@ -212,7 +212,7 @@ config("default_libs") {
         "ole32.lib",
       ]
     }
-  } else if (is_android) {
+  } else if (is_android || is_ohos) {
     libs = [
       "dl",
       "m",
@@ -313,7 +313,7 @@ config("executable_config") {
       "//build/config/ios:ios_dynamic_flags",
       "//build/config/ios:ios_executable_flags",
     ]
-  } else if (is_linux || is_chromeos || is_android || current_os == "aix") {
+  } else if (is_linux || is_chromeos || is_android || current_os == "aix" || is_ohos) {
     configs += [ "//build/config/gcc:executable_config" ]
     if (is_chromecast) {
       configs += [ "//build/config/chromecast:executable_config" ]
diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
index 0ef73ab2b2..f4f9d9bf46 100644
--- a/build/config/BUILDCONFIG.gn
+++ b/build/config/BUILDCONFIG.gn
@@ -148,6 +148,10 @@ declare_args() {
   # DON'T ADD MORE FLAGS HERE. Read the comment above.
 }
 
+declare_args() {
+  use_musl = false
+}
+
 declare_args() {
   # Debug build. Enabling official builds automatically sets is_debug to false.
   is_debug = !is_official_build
@@ -222,6 +226,8 @@ if (target_os == "android") {
   assert(host_os == "linux" || host_os == "mac",
          "Android builds are only supported on Linux and Mac hosts.")
   _default_toolchain = "//build/toolchain/android:android_clang_$target_cpu"
+} else if (target_os == "ohos") {
+  _default_toolchain = "//build/toolchain/ohos:ohos_clang_$target_cpu"
 } else if (target_os == "chromeos" || target_os == "linux") {
   # See comments in build/toolchain/cros/BUILD.gn about board compiles.
   if (is_clang) {
@@ -291,6 +297,7 @@ is_linux = current_os == "linux"
 is_mac = current_os == "mac"
 is_nacl = current_os == "nacl"
 is_win = current_os == "win" || current_os == "winuwp"
+is_ohos = current_os == "ohos"
 
 is_apple = is_ios || is_mac
 is_posix = !is_win && !is_fuchsia
@@ -360,7 +367,7 @@ if (is_fuchsia) {
   default_compiler_configs += [ "//build/config/gcc:symbol_visibility_hidden" ]
 }
 
-if (is_android) {
+if (is_android || is_ohos) {
   default_compiler_configs +=
       [ "//build/config/android:default_orderfile_instrumentation" ]
 }
@@ -499,7 +506,7 @@ foreach(_target_type,
       # On Android, write shared library output file to metadata. We will use
       # this information to, for instance, collect all shared libraries that
       # should be packaged into an APK.
-      if (!defined(invoker.metadata) && is_android &&
+      if (!defined(invoker.metadata) && (is_android || is_ohos) &&
           (_target_type == "shared_library" ||
            _target_type == "loadable_module")) {
         _output_name = _target_name
diff --git a/build/config/android/BUILD.gn b/build/config/android/BUILD.gn
index 8cfe7a0c34..98991d82eb 100644
--- a/build/config/android/BUILD.gn
+++ b/build/config/android/BUILD.gn
@@ -11,7 +11,7 @@ if (current_toolchain == default_toolchain) {
   import("//build/toolchain/concurrent_links.gni")
 }
 
-assert(is_android)
+assert(is_android || is_ohos)
 
 # This is included by reference in the //build/config/compiler config that
 # is applied to all targets. It is here to separate out the logic that is
diff --git a/build/config/android/abi.gni b/build/config/android/abi.gni
index ed7c2ffc8b..680086bd86 100644
--- a/build/config/android/abi.gni
+++ b/build/config/android/abi.gni
@@ -8,7 +8,11 @@
 # NOTE: Because Chrome OS builds may depend on targets built with the Android
 # toolchain, this GNI file may be read and processed from within Chrome OS
 # toolchains. Checking |is_android| here would therefore be too restrictive.
-assert(is_android || is_chromeos)
+assert(is_android || is_chromeos ||is_ohos)
+
+if (is_ohos) {
+  import("//build/config/ohos/abi.gni")
+}
 
 declare_args() {
   # Adds intrumentation to each function. Writes a file with the order that
diff --git a/build/config/android/config.gni b/build/config/android/config.gni
index 652ea7429a..2c8561c79f 100644
--- a/build/config/android/config.gni
+++ b/build/config/android/config.gni
@@ -7,7 +7,7 @@
 # NOTE: Because Chrome OS builds may depend on targets built with the Android
 # toolchain, this GNI file may be read and processed from within Chrome OS
 # toolchains. Checking |is_android| here would therefore be too restrictive.
-if (is_android || is_chromeos) {
+if (is_android || is_chromeos || is_ohos) {
   import("//build/config/chromecast_build.gni")
   import("//build/config/dcheck_always_on.gni")
   import("//build_overrides/build.gni")
diff --git a/build/config/arm.gni b/build/config/arm.gni
index ddd1c5df82..04b3341d8b 100644
--- a/build/config/arm.gni
+++ b/build/config/arm.gni
@@ -38,7 +38,7 @@ if (current_cpu == "arm" || v8_current_cpu == "arm") {
     arm_use_thumb = true
   }
 
-  if (current_os == "android" || target_os == "android") {
+  if (current_os == "android" || target_os == "android" || target_os == "ohos") {
     arm_float_abi = "softfp"
   } else {
     declare_args() {
diff --git a/build/config/c++/c++.gni b/build/config/c++/c++.gni
index a7448f3a0a..53f8d3f19c 100644
--- a/build/config/c++/c++.gni
+++ b/build/config/c++/c++.gni
@@ -46,6 +46,11 @@ use_custom_libcxx =
     use_custom_libcxx || (use_custom_libcxx_for_host && !is_a_target_toolchain)
 use_custom_libcxx = use_custom_libcxx && !is_nacl
 
+if (is_ohos) {
+  use_custom_libcxx = false
+  use_custom_libcxx_for_host = false
+}
+
 declare_args() {
   # WARNING: Setting this to a non-default value is highly discouraged.
   # If true, libc++ will be built as a shared library; otherwise libc++ will be
diff --git a/build/config/clang/BUILD.gn b/build/config/clang/BUILD.gn
index 180e2e626b..8d0904545d 100644
--- a/build/config/clang/BUILD.gn
+++ b/build/config/clang/BUILD.gn
@@ -21,7 +21,7 @@ config("find_bad_constructs") {
       "checked-ptr-as-trivial-member",
     ]
 
-    if (is_linux || is_chromeos || is_android || is_fuchsia) {
+    if (is_linux || is_chromeos || is_android || is_fuchsia || is_ohos) {
       cflags += [
         "-Xclang",
         "-plugin-arg-find-bad-constructs",
diff --git a/build/config/clang/clang.gni b/build/config/clang/clang.gni
index 588864586d..153c5930a1 100644
--- a/build/config/clang/clang.gni
+++ b/build/config/clang/clang.gni
@@ -4,7 +4,15 @@
 
 import("//build/toolchain/toolchain.gni")
 
-default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+if (is_ohos) {
+  import("//build/config/ohos/config.gni")
+}
+
+if (!is_ohos) {
+  default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+} else {
+  default_clang_base_path = ohos_toolchain_root
+}
 
 declare_args() {
   # Indicates if the build should use the Chrome-specific plugins for enforcing
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index 3a54227ed4..af07fe8066 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -94,7 +94,7 @@ declare_args() {
   # nonsensical for said projects.
   clang_use_default_sample_profile =
       chrome_pgo_phase == 0 && build_with_chromium && is_official_build &&
-      (is_android || chromeos_is_browser_only || is_chromecast)
+      (is_android || chromeos_is_browser_only || is_chromecast || is_ohos)
 
   # This configuration is used to select a default profile in Chrome OS based on
   # the microarchitectures we are using. This is only used if
@@ -120,7 +120,7 @@ declare_args() {
   # the space overhead is too great. We should use some mixture of profiles and
   # optimization settings to better tune the size increase.
   thin_lto_enable_optimizations =
-      (is_chromeos_ash || is_android || is_win || is_linux) && is_official_build
+      (is_chromeos_ash || is_android || is_win || is_linux || is_ohos) && is_official_build
 
   # Initialize all local variables with a pattern. This flag will fill
   # uninitialized floating-point types (and 32-bit pointers) with 0xFF and the
@@ -133,7 +133,7 @@ declare_args() {
   #
   # TODO(crbug.com/977230): Enabling this when 'use_xcode_clang' is true may
   # call an old clang that doesn't support auto-init.
-  init_stack_vars = !is_android && !use_xcode_clang
+  init_stack_vars = !is_android && !use_xcode_clang && !is_ohos
 
   # This argument is to control whether enabling text section splitting in the
   # final binary. When enabled, the separated text sections with prefix
@@ -151,8 +151,8 @@ declare_args() {
       ((is_mac && target_cpu == "x64" && !use_system_xcode) ||
        ((is_linux || is_chromeos_lacros) && target_cpu == "x64") ||
        (is_win && target_cpu == "x86") || (is_win && target_cpu == "x64") ||
-       (is_android && target_cpu == "arm") ||
-       (is_android && target_cpu == "arm64"))
+       ((is_android || is_ohos) && target_cpu == "arm") ||
+       ((is_android || is_ohos) && target_cpu == "arm64"))
 
   # Turn off the --call-graph-profile-sort flag for lld by default. Enable
   # selectively for targets where it's beneficial.
@@ -187,12 +187,12 @@ declare_args() {
   # lld doesn't have the bug.
   use_icf =
       (is_posix || is_fuchsia) && !is_debug && !using_sanitizer &&
-      !use_clang_coverage && !(is_android && use_order_profiling) &&
+      !use_clang_coverage && !((is_android || is_ohos) && use_order_profiling) &&
       (use_lld || (use_gold && (is_chromeos_ash || !(current_cpu == "x86" ||
                                                      current_cpu == "x64"))))
 }
 
-if (is_android || (is_chromeos_ash && is_chromeos_device)) {
+if (is_android || is_ohos || (is_chromeos_ash && is_chromeos_device)) {
   # Set the path to use orderfile for linking Chrome
   # Note that this is for using only one orderfile for linking
   # the Chrome binary/library.
@@ -251,6 +251,8 @@ config("compiler") {
     configs += [ "//build/config/win:compiler" ]
   } else if (is_android) {
     configs += [ "//build/config/android:compiler" ]
+  } else if (is_ohos) {
+    configs += [ "//build/config/ohos:compiler" ]
   } else if (is_linux || is_chromeos) {
     configs += [ "//build/config/linux:compiler" ]
     if (is_chromeos_ash) {
@@ -317,7 +319,7 @@ config("compiler") {
       cflags += [ "--param=ssp-buffer-size=4" ]
 
       # The x86 toolchain currently has problems with stack-protector.
-      if (is_android && current_cpu == "x86") {
+      if ((is_android || is_ohos) && current_cpu == "x86") {
         cflags += [ "-fno-stack-protector" ]
       } else if (current_os != "aix") {
         # Not available on aix.
@@ -377,7 +379,7 @@ config("compiler") {
       ldflags += [ "-Wl,--build-id" ]
     }
 
-    if (!is_android) {
+    if (!is_android && !is_ohos) {
       defines += [
         # _FILE_OFFSET_BITS=64 should not be set on Android in order to maintain
         # the behavior of the Android NDK from earlier versions.
@@ -403,7 +405,7 @@ config("compiler") {
 
   # Linux/Android/Fuchsia common flags setup.
   # ---------------------------------
-  if (is_linux || is_chromeos || is_android || is_fuchsia) {
+  if (is_linux || is_chromeos || is_android || is_fuchsia || is_ohos) {
     asmflags += [ "-fPIC" ]
     cflags += [ "-fPIC" ]
     ldflags += [ "-fPIC" ]
@@ -444,7 +446,7 @@ config("compiler") {
     }
   } else if (use_gold) {
     ldflags += [ "-fuse-ld=gold" ]
-    if (!is_android) {
+    if (!is_android && !is_ohos) {
       # On Android, this isn't needed.  gcc in the NDK knows to look next to
       # it with -fuse-ld=gold, and clang gets a --gcc-toolchain flag passed
       # above.
@@ -528,9 +530,9 @@ config("compiler") {
 
   # C11/C++11 compiler flags setup.
   # ---------------------------
-  if (is_linux || is_chromeos || is_android || (is_nacl && is_clang) ||
+  if (is_linux || is_chromeos || is_android || (is_nacl && is_clang) || is_ohos ||
       current_os == "aix") {
-    if (target_os == "android") {
+    if (target_os == "android" || target_os == "ohos") {
       cxx11_override = use_cxx11_on_android
     } else {
       cxx11_override = use_cxx11
@@ -563,10 +565,10 @@ config("compiler") {
       # Override Chromium's default for projects that wish to stay on C++11.
       cflags_cc += [ "-std=${standard_prefix}++11" ]
     } else {
-      cflags_cc += [ "-std=${standard_prefix}++14" ]
+      cflags_cc += [ "-std=${standard_prefix}++17" ]
     }
   } else if (!is_win && !is_nacl) {
-    if (target_os == "android") {
+    if (target_os == "android" || target_os == "ohos") {
       cxx11_override = use_cxx11_on_android
     } else {
       cxx11_override = use_cxx11
@@ -580,7 +582,7 @@ config("compiler") {
     if (cxx11_override) {
       cflags_cc += [ "-std=c++11" ]
     } else {
-      cflags_cc += [ "-std=c++14" ]
+      cflags_cc += [ "-std=c++17" ]
     }
   }
 
@@ -677,7 +679,7 @@ config("compiler") {
     # Whole-program devirtualization increases android libchrome.so size
     # by ~100kb on arm32 and reduces it by ~108kb on arm64 instead.
     # Tracked by llvm bug: https://bugs.llvm.org/show_bug.cgi?id=48245
-    if (!is_android || current_cpu == "arm64") {
+    if ((!is_android && !is_ohos) || current_cpu == "arm64") {
       cflags += [ "-fwhole-program-vtables" ]
       if (!is_win) {
         ldflags += [ "-fwhole-program-vtables" ]
@@ -708,7 +710,7 @@ config("compiler") {
 
   # Pass flag to LLD so Android builds can allow debuggerd to properly symbolize
   # stack crashes (http://crbug.com/919499).
-  if (use_lld && is_android) {
+  if (use_lld && (is_android || is_ohos)) {
     ldflags += [ "-Wl,--no-rosegment" ]
   }
 
@@ -817,7 +819,7 @@ config("compiler_cpu_abi") {
         ]
       }
     } else if (current_cpu == "arm") {
-      if (is_clang && !is_android && !is_nacl) {
+      if (is_clang && !is_android && !is_nacl && !is_ohos) {
         cflags += [ "--target=arm-linux-gnueabihf" ]
         ldflags += [ "--target=arm-linux-gnueabihf" ]
       }
@@ -831,7 +833,7 @@ config("compiler_cpu_abi") {
         cflags += [ "-mtune=$arm_tune" ]
       }
     } else if (current_cpu == "arm64") {
-      if (is_clang && !is_android && !is_nacl && !is_fuchsia) {
+      if (is_clang && !is_android && !is_nacl && !is_fuchsia && !is_ohos) {
         cflags += [ "--target=aarch64-linux-gnu" ]
         ldflags += [ "--target=aarch64-linux-gnu" ]
       }
@@ -1123,7 +1125,7 @@ config("compiler_codegen") {
     configs += [ "//build/config/nacl:compiler_codegen" ]
   }
 
-  if (current_cpu == "arm64" && is_android) {
+  if (current_cpu == "arm64" && (is_android || is_ohos)) {
     # On arm64 disable outlining for Android. See crbug.com/931297 for more
     # information.
     cflags += [ "-mno-outline" ]
@@ -1294,6 +1296,8 @@ config("runtime_library") {
     configs += [ "//build/config/mac:runtime_library" ]
   } else if (is_android) {
     configs += [ "//build/config/android:runtime_library" ]
+  } else if (is_ohos) {
+    configs += [ "//build/config/ohos:runtime_library" ]
   }
 
   if (is_component_build) {
@@ -1491,6 +1495,45 @@ config("default_warnings") {
       cflags += [ "-Wno-psabi" ]
     }
 
+    if (use_musl) {
+      cflags += [
+        "-Wno-psabi",
+        "-Wno-unknown-pragmas",
+        "-Wno-thread-safety-attributes",
+        "-Wno-cpp",
+        "-Wno-extra-tokens",
+        "-Wno-error=c99-designator",
+        "-Wno-error=anon-enum-enum-conversion",
+        "-Wno-error=implicit-fallthrough",
+        "-Wno-error=sizeof-array-div",
+        "-Wno-error=reorder-init-list",
+        "-Wno-error=range-loop-construct",
+        "-Wno-error=deprecated-copy",
+        "-Wno-error=implicit-int-float-conversion",
+        "-Wno-error=inconsistent-dllimport",
+        "-Wno-error=unknown-warning-option",
+        "-Wno-error=abstract-final-class",
+        "-Wno-error=sign-compare",
+        "-Wno-error=int-in-bool-context",
+        "-Wno-error=xor-used-as-pow",
+        "-Wno-error=return-stack-address",
+        "-Wno-error=dangling-gsl",
+        "-Wno-error=macro-redefined",
+        "-Wno-error=implicit-function-declaration",
+        "-Wno-error=misleading-indentation",
+      ]
+    } else {
+      cflags += [
+        "-Wno-psabi",
+        "-Wno-error=sign-compare",
+        "-Wno-error=unknown-warning-option",
+        "-Wno-error=unused-variable",
+        "-Wno-unknown-attributes",
+        "-Wno-thread-safety-attributes",
+        "-Wno-unknown-pragmas",
+      ]
+    }
+
     if (!is_clang) {
       cflags_cc += [
         # See comment for -Wno-c++11-narrowing.
@@ -1593,16 +1636,34 @@ config("default_warnings") {
           "-Wno-non-c-typedef-for-linkage",
         ]
 
+        if (use_musl) {
+          cflags -= [
+            "-Wno-psabi",
+            "-Wno-non-c-typedef-for-linkage",
+          ]
+        } else {
+          cflags -= [
+            "-Wno-psabi",
+            "-Wno-implicit-int-float-conversion",
+            "-Wno-final-dtor-non-final-class",
+            "-Wno-builtin-assume-aligned-alignment",
+            "-Wno-deprecated-copy",
+            "-Wno-non-c-typedef-for-linkage",
+          ]
+        }
+
         cflags_c += [
           # TODO(https://crbug.com/995993): Clean up and enable.
           "-Wno-implicit-fallthrough",
         ]
 
-        if (enable_wmax_tokens) {
-          cflags += [ "-Wmax-tokens" ]
-        } else {
-          # TODO(https://crbug.com/1049569): Remove after Clang 87b235db.
-          cflags += [ "-Wno-max-tokens" ]
+        if (!is_ohos) {
+          if (enable_wmax_tokens) {
+            cflags += [ "-Wmax-tokens" ]
+          } else {
+            # TODO(https://crbug.com/1049569): Remove after Clang 87b235db.
+            cflags += [ "-Wno-max-tokens" ]
+          }
         }
       }
     }
@@ -1690,7 +1751,7 @@ config("chromium_code") {
       # Temporarily disable -Wextra-semi for Chrome on Chrome OS.
     } else if (is_chromecast && chromecast_branding != "public") {
       # Temporarily disable -Wextra-semi for Chromecast.
-    } else {
+    } else if (!is_ohos) {
       cflags += [ "-Wextra-semi" ]
     }
   }
@@ -1734,7 +1795,7 @@ config("no_chromium_code") {
       # suppressing them individually, we just blanket suppress them here.
       "-Wno-unused-variable",
     ]
-    if (!is_nacl && (current_toolchain == host_toolchain || !use_xcode_clang)) {
+    if (!is_nacl && (current_toolchain == host_toolchain || !use_xcode_clang) && !is_ohos) {
       cflags += [
         # TODO(https://crbug.com/1031169): Clean up and enable.
         "-Wno-misleading-indentation",
@@ -1858,7 +1919,7 @@ config("no_exceptions") {
 # See: //docs/static_initializers.md
 # See: https://groups.google.com/a/chromium.org/d/topic/chromium-dev/B9Q5KTD7iCo/discussion
 config("wglobal_constructors") {
-  if (is_clang) {
+  if (is_clang && !is_ohos) {
     cflags = [ "-Wglobal-constructors" ]
   }
 }
@@ -1867,7 +1928,7 @@ config("wglobal_constructors") {
 # destructors, which will slow down closing the program.
 # TODO(thakis): Make this a blocklist instead, http://crbug.com/101600
 config("wexit_time_destructors") {
-  if (is_clang) {
+  if (is_clang && !is_ohos) {
     cflags = [ "-Wexit-time-destructors" ]
   }
 }
@@ -1978,7 +2039,7 @@ if (is_win) {
   common_optimize_on_cflags = []
   common_optimize_on_ldflags = []
 
-  if (is_android) {
+  if (is_android || is_ohos) {
     # TODO(jdduke) Re-enable on mips after resolving linking
     # issues with libc++ (crbug.com/456380).
     if (current_cpu != "mipsel" && current_cpu != "mips64el") {
@@ -2094,7 +2155,7 @@ config("no_optimize") {
       # traces on Windows ARM64 rely on it.
       cflags += [ "/Oy-" ]
     }
-  } else if (is_android && !android_full_debug) {
+  } else if ((is_android || is_ohos) && !android_full_debug) {
     # On Android we kind of optimize some things that don't affect debugging
     # much even when optimization is disabled to get the binary size down.
     if (is_clang) {
@@ -2214,9 +2275,9 @@ if (is_clang && is_a_target_toolchain) {
   } else if (clang_use_default_sample_profile) {
     assert(build_with_chromium,
            "Our default profiles currently only apply to Chromium")
-    assert(is_android || is_chromeos_lacros || is_chromeos_ash || is_chromecast,
+    assert(is_android || is_chromeos_lacros || is_chromeos_ash || is_chromecast || is_ohos,
            "The current platform has no default profile")
-    if (is_android || is_chromecast) {
+    if (is_android || is_chromecast || is_ohos) {
       _clang_sample_profile = "//chrome/android/profiles/afdo.prof"
     } else {
       assert(chromeos_afdo_platform == "atom" ||
@@ -2438,7 +2499,7 @@ config("minimal_symbols") {
       cflags += [ "-g1" ]
     }
     ldflags = []
-    if (is_android && is_clang) {
+    if ((is_android || is_ohos) && is_clang) {
       # Android defaults to symbol_level=1 builds in production builds
       # (https://crbug.com/648948), but clang, unlike gcc, doesn't emit
       # DW_AT_linkage_name in -g1 builds. -fdebug-info-for-profiling enables
@@ -2484,7 +2545,7 @@ config("default_symbols") {
   }
 
   # This config is removed by base unittests apk.
-  if (is_android && is_clang && strip_debug_info) {
+  if ((is_android || is_ohos) && is_clang && strip_debug_info) {
     configs += [ ":strip_debug" ]
   }
 }
@@ -2518,7 +2579,7 @@ if (is_chromeos_ash && is_chromeos_device) {
   }
 }
 
-if (is_android || (is_chromeos_ash && is_chromeos_device)) {
+if (is_android || is_ohos || (is_chromeos_ash && is_chromeos_device)) {
   # Use orderfile for linking Chrome on Android and Chrome OS.
   # This config enables using an orderfile for linking in LLD.
   # TODO: Consider using call graph sort instead, at least on Android.
diff --git a/build/config/compiler/compiler.gni b/build/config/compiler/compiler.gni
index 96a18d91a3..77ec200817 100644
--- a/build/config/compiler/compiler.gni
+++ b/build/config/compiler/compiler.gni
@@ -13,7 +13,7 @@ import("//build/toolchain/goma.gni")
 import("//build/toolchain/toolchain.gni")
 import("//build_overrides/build.gni")
 
-if (is_android) {
+if (is_android || is_ohos) {
   import("//build/config/android/abi.gni")
 }
 if (current_cpu == "arm" || current_cpu == "arm64") {
@@ -115,7 +115,7 @@ assert(!is_cfi || use_thin_lto, "CFI requires ThinLTO")
 # Linux & Mac favor speed over size.
 # TODO(brettw) it's weird that Mac and desktop Linux are different. We should
 # explore favoring size over speed in this case as well.
-optimize_for_size = is_android || is_chromecast || is_fuchsia || is_ios
+optimize_for_size = is_android || is_chromecast || is_fuchsia || is_ios || is_ohos
 
 declare_args() {
   # Whether we should consider the profile we're using to be accurate. Accurate
@@ -144,7 +144,7 @@ if (is_chromeos_ash) {
   } else {
     enable_frame_pointers = true
   }
-} else if (is_android) {
+} else if (is_android || is_ohos) {
   enable_frame_pointers =
       enable_profiling ||
       # Ensure that stacks from arm64 crash dumps are usable (crbug.com/391706).
@@ -190,7 +190,7 @@ can_unwind_with_cfi_table = is_android && !is_component_build &&
 # Whether or not cfi table should be enabled on arm.
 # TODO(crbug.com/1090409): Replace can_unwind_with_cfi_table with this once
 # sampling profiler is enabled on android.
-enable_arm_cfi_table = is_android && !is_component_build && current_cpu == "arm"
+enable_arm_cfi_table = (is_android || is_ohos) && !is_component_build && current_cpu == "arm"
 
 declare_args() {
   # Set to true to use lld, the LLVM linker.
@@ -208,7 +208,7 @@ declare_args() {
                (current_cpu == "x64" || current_cpu == "x86" ||
                 current_cpu == "arm" || current_cpu == "arm64" ||
                 current_cpu == "mipsel" || current_cpu == "mips64el")) ||
-              (is_android && (current_cpu == "x86" || current_cpu == "x64" ||
+              ((is_android || is_ohos) && (current_cpu == "x86" || current_cpu == "x64" ||
                               current_cpu == "arm" || current_cpu == "arm64")))
 }
 
@@ -225,7 +225,7 @@ strip_absolute_paths_from_debug_symbols_default =
     # TODO(crbug.com/1010267): remove '!use_clang_coverage', coverage build has
     # dependency to absolute path of source files.
     !use_clang_coverage &&
-    (is_android || is_fuchsia || is_nacl || (is_win && use_lld) || is_linux ||
+    (is_android || is_fuchsia || is_nacl || (is_win && use_lld) || is_linux || is_ohos ||
      is_chromeos || (is_apple && !enable_dsyms))
 
 # If the platform uses stripped absolute paths by default, then we don't expose
@@ -243,14 +243,14 @@ assert(
     use_debug_fission == "default" || use_debug_fission || !use_debug_fission,
     "Invalid use_debug_fission.")
 if (use_debug_fission == "default") {
-  use_debug_fission = is_debug && !is_android && !is_fuchsia && !is_apple &&
+  use_debug_fission = is_debug && !is_android && !is_fuchsia && !is_apple && !is_ohos &&
                       !is_win && (use_gold || use_lld) && cc_wrapper == ""
 }
 
 # If it wasn't manually set, set to an appropriate default.
 assert(symbol_level >= -1 && symbol_level <= 2, "Invalid symbol_level")
 if (symbol_level == -1) {
-  if (is_android && !is_component_build && !use_debug_fission) {
+  if ((is_android || is_ohos) && !is_component_build && !use_debug_fission) {
     # Reduce symbol level when it will cause invalid elf files to be created
     # (due to file size). https://crbug.com/648948.
     symbol_level = 1
diff --git a/build/config/gcc/BUILD.gn b/build/config/gcc/BUILD.gn
index 154b259b5f..184c4e1f3b 100644
--- a/build/config/gcc/BUILD.gn
+++ b/build/config/gcc/BUILD.gn
@@ -63,7 +63,7 @@ config("symbol_visibility_default") {
 #    configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
 #  }
 config("rpath_for_built_shared_libraries") {
-  if (!is_android) {
+  if (!is_android && !is_ohos) {
     # Note: Android doesn't support rpath.
     if (current_toolchain != default_toolchain || gcc_target_rpath == "") {
       ldflags = [
@@ -79,7 +79,7 @@ config("rpath_for_built_shared_libraries") {
   }
 }
 
-if (is_component_build && !is_android) {
+if (is_component_build && !(is_android || is_ohos)) {
   # See the rpath_for... config above for why this is necessary for component
   # builds.
   executable_and_shared_library_configs_ =
@@ -92,14 +92,14 @@ if (is_component_build && !is_android) {
 config("executable_config") {
   configs = executable_and_shared_library_configs_
   ldflags = [ "-pie" ]
-  if (is_android) {
+  if (is_android || is_ohos) {
     ldflags += [
       "-Bdynamic",
       "-Wl,-z,nocopyreloc",
     ]
   }
 
-  if (!is_android && current_os != "aix") {
+  if (!is_android && current_os != "aix" && !is_ohos) {
     ldflags += [
       # TODO(GYP): Do we need a check on the binutils version here?
       #
diff --git a/build/config/ohos/BUILD.gn b/build/config/ohos/BUILD.gn
new file mode 100644
index 0000000000..3e9b09269d
--- /dev/null
+++ b/build/config/ohos/BUILD.gn
@@ -0,0 +1,201 @@
+# Copyright 2022 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/c++/c++.gni")
+import("//build/config/compiler/compiler.gni")
+import("//build/config/ohos/config.gni")
+import("//build/config/sanitizers/sanitizers.gni")
+
+assert(is_ohos)
+
+# This is included by reference in the //build/config/compiler config that
+# is applied to all targets. It is here to separate out the logic that is
+# ohos-only.
+config("compiler") {
+  cflags = [
+    "-ffunction-sections",
+    "-fno-short-enums",
+  ]
+  defines = [
+    "OSOHOS",
+
+    # The NDK has these things, but doesn't define the constants to say that it
+    # does. Define them here instead.
+    "HAVE_SYS_UIO_H",
+  ]
+
+  if (use_musl) {
+    defines += [
+      "__MUSL__",
+      "_LIBCPP_HAS_MUSL_LIBC",
+      "__BUILD_LINUX_WITH_CLANG",
+    ]
+  } else {
+    defines += [
+      "__BUILD_LINUX_WITH_CLANG",
+    ]
+  }
+
+  ldflags = [
+    "-Wl,--exclude-libs=libgcc.a",
+    "-Wl,--no-undefined",
+    "-Wl,--exclude-libs=libunwind_llvm.a",
+    "-Wl,--exclude-libs=libc++_static.a",
+
+    # Don't allow visible symbols from libraries that contain
+    # assembly code with symbols that aren't hidden properly.
+    # http://crbug.com/448386
+    "-Wl,--exclude-libs=libvpx_assembly_arm.a",
+  ]
+
+  # TODO(crbug.com/1184398): Move to compiler-rt when we are ready.
+  if (use_musl) {
+    if (current_cpu == "arm") {
+    } else {
+      ldflags += [ "--rtlib=libgcc" ]
+    }
+  }
+
+  if (current_cpu == "arm64") {
+    # For outline atomics on AArch64 (can't pass this unconditionally
+    # due to unused flag warning on other targets).
+    cflags += [ "--rtlib=libgcc" ]
+  }
+
+  # $compile_api_level corresponds to the API level used for the sysroot path
+  # calculation in //build/config/ohos/config.gni
+  if (current_cpu == "arm") {
+    abi_target = "arm-linux-androideabi"
+    if (use_musl) {
+      abi_target = "arm-linux-ohosmusl"
+    } else {
+      compile_api_level = arm32_ndk_api_level
+    }
+  } else if (current_cpu == "x86") {
+    abi_target = ""
+    compile_api_level = ""
+  } else if (current_cpu == "arm64") {
+    if (!use_musl) {
+      abi_target = "aarch64-linux-android"
+      compile_api_level = arm64_ndk_api_level
+    }
+  } else if (current_cpu == "x64") {
+    abi_target = ""
+    compile_api_level = ""
+  } else {
+    assert(false, "Architecture not supported")
+  }
+
+  if (use_musl) {
+    cflags += [ "--target=$abi_target" ]
+    include_dirs = [
+      "$ohos_toolchain_root/include/c++/v1",
+    ]
+    ldflags += [ "--target=$abi_target" ]
+  } else {
+    cflags += [
+      "--target=$abi_target",
+      "-D__ANDROID_API__=$compile_api_level",
+    ]
+    ldflags += [ "--target=$abi_target" ]
+    include_dirs = [
+      "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/sysroot/usr/include",
+      "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/sysroot/usr/include/$abi_target",
+    ]
+  }
+
+  # Assign any flags set for the C compiler to asmflags so that they are sent
+  # to the assembler.
+  asmflags = cflags
+}
+
+# This is included by reference in the //build/config/compiler:runtime_library
+# config that is applied to all targets. It is here to separate out the logic
+# that is Android-only. Please see that target for advice on what should go in
+# :runtime_library vs. :compiler.
+config("runtime_library") {
+  libs = []
+  ldflags = []
+
+  if (use_musl) {
+    defines = [
+      "__MUSL__",
+      "_LIBCPP_HAS_MUSL_LIBC",
+      "__BUILD_LINUX_WITH_CLANG",
+    ]
+  } else {
+    defines = [
+      "__BUILD_LINUX_WITH_CLANG",
+    ]
+  }
+  if (use_musl) {
+    ldflags += [
+      "-L" + rebase_path("$ohos_sysroot/usr/lib/arm-linux-ohosmusl", root_build_dir),
+      "-L" + rebase_path("$ohos_toolchain_root/lib/arm-linux-ohosmusl/c++", root_build_dir),
+      "-L" + rebase_path("$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohosmusl", root_build_dir),
+    ]
+    ldflags += [ "-Wl,--dynamic-linker,/system/bin/ld-musl-arm.so.1" ]
+    libclang_rt_file = "$ohos_toolchain_root/lib/clang/10.0.1/lib/arm-linux-ohosmusl/libclang_rt.builtins.a"
+
+    libs += [
+      rebase_path(libclang_rt_file),
+      "c",
+      "c++",
+      "c++abi"
+    ]
+  } else {
+    cflags = [
+      "-isystem" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/libcxx/include", root_build_dir),
+      "-isystem" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/libcxxabi/include", root_build_dir),
+      "-isystem" + rebase_path("$ohos_toolchain_root/lib64/clang/9.0.3/include", root_build_dir),
+      "-isystem" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/sysroot/usr/include", root_build_dir),
+      "-isystem" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/sysroot/usr/include/arm-linux-androideabi", root_build_dir),
+    ]
+
+    cflags_cc = [
+      "-isystem" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/libcxx/include", root_build_dir),
+      "-isystem" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/libcxxabi/include", root_build_dir),
+    ]
+
+    if (current_cpu == "arm") {
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/gcc/linux-x86/arm/gcc-linaro-7.5.0-arm-linux-gnueabi/arm-linux-gnueabi/lib", root_build_dir) ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/gcc/linux-x86/arm/gcc-linaro-7.5.0-arm-linux-gnueabi/lib/gcc/arm-linux-gnueabi/7.5.0", root_build_dir) ]
+      ldflags += [ "-l:libgcc.a" ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/libcxx/arm", root_build_dir) ]
+      ldflags += [ "-l:libc++_static.a" ]
+      ldflags += [ "-L" + rebase_path("$ohos_toolchain_root/lib64/clang/9.0.3/lib/linux", root_build_dir) ]
+      ldflags += [ "-l:libclang_rt.builtins-arm-android.a" ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/sdk/shared_library/arm", root_build_dir) ]
+      ldflags += [ "-l:liblog.so" ]
+      ldflags += [ "-L" + rebase_path("$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm/usr/lib", root_build_dir) ]
+    }
+
+    libs += [ "unwind_llvm" ]
+  }
+
+  # arm builds of libc++ starting in NDK r12 depend on unwind.
+  if (current_cpu == "arm") {
+    libs += [ "unwind" ]
+  }
+
+  # TODO(jdduke) Re-enable on mips after resolving linking
+  # issues with libc++ (crbug.com/456380).
+  if (current_cpu != "mipsel" && current_cpu != "mips64el") {
+    ldflags += [ "-Wl,--warn-shared-textrel" ]
+  }
+}
+
+config("lld_pack_relocations") {
+  ldflags = [ "-Wl,--pack-dyn-relocs=android" ]
+}
+
+# Used for instrumented build to generate the orderfile.
+config("default_orderfile_instrumentation") {
+  if (use_order_profiling) {
+    cflags = [ "-finstrument-function-entry-bare" ]
+    if (use_thin_lto) {
+      ldflags = [ "-Wl,-u,__cyg_profile_func_enter_bare" ]
+    }
+  }
+}
diff --git a/build/config/ohos/abi.gni b/build/config/ohos/abi.gni
new file mode 100644
index 0000000000..71cfb23ccc
--- /dev/null
+++ b/build/config/ohos/abi.gni
@@ -0,0 +1,48 @@
+# Copyright 2022 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# Logic separated out from config.gni so that it can be used by compiler.gni
+# without introducing a circular dependency.
+
+assert(is_ohos)
+
+if (current_cpu == "x86") {
+  ohos_app_abi = "x86"
+} else if (current_cpu == "arm") {
+  import("//build/config/arm.gni")
+  if (arm_version < 7) {
+    ohos_app_abi = "armeabi"
+  } else {
+    ohos_app_abi = "armeabi-v7a"
+  }
+} else if (current_cpu == "x64") {
+  ohos_app_abi = "x86_64"
+} else if (current_cpu == "arm64") {
+  ohos_app_abi = "arm64-v8a"
+} else {
+  assert(false, "Unknown ABI: " + current_cpu)
+}
+
+if (target_cpu == "arm64" || target_cpu == "x64") {
+  ohos_64bit_target_cpu = true
+} else if (target_cpu == "arm" || target_cpu == "x86") {
+  ohos_64bit_target_cpu = false
+} else {
+  assert(false, "Unknown target CPU: $target_cpu")
+}
+
+# Intentionally do not define ohos_app_secondary_abi_cpu and
+# ohos_app_secondary_abi for 32-bit target_cpu, since they are not used.
+if (target_cpu == "arm64") {
+  ohos_secondary_abi_cpu = "arm"
+  ohos_app_secondary_abi = "armeabi-v7a"
+} else if (target_cpu == "x64") {
+  ohos_secondary_abi_cpu = "x86"
+  ohos_app_secondary_abi = "x86"
+}
+
+if (defined(ohos_secondary_abi_cpu)) {
+  ohos_secondary_abi_cpu =
+      "//build/toolchain/ohos:ohos_clang_${ohos_secondary_abi_cpu}"
+}
diff --git a/build/config/ohos/config.gni b/build/config/ohos/config.gni
new file mode 100644
index 0000000000..951d4a7f26
--- /dev/null
+++ b/build/config/ohos/config.gni
@@ -0,0 +1,116 @@
+# Copyright 2022 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+if (is_ohos) {
+  import("//build/config/dcheck_always_on.gni")
+  import("//build_overrides/build.gni")
+  import("abi.gni")
+
+  declare_args() {
+    arm32_ndk_api_level = 21
+    arm64_ndk_api_level = 21
+  }
+
+  declare_args() {
+    build_chromium_with_ohos_src = false
+  }
+
+  # Defines the name the ohos build gives to the current host CPU
+  # architecture, which is different than the names GN uses.
+  if (host_cpu == "x64") {
+    ohos_host_arch = "x86_64"
+  } else if (host_cpu == "x86") {
+    ohos_host_arch = "x86"
+  } else {
+    assert(false, "Need ohos toolchain support for your build CPU arch.")
+  }
+
+  # Defines the name the ohos build gives to the current host CPU
+  # architecture, which is different than the names GN uses.
+  if (host_os == "linux") {
+    ohos_host_os = "linux"
+  } else if (host_os == "mac") {
+    ohos_host_os = "darwin"
+  } else {
+    assert(false, "Need ohos toolchain support for your build OS.")
+  }
+
+  # config dependent paths
+  if (build_chromium_with_ohos_src) {
+    ohos_ndk_root = "//../../../prebuilts"
+    ohos_build_root = "//../../.."
+    if (use_musl) {
+      ohos_toolchain_root = "$ohos_ndk_root/clang/ohos/linux-x86_64/llvm"
+      ohos_sysroot = "$ohos_build_root/out/ohos-arm-release/obj/third_party/musl"
+    } else {
+      ohos_toolchain_root = "$ohos_ndk_root/clang/host/linux-x86/clang-r353983c"
+      ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
+    }
+
+    # ohos include and libs dependencies
+    ohos_src_includes = [
+      "$ohos_build_root/foundation/appexecfwk/standard/interfaces/innerkits/libeventhandler/include",
+      "$ohos_build_root/utils/native/base/include",
+      "$ohos_build_root/base/hiviewdfx/hilog/interfaces/native/innerkits/include",
+      "$ohos_build_root/foundation/graphic/standard/interfaces/innerkits/common",
+      "$ohos_build_root/drivers/peripheral/display/interfaces/include",
+      "$ohos_build_root/foundation/graphic/standard/utils/buffer_handle/export",
+      "$ohos_build_root/foundation/multimedia/media_standard/interfaces/innerkits/native/media/include",
+      "$ohos_build_root/drivers/peripheral/base",
+      "$ohos_build_root/foundation/graphic/standard/interfaces/innerkits/surface",
+      "$ohos_build_root/foundation/communication/ipc/interfaces/innerkits/ipc_core/include",
+      "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_controller/include",
+      "$ohos_build_root/base/miscservices/inputmethod/services/include",
+      "$ohos_build_root/base/miscservices/inputmethod/frameworks/inputmethod_ability/include",
+      "$ohos_build_root/utils/native/base/include",
+      "$ohos_build_root/foundation/multimodalinput/input/interfaces/native/innerkits/event/include",
+      "$ohos_build_root/base/location/location_locator/callback/include",
+      "$ohos_build_root/base/location/utils/include",
+      "$ohos_build_root/base/location/interfaces/innerkits/locator_standard/include",
+      "$ohos_build_root/base/location/location_common/common/include",
+      "$ohos_build_root/utils/system/safwk/native/include",
+    ]
+    ohos_libs_dir = [
+      "$ohos_build_root/out/ohos-arm-release/packages/phone/system/lib",
+    ]
+  } else {
+    if (use_musl) {
+      ohos_build_root = "//ohos_ndk"
+      ohos_ndk_root = "//ohos_ndk"
+      ohos_toolchain_root = "$ohos_ndk_root/toolchains/llvm"
+      ohos_sysroot = "$ohos_ndk_root/sysroot"
+    } else {
+      ohos_build_root = "//ohos_ndk_aosp"
+      ohos_ndk_root = "//ohos_ndk_aosp"
+      ohos_toolchain_root = "$ohos_ndk_root/toolchains/clang-r353983c"
+      ohos_sysroot = "$ohos_ndk_root/aosp_prebuilt_libs/asdk_libs/ndk/platforms/current/arch-arm"
+    }
+
+    # ohos include and libs dependencies, corresponding to gen_ohos_ndk.sh
+    ohos_src_includes = [
+      "$ohos_build_root/includes/libeventhandler",
+      "$ohos_build_root/includes/utils",
+      "$ohos_build_root/includes/common",
+      "$ohos_build_root/includes/display",
+      "$ohos_build_root/includes/graphic_util",
+      "$ohos_build_root/includes/media",
+      "$ohos_build_root/includes/peripheral",
+      "$ohos_build_root/includes/surface",
+      "$ohos_build_root/includes/ipc_core",
+      "$ohos_build_root/includes/inputmethod_controller",
+      "$ohos_build_root/includes",
+      "$ohos_build_root/includes/inputmethod_services",
+      "$ohos_build_root/includes/inputmethod_ability",
+      "$ohos_build_root/includes/multimodalinput",
+      "$ohos_build_root/includes/location",
+      "$ohos_build_root/includes/location_utils",
+      "$ohos_build_root/includes/location_callback",
+      "$ohos_build_root/includes/location_request_config",
+      "$ohos_build_root/includes/system_ability",
+    ]
+    ohos_libs_dir = [
+      "$ohos_build_root/libs",
+    ]
+  }
+}
diff --git a/build/config/ozone.gni b/build/config/ozone.gni
index a14eb93cec..187d05846b 100644
--- a/build/config/ozone.gni
+++ b/build/config/ozone.gni
@@ -89,6 +89,8 @@ declare_args() {
     } else if (is_fuchsia) {
       ozone_platform = "scenic"
       ozone_platform_scenic = true
+    } else if (is_ohos) {
+      ozone_platform_wayland = true
     }
   }
 
diff --git a/build/config/sysroot.gni b/build/config/sysroot.gni
index 18d2d57362..359776d661 100644
--- a/build/config/sysroot.gni
+++ b/build/config/sysroot.gni
@@ -35,6 +35,9 @@ if (sysroot == "") {
 
     # Android uses unified headers, and thus a single compile time sysroot
     sysroot = "$android_toolchain_root/sysroot"
+  } else if (is_ohos) {
+    import("//build/config/ohos/config.gni")
+    sysroot = "$ohos_sysroot"
   } else if ((is_linux || is_chromeos) && use_sysroot) {
     # By default build against a sysroot image downloaded from Cloud Storage
     # during gclient runhooks.
diff --git a/build/config/ui.gni b/build/config/ui.gni
index 022f008ab1..ec0b388f3d 100644
--- a/build/config/ui.gni
+++ b/build/config/ui.gni
@@ -24,7 +24,7 @@ declare_args() {
   # Indicates if Ozone is enabled. Ozone is a low-level library layer for Linux
   # that does not require X11.
   use_ozone =
-      is_chromeos || (is_chromecast && !is_android) || is_fuchsia || is_linux
+      is_chromeos || (is_chromecast && !is_android) || is_fuchsia || is_linux || is_ohos
 
   # Indicates if the UI toolkit depends on X11.
   # Enabled by default. Can be disabled if Ozone only build is required and
diff --git a/build/toolchain/android/BUILD.gn b/build/toolchain/android/BUILD.gn
index 65be9970c2..e8b2f872b2 100644
--- a/build/toolchain/android/BUILD.gn
+++ b/build/toolchain/android/BUILD.gn
@@ -32,11 +32,11 @@ template("android_clang_toolchain") {
     # toolchain definitions are evaluated under the default toolchain.
     # Rather than computing the value under current_os="android", just disable
     # it if target_os != "android".
-    _use_debug_fission = use_debug_fission && target_os == "android"
+    _use_debug_fission = use_debug_fission && (target_os == "android" || target_os == "ohos")
 
     toolchain_args = {
       forward_variables_from(invoker.toolchain_args, "*")
-      current_os = "android"
+      current_os = target_os
       use_debug_fission = _use_debug_fission
     }
 
diff --git a/build/toolchain/concurrent_links.gni b/build/toolchain/concurrent_links.gni
index f1a42c9101..20068b6470 100644
--- a/build/toolchain/concurrent_links.gni
+++ b/build/toolchain/concurrent_links.gni
@@ -58,10 +58,10 @@ if (concurrent_links == -1) {
     } else {
       _args = [ "--mem_per_link_gb=4" ]
     }
-  } else if (is_android && !is_component_build && symbol_level == 2) {
+  } else if ((is_android || is_ohos) && !is_component_build && symbol_level == 2) {
     # Full debug symbols require large memory for link.
     _args = [ "--mem_per_link_gb=25" ]
-  } else if (is_android && !is_debug && !using_sanitizer && is_java_debug &&
+  } else if ((is_android || is_ohos) && !is_debug && !using_sanitizer && is_java_debug &&
              disable_android_lint && symbol_level < 2) {
     if (symbol_level == 1) {
       _args = [ "--mem_per_link_gb=6" ]
@@ -81,7 +81,7 @@ if (concurrent_links == -1) {
   # These both have a peak usage of < 2GB, but that is still large enough for
   # them to need to use a pool since they both typically happen at the
   # same time as linking.
-  if (is_android) {
+  if (is_android || is_ohos) {
     _args += [ "--secondary_mem_per_link=2" ]
   }
 
diff --git a/build/toolchain/gcc_toolchain.gni b/build/toolchain/gcc_toolchain.gni
index 650784bb54..029cdc857d 100644
--- a/build/toolchain/gcc_toolchain.gni
+++ b/build/toolchain/gcc_toolchain.gni
@@ -27,12 +27,12 @@ declare_args() {
       is_official_build &&
       # Don't enable for Android-on-Chrome OS so that they can build with
       # symbol_level=0 without this failing (crbug.com/891164).
-      (target_os == "android" || target_os == "win")
+      (target_os == "android" || target_os == "win" || target_os == "ohos")
 }
 
 # When the arg is set via args.gn, it applies to all toolchains. In order to not
 # hit the assert in grit_rule.gni, explicitly disable for host toolchains.
-if ((is_linux || is_chromeos) && target_os == "android") {
+if ((is_linux || is_chromeos) && (target_os == "android" || target_os == "ohos")) {
   enable_resource_allowlist_generation = false
 }
 
@@ -47,7 +47,7 @@ if (enable_resource_allowlist_generation) {
       !is_component_build,
       "enable_resource_allowlist_generation=true requires is_component_build=false")
   assert(
-      target_os == "android" || target_os == "win",
+      target_os == "android" || target_os == "win" || target_os == "ohos",
       "enable_resource_allowlist_generation=true does not work for target_os=$target_os")
 }
 
diff --git a/build/toolchain/ohos/BUILD.gn b/build/toolchain/ohos/BUILD.gn
new file mode 100644
index 0000000000..c8540c7b3a
--- /dev/null
+++ b/build/toolchain/ohos/BUILD.gn
@@ -0,0 +1,63 @@
+# Copyright 2022 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/clang/clang.gni")
+import("//build/config/compiler/compiler.gni")
+import("//build/config/ohos/config.gni")
+import("//build/config/ozone.gni")
+import("//build/config/sysroot.gni")
+import("//build/toolchain/gcc_toolchain.gni")
+
+declare_args() {
+  # Whether unstripped binaries, i.e. compiled with debug symbols, should be
+  # considered runtime_deps rather than stripped ones.
+  ohos_unstripped_runtime_outputs = true
+}
+
+# The ohos clang toolchains share most of the same parameters, so we have this
+# wrapper around gcc_toolchain to avoid duplication of logic.
+#
+# Parameters:
+#  - binary_prefix
+#      Prefix of compiler executables.
+template("ohos_clang_toolchain") {
+  gcc_toolchain(target_name) {
+    assert(defined(invoker.toolchain_args),
+           "toolchain_args must be defined for ohos_clang_toolchain()")
+
+    toolchain_args = {
+      forward_variables_from(invoker.toolchain_args, "*")
+      current_os = target_os
+    }
+
+    # Output linker map files for binary size analysis.
+    enable_linker_map = true
+
+    _prefix = rebase_path("$clang_base_path/bin", root_build_dir)
+    cc = "$_prefix/clang"
+    cxx = "$_prefix/clang++"
+    ar = "$_prefix/llvm-ar"
+    ld = cxx
+    readelf = "$_prefix/llvm-readobj"
+    nm = "$_prefix/llvm-nm"
+    strip = rebase_path("$clang_base_path/bin/llvm-strip", root_build_dir)
+    use_unstripped_as_runtime_outputs = ohos_unstripped_runtime_outputs
+
+    # Don't use .cr.so for loadable_modules since they are always loaded via
+    # absolute path.
+    loadable_module_extension = ".so"
+  }
+}
+
+ohos_clang_toolchain("ohos_clang_arm") {
+  toolchain_args = {
+    current_cpu = "arm"
+  }
+}
+
+ohos_clang_toolchain("ohos_clang_arm64") {
+  toolchain_args = {
+    current_cpu = "arm64"
+  }
+}
diff --git a/build/toolchain/toolchain.gni b/build/toolchain/toolchain.gni
index 94ecbbb13e..92a0e4ea4a 100644
--- a/build/toolchain/toolchain.gni
+++ b/build/toolchain/toolchain.gni
@@ -23,7 +23,7 @@ declare_args() {
   use_xcode_clang = false
 
   # Used for binary size analysis.
-  generate_linker_map = is_android && is_official_build
+  generate_linker_map = (is_android || is_ohos) && is_official_build
 }
 
 if (generate_linker_map) {
@@ -32,7 +32,7 @@ if (generate_linker_map) {
              "true or is_chromecast = true")
   assert(current_os == "android" || current_os == "linux" ||
              target_os == "android" || target_os == "linux" ||
-             target_os == "chromeos",
+             target_os == "chromeos" || target_os == "ohos",
          "Linker map files should only be generated for Android, Linux, " +
              "or ChromeOS.")
 }
@@ -50,7 +50,7 @@ assert(!use_xcode_clang || target_os == "ios",
 # Extension for shared library files (including leading dot).
 if (is_apple) {
   shlib_extension = ".dylib"
-} else if (is_android && is_component_build) {
+} else if ((is_android || is_ohos) && is_component_build) {
   # By appending .cr, we prevent name collisions with libraries already
   # loaded by the Android zygote.
   shlib_extension = ".cr.so"
diff --git a/build/util/version.gni b/build/util/version.gni
index fb8715d32d..9e76b887c7 100644
--- a/build/util/version.gni
+++ b/build/util/version.gni
@@ -35,7 +35,7 @@ if (is_mac) {
     "-e",
     "PATCH_LO=int(PATCH)%256",
   ]
-} else if (target_os == "android") {
+} else if (target_os == "android" || target_os == "ohos") {
   import("//build/config/android/config.gni")
 
   _version_dictionary_template +=
@@ -93,7 +93,7 @@ if (is_mac) {
 
   chrome_dylib_version = "$chrome_version_build.$chrome_version_patch_hi" +
                          ".$chrome_version_patch_lo"
-} else if (target_os == "android") {
+} else if (target_os == "android" || target_os == "ohos") {
   forward_variables_from(_result,
                          [
                            "chrome_modern_version_code",
diff --git a/cc/mojom/BUILD.gn b/cc/mojom/BUILD.gn
index fc4ab95cb5..e1392a9ec2 100644
--- a/cc/mojom/BUILD.gn
+++ b/cc/mojom/BUILD.gn
@@ -21,6 +21,9 @@ component("shared_mojom_traits") {
 
 mojom("mojom") {
   generate_java = true
+  if (is_android) {
+    enabled_features = [ "is_android" ]
+  }
   sources = [
     "browser_controls_params.mojom",
     "browser_controls_state.mojom",
diff --git a/cef/BUILD.gn b/cef/BUILD.gn
index 1a5a0a93d0..776db090a5 100644
--- a/cef/BUILD.gn
+++ b/cef/BUILD.gn
@@ -254,7 +254,7 @@ assert(enable_basic_printing)
 assert(enable_print_preview)
 
 # Enable support for Widevine CDM.
-assert(enable_widevine)
+assert(enable_widevine || is_ohos)
 
 if (is_clang) {
   # Don't use the chrome style plugin.
@@ -872,7 +872,7 @@ static_library("libcef_static") {
     "//components/printing/common",
     "//components/printing/renderer",
     "//components/proxy_config",
-    "//components/safe_browsing/core/db:test_database_manager",
+    # "//components/safe_browsing/core/db:test_database_manager",
     "//components/services/print_compositor/public/cpp",
     "//components/services/print_compositor/public/mojom",
     "//components/update_client",
@@ -935,6 +935,12 @@ static_library("libcef_static") {
     "//v8",
   ]
 
+  if (safe_browsing_mode != 0) {
+    deps += [
+      "//components/safe_browsing/core/db:test_database_manager"
+    ]
+  }
+
   if (is_win) {
     sources += includes_win + [
       "libcef/browser/alloy/alloy_browser_main_win.cc",
@@ -980,6 +986,18 @@ static_library("libcef_static") {
     ]
   }
 
+  if (is_ohos) {
+    sources += includes_linux + [
+      "libcef/browser/native/browser_platform_delegate_native_linux.cc",
+      "libcef/browser/native/browser_platform_delegate_native_linux.h",
+      "libcef/browser/native/cursor_util_linux.cc",
+      "libcef/browser/native/menu_runner_linux.cc",
+      "libcef/browser/native/menu_runner_linux.h",
+      "libcef/browser/osr/browser_platform_delegate_osr_linux.cc",
+      "libcef/browser/osr/browser_platform_delegate_osr_linux.h",
+    ]
+  }
+
   if (is_linux) {
     sources += includes_linux + [
       "libcef/browser/native/browser_platform_delegate_native_linux.cc",
@@ -1057,7 +1075,7 @@ static_library("libcef_static") {
     deps += [ "//tools/v8_context_snapshot" ]
   }
 
-  if (toolkit_views) {
+  if (toolkit_views || is_ohos) {
     sources += [
       "libcef/browser/chrome/views/browser_platform_delegate_chrome_views.cc",
       "libcef/browser/chrome/views/browser_platform_delegate_chrome_views.h",
@@ -1214,6 +1232,14 @@ static_library("libcef_static") {
           ]
         }
       }
+      if (is_ohos) {
+        sources += [
+          # Support for UI input events.
+          # Part of //ui/aura:test_support which is testingonly.
+          "//ui/aura/test/aura_test_utils.cc",
+          "//ui/aura/test/aura_test_utils.h",
+        ]
+      }
     }
 
     if (is_mac) {
@@ -1406,7 +1432,7 @@ make_pack_header("resources") {
     "//ui/resources:webui_resources_grd",
   ]
 
-  if (toolkit_views) {
+  if (toolkit_views || is_ohos) {
     inputs += [ "$root_gen_dir/ui/views/resources/grit/views_resources.h" ]
     deps += [ "//ui/views/resources:resources_grd" ]
   }
diff --git a/cef/include/capi/cef_base_capi.h b/cef/include/capi/cef_base_capi.h
index dbd0b9f339..09c397421a 100644
--- a/cef/include/capi/cef_base_capi.h
+++ b/cef/include/capi/cef_base_capi.h
@@ -38,6 +38,7 @@
 #include "include/internal/cef_string_map.h"
 #include "include/internal/cef_string_multimap.h"
 #include "include/internal/cef_types.h"
+#include "include/internal/cef_types_wrappers.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/cef/include/cef_api_hash.h b/cef/include/cef_api_hash.h
index 1bbed1b2e5..c09e0c63ce 100644
--- a/cef/include/cef_api_hash.h
+++ b/cef/include/cef_api_hash.h
@@ -49,6 +49,8 @@
 #define CEF_API_HASH_PLATFORM "5cc32f88bd134410eff86b21095138b339d572f2"
 #elif defined(OS_LINUX)
 #define CEF_API_HASH_PLATFORM "b227b3fdd6142a9d8ff0f2252a71425f15960800"
+#elif defined(OS_OHOS)
+#define CEF_API_HASH_PLATFORM "b227b3fdd6142a9d8ff0f2252a71425f15960800"
 #endif
 
 #ifdef __cplusplus
diff --git a/cef/include/cef_base.h b/cef/include/cef_base.h
index 89e9c7a1e0..8dadcf45e0 100644
--- a/cef/include/cef_base.h
+++ b/cef/include/cef_base.h
@@ -42,7 +42,7 @@
 #include "include/internal/cef_win.h"
 #elif defined(OS_MAC)
 #include "include/internal/cef_mac.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_OHOS)
 #include "include/internal/cef_linux.h"
 #endif
 
diff --git a/cef/include/cef_config.h b/cef/include/cef_config.h
index 9938c4019d..e90ae957b4 100644
--- a/cef/include/cef_config.h
+++ b/cef/include/cef_config.h
@@ -35,7 +35,7 @@
 #ifndef CEF_INCLUDE_CEF_CONFIG_H_
 #define CEF_INCLUDE_CEF_CONFIG_H_
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_OHOS)
 
 #define CEF_X11 1
 
diff --git a/cef/include/internal/cef_types.h b/cef/include/internal/cef_types.h
index 0ec9fcb5cf..db67632877 100644
--- a/cef/include/internal/cef_types.h
+++ b/cef/include/internal/cef_types.h
@@ -41,7 +41,7 @@
 #include "include/internal/cef_types_win.h"
 #elif defined(OS_MAC)
 #include "include/internal/cef_types_mac.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_OHOS)
 #include "include/internal/cef_types_linux.h"
 #endif
 
diff --git a/cef/include/internal/cef_types_linux.h b/cef/include/internal/cef_types_linux.h
index b21d6551e1..94c85dea40 100644
--- a/cef/include/internal/cef_types_linux.h
+++ b/cef/include/internal/cef_types_linux.h
@@ -34,7 +34,7 @@
 #include "include/base/cef_build.h"
 #include "include/cef_config.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_OHOS)
 
 #if defined(CEF_X11)
 typedef union _XEvent XEvent;
diff --git a/cef/libcef/browser/alloy/alloy_browser_main.cc b/cef/libcef/browser/alloy/alloy_browser_main.cc
index ffcde42815..433272c61c 100644
--- a/cef/libcef/browser/alloy/alloy_browser_main.cc
+++ b/cef/libcef/browser/alloy/alloy_browser_main.cc
@@ -148,7 +148,11 @@ int AlloyBrowserMainParts::PreCreateThreads() {
   // Initialize these objects before IO access restrictions are applied and
   // before the IO thread is started.
   content::GpuDataManager::GetInstance();
+#if !defined(OS_OHOS)
   SystemNetworkContextManager::CreateInstance(g_browser_process->local_state());
+#else
+  LOG(INFO) << "SystemNetworkContextManager::CreateInstance UNIMPLEMENT for OS_OHOS";
+#endif
 
   return 0;
 }
diff --git a/cef/libcef/browser/alloy/alloy_content_browser_client.cc b/cef/libcef/browser/alloy/alloy_content_browser_client.cc
index 48f567f9be..33be06def0 100644
--- a/cef/libcef/browser/alloy/alloy_content_browser_client.cc
+++ b/cef/libcef/browser/alloy/alloy_content_browser_client.cc
@@ -383,7 +383,7 @@ class CefQuotaPermissionContext : public content::QuotaPermissionContext {
   DISALLOW_COPY_AND_ASSIGN(CefQuotaPermissionContext);
 };
 
-#if defined(OS_POSIX) && !defined(OS_MAC)
+#if defined(OS_POSIX) && !defined(OS_MAC) && !defined(OS_OHOS)
 breakpad::CrashHandlerHostLinux* CreateCrashHandlerHost(
     const std::string& process_type) {
   base::FilePath dumps_path;
@@ -693,7 +693,6 @@ void AlloyContentBrowserClient::AppendExtraCommandLineSwitches(
       switches::kMainBundlePath,
 #endif
       switches::kLocalesDirPath,
-      switches::kLogFile,
       switches::kLogSeverity,
       switches::kResourcesDirPath,
       embedder_support::kUserAgent,
@@ -705,6 +704,16 @@ void AlloyContentBrowserClient::AppendExtraCommandLineSwitches(
 
   const std::string& process_type =
       command_line->GetSwitchValueASCII(switches::kProcessType);
+  if (process_type == switches::kZygoteProcess ||
+      (browser_cmd->HasSwitch(switches::kNoZygote) &&
+       process_type == switches::kRendererProcess)) {
+    static const char* const kSwitchNames[] = {
+        switches::kUserDataDir,
+    };
+    command_line->CopySwitchesFrom(*browser_cmd, kSwitchNames,
+                                   base::size(kSwitchNames));
+  }
+
   if (process_type == switches::kRendererProcess) {
     // Propagate the following switches to the renderer command line (along with
     // any associated values) if present in the browser command line.
@@ -718,6 +727,7 @@ void AlloyContentBrowserClient::AppendExtraCommandLineSwitches(
         switches::kEnableSpeechInput,
         switches::kUncaughtExceptionStackSize,
         network::switches::kUnsafelyTreatInsecureOriginAsSecure,
+        switches::kUserDataDir,
     };
     command_line->CopySwitchesFrom(*browser_cmd, kSwitchNames,
                                    base::size(kSwitchNames));
@@ -1046,6 +1056,7 @@ void AlloyContentBrowserClient::ExposeInterfacesToRenderer(
       base::BindRepeating(&BindPluginInfoHost, host->GetID()));
 }
 
+#if !defined(OS_OHOS)
 std::unique_ptr<net::ClientCertStore>
 AlloyContentBrowserClient::CreateClientCertStore(
     content::BrowserContext* browser_context) {
@@ -1058,10 +1069,14 @@ AlloyContentBrowserClient::CreateClientCertStore(
   return std::unique_ptr<net::ClientCertStore>(new net::ClientCertStoreWin());
 #elif defined(OS_MAC)
   return std::unique_ptr<net::ClientCertStore>(new net::ClientCertStoreMac());
+#elif defined(OS_OHOS)
+  LOG(INFO) << "ClientCertStore UNIMPLEMENT for OS_OHOS";
+  return nullptr;
 #else
 #error Unknown platform.
 #endif
 }
+#endif
 
 std::unique_ptr<content::LoginDelegate>
 AlloyContentBrowserClient::CreateLoginDelegate(
@@ -1176,10 +1191,15 @@ void AlloyContentBrowserClient::OnNetworkServiceCreated(
   PrefService* local_state = g_browser_process->local_state();
   DCHECK(local_state);
 
+#if !defined(OS_OHOS)
   // Need to set up global NetworkService state before anything else uses it.
   DCHECK(SystemNetworkContextManager::GetInstance());
   SystemNetworkContextManager::GetInstance()->OnNetworkServiceCreated(
       network_service);
+#else
+  LOG(INFO) << "AlloyContentBrowserClient::OnNetworkServiceCreated UNIMPLEMENT "
+               "for OS_OHOS";
+#endif
 }
 
 void AlloyContentBrowserClient::ConfigureNetworkContextParams(
@@ -1261,6 +1281,7 @@ bool AlloyContentBrowserClient::HandleExternalProtocol(
     content::NavigationUIData* navigation_data,
     const network::ResourceRequest& resource_request,
     mojo::PendingRemote<network::mojom::URLLoaderFactory>* out_factory) {
+#if !defined(OS_OHOS)
   mojo::PendingReceiver<network::mojom::URLLoaderFactory> receiver =
       out_factory->InitWithNewPipeAndPassReceiver();
 
@@ -1274,6 +1295,11 @@ bool AlloyContentBrowserClient::HandleExternalProtocol(
   net_service::ProxyURLLoaderFactory::CreateProxy(
       web_contents_getter, std::move(receiver), std::move(request_handler));
   return true;
+#else
+  LOG(INFO) << "AlloyContentBrowserClient::HandleExternalProtocol UNIMPLEMENT "
+               "for OS_OHOS";
+  return false;
+#endif
 }
 
 std::unique_ptr<content::OverlayWindow>
@@ -1285,7 +1311,11 @@ AlloyContentBrowserClient::CreateWindowForPictureInPicture(
   // dependency constraints that disallow directly calling
   // chrome/browser/ui/views code either from here or from other code in
   // chrome/browser.
+#if !defined(OS_OHOS)
   return content::OverlayWindow::Create(controller);
+#else
+  return nullptr;
+#endif
 }
 
 void AlloyContentBrowserClient::RegisterBrowserInterfaceBindersForFrame(
@@ -1395,6 +1425,23 @@ bool AlloyContentBrowserClient::ShouldAllowPluginCreation(
   return true;
 }
 
+#if defined(OS_OHOS)
+bool AlloyContentBrowserClient::ShouldTryToUseExistingProcessHost(
+    content::BrowserContext* browser_context,
+    const GURL& url) {
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (!command_line)
+    return false;
+  return command_line->HasSwitch(switches::kEnableMultiRendererProcess) ? false
+                                                                        : true;
+}
+
+bool AlloyContentBrowserClient::ShouldDisableSiteIsolation() {
+  return true;
+}
+#endif
+
 CefRefPtr<CefRequestContextImpl> AlloyContentBrowserClient::request_context()
     const {
   return browser_main_parts_->request_context();
diff --git a/cef/libcef/browser/alloy/alloy_content_browser_client.h b/cef/libcef/browser/alloy/alloy_content_browser_client.h
index 9b4a842b08..35b45c4f89 100644
--- a/cef/libcef/browser/alloy/alloy_content_browser_client.h
+++ b/cef/libcef/browser/alloy/alloy_content_browser_client.h
@@ -133,8 +133,10 @@ class AlloyContentBrowserClient : public content::ContentBrowserClient {
       service_manager::BinderRegistry* registry,
       blink::AssociatedInterfaceRegistry* associated_registry,
       content::RenderProcessHost* render_process_host) override;
+#if !defined(OS_OHOS)
   std::unique_ptr<net::ClientCertStore> CreateClientCertStore(
       content::BrowserContext* browser_context) override;
+#endif
   std::unique_ptr<content::LoginDelegate> CreateLoginDelegate(
       const net::AuthChallengeInfo& auth_info,
       content::WebContents* web_contents,
@@ -216,6 +218,13 @@ class AlloyContentBrowserClient : public content::ContentBrowserClient {
       const url::Origin& embedder_origin,
       const content::PepperPluginInfo& plugin_info) override;
 
+#if defined(OS_OHOS)
+  bool ShouldTryToUseExistingProcessHost(
+      content::BrowserContext* browser_context,
+      const GURL& url) override;
+  bool ShouldDisableSiteIsolation() override;
+#endif
+
   CefRefPtr<CefRequestContextImpl> request_context() const;
   CefDevToolsDelegate* devtools_delegate() const;
 
diff --git a/cef/libcef/browser/alloy/chrome_browser_process_alloy.cc b/cef/libcef/browser/alloy/chrome_browser_process_alloy.cc
index d0630ee159..eb37471ece 100644
--- a/cef/libcef/browser/alloy/chrome_browser_process_alloy.cc
+++ b/cef/libcef/browser/alloy/chrome_browser_process_alloy.cc
@@ -303,10 +303,12 @@ StatusTray* ChromeBrowserProcessAlloy::status_tray() {
   return nullptr;
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 safe_browsing::SafeBrowsingService*
 ChromeBrowserProcessAlloy::safe_browsing_service() {
   return nullptr;
 }
+#endif
 
 subresource_filter::RulesetService*
 ChromeBrowserProcessAlloy::subresource_filter_ruleset_service() {
diff --git a/cef/libcef/browser/alloy/chrome_browser_process_alloy.h b/cef/libcef/browser/alloy/chrome_browser_process_alloy.h
index 01460594b7..6e9e2d03f8 100644
--- a/cef/libcef/browser/alloy/chrome_browser_process_alloy.h
+++ b/cef/libcef/browser/alloy/chrome_browser_process_alloy.h
@@ -78,7 +78,9 @@ class ChromeBrowserProcessAlloy : public BrowserProcess {
       std::unique_ptr<BackgroundModeManager> manager) override;
 #endif
   StatusTray* status_tray() override;
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingService* safe_browsing_service() override;
+#endif
   subresource_filter::RulesetService* subresource_filter_ruleset_service()
       override;
   federated_learning::FlocSortingLshClustersService*
diff --git a/cef/libcef/browser/browser_host_base.h b/cef/libcef/browser/browser_host_base.h
index 48331e81e3..d30f0b43d0 100644
--- a/cef/libcef/browser/browser_host_base.h
+++ b/cef/libcef/browser/browser_host_base.h
@@ -39,7 +39,7 @@ struct CefBrowserCreateParams {
     settings = that.settings;
     request_context = that.request_context;
     extra_info = that.extra_info;
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
     browser_view = that.browser_view;
 #endif
     return *this;
@@ -49,7 +49,7 @@ struct CefBrowserCreateParams {
   // views-hosted browser. Currently used with the alloy runtime only.
   std::unique_ptr<CefWindowInfo> window_info;
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
   // The BrowserView that will own a Views-hosted browser. Will be nullptr for
   // popup browsers.
   CefRefPtr<CefBrowserView> browser_view;
@@ -262,7 +262,7 @@ class CefBrowserHostBase : public CefBrowserHost,
     return contents_delegate_.get();
   }
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
   // Returns the Widget owner for the browser window. Only used with windowed
   // rendering.
   views::Widget* GetWindowWidget() const;
diff --git a/cef/libcef/browser/browser_info_manager.cc b/cef/libcef/browser/browser_info_manager.cc
index 4193972c9c..6482a7cee7 100644
--- a/cef/libcef/browser/browser_info_manager.cc
+++ b/cef/libcef/browser/browser_info_manager.cc
@@ -182,7 +182,9 @@ bool CefBrowserInfoManager::CanCreateWindow(
     CefBrowserCreateParams create_params;
 
     if (browser->HasView()) {
+#if defined(TOOLKIT_VIEWS)
       create_params.popup_with_views_hosted_opener = true;
+#endif
     } else {
       create_params.window_info = std::move(window_info);
     }
diff --git a/cef/libcef/browser/browser_platform_delegate.cc b/cef/libcef/browser/browser_platform_delegate.cc
index 31f3a811a1..646614c126 100644
--- a/cef/libcef/browser/browser_platform_delegate.cc
+++ b/cef/libcef/browser/browser_platform_delegate.cc
@@ -112,7 +112,7 @@ CefWindowHandle CefBrowserPlatformDelegate::GetHostWindowHandle() const {
   return kNullWindowHandle;
 }
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 views::Widget* CefBrowserPlatformDelegate::GetWindowWidget() const {
   NOTREACHED();
   return nullptr;
diff --git a/cef/libcef/browser/browser_platform_delegate.h b/cef/libcef/browser/browser_platform_delegate.h
index 501a778f68..938f40840e 100644
--- a/cef/libcef/browser/browser_platform_delegate.h
+++ b/cef/libcef/browser/browser_platform_delegate.h
@@ -57,7 +57,7 @@ class Size;
 class Vector2d;
 }  // namespace gfx
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 namespace views {
 class Widget;
 }
@@ -168,7 +168,7 @@ class CefBrowserPlatformDelegate {
   // the client, which may be NULL. May be called on multiple threads.
   virtual CefWindowHandle GetHostWindowHandle() const;
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
   // Returns the Widget owner for the browser window. Only used with windowed
   // rendering.
   virtual views::Widget* GetWindowWidget() const;
diff --git a/cef/libcef/browser/browser_platform_delegate_create.cc b/cef/libcef/browser/browser_platform_delegate_create.cc
index e8da240f0b..2409bf5767 100644
--- a/cef/libcef/browser/browser_platform_delegate_create.cc
+++ b/cef/libcef/browser/browser_platform_delegate_create.cc
@@ -22,7 +22,7 @@
 #elif defined(OS_MAC)
 #include "libcef/browser/native/browser_platform_delegate_native_mac.h"
 #include "libcef/browser/osr/browser_platform_delegate_osr_mac.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_OHOS)
 #include "libcef/browser/native/browser_platform_delegate_native_linux.h"
 #include "libcef/browser/osr/browser_platform_delegate_osr_linux.h"
 #else
@@ -45,7 +45,7 @@ std::unique_ptr<CefBrowserPlatformDelegateNative> CreateNativeDelegate(
 #elif defined(OS_MAC)
   return std::make_unique<CefBrowserPlatformDelegateNativeMac>(
       window_info, background_color);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_OHOS)
   return std::make_unique<CefBrowserPlatformDelegateNativeLinux>(
       window_info, background_color);
 #endif
@@ -61,7 +61,7 @@ std::unique_ptr<CefBrowserPlatformDelegateOsr> CreateOSRDelegate(
 #elif defined(OS_MAC)
   return std::make_unique<CefBrowserPlatformDelegateOsrMac>(
       std::move(native_delegate));
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_OHOS)
   return std::make_unique<CefBrowserPlatformDelegateOsrLinux>(
       std::move(native_delegate), use_external_begin_frame);
 #endif
diff --git a/cef/libcef/browser/extensions/extension_system.cc b/cef/libcef/browser/extensions/extension_system.cc
index 22da03fea5..fddfc70a9a 100644
--- a/cef/libcef/browser/extensions/extension_system.cc
+++ b/cef/libcef/browser/extensions/extension_system.cc
@@ -126,6 +126,7 @@ void LoadExtensionWithManifest(base::WeakPtr<CefExtensionSystem> context,
                           internal, loader_context, handler);
 }
 
+#if !defined(OS_OHOS)
 void LoadExtensionFromDisk(base::WeakPtr<CefExtensionSystem> context,
                            const base::FilePath& root_directory,
                            bool internal,
@@ -145,6 +146,7 @@ void LoadExtensionFromDisk(base::WeakPtr<CefExtensionSystem> context,
   LoadExtensionWithManifest(context, manifest_contents, root_directory,
                             internal, loader_context, handler);
 }
+#endif
 
 }  // namespace
 
@@ -265,10 +267,14 @@ void CefExtensionSystem::LoadExtension(
     bool internal,
     CefRefPtr<CefRequestContext> loader_context,
     CefRefPtr<CefExtensionHandler> handler) {
+#if !defined(OS_OHOS)
   CEF_REQUIRE_UIT();
   CEF_POST_USER_VISIBLE_TASK(
       base::BindOnce(LoadExtensionFromDisk, weak_ptr_factory_.GetWeakPtr(),
                      root_directory, internal, loader_context, handler));
+#else
+  LOG(INFO) << "CefExtensionSystem::LoadExtension UNIMPLEMENT for OS_OHOS";
+#endif
 }
 
 void CefExtensionSystem::LoadExtension(
diff --git a/cef/libcef/browser/views/window_impl.cc b/cef/libcef/browser/views/window_impl.cc
index eeb1fcced7..a90011f029 100644
--- a/cef/libcef/browser/views/window_impl.cc
+++ b/cef/libcef/browser/views/window_impl.cc
@@ -38,6 +38,7 @@ void InitializeUITesting() {
   if (!initialized) {
     ui_controls::EnableUIControls();
 
+#if !defined(OS_OHOS)
 #if defined(USE_AURA)
 #if defined(OS_LINUX) && defined(USE_X11)
     ui_controls::InstallUIControlsAura(
@@ -46,6 +47,7 @@ void InitializeUITesting() {
     ui_controls::InstallUIControlsAura(
         aura::test::CreateUIControlsAura(nullptr));
 #endif
+#endif
 #endif
 
     initialized = true;
diff --git a/cef/libcef/common/alloy/alloy_main_delegate.cc b/cef/libcef/common/alloy/alloy_main_delegate.cc
index ba5b08cd78..ccbd621288 100644
--- a/cef/libcef/common/alloy/alloy_main_delegate.cc
+++ b/cef/libcef/common/alloy/alloy_main_delegate.cc
@@ -211,6 +211,11 @@ bool AlloyMainDelegate::BasicStartupComplete(int* exit_code) {
                                       CefString(&settings_->javascript_flags));
     }
 
+    if (settings_->user_data_path.length > 0) {
+      command_line->AppendSwitchPath(switches::kUserDataDir,
+                                     CefString(&settings_->user_data_path));
+    }
+
     if (settings_->pack_loading_disabled) {
       command_line->AppendSwitch(switches::kDisablePackLoading);
     } else {
@@ -521,7 +526,22 @@ void AlloyMainDelegate::InitializeResourceBundle() {
       base::PathService::Override(ui::DIR_LOCALES, locales_dir);
   }
 
+#if defined(OS_OHOS)
+  base::FilePath userdata_dir;
+  if (command_line->HasSwitch(switches::kUserDataDir)) {
+    userdata_dir = command_line->GetSwitchValuePath(switches::kUserDataDir);
+  }
+  if (!userdata_dir.empty()) {
+    base::PathService::Override(base::DIR_OHOS_APP_DATA, userdata_dir);
+    base::PathService::Override(base::DIR_CACHE, userdata_dir.Append("cache"));
+  }
+#endif
+
+#if !defined(OS_OHOS)
   std::string locale = command_line->GetSwitchValueASCII(switches::kLang);
+#else
+  std::string locale = "zh-CN";
+#endif
   DCHECK(!locale.empty());
 
   const std::string loaded_locale =
diff --git a/cef/libcef/common/extensions/extensions_util.cc b/cef/libcef/common/extensions/extensions_util.cc
index 4780f5bbfc..7da19e691d 100644
--- a/cef/libcef/common/extensions/extensions_util.cc
+++ b/cef/libcef/common/extensions/extensions_util.cc
@@ -18,10 +18,14 @@ bool ExtensionsEnabled() {
 }
 
 bool PdfExtensionEnabled() {
+#if !defined(OS_OHOS)
   static bool enabled =
       ExtensionsEnabled() && !base::CommandLine::ForCurrentProcess()->HasSwitch(
                                  switches::kDisablePdfExtension);
   return enabled;
+#else
+  return false;
+#endif
 }
 
 bool PrintPreviewEnabled() {
diff --git a/cef/libcef/common/resource_util.cc b/cef/libcef/common/resource_util.cc
index 7e8e49f38d..cd608ab345 100644
--- a/cef/libcef/common/resource_util.cc
+++ b/cef/libcef/common/resource_util.cc
@@ -15,6 +15,7 @@
 #include "base/files/file_util.h"
 #include "base/notreached.h"
 #include "base/path_service.h"
+#include "base/logging.h"
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths.h"
 #include "chrome/common/chrome_paths_internal.h"
@@ -26,7 +27,7 @@
 #include "libcef/common/util_mac.h"
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_OHOS)
 #include "base/environment.h"
 #include "base/nix/xdg_util.h"
 #endif
@@ -77,6 +78,16 @@ bool GetDefaultUserDataDirectory(base::FilePath* result) {
   return true;
 }
 
+#elif defined(OS_OHOS)
+
+bool GetDefaultUserDataDirectory(base::FilePath* result) {
+  if (!base::PathService::Get(base::DIR_OHOS_APP_DATA, result))
+    return false;
+  *result = result->Append(FILE_PATH_LITERAL("cef"));
+  *result = result->Append(FILE_PATH_LITERAL("cef_user_data"));
+  return true;
+}
+
 #endif
 
 base::FilePath GetUserDataPath(CefSettings* settings,
@@ -118,6 +129,7 @@ base::FilePath GetUserDataPath(CefSettings* settings,
 // to the desktop on any platform.
 // From chrome/browser/download/download_prefs.cc.
 bool DownloadPathIsDangerous(const base::FilePath& download_path) {
+#if !defined(OS_OHOS)
 #if defined(OS_LINUX)
   base::FilePath home_dir = base::GetHomeDir();
   if (download_path == home_dir) {
@@ -131,6 +143,10 @@ bool DownloadPathIsDangerous(const base::FilePath& download_path) {
     return false;
   }
   return (download_path == desktop_dir);
+#else
+  // chrome/browser/download/download_prefs.cc: DownloadPathIsDangerous, have no destop dir
+  return false;
+#endif
 }
 
 bool GetDefaultDownloadDirectory(base::FilePath* result) {
@@ -184,7 +200,11 @@ base::FilePath GetResourcesDir() {
 // Use a "debug.log" file in the running executable's directory.
 base::FilePath GetDefaultLogFilePath() {
   base::FilePath log_path;
+#if defined(OS_OHOS)
+  base::PathService::Get(base::DIR_OHOS_APP_DATA, &log_path);
+#else
   base::PathService::Get(base::DIR_EXE, &log_path);
+#endif
   return log_path.Append(FILE_PATH_LITERAL("debug.log"));
 }
 
@@ -207,6 +227,11 @@ void OverrideUserDataDir(CefSettings* settings,
                          const base::CommandLine* command_line) {
   const base::FilePath& user_data_path =
       GetUserDataPath(settings, command_line);
+
+#if defined(OS_OHOS)
+  base::PathService::Override(base::DIR_CACHE, user_data_path.Append("cache"));
+  base::PathService::Override(base::DIR_OHOS_APP_DATA, user_data_path);
+#else
   base::PathService::Override(chrome::DIR_USER_DATA, user_data_path);
 
   // Path used for crash dumps.
@@ -217,6 +242,8 @@ void OverrideUserDataDir(CefSettings* settings,
       chrome::DIR_APP_DICTIONARIES, user_data_path.AppendASCII("Dictionaries"),
       false,  // May not be an absolute path.
       true);  // Create if necessary.
+
+#endif
 }
 
 // Same as ui::ResourceBundle::IsScaleFactorSupported.
diff --git a/cef/libcef_dll/base/cef_logging.cc b/cef/libcef_dll/base/cef_logging.cc
index 35602911bf..1b4833fa68 100644
--- a/cef/libcef_dll/base/cef_logging.cc
+++ b/cef/libcef_dll/base/cef_logging.cc
@@ -67,6 +67,7 @@ wrap_posix_strerror_r(char* (*strerror_r_ptr)(int, char*, size_t),
 // guarantee that they are handled. This is compiled on all POSIX platforms, but
 // it will only be used on Linux if the POSIX strerror_r implementation is
 // being used (see below).
+#ifndef COMPILE_WITH_OHOS
 static void POSSIBLY_UNUSED wrap_posix_strerror_r(int (*strerror_r_ptr)(int,
                                                                         char*,
                                                                         size_t),
@@ -109,6 +110,7 @@ static void POSSIBLY_UNUSED wrap_posix_strerror_r(int (*strerror_r_ptr)(int,
   }
   errno = old_errno;
 }
+#endif
 
 void safe_strerror_r(int err, char* buf, size_t len) {
   if (buf == NULL || len <= 0) {
@@ -118,7 +120,9 @@ void safe_strerror_r(int err, char* buf, size_t len) {
   // appropriate overloaded function based on the function type of strerror_r.
   // The other one will be elided from the translation unit since both are
   // static.
+#ifndef COMPILE_WITH_OHOS
   wrap_posix_strerror_r(&strerror_r, err, buf, len);
+#endif
 }
 
 std::string safe_strerror(int err) {
diff --git a/cef/tools/cef_api_hash.py b/cef/tools/cef_api_hash.py
index 6dbecf5dbc..229f219bf3 100644
--- a/cef/tools/cef_api_hash.py
+++ b/cef/tools/cef_api_hash.py
@@ -35,7 +35,7 @@ class cef_api_hash:
     self.__debug_enabled = not (self.__debugdir is
                                 None) and len(self.__debugdir) > 0
 
-    self.platforms = ["windows", "mac", "linux"]
+    self.platforms = ["windows", "mac", "linux", "ohos"]
 
     self.platform_files = {
         # List of includes_win_capi from cef_paths2.gypi.
@@ -49,6 +49,9 @@ class cef_api_hash:
         # List of includes_linux_capi from cef_paths2.gypi.
         "linux": [
             "internal/cef_types_linux.h",
+        ],
+        "ohos": [
+            "internal/cef_types_linux.h",
         ]
     }
 
diff --git a/cef/tools/make_api_hash_header.py b/cef/tools/make_api_hash_header.py
index 6c79efcdba..8901749c7d 100644
--- a/cef/tools/make_api_hash_header.py
+++ b/cef/tools/make_api_hash_header.py
@@ -39,6 +39,8 @@ def make_api_hash_header(cpp_header_dir):
 #define CEF_API_HASH_PLATFORM "$MAC$"
 #elif defined(OS_LINUX)
 #define CEF_API_HASH_PLATFORM "$LINUX$"
+#elif defined(OS_OHOS)
+#define CEF_API_HASH_PLATFORM "$OHOS$"
 #endif
 
 #ifdef __cplusplus
diff --git a/chrome/BUILD.gn b/chrome/BUILD.gn
index f80853980d..210e5654c9 100644
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -1611,13 +1611,21 @@ if (is_android) {
       "//components/gwp_asan/buildflags",
       "//components/heap_profiling/in_process",
       "//components/minidump_uploader",
-      "//components/safe_browsing:buildflags",
-      "//components/safe_browsing/android:safe_browsing_api_handler",
-      "//components/safe_browsing/android:safe_browsing_mobile",
+      # "//components/safe_browsing:buildflags",
+      # "//components/safe_browsing/android:safe_browsing_api_handler",
+      # "//components/safe_browsing/android:safe_browsing_mobile",
       "//components/services/heap_profiling",
       "//content/public/app",
     ]
 
+    if (safe_browsing_mode != 0) {
+      deps += [
+        "//components/safe_browsing:buildflags",
+        "//components/safe_browsing/android:safe_browsing_api_handler",
+        "//components/safe_browsing/android:safe_browsing_mobile",
+      ]
+    }
+
     # Explicit dependency required for JNI registration to be able to
     # find the native side functions.
     if (is_android && is_component_build) {
diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index 0673d955b5..2215e0f08f 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -156,7 +156,7 @@
 #endif
 
 #if defined(OS_MAC) || defined(OS_WIN) || defined(OS_ANDROID) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "chrome/browser/policy/policy_path_parser.h"
 #include "components/crash/core/app/crashpad.h"
 #endif
@@ -353,7 +353,7 @@ void HandleHelpSwitches(const base::CommandLine& command_line) {
 }
 #endif  // defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
 
-#if !defined(OS_MAC) && !defined(OS_ANDROID)
+#if !defined(OS_MAC) && !defined(OS_ANDROID) && !defined(OS_OHOS)
 void SIGTERMProfilingShutdown(int signal) {
   content::Profiling::Stop();
   struct sigaction sigact;
@@ -1105,8 +1105,10 @@ void ChromeMainDelegate::PreSandboxStartup() {
 #else  // !defined(OS_ANDROID)
     if (crash_reporter::IsCrashpadEnabled()) {
       crash_reporter::InitializeCrashpad(process_type.empty(), process_type);
+#if !defined(__MUSL__)
       crash_reporter::SetFirstChanceExceptionHandler(
           v8::TryHandleWebAssemblyTrapPosix);
+#endif
     } else {
       breakpad::InitCrashReporter(process_type);
     }
diff --git a/chrome/app/chromium_strings.grd b/chrome/app/chromium_strings.grd
index b0a9f00730..d7a65ff5c5 100644
--- a/chrome/app/chromium_strings.grd
+++ b/chrome/app/chromium_strings.grd
@@ -681,7 +681,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="toolkit_views or is_ohos">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chromium data to this account?
         </message>
diff --git a/chrome/app/generated_resources.grd b/chrome/app/generated_resources.grd
index d3c77c82a8..1ef5193794 100644
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -383,7 +383,7 @@ are declared in tools/grit/grit_rule.gni.
           Permission requested, press  + Option + Down arrow to respond
         </message>
       </if>
-      <if expr="is_win or desktop_linux">
+      <if expr="is_win or desktop_linux or is_ohos">
         <message name="IDS_PERMISSIONS_REQUESTED_SCREENREADER_ANNOUNCEMENT" desc="Announcement to screen readers on Windows or Linux when permission is requested to inform users of how to focus the permission UI.">
           Permission requested, press F6 to respond
         </message>
@@ -2832,7 +2832,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Win certificate selector dialog strings.  -->
-      <if expr="toolkit_views">
+      <if expr="toolkit_views or is_ohos">
         <message name="IDS_CERT_SELECTOR_SUBJECT_COLUMN" desc="The text of the header for the certificate subject column in the certificate selector dialog.">
           Subject
         </message>
@@ -7572,7 +7572,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- Accessiblility strings for Infobars in Views -->
-      <if expr="toolkit_views">
+      <if expr="toolkit_views or is_ohos">
         <message name="IDS_ACCNAME_INFOBAR_CONTAINER" desc="The accessible name for the infobar container.">
           Infobar Container
         </message>
@@ -8566,7 +8566,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </if>
 
       <!-- Translate Bubble -->
-      <if expr="toolkit_views">
+      <if expr="toolkit_views or is_ohos">
         <message name="IDS_TRANSLATE_BUBBLE_BEFORE_TRANSLATE_TITLE" desc="Title text for the translate bubble when asking to translate a page.">
           Translate this page?
         </message>
@@ -9646,7 +9646,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
         Live Caption visible, press  + Option + Up arrow or Down arrow to cycle focus
       </message>
     </if>
-    <if expr="is_win or desktop_linux">
+    <if expr="is_win or desktop_linux or is_ohos">
       <message name="IDS_LIVE_CAPTION_BUBBLE_APPEAR_SCREENREADER_ANNOUNCEMENT" desc="Announcement to screen readers on Windows or Linux when the Live Caption bubble appears to inform users of how to focus the bubble.">
         Live Caption visible, press F6 to cycle focus
       </message>
@@ -9834,7 +9834,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       <message name="IDS_DESKTOP_MEDIA_PRESENTER_TOOLS" desc="Text for the checkbox on window picker dialog, when checked the presenter tools will be shown.">
         Presenter Tools
       </message>
-      <if expr="toolkit_views">
+      <if expr="toolkit_views or is_ohos">
         <message name="IDS_DESKTOP_MEDIA_PICKER_SOURCE_TYPE_THIS_TAB" desc="Text for one of the dialog-tabs on the media picker dialog. This dialog-tab controls sharing the current tab.">
           This Tab
         </message>
@@ -9984,7 +9984,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
           <ph name="WINDOW_TITLE">$1<ex>Google Search</ex></ph> - Permission requested, press  + Option + Up arrow to respond
         </message>
       </if>
-      <if expr="is_win or desktop_linux">
+      <if expr="is_win or desktop_linux or is_ohos">
         <message name="IDS_TAB_AX_LABEL_PERMISSION_REQUESTED_FORMAT" desc="Accessibility label text for Windows or Linux, when a tab has a pending request. Example: 'Google Search - Permission requested, press F6 to respond'.">
           <ph name="WINDOW_TITLE">$1<ex>Google Search</ex></ph> - Permission requested, press F6 to respond
         </message>
@@ -10652,7 +10652,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Web-modal dialog shown during Web Authenticaton API requests. -->
-    <if expr="is_win or is_macosx or desktop_linux or chromeos">
+    <if expr="is_win or is_macosx or desktop_linux or chromeos or is_ohos">
       <message name="IDS_WEBAUTHN_GENERIC_TITLE" desc="Title of most dialogs shown while the user is authenticating on a web site using a security key.">
         Use your security key with <ph name="APP_NAME">$1<ex>google.com</ex></ph>
       </message>
diff --git a/chrome/app/google_chrome_strings.grd b/chrome/app/google_chrome_strings.grd
index 6e262a2562..ab8064c7d0 100644
--- a/chrome/app/google_chrome_strings.grd
+++ b/chrome/app/google_chrome_strings.grd
@@ -689,7 +689,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="toolkit_views or is_ohos">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chrome data to this account?
         </message>
diff --git a/chrome/app/settings_strings.grdp b/chrome/app/settings_strings.grdp
index 70fa4da663..cf925eb113 100644
--- a/chrome/app/settings_strings.grdp
+++ b/chrome/app/settings_strings.grdp
@@ -142,6 +142,11 @@
       Reset to default
     </message>
   </if>
+  <if expr="is_ohos">
+    <message name="IDS_SETTINGS_RESET_TO_DEFAULT_THEME" desc="Name of the control which resets the browser theme back to the default theme.">
+      Reset to default
+    </message>
+  </if>
   <message name="IDS_SETTINGS_CHROME_COLORS" desc="Text of the label describing 'Chrome Colors' theme.">
     Chrome Colors
   </message>
diff --git a/chrome/app/theme/theme_resources.grd b/chrome/app/theme/theme_resources.grd
index f26b92c575..ad4fcca0e9 100644
--- a/chrome/app/theme/theme_resources.grd
+++ b/chrome/app/theme/theme_resources.grd
@@ -28,7 +28,7 @@
       <if expr="is_linux or is_win or chromeos">
         <structure type="chrome_scaled_image" name="IDR_ACCESSIBILITY_CAPTIONS_PREVIEW_BACKGROUND" file="common/captions-preview-bg.png" />
       </if>
-      <if expr="toolkit_views and not is_macosx">
+      <if expr="toolkit_views and not is_macosx or is_ohos">
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE" file="common/app_window_close.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_H" file="common/app_window_close_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_P" file="common/app_window_close_active.png" />
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index e2872b0c85..054746e8cb 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -1119,8 +1119,8 @@ static_library("browser") {
     "permissions/contextual_notification_permission_ui_selector.h",
     "permissions/crowd_deny_preload_data.cc",
     "permissions/crowd_deny_preload_data.h",
-    "permissions/crowd_deny_safe_browsing_request.cc",
-    "permissions/crowd_deny_safe_browsing_request.h",
+    # "permissions/crowd_deny_safe_browsing_request.cc",
+    # "permissions/crowd_deny_safe_browsing_request.h",
     "permissions/last_tab_standing_tracker.cc",
     "permissions/last_tab_standing_tracker.h",
     "permissions/last_tab_standing_tracker_factory.cc",
@@ -1844,6 +1844,13 @@ static_library("browser") {
     "window_placement/window_placement_permission_context.h",
   ]
 
+  if (safe_browsing_mode != 0) {
+    sources += [
+      "permissions/crowd_deny_safe_browsing_request.cc",
+      "permissions/crowd_deny_safe_browsing_request.h",
+    ]
+  }
+
   configs += [
     "//build/config/compiler:wexit_time_destructors",
     "//build/config:precompiled_headers",
@@ -1862,15 +1869,24 @@ static_library("browser") {
     "//chrome/browser/profiling_host",
     "//chrome/browser/ui",
     "//chrome/browser/ui/webui/bluetooth_internals",
-    "//chrome/browser/safe_browsing",
-    "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
-    "//chrome/browser/safe_browsing:advanced_protection",
-    "//chrome/browser/safe_browsing:metrics_collector",
+    # "//chrome/browser/safe_browsing",
+    # "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
+    # "//chrome/browser/safe_browsing:advanced_protection",
+    # "//chrome/browser/safe_browsing:metrics_collector",
 
     # TODO(crbug.com/1030821): Eliminate usages of browser.h from Media Router.
     "//chrome/browser/media/router",
   ]
 
+  if (safe_browsing_mode != 0) {
+    allow_circular_includes_from += [
+      "//chrome/browser/safe_browsing",
+      "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
+      "//chrome/browser/safe_browsing:advanced_protection",
+      "//chrome/browser/safe_browsing:metrics_collector",
+    ]
+  }
+
   public_deps = [
     "//base",
     "//chrome/common",
@@ -1946,10 +1962,10 @@ static_library("browser") {
     "//chrome/browser/push_messaging:budget_proto",
     "//chrome/browser/resource_coordinator:mojo_bindings",
     "//chrome/browser/resource_coordinator:tab_manager_features",
-    "//chrome/browser/safe_browsing",
-    "//chrome/browser/safe_browsing:advanced_protection",
-    "//chrome/browser/safe_browsing:metrics_collector",
-    "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
+    # "//chrome/browser/safe_browsing",
+    # "//chrome/browser/safe_browsing:advanced_protection",
+    # "//chrome/browser/safe_browsing:metrics_collector",
+    # "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
     "//chrome/browser/search/drive:mojo_bindings",
     "//chrome/browser/search/task_module:mojo_bindings",
     "//chrome/browser/sharing:buildflags",
@@ -2152,19 +2168,19 @@ static_library("browser") {
     "//components/reputation/core",
     "//components/reputation/core:proto",
     "//components/resources",
-    "//components/safe_browsing/content/browser",
-    "//components/safe_browsing/content/password_protection",
-    "//components/safe_browsing/core:download_file_types_proto",
-    "//components/safe_browsing/core:features",
+    # "//components/safe_browsing/content/browser",
+    # "//components/safe_browsing/content/password_protection",
+    # "//components/safe_browsing/core:download_file_types_proto",
+    # "//components/safe_browsing/core:features",
     "//components/safe_browsing/core:file_type_policies",
-    "//components/safe_browsing/core:public",
-    "//components/safe_browsing/core/browser",
-    "//components/safe_browsing/core/browser/sync",
-    "//components/safe_browsing/core/common",
-    "//components/safe_browsing/core/common:safe_browsing_policy_handler",
-    "//components/safe_browsing/core/db:database_manager",
-    "//components/safe_browsing/core/realtime:policy_engine",
-    "//components/safe_browsing/core/realtime:url_lookup_service",
+    # "//components/safe_browsing/core:public",
+    # "//components/safe_browsing/core/browser",
+    # "//components/safe_browsing/core/browser/sync",
+    # "//components/safe_browsing/core/common",
+    # "//components/safe_browsing/core/common:safe_browsing_policy_handler",
+    # "//components/safe_browsing/core/db:database_manager",
+    # "//components/safe_browsing/core/realtime:policy_engine",
+    # "//components/safe_browsing/core/realtime:url_lookup_service",
     "//components/safe_search_api",
     "//components/safe_search_api:safe_search_client",
     "//components/schema_org/common:improved_mojom",
@@ -2357,6 +2373,29 @@ static_library("browser") {
     "//ui/webui",
     "//ui/webui/resources/cr_components/customize_themes:mojom",
   ]
+
+  if (safe_browsing_mode != 0) {
+    deps += [
+      "//chrome/browser/safe_browsing",
+      "//chrome/browser/safe_browsing:advanced_protection",
+      "//chrome/browser/safe_browsing:metrics_collector",
+      "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
+      "//components/safe_browsing/content/browser",
+      "//components/safe_browsing/content/password_protection",
+      "//components/safe_browsing/core:download_file_types_proto",
+      "//components/safe_browsing/core:features",
+      #"//components/safe_browsing/core:file_type_policies",
+      "//components/safe_browsing/core:public",
+      "//components/safe_browsing/core/browser",
+      "//components/safe_browsing/core/browser/sync",
+      "//components/safe_browsing/core/common",
+      "//components/safe_browsing/core/common:safe_browsing_policy_handler",
+      "//components/safe_browsing/core/db:database_manager",
+      "//components/safe_browsing/core/realtime:policy_engine",
+      "//components/safe_browsing/core/realtime:url_lookup_service",
+    ]
+  }
+
   if (is_chromeos_ash) {
     sources += [
       "apps/digital_goods/digital_goods_factory_impl.cc",
@@ -3138,12 +3177,12 @@ static_library("browser") {
       "reputation/safety_tip_infobar.h",
       "reputation/safety_tip_infobar_delegate.cc",
       "reputation/safety_tip_infobar_delegate.h",
-      "safe_browsing/android/password_reuse_controller_android.cc",
-      "safe_browsing/android/password_reuse_controller_android.h",
-      "safe_browsing/android/safe_browsing_referring_app_bridge_android.cc",
-      "safe_browsing/android/safe_browsing_referring_app_bridge_android.h",
-      "safe_browsing/android/safe_browsing_settings_launcher_android.cc",
-      "safe_browsing/android/safe_browsing_settings_launcher_android.h",
+      # "safe_browsing/android/password_reuse_controller_android.cc",
+      # "safe_browsing/android/password_reuse_controller_android.h",
+      # "safe_browsing/android/safe_browsing_referring_app_bridge_android.cc",
+      # "safe_browsing/android/safe_browsing_referring_app_bridge_android.h",
+      # "safe_browsing/android/safe_browsing_settings_launcher_android.cc",
+      # "safe_browsing/android/safe_browsing_settings_launcher_android.h",
       "search/contextual_search_policy_handler_android.cc",
       "search/contextual_search_policy_handler_android.h",
       "search_engines/template_url_service_factory_android.cc",
@@ -3195,6 +3234,18 @@ static_library("browser") {
       "video_tutorials/internal/android/video_tutorial_service_bridge_factory.cc",
       "webauthn/android/cable_module_android.cc",
     ]
+
+    if (safe_browsing_mode != 0) {
+      sources += [
+        "safe_browsing/android/password_reuse_controller_android.cc",
+        "safe_browsing/android/password_reuse_controller_android.h",
+        "safe_browsing/android/safe_browsing_referring_app_bridge_android.cc",
+        "safe_browsing/android/safe_browsing_referring_app_bridge_android.h",
+        "safe_browsing/android/safe_browsing_settings_launcher_android.cc",
+        "safe_browsing/android/safe_browsing_settings_launcher_android.h",
+      ]
+    }
+
     public_deps += [
       "//chrome/android/features/dev_ui:buildflags",
       "//components/image_fetcher/core",
@@ -3302,7 +3353,7 @@ static_library("browser") {
       "//components/reading_list/features:flags",
       "//components/resources:android_resources",
       "//components/resources:components_resources",
-      "//components/safe_browsing/core/password_protection:password_protection_metrics_util",
+      # "//components/safe_browsing/core/password_protection:password_protection_metrics_util",
       "//components/security_state/content/android",
       "//components/send_tab_to_self",
       "//components/signin/internal/identity_manager",  # cf android / signin /
@@ -3334,6 +3385,13 @@ static_library("browser") {
       "//url:gurl_android",
       "//url:origin_android",
     ]
+
+    if (safe_browsing_mode != 0) {
+      deps += [
+        "//components/safe_browsing/core/password_protection:password_protection_metrics_util"
+      ]
+    }
+
     allow_circular_includes_from += [
       # chrome/browser depends on webapps, but that module needs
       # app_banner_manager_android.h from chrome. However, the .h file will soon
@@ -3869,8 +3927,8 @@ static_library("browser") {
       "resource_coordinator/tab_metrics_logger.h",
       "resource_coordinator/usage_clock.cc",
       "resource_coordinator/usage_clock.h",
-      "safe_browsing/generated_safe_browsing_pref.cc",
-      "safe_browsing/generated_safe_browsing_pref.h",
+      # "safe_browsing/generated_safe_browsing_pref.cc",
+      # "safe_browsing/generated_safe_browsing_pref.h",
       "search/background/ntp_background_data.cc",
       "search/background/ntp_background_data.h",
       "search/background/ntp_background_service.cc",
@@ -4158,6 +4216,14 @@ static_library("browser") {
       "webauthn/observable_authenticator_list.cc",
       "webauthn/observable_authenticator_list.h",
     ]
+
+    if (safe_browsing_mode != 0) {
+      deps += [
+        "safe_browsing/generated_safe_browsing_pref.cc",
+        "safe_browsing/generated_safe_browsing_pref.h",
+      ]
+    }
+
     deps += [
       ":cart_db_content_proto",
       ":theme_properties",
@@ -4855,8 +4921,8 @@ static_library("browser") {
       ":chrome_process_finder",
       "//base/win:base_win_buildflags",
       "//chrome/app/theme:chrome_unscaled_resources_grit",
-      "//chrome/browser/safe_browsing/chrome_cleaner",
-      "//chrome/browser/safe_browsing/chrome_cleaner:public",
+      # "//chrome/browser/safe_browsing/chrome_cleaner",
+      # "//chrome/browser/safe_browsing/chrome_cleaner:public",
       "//chrome/browser/web_applications/chrome_pwa_launcher:util",
       "//chrome/browser/win/conflicts:module_info",
       "//chrome/chrome_elf:constants",
@@ -4885,8 +4951,16 @@ static_library("browser") {
       "//ui/base:fullscreen_win",
       "//ui/base/cursor",
     ]
-    allow_circular_includes_from +=
+
+    if (safe_browsing_mode != 0) {
+      deps += [
+        "//chrome/browser/safe_browsing/chrome_cleaner",
+        "//chrome/browser/safe_browsing/chrome_cleaner:public"
+      ]
+
+      allow_circular_includes_from +=
         [ "//chrome/browser/safe_browsing/chrome_cleaner" ]
+    }
 
     all_dependent_configs = [ ":browser_win_linker_flags" ]
 
@@ -5100,6 +5174,20 @@ static_library("browser") {
     }
   }
 
+
+  if (is_ohos) {
+    sources += [
+      "chrome_browser_main_linux.cc",
+      "chrome_browser_main_linux.h",
+      "enterprise/signals/device_info_fetcher_linux.cc",
+      "enterprise/signals/device_info_fetcher_linux.h",
+      "first_run/first_run_internal_linux.cc",
+      "memory_details_linux.cc",
+      "obsolete_system/obsolete_system_linux.cc",
+      "policy/browser_dm_token_storage_linux.cc",
+      "policy/browser_dm_token_storage_linux.h",
+    ]
+  }
   if (is_linux || is_chromeos) {
     sources += [
       "chrome_browser_main_linux.cc",
@@ -5134,7 +5222,7 @@ static_library("browser") {
     }
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     # Desktop linux, doesn't count ChromeOS.
     sources += [
       "download/download_status_updater_linux.cc",
@@ -5209,7 +5297,7 @@ static_library("browser") {
     sources += [ "hang_monitor/hang_crash_dump.cc" ]
   }
 
-  if (is_win || is_linux || is_chromeos) {
+  if (is_win || is_linux || is_chromeos || is_ohos) {
     sources += [
       "renderer_context_menu/spelling_options_submenu_observer.cc",
       "renderer_context_menu/spelling_options_submenu_observer.h",
@@ -5231,7 +5319,7 @@ static_library("browser") {
     deps += [ "//chrome/browser/webshare:storage" ]
   }
 
-  if (is_win || is_mac || (is_linux || is_chromeos_lacros)) {
+  if (is_win || is_mac || (is_linux || is_chromeos_lacros) || is_ohos) {
     sources += [
       "browser_switcher/alternative_browser_driver.h",
       "browser_switcher/browser_switcher_navigation_throttle.cc",
@@ -5250,7 +5338,7 @@ static_library("browser") {
     if (is_win) {
       sources += [ "browser_switcher/alternative_browser_driver_win.cc" ]
     }
-    if (is_mac || (is_linux || is_chromeos_lacros)) {
+    if (is_mac || (is_linux || is_chromeos_lacros) || is_ohos) {
       sources += [ "browser_switcher/alternative_browser_driver_posix.cc" ]
     }
   }
@@ -5367,7 +5455,7 @@ static_library("browser") {
     ]
   }
 
-  if (is_win || is_mac || is_linux || is_chromeos) {
+  if (is_win || is_mac || is_linux || is_chromeos || is_ohos) {
     sources += [
       "media/cast_mirroring_service_host.cc",
       "media/cast_mirroring_service_host.h",
@@ -5517,10 +5605,10 @@ static_library("browser") {
     if (is_mac) {
       sources += [ "printing/printer_manager_dialog_mac.mm" ]
     }
-    if (is_linux || is_chromeos) {
+    if (is_linux || is_chromeos || is_ohos) {
       sources += [ "printing/printer_manager_dialog_linux.cc" ]
     }
-    if (is_win || is_mac || is_linux || is_chromeos) {
+    if (is_win || is_mac || is_linux || is_chromeos || is_ohos) {
       sources += [
         "printing/print_backend_service.cc",
         "printing/print_backend_service.h",
@@ -6417,7 +6505,7 @@ static_library("browser") {
         "net/nss_service_chromeos_factory.h",
       ]
     }
-    if (is_linux || is_chromeos_lacros) {
+    if (is_linux || is_chromeos_lacros || is_ohos) {
       sources += [ "net/nss_context_linux.cc" ]
     }
   }
@@ -6557,7 +6645,7 @@ grit("resources") {
     if (is_chromeos_ash) {
       inputs = [ "resources/plugin_metadata/plugins_chromeos.json" ]
     }
-    if (is_linux || is_chromeos_lacros) {
+    if (is_linux || is_chromeos_lacros || is_ohos) {
       inputs = [ "resources/plugin_metadata/plugins_linux.json" ]
     }
     if (is_mac) {
@@ -6568,7 +6656,7 @@ grit("resources") {
     }
   }
 
-  if (is_win || is_mac || is_linux || is_chromeos) {
+  if (is_win || is_mac || is_linux || is_chromeos || is_ohos) {
     deps += [
       "//chrome/browser/resources/discards:discards_resources_gen",
       "//chrome/browser/resources/gaia_auth_host:modulize",
@@ -6757,15 +6845,22 @@ static_library("test_support") {
   public_deps = [
     ":browser",
     "//chrome/browser/profiles:profile",
-    "//chrome/browser/safe_browsing:test_support",
+    # "//chrome/browser/safe_browsing:test_support",
     "//chrome/browser/ui:test_support",
   ]
+
+  if (safe_browsing_mode != 0) {
+    public_deps += [
+      "//chrome/browser/safe_browsing:test_support"
+    ]
+  }
+
   deps = [
     "//build:chromeos_buildflags",
     "//chrome/app/theme:theme_resources",
     "//chrome/browser:browser_process",
     "//chrome/common",
-    "//chrome/common/safe_browsing:proto",
+    # "//chrome/common/safe_browsing:proto",
     "//components/consent_auditor:test_support",
     "//components/invalidation/impl",
     "//components/invalidation/impl:test_support",
@@ -6782,7 +6877,7 @@ static_library("test_support") {
     "//components/reporting/util:task_runner_context",
     "//components/reputation/core",
     "//components/reputation/core:proto",
-    "//components/safe_browsing/core:csd_proto",
+    # "//components/safe_browsing/core:csd_proto",
     "//components/search_engines:test_support",
     "//components/security_interstitials/content:security_interstitial_page",
     "//components/services/unzip/content",
@@ -6804,6 +6899,13 @@ static_library("test_support") {
     "//ui/gfx",
   ]
 
+  if (safe_browsing_mode != 0) {
+    deps += [
+      "//chrome/common/safe_browsing:proto",
+      "//components/safe_browsing/core:csd_proto"
+    ]
+  }
+
   if (!is_android && !is_fuchsia) {
     deps += [ "//components/policy/test_support" ]
   }
@@ -6951,7 +7053,7 @@ static_library("test_support") {
     deps += [
       "//components/crx_file",
       "//components/drive:test_support",
-      "//components/safe_browsing/core/db:v4_test_util",
+      # "//components/safe_browsing/core/db:v4_test_util",
       "//components/services/unzip:in_process",
       "//components/storage_monitor:test_support",
       "//extensions:test_support",
@@ -6961,6 +7063,11 @@ static_library("test_support") {
       "//google_apis:test_support",
       "//services/data_decoder/public/cpp:test_support",
     ]
+    if (safe_browsing_mode != 0) {
+      deps += [
+        "//components/safe_browsing/core/db:v4_test_util",
+      ]
+    }
     if (is_chromeos_ash) {
       deps += [ "//chrome/browser/chromeos" ]
     }
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 6821bb60ca..b934165fda 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -6589,7 +6589,7 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableTranslateSubFramesDescription, kOsAll,
      FEATURE_VALUE_TYPE(translate::kTranslateSubFrames)},
 
-#if !defined(OS_ANDROID)
+#if !defined(OS_ANDROID) && !defined(OS_OHOS)
     {"enable-media-feeds", flag_descriptions::kEnableMediaFeedsName,
      flag_descriptions::kEnableMediaFeedsDescription, kOsDesktop,
      FEATURE_VALUE_TYPE(media::kMediaFeeds)},
@@ -6892,7 +6892,7 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kPrivacyAdvisorDescription, kOsDesktop,
      FEATURE_VALUE_TYPE(features::kPrivacyAdvisor)},
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) && !defined(OS_OHOS)
     {"desktop-in-product-help-snooze",
      flag_descriptions::kDesktopInProductHelpSnoozeName,
      flag_descriptions::kDesktopInProductHelpSnoozeDescription, kOsDesktop,
diff --git a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
index 2b63f2831c..213e1889bd 100644
--- a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
@@ -33,7 +33,7 @@ source_set("music_manager_private") {
 
   if (is_chromeos_ash) {
     sources += [ "device_id_chromeos.cc" ]
-  } else if (is_linux || is_chromeos_lacros) {
+  } else if (is_linux || is_chromeos_lacros || is_ohos) {
     sources += [ "device_id_linux.cc" ]
   } else if (is_mac) {
     sources += [ "device_id_mac.cc" ]
diff --git a/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc
index 0cb7a5f1d0..6177058513 100644
--- a/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc
@@ -40,9 +40,11 @@ const char* const kDeviceNames[] = {
 // Fedora 15 uses biosdevname feature where Embedded ethernet uses the
 // "em" prefix and PCI cards use the p[0-9]c[0-9] format based on PCI
 // slot and card information.
+#if !defined(OS_OHOS)
 const char* const kNetDeviceNamePrefixes[] = {
     "eth", "em", "en", "wl", "ww", "p0", "p1", "p2",
     "p3",  "p4", "p5", "p6", "p7", "p8", "p9", "wlan"};
+#endif
 
 // Map from device name to disk uuid
 typedef std::map<base::FilePath, base::FilePath> DiskEntries;
@@ -151,7 +153,7 @@ class MacAddressProcessor {
 std::string GetMacAddress(IsValidMacAddressCallback is_valid_mac_address) {
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
-
+#if !defined(OS_OHOS)
   struct ifaddrs* ifaddrs;
   int rv = getifaddrs(&ifaddrs);
   if (rv < 0) {
@@ -168,6 +170,10 @@ std::string GetMacAddress(IsValidMacAddressCallback is_valid_mac_address) {
   }
   freeifaddrs(ifaddrs);
   return processor.mac_address();
+#else
+  LOG(INFO) << "GetMacAddress TODO for OS_OHOS";
+  return "";
+#endif
 }
 
 void GetRawDeviceIdImpl(IsValidMacAddressCallback is_valid_mac_address,
diff --git a/chrome/browser/browser_process.h b/chrome/browser/browser_process.h
index 96e44ad48e..99af2a8af6 100644
--- a/chrome/browser/browser_process.h
+++ b/chrome/browser/browser_process.h
@@ -22,6 +22,7 @@
 #include "build/chromeos_buildflags.h"
 #include "chrome/common/buildflags.h"
 #include "media/media_buildflags.h"
+#include "components/safe_browsing/buildflags.h"
 
 class BackgroundModeManager;
 class BrowserProcessPlatformPart;
@@ -209,8 +210,10 @@ class BrowserProcess {
   // on this platform (or this is a unit test).
   virtual StatusTray* status_tray() = 0;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Returns the SafeBrowsing service.
   virtual safe_browsing::SafeBrowsingService* safe_browsing_service() = 0;
+#endif
 
   // Returns the service providing versioned storage for rules used by the Safe
   // Browsing subresource filter.
diff --git a/chrome/browser/browser_process_impl.cc b/chrome/browser/browser_process_impl.cc
index 946ccbda58..f7ef428ec8 100644
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -367,8 +367,10 @@ void BrowserProcessImpl::StartTearDown() {
 
   metrics_services_manager_.reset();
   intranet_redirect_detector_.reset();
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (safe_browsing_service_.get())
     safe_browsing_service()->ShutDown();
+#endif
   network_time_tracker_.reset();
 #if BUILDFLAG(ENABLE_PLUGINS)
   plugins_resource_service_.reset();
@@ -968,6 +970,7 @@ StatusTray* BrowserProcessImpl::status_tray() {
   return status_tray_.get();
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 safe_browsing::SafeBrowsingService*
 BrowserProcessImpl::safe_browsing_service() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -975,6 +978,7 @@ BrowserProcessImpl::safe_browsing_service() {
     CreateSafeBrowsingService();
   return safe_browsing_service_.get();
 }
+#endif
 
 subresource_filter::RulesetService*
 BrowserProcessImpl::subresource_filter_ruleset_service() {
@@ -1225,6 +1229,7 @@ void BrowserProcessImpl::CreateBackgroundPrintingManager() {
 #endif
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void BrowserProcessImpl::CreateSafeBrowsingService() {
   DCHECK(!safe_browsing_service_);
   // Set this flag to true so that we don't retry indefinitely to
@@ -1244,6 +1249,7 @@ void BrowserProcessImpl::CreateSafeBrowsingService() {
   if (safe_browsing_service_)
     safe_browsing_service_->Initialize();
 }
+#endif
 
 void BrowserProcessImpl::CreateSubresourceFilterRulesetService() {
   DCHECK(!subresource_filter_ruleset_service_);
diff --git a/chrome/browser/browser_process_impl.h b/chrome/browser/browser_process_impl.h
index 7d60206c83..1fa86f19b3 100644
--- a/chrome/browser/browser_process_impl.h
+++ b/chrome/browser/browser_process_impl.h
@@ -28,6 +28,7 @@
 #include "components/nacl/common/buildflags.h"
 #include "components/prefs/persistent_pref_store.h"
 #include "components/prefs/pref_change_registrar.h"
+#include "components/safe_browsing/buildflags.h"
 #include "extensions/buildflags/buildflags.h"
 #include "media/media_buildflags.h"
 #include "ppapi/buildflags/buildflags.h"
@@ -175,7 +176,9 @@ class BrowserProcessImpl : public BrowserProcess,
       std::unique_ptr<BackgroundModeManager> manager) override;
 #endif
   StatusTray* status_tray() override;
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingService* safe_browsing_service() override;
+#endif
   subresource_filter::RulesetService* subresource_filter_ruleset_service()
       override;
   federated_learning::FlocSortingLshClustersService*
@@ -222,7 +225,9 @@ class BrowserProcessImpl : public BrowserProcess,
   void CreateNotificationUIManager();
   void CreatePrintPreviewDialogController();
   void CreateBackgroundPrintingManager();
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   void CreateSafeBrowsingService();
+#endif
   void CreateSubresourceFilterRulesetService();
   void CreateFlocBlocklistService();
   void CreateFlocSortingLshClustersService();
@@ -322,9 +327,10 @@ class BrowserProcessImpl : public BrowserProcess,
   // itself as a profile attributes storage observer on destruction.
   std::unique_ptr<BackgroundModeManager> background_mode_manager_;
 #endif
-
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   bool created_safe_browsing_service_ = false;
   scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service_;
+#endif
 
   bool created_subresource_filter_ruleset_service_ = false;
   std::unique_ptr<subresource_filter::RulesetService>
diff --git a/chrome/browser/browser_resources.grd b/chrome/browser/browser_resources.grd
index 41702ce803..b8e10ad4a2 100644
--- a/chrome/browser/browser_resources.grd
+++ b/chrome/browser/browser_resources.grd
@@ -8,7 +8,7 @@
   </outputs>
   <release seq="1">
     <structures>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_win or is_macosx or desktop_linux or chromeos or is_ohos">
         <structure name="IDR_SIGNIN_SHARED_CSS_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_shared_css.js" use_base_dir="false" preprocess="true" type="chrome_html" />
         <structure name="IDR_SIGNIN_VARS_CSS_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_vars_css.js" use_base_dir="false" type="chrome_html" />
       </if>
@@ -29,7 +29,7 @@
       </if>
     </structures>
     <includes>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_win or is_macosx or desktop_linux or chromeos or is_ohos">
         <include name="IDR_DISCARDS_DATABASE_TAB_JS" file="${root_gen_dir}\chrome\browser\resources\discards\database_tab.js" use_base_dir="false" type="BINDATA" />
         <include name="IDR_DISCARDS_DISCARDS_MAIN_JS" file="${root_gen_dir}\chrome\browser\resources\discards\discards_main.js" use_base_dir="false" type="BINDATA" />
         <include name="IDR_DISCARDS_DISCARDS_TAB_JS" file="${root_gen_dir}\chrome\browser\resources\discards\discards_tab.js" use_base_dir="false" type="BINDATA" />
@@ -144,7 +144,7 @@
       <if expr="chromeos">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_chromeos.json" type="BINDATA" />
       </if>
-      <if expr="desktop_linux">
+      <if expr="desktop_linux or is_ohos">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_linux.json" type="BINDATA" />
       </if>
       <if expr="not is_android">
@@ -154,7 +154,7 @@
         <include name="IDR_MANAGEMENT_ICONS_JS" file="${root_gen_dir}/chrome/browser/resources/management/icons.js" use_base_dir="false" type="BINDATA" preprocess="true" />
       </if>
       <include name="IDR_URL_MOJOM_LITE_JS" file="${root_gen_dir}\url\mojom\url.mojom-lite.js" use_base_dir="false" type="BINDATA" />
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_win or is_macosx or desktop_linux or chromeos or is_ohos">
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_disabled_confirmation.html" type="BINDATA" />
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_APP_JS" file="${root_gen_dir}\chrome\browser\resources\signin\sync_confirmation\sync_disabled_confirmation_app.js" use_base_dir="false" preprocess="true" type="BINDATA" />
         <include name="IDR_SYNC_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_confirmation.html" type="BINDATA" />
@@ -166,7 +166,7 @@
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_REFRESHED_ILLUSTRATION_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_refreshed_illustration.svg" type="BINDATA" />
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_REFRESHED_ILLUSTRATION_DARK_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_refreshed_illustration_dark.svg" type="BINDATA" />
       </if>
-      <if expr="is_win or is_macosx or desktop_linux">
+      <if expr="is_win or is_macosx or desktop_linux or is_ohos">
         <include name="IDR_SIGNIN_DICE_WEB_INTERCEPT_HTML" file="resources\signin\dice_web_signin_intercept\dice_web_signin_intercept.html" type="BINDATA" />
         <include name="IDR_SIGNIN_DICE_WEB_INTERCEPT_APP_JS" file="${root_gen_dir}\chrome\browser\resources\signin\dice_web_signin_intercept\dice_web_signin_intercept_app.js" use_base_dir="false" type="BINDATA" />
         <include name="IDR_SIGNIN_DICE_WEB_INTERCEPT_BROWSER_PROXY_JS" file="resources/signin/dice_web_signin_intercept/dice_web_signin_intercept_browser_proxy.js" type="BINDATA" />
diff --git a/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc b/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
index dec02fc1fc..2edbadc772 100644
--- a/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
@@ -656,6 +656,7 @@ void ChromeBrowsingDataRemoverDelegate::RemoveEmbedderData(
        content::BrowsingDataRemover::ORIGIN_TYPE_UNPROTECTED_WEB)) {
     base::RecordAction(UserMetricsAction("ClearBrowsingData_Cookies"));
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
     network::mojom::NetworkContext* safe_browsing_context = nullptr;
     safe_browsing::SafeBrowsingService* sb_service =
         g_browser_process->safe_browsing_service();
@@ -668,7 +669,7 @@ void ChromeBrowsingDataRemoverDelegate::RemoveEmbedderData(
         base::BindOnce(
             &ChromeBrowsingDataRemoverDelegate::CreateTaskCompletionClosure,
             base::Unretained(this), TracingDataType::kCookies));
-
+#endif
     if (filter_builder->GetMode() ==
         BrowsingDataFilterBuilder::Mode::kPreserve) {
       PrivacySandboxSettings* privacy_sandbox_settings =
diff --git a/chrome/browser/chrome_browser_main_linux.cc b/chrome/browser/chrome_browser_main_linux.cc
index a9e15135f9..aff941f13c 100644
--- a/chrome/browser/chrome_browser_main_linux.cc
+++ b/chrome/browser/chrome_browser_main_linux.cc
@@ -79,7 +79,7 @@ void ChromeBrowserMainPartsLinux::PreProfileInit() {
 
 
 void ChromeBrowserMainPartsLinux::PostMainMessageLoopStart() {
-#if !BUILDFLAG(IS_CHROMEOS_ASH)
+#if !BUILDFLAG(IS_CHROMEOS_ASH) && !defined(OS_OHOS)
   bluez::BluezDBusManager::Initialize(nullptr /* system_bus */);
 #endif
 
@@ -87,7 +87,7 @@ void ChromeBrowserMainPartsLinux::PostMainMessageLoopStart() {
 }
 
 void ChromeBrowserMainPartsLinux::PostDestroyThreads() {
-#if !BUILDFLAG(IS_CHROMEOS_ASH)
+#if !BUILDFLAG(IS_CHROMEOS_ASH) && !defined(OS_OHOS)
   bluez::BluezDBusManager::Shutdown();
   bluez::BluezDBusThreadManager::Shutdown();
 #endif
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 3c69c7da0f..a99bc28830 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -506,7 +506,7 @@
 #include "chrome/browser/browser_switcher/browser_switcher_navigation_throttle.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "components/crash/core/app/crash_switches.h"
 #include "components/crash/core/app/crashpad.h"
 #endif
@@ -999,18 +999,26 @@ class CertificateReportingServiceCertReporter : public SSLCertReporter {
  public:
   explicit CertificateReportingServiceCertReporter(
       content::WebContents* web_contents)
+    #if BUILDFLAG(FULL_SAFE_BROWSING)
       : service_(CertificateReportingServiceFactory::GetForBrowserContext(
             web_contents->GetBrowserContext())) {}
+    #else
+      {}
+    #endif
   ~CertificateReportingServiceCertReporter() override {}
 
   // SSLCertReporter implementation
   void ReportInvalidCertificateChain(
       const std::string& serialized_report) override {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
     service_->Send(serialized_report);
+#endif
   }
 
  private:
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   CertificateReportingService* service_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(CertificateReportingServiceCertReporter);
 };
@@ -1440,7 +1448,9 @@ void ChromeContentBrowserClient::PostAfterStartupTask(
   InitNetworkContextsParentDirectory();
 
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing_service_ = g_browser_process->safe_browsing_service();
+#endif
 }
 
 bool ChromeContentBrowserClient::IsBrowserStartupComplete() {
@@ -4154,6 +4164,7 @@ ChromeContentBrowserClient::CreateThrottlesForNavigation(
                    &throttles);
 #endif
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   throttles.push_back(
       std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(handle));
 
@@ -4162,6 +4173,7 @@ ChromeContentBrowserClient::CreateThrottlesForNavigation(
         std::make_unique<safe_browsing::DelayedWarningNavigationThrottle>(
             handle));
   }
+#endif
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
@@ -5368,6 +5380,7 @@ ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate(
     const std::vector<std::string>& allowlist_domains) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Should not bypass safe browsing check if the check is for enterprise
   // lookup.
   if (!safe_browsing_enabled_for_profile && !should_check_on_sb_disabled)
@@ -5388,6 +5401,10 @@ ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate(
   }
 
   return safe_browsing_url_checker_delegate_;
+#else
+  return nullptr;
+#endif
+
 }
 
 safe_browsing::RealTimeUrlLookupServiceBase*
@@ -5399,7 +5416,7 @@ ChromeContentBrowserClient::GetUrlLookupService(
   if (!safe_browsing_service_) {
     return nullptr;
   }
-
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   Profile* profile = Profile::FromBrowserContext(browser_context);
 
 #if BUILDFLAG(SAFE_BROWSING_DB_LOCAL)
@@ -5407,12 +5424,14 @@ ChromeContentBrowserClient::GetUrlLookupService(
     return safe_browsing::ChromeEnterpriseRealTimeUrlLookupServiceFactory::
         GetForProfile(profile);
   }
-#endif
+#endif // BUILDFLAG(SAFE_BROWSING_DB_LOCAL)
 
   if (is_consumer_lookup_enabled) {
     return safe_browsing::RealTimeUrlLookupServiceFactory::GetForProfile(
         profile);
   }
+#endif // BUILDFLAG(SAFE_BROWSING_AVAILABLE)
+
   return nullptr;
 }
 
diff --git a/chrome/browser/chrome_content_browser_client_receiver_bindings.cc b/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
index a406da288f..005625bb1c 100644
--- a/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
+++ b/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
@@ -75,6 +75,7 @@
 
 namespace {
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 // Helper method for ExposeInterfacesToRenderer() that checks the latest
 // SafeBrowsing pref value on the UI thread before hopping over to the IO
 // thread.
@@ -87,6 +88,8 @@ void MaybeCreateSafeBrowsingForRenderer(
         const std::vector<std::string>& allowlist_domains)>
         get_checker_delegate,
     mojo::PendingReceiver<safe_browsing::mojom::SafeBrowsing> receiver) {
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   content::RenderProcessHost* render_process_host =
@@ -126,7 +129,10 @@ void MaybeCreateSafeBrowsingForRenderer(
                               /*should_check_on_sb_disabled=*/false,
                               allowlist_domains),
           std::move(receiver)));
+#endif
+
 }
+#endif
 
 }  // namespace
 
@@ -164,6 +170,7 @@ void ChromeContentBrowserClient::ExposeInterfacesToRenderer(
   if (safe_browsing_service_) {
     content::ResourceContext* resource_context =
         render_process_host->GetBrowserContext()->GetResourceContext();
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
     registry->AddInterface(
         base::BindRepeating(
             &MaybeCreateSafeBrowsingForRenderer, render_process_host->GetID(),
@@ -172,6 +179,7 @@ void ChromeContentBrowserClient::ExposeInterfacesToRenderer(
                 &ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate,
                 base::Unretained(this))),
         ui_task_runner);
+  #endif
   }
 #endif
 
diff --git a/chrome/browser/chrome_notification_types.h b/chrome/browser/chrome_notification_types.h
index 858b7d94eb..0bfb0098f8 100644
--- a/chrome/browser/chrome_notification_types.h
+++ b/chrome/browser/chrome_notification_types.h
@@ -170,7 +170,7 @@ enum NotificationType {
   NOTIFICATION_SCREEN_LOCK_STATE_CHANGED,
 #endif
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
   // Notification that the nested loop using during tab dragging has returned.
   // Used for testing.
   // TODO(https://crbug.com/1174797): Remove.
diff --git a/chrome/browser/component_updater/file_type_policies_component_installer.cc b/chrome/browser/component_updater/file_type_policies_component_installer.cc
index f47bb82a97..16968830f7 100644
--- a/chrome/browser/component_updater/file_type_policies_component_installer.cc
+++ b/chrome/browser/component_updater/file_type_policies_component_installer.cc
@@ -51,8 +51,11 @@ void LoadFileTypesFromDisk(const base::FilePath& pb_path) {
     return;
   }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::FileTypePolicies::GetInstance()->PopulateFromDynamicUpdate(
       binary_pb);
+#endif
+
 }
 
 }  // namespace
diff --git a/chrome/browser/devtools/devtools_window.cc b/chrome/browser/devtools/devtools_window.cc
index 78f6754375..0efa47f797 100644
--- a/chrome/browser/devtools/devtools_window.cc
+++ b/chrome/browser/devtools/devtools_window.cc
@@ -1563,8 +1563,10 @@ void DevToolsWindow::ShowCertificateViewer(const std::string& cert_chain) {
   int tab = 0;
   if (!FindInspectedBrowserAndTabIndex(inspected_contents, &browser, &tab))
     return;
+#if !defined(OS_OHOS)
   gfx::NativeWindow parent = browser->window()->GetNativeWindow();
   ::ShowCertificateViewer(inspected_contents, parent, cert.get());
+#endif
 }
 
 void DevToolsWindow::OnLoadCompleted() {
diff --git a/chrome/browser/download/chrome_download_manager_delegate.cc b/chrome/browser/download/chrome_download_manager_delegate.cc
index cebed2a6c0..61adceb5ba 100644
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -72,6 +72,7 @@
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/buildflags.h"
 #include "components/safe_browsing/core/file_type_policies.h"
+#include "components/safe_browsing/buildflags.h"
 #include "components/services/quarantine/public/mojom/quarantine.mojom.h"
 #include "components/services/quarantine/quarantine_impl.h"
 #include "content/public/browser/browser_task_traits.h"
@@ -92,6 +93,10 @@
 #include "services/network/public/cpp/network_connection_tracker.h"
 #include "ui/base/l10n/l10n_util.h"
 
+#if defined(OS_OHOS)
+#include "net/http/http_content_disposition.h"
+#endif
+
 #if defined(OS_ANDROID)
 #include "base/android/path_utils.h"
 #include "chrome/browser/download/android/chrome_duplicate_download_infobar_delegate.h"
@@ -131,7 +136,11 @@ using content::DownloadManager;
 using download::DownloadItem;
 using download::DownloadPathReservationTracker;
 using download::PathValidationResult;
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 using safe_browsing::DownloadFileType;
+#endif
+
 using safe_browsing::DownloadProtectionService;
 
 namespace {
@@ -394,13 +403,14 @@ ChromeDownloadManagerDelegate::~ChromeDownloadManagerDelegate() {
 
 void ChromeDownloadManagerDelegate::SetDownloadManager(DownloadManager* dm) {
   download_manager_ = dm;
-
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingService* sb_service =
       g_browser_process->safe_browsing_service();
   if (sb_service && !profile_->IsOffTheRecord()) {
     // Include this download manager in the set monitored by safe browsing.
     sb_service->AddDownloadManager(dm);
   }
+#endif
 }
 
 #if defined(OS_ANDROID)
@@ -741,13 +751,14 @@ void ChromeDownloadManagerDelegate::ChooseSavePath(
 
 void ChromeDownloadManagerDelegate::SanitizeSavePackageResourceName(
     base::FilePath* filename) {
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::FileTypePolicies* file_type_policies =
       safe_browsing::FileTypePolicies::GetInstance();
 
   if (file_type_policies->GetFileDangerLevel(*filename) ==
       safe_browsing::DownloadFileType::NOT_DANGEROUS)
     return;
-
+#endif
   base::FilePath default_filename = base::FilePath::FromUTF8Unsafe(
       l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME));
   *filename = filename->AddExtension(default_filename.BaseName().value());
@@ -1449,7 +1460,10 @@ void ChromeDownloadManagerDelegate::OnDownloadTargetDetermined(
       DownloadItemModel(item).SetShouldPreferOpeningInBrowser(true);
 #endif
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
     DownloadItemModel(item).SetDangerLevel(target_info->danger_level);
+#endif
+
   }
   if (ShouldBlockFile(target_info->danger_type, item)) {
     MaybeReportDangerousDownloadBlocked(
diff --git a/chrome/browser/download/download_commands.cc b/chrome/browser/download/download_commands.cc
index fe0e3b6bed..e254f35a33 100644
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -28,7 +28,7 @@
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_OHOS)
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -156,7 +156,7 @@ void DownloadCommands::ExecuteCommand(Command command) {
 }
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 
 Browser* DownloadCommands::GetBrowser() const {
   chrome::ScopedTabbedBrowserDisplayer browser_displayer(model_->profile());
@@ -179,7 +179,7 @@ bool DownloadCommands::CanOpenPdfInSystemViewer() const {
   return IsDownloadPdf() &&
          (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
                                           : true);
-#elif defined(OS_MAC) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_MAC) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   return IsDownloadPdf();
 #endif
 }
diff --git a/chrome/browser/download/download_commands.h b/chrome/browser/download/download_commands.h
index 82d66ff175..f8f7737856 100644
--- a/chrome/browser/download/download_commands.h
+++ b/chrome/browser/download/download_commands.h
@@ -50,7 +50,7 @@ class DownloadCommands {
   void ExecuteCommand(Command command);
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_OHOS)
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
   Browser* GetBrowser() const;
diff --git a/chrome/browser/download/download_danger_prompt.cc b/chrome/browser/download/download_danger_prompt.cc
index 3643ca2131..44d34d2829 100644
--- a/chrome/browser/download/download_danger_prompt.cc
+++ b/chrome/browser/download/download_danger_prompt.cc
@@ -19,7 +19,7 @@ using safe_browsing::ClientDownloadResponse;
 using safe_browsing::ClientSafeBrowsingReportRequest;
 
 namespace {
-
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 const char kDownloadDangerPromptPrefix[] = "Download.DownloadDangerPrompt";
 
 // Converts DownloadDangerType into their corresponding string.
@@ -66,9 +66,11 @@ const char* GetDangerTypeString(
   NOTREACHED();
   return nullptr;
 }
+#endif
 
 }  // namespace
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
     ClientSafeBrowsingReportRequest::ReportType report_type,
     bool did_proceed,
@@ -109,10 +111,12 @@ void DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
   else
     DLOG(ERROR) << "Unable to serialize the threat report.";
 }
+#endif
 
 void DownloadDangerPrompt::RecordDownloadDangerPrompt(
     bool did_proceed,
     const download::DownloadItem& download) {
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   int64_t file_type_uma_value =
       safe_browsing::FileTypePolicies::GetInstance()->UmaValueForFile(
           download.GetTargetFilePath());
@@ -128,4 +132,5 @@ void DownloadDangerPrompt::RecordDownloadDangerPrompt(
                            GetDangerTypeString(danger_type)),
         file_type_uma_value);
   }
+#endif
 }
diff --git a/chrome/browser/download/download_danger_prompt.h b/chrome/browser/download/download_danger_prompt.h
index 274d59d136..c2574b525a 100644
--- a/chrome/browser/download/download_danger_prompt.h
+++ b/chrome/browser/download/download_danger_prompt.h
@@ -7,6 +7,7 @@
 
 #include "base/callback_forward.h"
 #include "components/safe_browsing/core/proto/csd.pb.h"
+#include "components/safe_browsing/buildflags.h"
 
 namespace content {
 class WebContents;
@@ -53,6 +54,7 @@ class DownloadDangerPrompt {
   // respective button click handler.
   virtual void InvokeActionForTesting(Action action) = 0;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Sends download recovery report to safe browsing backend.
   // Since it only records download url (DownloadItem::GetURL()), user's
   // action (click through or not) and its download danger type, it isn't gated
@@ -63,6 +65,7 @@ class DownloadDangerPrompt {
       safe_browsing::ClientSafeBrowsingReportRequest::ReportType report_type,
       bool did_proceed,
       const download::DownloadItem& download);
+#endif
 
  protected:
   // Records UMA stats for a download danger prompt event.
diff --git a/chrome/browser/download/download_item_model.cc b/chrome/browser/download/download_item_model.cc
index c83a001251..f45dc63ecf 100644
--- a/chrome/browser/download/download_item_model.cc
+++ b/chrome/browser/download/download_item_model.cc
@@ -535,6 +535,7 @@ bool DownloadItemModel::IsCommandEnabled(
       return download_->CanOpenDownload() &&
              !download_crx_util::IsExtensionDownload(*download_);
     case DownloadCommands::ALWAYS_OPEN_TYPE:
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
       // For temporary downloads, the target filename might be a temporary
       // filename. Don't base an "Always open" decision based on it. Also
       // exclude extensions.
@@ -543,6 +544,10 @@ bool DownloadItemModel::IsCommandEnabled(
                  ->IsAllowedToOpenAutomatically(
                      download_->GetTargetFilePath()) &&
              !download_crx_util::IsExtensionDownload(*download_);
+#else
+      return download_->CanOpenDownload() &&
+             !download_crx_util::IsExtensionDownload(*download_);
+#endif
     case DownloadCommands::PAUSE:
       return !download_->IsSavePackageDownload() &&
              DownloadUIModel::IsCommandEnabled(download_commands, command);
@@ -702,6 +707,7 @@ void DownloadItemModel::ExecuteCommand(DownloadCommands* download_commands,
       DownloadUIModel::ExecuteCommand(download_commands, command);
       break;
     case DownloadCommands::DEEP_SCAN:
+#if BUILDFLAG(FULL_SAFE_BROWSING)
       safe_browsing::SafeBrowsingService* sb_service =
           g_browser_process->safe_browsing_service();
       if (!sb_service)
@@ -727,6 +733,7 @@ void DownloadItemModel::ExecuteCommand(DownloadCommands* download_commands,
           safe_browsing::DeepScanningRequest::DeepScanTrigger::
               TRIGGER_APP_PROMPT,
           std::move(settings));
+#endif
       break;
   }
 }
diff --git a/chrome/browser/download/download_prefs.cc b/chrome/browser/download/download_prefs.cc
index 6d82d55acd..1e5e4f9d72 100644
--- a/chrome/browser/download/download_prefs.cc
+++ b/chrome/browser/download/download_prefs.cc
@@ -73,14 +73,14 @@ namespace {
 // Consider downloads 'dangerous' if they go to the home directory on Linux and
 // to the desktop on any platform.
 bool DownloadPathIsDangerous(const base::FilePath& download_path) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   base::FilePath home_dir = base::GetHomeDir();
   if (download_path == home_dir) {
     return true;
   }
 #endif
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   // Android does not have a desktop dir.
   return false;
 #else
@@ -271,6 +271,7 @@ DownloadPrefs::DownloadPrefs(Profile* profile) : profile_(profile) {
         base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +
         extension);
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
     // Note that the list of file types that are not allowed to open
     // automatically can change in the future. When the list is tightened, it is
     // expected that some entries in the users' auto open list will get dropped
@@ -279,6 +280,7 @@ DownloadPrefs::DownloadPrefs(Profile* profile) : profile_(profile) {
             filename_with_extension)) {
       auto_open_by_user_.insert(extension);
     }
+#endif
   }
 }
 
@@ -483,11 +485,12 @@ bool DownloadPrefs::IsAutoOpenByPolicy(const GURL& url,
 bool DownloadPrefs::EnableAutoOpenByUserBasedOnExtension(
     const base::FilePath& file_name) {
   base::FilePath::StringType extension = file_name.Extension();
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   if (!FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
           file_name)) {
     return false;
   }
-
+#endif
   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);
   extension.erase(0, 1);
 
diff --git a/chrome/browser/download/download_shelf_context_menu.cc b/chrome/browser/download/download_shelf_context_menu.cc
index 7efa464116..711893472d 100644
--- a/chrome/browser/download/download_shelf_context_menu.cc
+++ b/chrome/browser/download/download_shelf_context_menu.cc
@@ -146,7 +146,7 @@ std::u16string DownloadShelfContextMenu::GetLabelForCommandId(
                    : IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
           break;
         }
-#elif defined(OS_MAC) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_MAC) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
         if (can_open_pdf_in_system_viewer) {
           id = IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
           break;
diff --git a/chrome/browser/download/download_target_determiner.cc b/chrome/browser/download/download_target_determiner.cc
index b5f4616ff8..c1ce60db1b 100644
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -291,14 +291,14 @@ base::FilePath DownloadTargetDeterminer::GenerateFileName() const {
   base::FilePath generated_filename = net::GenerateFileName(
       download_->GetURL(), download_->GetContentDisposition(), referrer_charset,
       suggested_filename, sniffed_mime_type, default_filename);
-
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // We don't replace the file extension if sfafe browsing consider the file
   // extension to be unsafe. Just let safe browsing scan the generated file.
   if (safe_browsing::FileTypePolicies::GetInstance()->IsCheckedBinaryFile(
           generated_filename)) {
     return generated_filename;
   }
-
+#endif
   // If no mime type or explicitly specified a name, don't replace file
   // extension.
   if (sniffed_mime_type.empty() || !suggested_filename.empty())
@@ -1097,9 +1097,12 @@ DownloadFileType::DangerLevel DownloadTargetDeterminer::GetDangerLevel(
       download_->HasUserGesture())
     return DownloadFileType::NOT_DANGEROUS;
 
-  DownloadFileType::DangerLevel danger_level =
+  DownloadFileType::DangerLevel danger_level = DownloadFileType::NOT_DANGEROUS;
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
+    danger_level =
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           virtual_path_.BaseName());
+#endif
 
   // A danger level of ALLOW_ON_USER_GESTURE is used to label potentially
   // dangerous file types that have a high frequency of legitimate use. We would
diff --git a/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc b/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
index d4da2eadd6..8edbefeebb 100644
--- a/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
+++ b/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
@@ -37,13 +37,21 @@
 #include "chrome/browser/safe_browsing/cloud_content_scanning/binary_upload_service_factory.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/deep_scanning_utils.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/file_analysis_request.h"
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "chrome/browser/safe_browsing/download_protection/check_client_download_request.h"
+#endif
+
 #include "chrome/grit/generated_resources.h"
 #include "components/enterprise/common/proto/connectors.pb.h"
 #include "components/policy/core/browser/url_util.h"
 #include "components/policy/core/common/chrome_schema.h"
 #include "components/prefs/pref_service.h"
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
+
 #include "components/safe_browsing/core/features.h"
 #include "components/url_matcher/url_matcher.h"
 #include "content/public/browser/web_contents.h"
@@ -137,6 +145,7 @@ bool* UIEnabledStorage() {
   return &enabled;
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 safe_browsing::EventResult CalculateEventResult(
     const enterprise_connectors::AnalysisSettings& settings,
     bool allowed_by_scan_result,
@@ -148,7 +157,7 @@ safe_browsing::EventResult CalculateEventResult(
              : (should_warn ? safe_browsing::EventResult::WARNED
                             : safe_browsing::EventResult::BLOCKED);
 }
-
+#endif
 }  // namespace
 
 ContentAnalysisDelegate::Data::Data() = default;
@@ -179,6 +188,7 @@ void ContentAnalysisDelegate::BypassWarnings() {
   if (callback_.is_null())
     return;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Mark the full text as complying and report a warning bypass.
   if (text_warning_) {
     std::fill(result_.text_results.begin(), result_.text_results.end(), true);
@@ -204,6 +214,7 @@ void ContentAnalysisDelegate::BypassWarnings() {
         extensions::SafeBrowsingPrivateEventRouter::kTriggerFileUpload,
         access_point_, file_info_[index].size, warning.second);
   }
+#endif
 
   RunCallback();
 }
@@ -212,6 +223,7 @@ void ContentAnalysisDelegate::Cancel(bool warning) {
   if (callback_.is_null())
     return;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Don't report this upload as cancelled if the user didn't bypass the
   // warning.
   if (!warning) {
@@ -219,6 +231,7 @@ void ContentAnalysisDelegate::Cancel(bool warning) {
                           base::TimeTicks::Now() - upload_start_time_, 0,
                           "CancelledByUser", false);
   }
+#endif
 
   // Make sure to reject everything.
   FillAllResultsWith(false);
@@ -356,8 +369,11 @@ ContentAnalysisDelegate::ContentAnalysisDelegate(
     CompletionCallback callback,
     safe_browsing::DeepScanAccessPoint access_point)
     : data_(std::move(data)),
-      callback_(std::move(callback)),
-      access_point_(access_point) {
+      callback_(std::move(callback))
+#if BUILDFLAG(FULL_SAFE_BROWSING)
+      ,access_point_(access_point)
+#endif
+      {
   DCHECK(web_contents);
   profile_ = Profile::FromBrowserContext(web_contents->GetBrowserContext());
   url_ = web_contents->GetLastCommittedURL();
@@ -372,9 +388,12 @@ void ContentAnalysisDelegate::StringRequestCallback(
   int64_t content_size = 0;
   for (const std::u16string& entry : data_.text)
     content_size += (entry.size() * sizeof(char16_t));
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   RecordDeepScanMetrics(access_point_,
                         base::TimeTicks::Now() - upload_start_time_,
                         content_size, result, response);
+#endif
 
   text_request_complete_ = true;
   auto action = enterprise_connectors::GetHighestPrecedenceAction(response);
@@ -386,11 +405,13 @@ void ContentAnalysisDelegate::StringRequestCallback(
   std::fill(result_.text_results.begin(), result_.text_results.end(),
             text_complies);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   MaybeReportDeepScanningVerdict(
       profile_, url_, "Text data", std::string(), "text/plain",
       extensions::SafeBrowsingPrivateEventRouter::kTriggerWebContentUpload,
       access_point_, content_size, result, response,
       CalculateEventResult(data_.settings, text_complies, should_warn));
+#endif
 
   if (!text_complies) {
     if (should_warn) {
@@ -419,11 +440,13 @@ void ContentAnalysisDelegate::CompleteFileRequestCallback(
   bool should_warn = action == enterprise_connectors::TriggeredRule::WARN;
   result_.paths_results[index] = file_complies;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   MaybeReportDeepScanningVerdict(
       profile_, url_, path.AsUTF8Unsafe(), file_info_[index].sha256, mime_type,
       extensions::SafeBrowsingPrivateEventRouter::kTriggerFileUpload,
       access_point_, file_info_[index].size, result, response,
       CalculateEventResult(data_.settings, file_complies, should_warn));
+#endif
 
   ++file_result_count_;
 
@@ -452,9 +475,11 @@ void ContentAnalysisDelegate::FileRequestCallback(
   DCHECK(it != data_.paths.end());
   size_t index = std::distance(data_.paths.begin(), it);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   RecordDeepScanMetrics(access_point_,
                         base::TimeTicks::Now() - upload_start_time_,
                         file_info_[index].size, result, response);
+#endif
 
   base::ThreadPool::PostTaskAndReplyWithResult(
       FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
@@ -467,10 +492,12 @@ void ContentAnalysisDelegate::FileRequestCallback(
 bool ContentAnalysisDelegate::UploadData() {
   upload_start_time_ = base::TimeTicks::Now();
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Create a text request and a file request for each file.
   PrepareTextRequest();
   for (const base::FilePath& path : data_.paths)
     PrepareFileRequest(path);
+#endif
 
   data_uploaded_ = true;
   // Do not add code under this comment. The above line should be the last thing
@@ -479,6 +506,7 @@ bool ContentAnalysisDelegate::UploadData() {
   return !text_request_complete_ || file_result_count_ != data_.paths.size();
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void ContentAnalysisDelegate::PrepareTextRequest() {
   std::string full_text;
   for (const auto& text : data_.text)
@@ -534,6 +562,7 @@ void ContentAnalysisDelegate::PrepareRequest(
   for (const std::string& tag : data_.settings.tags)
     request->add_tag(tag);
 }
+#endif
 
 void ContentAnalysisDelegate::FillAllResultsWith(bool status) {
   std::fill(result_.text_results.begin(), result_.text_results.end(), status);
@@ -541,7 +570,11 @@ void ContentAnalysisDelegate::FillAllResultsWith(bool status) {
 }
 
 BinaryUploadService* ContentAnalysisDelegate::GetBinaryUploadService() {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   return safe_browsing::BinaryUploadServiceFactory::GetForProfile(profile_);
+#else
+  return nullptr;
+#endif
 }
 
 void ContentAnalysisDelegate::UploadTextForDeepScanning(
diff --git a/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.h b/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.h
index fbab5d66e5..8df980e1fb 100644
--- a/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.h
+++ b/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.h
@@ -22,6 +22,7 @@
 #include "chrome/browser/ui/tab_modal_confirm_dialog.h"
 #include "chrome/browser/ui/tab_modal_confirm_dialog_delegate.h"
 #include "components/enterprise/common/proto/connectors.pb.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/web_contents_view_delegate.h"
 #include "url/gurl.h"
 
@@ -247,6 +248,7 @@ class ContentAnalysisDelegate {
   // to true right before returning.
   bool UploadData();
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Prepares an upload request for the text in |data_|. If |data_.text| is
   // empty, this method does nothing.
   void PrepareTextRequest();
@@ -260,6 +262,7 @@ class ContentAnalysisDelegate {
   // service.
   void PrepareRequest(enterprise_connectors::AnalysisConnector connector,
                       safe_browsing::BinaryUploadService::Request* request);
+#endif
 
   // Fills the arrays in |result_| with the given boolean status.
   void FillAllResultsWith(bool status);
@@ -350,8 +353,10 @@ class ContentAnalysisDelegate {
   // Pointer to UI when enabled.
   ContentAnalysisDialog* dialog_ = nullptr;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Access point to use to record UMA metrics.
   safe_browsing::DeepScanAccessPoint access_point_;
+#endif
 
   // Scanning result to be shown to the user once every request is done.
   FinalResult final_result_ = FinalResult::SUCCESS;
diff --git a/chrome/browser/enterprise/connectors/connectors_service.cc b/chrome/browser/enterprise/connectors/connectors_service.cc
index 2a28a3e059..493f1acead 100644
--- a/chrome/browser/enterprise/connectors/connectors_service.cc
+++ b/chrome/browser/enterprise/connectors/connectors_service.cc
@@ -265,6 +265,7 @@ base::Optional<std::string> ConnectorsService::GetDMTokenForRealTimeUrlCheck()
   return base::nullopt;
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 safe_browsing::EnterpriseRealTimeUrlCheckMode
 ConnectorsService::GetAppliedRealTimeUrlCheck() const {
   if (!ConnectorsEnabled() ||
@@ -277,6 +278,7 @@ ConnectorsService::GetAppliedRealTimeUrlCheck() const {
       Profile::FromBrowserContext(context_)->GetPrefs()->GetInteger(
           prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckMode));
 }
+#endif
 
 ConnectorsManager* ConnectorsService::ConnectorsManagerForTesting() {
   return connectors_manager_.get();
diff --git a/chrome/browser/enterprise/connectors/connectors_service.h b/chrome/browser/enterprise/connectors/connectors_service.h
index e0415ce336..41dd7f6312 100644
--- a/chrome/browser/enterprise/connectors/connectors_service.h
+++ b/chrome/browser/enterprise/connectors/connectors_service.h
@@ -13,7 +13,12 @@
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/policy/core/common/policy_types.h"
+#include "components/safe_browsing/buildflags.h"
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
+
 #include "content/public/browser/browser_context.h"
 
 namespace base {
@@ -73,11 +78,13 @@ class ConnectorsService : public KeyedService {
   // is no token to use.
   base::Optional<std::string> GetDMTokenForRealTimeUrlCheck() const;
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Returns the value to used by the enterprise real-time URL check Connector
   // if it is set and if the scope it's set at has a valid browser-profile
   // affiliation.
   safe_browsing::EnterpriseRealTimeUrlCheckMode GetAppliedRealTimeUrlCheck()
       const;
+#endif
 
   // Testing functions.
   ConnectorsManager* ConnectorsManagerForTesting();
diff --git a/chrome/browser/enterprise/signals/context_info_fetcher.cc b/chrome/browser/enterprise/signals/context_info_fetcher.cc
index 9ab02af1f4..cf299e0761 100644
--- a/chrome/browser/enterprise/signals/context_info_fetcher.cc
+++ b/chrome/browser/enterprise/signals/context_info_fetcher.cc
@@ -50,7 +50,11 @@ void ContextInfoFetcher::Fetch(ContextInfoCallback callback) {
       GetAnalysisConnectorProviders(enterprise_connectors::FILE_DOWNLOADED);
   info.on_bulk_data_entry_providers =
       GetAnalysisConnectorProviders(enterprise_connectors::BULK_DATA_ENTRY);
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   info.realtime_url_check_mode = GetRealtimeUrlCheckMode();
+#endif
+
   info.on_security_event_providers = GetOnSecurityEventProviders();
   info.browser_version = version_info::GetVersionNumber();
 
@@ -92,10 +96,12 @@ std::vector<std::string> ContextInfoFetcher::GetAnalysisConnectorProviders(
   return connectors_service_->GetAnalysisServiceProviderNames(connector);
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 safe_browsing::EnterpriseRealTimeUrlCheckMode
 ContextInfoFetcher::GetRealtimeUrlCheckMode() {
   return connectors_service_->GetAppliedRealTimeUrlCheck();
 }
+#endif
 
 std::vector<std::string> ContextInfoFetcher::GetOnSecurityEventProviders() {
   return connectors_service_->GetReportingServiceProviderNames(
diff --git a/chrome/browser/enterprise/signals/context_info_fetcher.h b/chrome/browser/enterprise/signals/context_info_fetcher.h
index 098c428352..8a89e4818a 100644
--- a/chrome/browser/enterprise/signals/context_info_fetcher.h
+++ b/chrome/browser/enterprise/signals/context_info_fetcher.h
@@ -6,10 +6,15 @@
 #define CHROME_BROWSER_ENTERPRISE_SIGNALS_CONTEXT_INFO_FETCHER_H_
 
 #include <string>
+#include <memory>
 #include <vector>
 
 #include "base/callback_forward.h"
+#include "components/safe_browsing/buildflags.h"
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
 
 namespace content {
 class BrowserContext;
@@ -35,7 +40,11 @@ struct ContextInfo {
   std::vector<std::string> on_file_downloaded_providers;
   std::vector<std::string> on_bulk_data_entry_providers;
   std::vector<std::string> on_security_event_providers;
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::EnterpriseRealTimeUrlCheckMode realtime_url_check_mode;
+#endif
+
   std::string browser_version;
 };
 
@@ -76,7 +85,9 @@ class ContextInfoFetcher {
   std::vector<std::string> GetAnalysisConnectorProviders(
       enterprise_connectors::AnalysisConnector connector);
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::EnterpriseRealTimeUrlCheckMode GetRealtimeUrlCheckMode();
+#endif
 
   std::vector<std::string> GetOnSecurityEventProviders();
 
diff --git a/chrome/browser/error_reporting/BUILD.gn b/chrome/browser/error_reporting/BUILD.gn
index f9ba0712b8..2ae2230074 100644
--- a/chrome/browser/error_reporting/BUILD.gn
+++ b/chrome/browser/error_reporting/BUILD.gn
@@ -5,7 +5,7 @@ import("//build/config/chromeos/ui_mode.gni")
 
 # TODO(crbug.com/1129544) This is currently disabled due to Windows DLL
 # thunking issues. Fix & re-enable.
-assert(is_linux || is_chromeos_ash || is_chromeos_lacros)
+assert(is_linux || is_chromeos_ash || is_chromeos_lacros || is_ohos)
 
 source_set("constants") {
   sources = [
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index c8a4da2105..37117db7fc 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -1148,7 +1148,7 @@ static_library("extensions") {
       "//components/enterprise/common/proto:connectors_proto",
       "//components/keep_alive_registry",
     ]
-    if (is_linux || is_chromeos) {
+    if (is_linux || is_chromeos || is_ohos) {
       sources +=
           [ "api/image_writer_private/removable_storage_provider_linux.cc" ]
     }
@@ -1272,7 +1272,7 @@ static_library("extensions") {
     deps += [ "//rlz:rlz_lib" ]
   }
 
-  if (toolkit_views) {
+  if (toolkit_views || is_ohos) {
     deps += [ "//ui/views" ]
   }
 
diff --git a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
index 2b40124456..76ddaa32cf 100644
--- a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
@@ -245,6 +245,8 @@ base::FilePath GetEndpointVerificationDir() {
   if (path.empty())
 #elif defined(OS_MAC)
   if (!base::PathService::Get(base::DIR_APP_DATA, &path))
+#elif defined(OS_OHOS)
+  if (!base::PathService::Get(base::DIR_OHOS_APP_DATA, &path))
 #else
   if (true)
 #endif
diff --git a/chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_api.cc b/chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_api.cc
index 0c795e2e8c..023a6453ab 100644
--- a/chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_api.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_api.cc
@@ -68,10 +68,16 @@ api::enterprise_reporting_private::ContextInfo ToContextInfo(
   info.on_file_downloaded_providers = signals.on_file_downloaded_providers;
   info.on_bulk_data_entry_providers = signals.on_bulk_data_entry_providers;
   info.on_security_event_providers = signals.on_security_event_providers;
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   switch (signals.realtime_url_check_mode) {
     case safe_browsing::REAL_TIME_CHECK_DISABLED:
+#endif
+
       info.realtime_url_check_mode = extensions::api::
           enterprise_reporting_private::REALTIME_URL_CHECK_MODE_DISABLED;
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
       break;
     case safe_browsing::REAL_TIME_CHECK_FOR_MAINFRAME_ENABLED:
       info.realtime_url_check_mode =
@@ -79,6 +85,8 @@ api::enterprise_reporting_private::ContextInfo ToContextInfo(
               REALTIME_URL_CHECK_MODE_ENABLED_MAIN_FRAME;
       break;
   }
+#endif
+
   info.browser_version = signals.browser_version;
 
   return info;
diff --git a/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc b/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc
index c32321a8ed..f3ce4b7f5e 100644
--- a/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc
+++ b/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc
@@ -15,6 +15,10 @@
 
 namespace extensions {
 
+NetworkingPrivateDelegateFactory::UIDelegateFactory::UIDelegateFactory() {}
+
+NetworkingPrivateDelegateFactory::UIDelegateFactory::~UIDelegateFactory() {}
+
 NetworkingPrivateUIDelegateFactoryImpl::
     NetworkingPrivateUIDelegateFactoryImpl() {}
 
diff --git a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc
index 579d813e1b..b70366c0e3 100644
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_api.cc
@@ -22,10 +22,10 @@ using safe_browsing::SafeBrowsingNavigationObserverManager;
 namespace extensions {
 
 namespace {
-
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 // The number of user gestures we trace back for the referrer chain.
 const int kReferrerUserGestureLimit = 2;
-
+#endif
 }  // namespace
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -52,6 +52,7 @@ SafeBrowsingPrivateGetReferrerChainFunction::Run() {
         base::StringPrintf("Could not find tab with id %d.", params->tab_id)));
   }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   Profile* profile = Profile::FromBrowserContext(browser_context());
   if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile))
     return RespondNow(NoArguments());
@@ -86,6 +87,9 @@ SafeBrowsingPrivateGetReferrerChainFunction::Run() {
   return RespondNow(ArgumentList(
       api::safe_browsing_private::GetReferrerChain::Results::Create(
           referrer_entries)));
+#else
+  return RespondLater();
+#endif
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
index f860532891..60a8fdd25c 100644
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -71,6 +71,7 @@ const char kChromeBrowserCloudManagementClientDescription[] =
 #endif
 const char kProfilePolicyClientDescription[] = "a profile-level user";
 
+#if defined(FULL_SAFE_BROWSING)
 void AddAnalysisConnectorVerdictToEvent(
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     base::Value* event) {
@@ -101,6 +102,7 @@ std::string MalwareRuleToThreatType(const std::string& rule_name) {
     return "UNKNOWN";
   }
 }
+#endif // FULL_SAFE_BROWSING
 
 bool IsClientValid(const std::string& dm_token,
                    policy::CloudPolicyClient* client) {
@@ -236,6 +238,7 @@ void SafeBrowsingPrivateEventRouter::OnPolicySpecifiedPasswordReuseDetected(
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyPasswordReuseEvent) == 0) {
@@ -250,6 +253,8 @@ void SafeBrowsingPrivateEventRouter::OnPolicySpecifiedPasswordReuseDetected(
 
   ReportRealtimeEvent(kKeyPasswordReuseEvent, std::move(settings.value()),
                       std::move(event));
+#endif
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnPolicySpecifiedPasswordChanged(
@@ -305,6 +310,7 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDownloadOpened(
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -322,14 +328,18 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDownloadOpened(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, kTriggerFileDownload);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(
       kKeyEventResult,
       safe_browsing::EventResultToString(safe_browsing::EventResult::BYPASSED));
+#endif
   event.SetBoolKey(kKeyClickedThrough, true);
   event.SetStringKey(kKeyThreatType, DangerTypeToThreatType(danger_type));
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialShown(
@@ -357,6 +367,7 @@ void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialShown(
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyInterstitialEvent) == 0) {
@@ -379,6 +390,8 @@ void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialShown(
 
   ReportRealtimeEvent(kKeyInterstitialEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialProceeded(
@@ -406,6 +419,7 @@ void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialProceeded(
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyInterstitialEvent) == 0) {
@@ -418,12 +432,16 @@ void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialProceeded(
   event.SetIntKey(kKeyNetErrorCode, net_error_code);
   event.SetStringKey(kKeyProfileUserName, params.user_name);
   event.SetBoolKey(kKeyClickedThrough, true);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(
       kKeyEventResult,
       safe_browsing::EventResultToString(safe_browsing::EventResult::BYPASSED));
-
+#endif
   ReportRealtimeEvent(kKeyInterstitialEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorResult(
@@ -436,6 +454,8 @@ void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorResult(
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+
+#if defined(FULL_SAFE_BROWSING)
   if (result.tag() == "malware") {
     DCHECK_EQ(1, result.triggered_rules().size());
     OnDangerousDeepScanningResult(
@@ -447,6 +467,8 @@ void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorResult(
     OnSensitiveDataEvent(url, file_name, download_digest_sha256, mime_type,
                          trigger, result, content_size, event_result);
   }
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(
@@ -461,6 +483,8 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(
     const std::string& malware_family,
     const std::string& malware_category,
     const std::string& evidence_locker_filepath) {
+
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -479,8 +503,12 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, trigger);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(kKeyEventResult,
                      safe_browsing::EventResultToString(event_result));
+#endif
+
   event.SetBoolKey(kKeyClickedThrough,
                    event_result == safe_browsing::EventResult::BYPASSED);
   if (!malware_family.empty())
@@ -493,6 +521,8 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnSensitiveDataEvent(
@@ -504,6 +534,8 @@ void SafeBrowsingPrivateEventRouter::OnSensitiveDataEvent(
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeySensitiveDataEvent) == 0) {
@@ -521,8 +553,12 @@ void SafeBrowsingPrivateEventRouter::OnSensitiveDataEvent(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, trigger);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(kKeyEventResult,
                      safe_browsing::EventResultToString(event_result));
+#endif
+
   event.SetBoolKey(kKeyClickedThrough,
                    event_result == safe_browsing::EventResult::BYPASSED);
   if (!result.evidence_locker_filepath().empty()) {
@@ -534,6 +570,8 @@ void SafeBrowsingPrivateEventRouter::OnSensitiveDataEvent(
 
   ReportRealtimeEvent(kKeySensitiveDataEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorWarningBypassed(
@@ -545,6 +583,8 @@ void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorWarningBypassed(
     safe_browsing::DeepScanAccessPoint access_point,
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size) {
+
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeySensitiveDataEvent) == 0) {
@@ -562,9 +602,13 @@ void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorWarningBypassed(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, trigger);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(
       kKeyEventResult,
       safe_browsing::EventResultToString(safe_browsing::EventResult::BYPASSED));
+#endif
+
   event.SetBoolKey(kKeyClickedThrough, true);
   if (!result.evidence_locker_filepath().empty()) {
     event.SetStringKey(kKeyEvidenceLockerFilePath,
@@ -575,6 +619,8 @@ void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorWarningBypassed(
 
   ReportRealtimeEvent(kKeySensitiveDataEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
@@ -587,6 +633,8 @@ void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
     const std::string& reason,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyUnscannedFileEvent) == 0) {
@@ -605,13 +653,19 @@ void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, trigger);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(kKeyEventResult,
                      safe_browsing::EventResultToString(event_result));
+#endif
+
   event.SetBoolKey(kKeyClickedThrough,
                    event_result == safe_browsing::EventResult::BYPASSED);
 
   ReportRealtimeEvent(kKeyUnscannedFileEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDownloadEvent(
@@ -654,8 +708,11 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDownloadEvent(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, kTriggerFileDownload);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(kKeyEventResult,
                      safe_browsing::EventResultToString(event_result));
+#endif
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
@@ -680,6 +737,8 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDownloadWarningBypassed(
     const std::string& threat_type,
     const std::string& mime_type,
     const int64_t content_size) {
+
+#if defined(FULL_SAFE_BROWSING)
   auto settings = GetReportingSettings();
   if (!settings.has_value() ||
       settings->enabled_event_names.count(kKeyDangerousDownloadEvent) == 0) {
@@ -699,12 +758,17 @@ void SafeBrowsingPrivateEventRouter::OnDangerousDownloadWarningBypassed(
   if (content_size >= 0)
     event.SetIntKey(kKeyContentSize, content_size);
   event.SetStringKey(kKeyTrigger, kTriggerFileDownload);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   event.SetStringKey(
       kKeyEventResult,
       safe_browsing::EventResultToString(safe_browsing::EventResult::BYPASSED));
+#endif
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
+
 }
 
 // static
@@ -977,7 +1041,11 @@ void SafeBrowsingPrivateEventRouter::ReportRealtimeEvent(
 }
 
 std::string SafeBrowsingPrivateEventRouter::GetProfileUserName() const {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   return safe_browsing::GetProfileEmail(identity_manager_);
+#else
+  return "";
+#endif
 }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
diff --git a/chrome/browser/extensions/api/settings_private/generated_prefs.cc b/chrome/browser/extensions/api/settings_private/generated_prefs.cc
index f9704d6f06..3843913b15 100644
--- a/chrome/browser/extensions/api/settings_private/generated_prefs.cc
+++ b/chrome/browser/extensions/api/settings_private/generated_prefs.cc
@@ -15,6 +15,7 @@
 #include "chrome/browser/safe_browsing/generated_safe_browsing_pref.h"
 #include "chrome/common/extensions/api/settings_private.h"
 #include "components/content_settings/core/common/pref_names.h"
+#include "components/safe_browsing/buildflags.h"
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 #include "chrome/browser/extensions/api/settings_private/chromeos_resolve_time_zone_by_geolocation_method_short.h"
@@ -99,8 +100,10 @@ void GeneratedPrefs::CreatePrefs() {
           profile_);
   prefs_[kGeneratedPasswordLeakDetectionPref] =
       std::make_unique<GeneratedPasswordLeakDetectionPref>(profile_);
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   prefs_[safe_browsing::kGeneratedSafeBrowsingPref] =
       std::make_unique<safe_browsing::GeneratedSafeBrowsingPref>(profile_);
+#endif
   prefs_[content_settings::kGeneratedNotificationPref] =
       std::make_unique<content_settings::GeneratedNotificationPref>(profile_);
 }
diff --git a/chrome/browser/extensions/api/settings_private/prefs_util.cc b/chrome/browser/extensions/api/settings_private/prefs_util.cc
index 1a1294016d..626b8e1772 100644
--- a/chrome/browser/extensions/api/settings_private/prefs_util.cc
+++ b/chrome/browser/extensions/api/settings_private/prefs_util.cc
@@ -287,9 +287,10 @@ const PrefsUtil::TypedPrefMap& PrefsUtil::GetAllowlistedKeys() {
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
   (*s_allowlist)[::prefs::kSafeBrowsingScoutReportingEnabled] =
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   (*s_allowlist)[::safe_browsing::kGeneratedSafeBrowsingPref] =
       settings_api::PrefType::PREF_TYPE_NUMBER;
-
+#endif
   // Sync and personalization page.
   (*s_allowlist)[::prefs::kSearchSuggestEnabled] =
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
diff --git a/chrome/browser/extensions/api/tabs/windows_event_router.cc b/chrome/browser/extensions/api/tabs/windows_event_router.cc
index 734cefc15a..90c4c4e70e 100644
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,6 +164,8 @@ WindowsEventRouter::WindowsEventRouter(Profile* profile)
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
+#elif defined(OS_OHOS)
+  LOG(INFO) << "WindowsEventRouter::WindowsEventRouter TODO for OS_OHOS";
 #else
 #error Unsupported
 #endif
diff --git a/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc b/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
index d4cdfc2f5a..2675713312 100644
--- a/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
+++ b/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
@@ -42,6 +42,7 @@
 #include "components/prefs/pref_service.h"
 #include "components/prefs/scoped_user_pref_update.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/gpu_feature_checker.h"
 #include "content/public/browser/storage_partition.h"
 #include "content/public/browser/web_contents.h"
@@ -204,8 +205,10 @@ void ShowBlockedByParentDialog(const Extension* extension,
 
 #endif  // BUILDFLAG(ENABLE_SUPERVISED_USERS)
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 // The number of user gestures to trace back for the referrer chain.
 const int kExtensionReferrerUserGestureLimit = 2;
+#endif
 
 WebstoreInstaller::Delegate* test_webstore_installer_delegate = nullptr;
 
@@ -1098,6 +1101,7 @@ WebstorePrivateGetReferrerChainFunction::
 
 ExtensionFunction::ResponseAction
 WebstorePrivateGetReferrerChainFunction::Run() {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   Profile* profile = chrome_details_.GetProfile();
   if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile))
     return RespondNow(ArgumentList(
@@ -1143,6 +1147,9 @@ WebstorePrivateGetReferrerChainFunction::Run() {
   return RespondNow(
       ArgumentList(api::webstore_private::GetReferrerChain::Results::Create(
           serialized_referrer_proto)));
+#else
+  return RespondLater();
+#endif
 }
 
 WebstorePrivateGetExtensionStatusFunction::
diff --git a/chrome/browser/extensions/blocklist_state_fetcher.cc b/chrome/browser/extensions/blocklist_state_fetcher.cc
index fd18b0b520..36826b2da6 100644
--- a/chrome/browser/extensions/blocklist_state_fetcher.cc
+++ b/chrome/browser/extensions/blocklist_state_fetcher.cc
@@ -32,6 +32,7 @@ BlocklistStateFetcher::~BlocklistStateFetcher() {
 void BlocklistStateFetcher::Request(const std::string& id,
                                     RequestCallback callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!safe_browsing_config_) {
     if (g_browser_process && g_browser_process->safe_browsing_service()) {
       SetSafeBrowsingConfig(
@@ -57,6 +58,7 @@ void BlocklistStateFetcher::Request(const std::string& id,
           g_browser_process->safe_browsing_service()->GetURLLoaderFactory();
     }
   }
+#endif
 
   SendRequest(id);
 }
diff --git a/chrome/browser/extensions/extension_service.cc b/chrome/browser/extensions/extension_service.cc
index e41f860400..94c95543b5 100644
--- a/chrome/browser/extensions/extension_service.cc
+++ b/chrome/browser/extensions/extension_service.cc
@@ -150,6 +150,7 @@ const char* const kObsoleteComponentExtensionIds[] = {
     "ljoammodoonkhnehlncldjelhidljdpi"  // Genius
 };
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 void ReportExtensionDisabledRemotely(bool should_be_remotely_disabled,
                                      ExtensionUpdateCheckDataKey reason) {
   // Report that the extension is newly disabled due to Omaha attributes.
@@ -182,6 +183,7 @@ void ReportNoUpdateCheckKeys() {
   base::UmaHistogramEnumeration("Extensions.ExtensionDisabledRemotely",
                                 ExtensionUpdateCheckDataKey::kNoKey);
 }
+#endif
 
 void ReportReenableExtensionFromMalware() {
   base::UmaHistogramCounts100("Extensions.ExtensionReenabledRemotely", 1);
@@ -885,6 +887,7 @@ bool ExtensionService::IsExtensionEnabled(
   return extension_registrar_.IsExtensionEnabled(extension_id);
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 void ExtensionService::PerformActionBasedOnOmahaAttributes(
     const std::string& extension_id,
     const base::Value& attributes) {
@@ -925,6 +928,7 @@ void ExtensionService::HandleMalwareOmahaAttribute(
   // Show an error for the newly blocklisted extension.
   error_controller_->ShowErrorIfNeeded();
 }
+#endif
 
 void ExtensionService::MaybeEnableRemotelyDisabledExtension(
     const std::string& extension_id) {
diff --git a/chrome/browser/extensions/extension_service.h b/chrome/browser/extensions/extension_service.h
index 88c7c5968f..abeef88116 100644
--- a/chrome/browser/extensions/extension_service.h
+++ b/chrome/browser/extensions/extension_service.h
@@ -31,6 +31,7 @@
 #include "chrome/browser/profiles/profile_manager_observer.h"
 #include "chrome/browser/upgrade_detector/upgrade_observer.h"
 #include "components/sync/model/string_ordinal.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
 #include "extensions/browser/api/declarative_net_request/ruleset_install_pref.h"
@@ -274,9 +275,11 @@ class ExtensionService : public ExtensionServiceInterface,
   void RemoveDisableReasonAndMaybeEnable(const std::string& extension_id,
                                          disable_reason::DisableReason reason);
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Performs action based on Omaha attributes for the extension.
   void PerformActionBasedOnOmahaAttributes(const std::string& extension_id,
                                            const base::Value& attributes);
+#endif
 
   // Disables the extension. If the extension is already disabled, just adds
   // the |disable_reasons| (a bitmask of disable_reason::DisableReason - there
@@ -557,9 +560,11 @@ class ExtensionService : public ExtensionServiceInterface,
   // Helper method to determine if an extension can be blocked.
   bool CanBlockExtension(const Extension* extension) const;
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Handles the malware Omaha attribute for remotely disabled extensions.
   void HandleMalwareOmahaAttribute(const std::string& extension_id,
                                    const base::Value& attributes);
+#endif
 
   // Enables an extension that was only previously disabled remotely.
   void MaybeEnableRemotelyDisabledExtension(const std::string& extension_id);
diff --git a/chrome/browser/extensions/extension_system_impl.cc b/chrome/browser/extensions/extension_system_impl.cc
index e016a21fd0..e8ff8bf118 100644
--- a/chrome/browser/extensions/extension_system_impl.cc
+++ b/chrome/browser/extensions/extension_system_impl.cc
@@ -464,8 +464,12 @@ void ExtensionSystemImpl::InstallUpdate(
 void ExtensionSystemImpl::PerformActionBasedOnOmahaAttributes(
     const std::string& extension_id,
     const base::Value& attributes) {
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   extension_service()->PerformActionBasedOnOmahaAttributes(extension_id,
                                                            attributes);
+#endif
+
 }
 
 bool ExtensionSystemImpl::FinishDelayedInstallationIfReady(
diff --git a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
index 89317d47d3..92dc6e2f67 100644
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
@@ -25,7 +25,11 @@
 #include "chrome/browser/file_system_access/file_system_access_permission_context_factory.h"
 #include "chrome/browser/file_system_access/file_system_access_permission_request_manager.h"
 #include "chrome/browser/profiles/profile.h"
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "chrome/browser/safe_browsing/download_protection/download_protection_service.h"
+#endif
+
 #include "chrome/browser/ui/file_system_access_dialogs.h"
 #include "chrome/common/chrome_paths.h"
 #include "components/content_settings/core/browser/host_content_settings_map.h"
@@ -278,6 +282,7 @@ BindResultCallbackToCurrentSequence(
       base::SequencedTaskRunnerHandle::Get(), std::move(callback));
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 void DoSafeBrowsingCheckOnUIThread(
     content::GlobalFrameRoutingId frame_id,
     std::unique_ptr<content::FileSystemAccessWriteItem> item,
@@ -350,6 +355,7 @@ InterpretSafeBrowsingResult(safe_browsing::DownloadCheckResult result) {
   NOTREACHED();
   return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::kBlock;
 }
+#endif // SAFE_BROWSING_AVAILABLE
 
 std::string GenerateLastPickedDirectoryKey(const std::string& id) {
   return id.empty() ? kDefaultLastPickedDirectoryKey
@@ -825,6 +831,7 @@ void ChromeFileSystemAccessPermissionContext::ConfirmSensitiveDirectoryAccess(
                      std::move(callback)));
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 void ChromeFileSystemAccessPermissionContext::PerformAfterWriteChecks(
     std::unique_ptr<content::FileSystemAccessWriteItem> item,
     content::GlobalFrameRoutingId frame_id,
@@ -846,6 +853,7 @@ void ChromeFileSystemAccessPermissionContext::PerformAfterWriteChecks(
               },
               base::SequencedTaskRunnerHandle::Get(), std::move(callback))));
 }
+#endif
 
 void ChromeFileSystemAccessPermissionContext::
     DidConfirmSensitiveDirectoryAccess(
diff --git a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
index ec5c2bc932..ddc69f1419 100644
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
@@ -12,6 +12,7 @@
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/permissions/permission_util.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/file_system_access_permission_context.h"
 #include "third_party/blink/public/mojom/permissions/permission_status.mojom.h"
 
@@ -63,10 +64,14 @@ class ChromeFileSystemAccessPermissionContext
       HandleType handle_type,
       content::GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) override;
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   void PerformAfterWriteChecks(
       std::unique_ptr<content::FileSystemAccessWriteItem> item,
       content::GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(AfterWriteCheckResult)> callback) override;
+#endif
+
   bool CanObtainReadPermission(const url::Origin& origin) override;
   bool CanObtainWritePermission(const url::Origin& origin) override;
 
diff --git a/chrome/browser/first_run/first_run.cc b/chrome/browser/first_run/first_run.cc
index 3127164f14..d8f5c2212c 100644
--- a/chrome/browser/first_run/first_run.cc
+++ b/chrome/browser/first_run/first_run.cc
@@ -278,7 +278,7 @@ void SetupInitialPrefsFromInstallPrefs(
 
 // -- Platform-specific functions --
 
-#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_BSD)
+#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_BSD) && !defined(OS_OHOS)
 bool IsOrganicFirstRun() {
   std::string brand;
   google_brand::GetBrand(&brand);
diff --git a/chrome/browser/first_run/first_run_dialog.h b/chrome/browser/first_run/first_run_dialog.h
index ba4a13b672..e3a09a8dbe 100644
--- a/chrome/browser/first_run/first_run_dialog.h
+++ b/chrome/browser/first_run/first_run_dialog.h
@@ -12,7 +12,7 @@
 // Hide this function on platforms where the dialog does not exist.
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_MAC) || (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
+#if defined(OS_MAC) || (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 
 class Profile;
 
diff --git a/chrome/browser/first_run/first_run_internal_posix.cc b/chrome/browser/first_run/first_run_internal_posix.cc
index c9f8852839..c1908fd6fd 100644
--- a/chrome/browser/first_run/first_run_internal_posix.cc
+++ b/chrome/browser/first_run/first_run_internal_posix.cc
@@ -46,7 +46,7 @@ enum class ForcedShowDialogState {
 ForcedShowDialogState g_forced_show_dialog_state =
     ForcedShowDialogState::kNotForced;
 
-#if !BUILDFLAG(IS_CHROMEOS_ASH)
+#if !BUILDFLAG(IS_CHROMEOS_ASH) && !defined(OS_OHOS)
 // Returns whether the first run dialog should be shown. This is only true for
 // certain builds, and only if the user has not already set preferences. In a
 // real, official-build first run, initializes the default metrics reporting if
@@ -97,7 +97,7 @@ void ForceFirstRunDialogShownForTesting(bool shown) {
 }
 
 void DoPostImportPlatformSpecificTasks(Profile* profile) {
-#if !BUILDFLAG(IS_CHROMEOS_ASH)
+#if !BUILDFLAG(IS_CHROMEOS_ASH) && !defined(OS_OHOS)
   if (!ShouldShowFirstRunDialog())
     return;
 
diff --git a/chrome/browser/font_access/chrome_font_access_delegate.cc b/chrome/browser/font_access/chrome_font_access_delegate.cc
index 7262851220..b7f1328045 100644
--- a/chrome/browser/font_access/chrome_font_access_delegate.cc
+++ b/chrome/browser/font_access/chrome_font_access_delegate.cc
@@ -20,7 +20,12 @@ ChromeFontAccessDelegate::RunChooser(
   // TODO(crbug.com/1151464): Decide whether or not to extend/refactor the
   // bubble view launched by chrome::ShowDeviceChooserDialog() or build a new
   // one.
+#if !defined(OS_OHOS)
   return std::make_unique<FontAccessChooser>(chrome::ShowDeviceChooserDialog(
       frame, std::make_unique<FontAccessChooserController>(
                  frame, selection, std::move(callback))));
+#else
+  LOG(INFO) << "ChromeFontAccessDelegate::RunChooser TODO for OS_OHOS";
+  return nullptr;
+#endif
 }
diff --git a/chrome/browser/hid/chrome_hid_delegate.cc b/chrome/browser/hid/chrome_hid_delegate.cc
index 671000bc7c..464dff397e 100644
--- a/chrome/browser/hid/chrome_hid_delegate.cc
+++ b/chrome/browser/hid/chrome_hid_delegate.cc
@@ -40,9 +40,14 @@ std::unique_ptr<content::HidChooser> ChromeHidDelegate::RunChooser(
   if (!permission_observer_.IsObservingSources())
     permission_observer_.Add(chooser_context);
 
+#if !defined(OS_OHOS)
   return std::make_unique<HidChooser>(chrome::ShowDeviceChooserDialog(
       frame, std::make_unique<HidChooserController>(frame, std::move(filters),
                                                     std::move(callback))));
+#else
+  LOG(INFO) << "ChromeHidDelegate::RunChooser TODO for OS_OHOS";
+  return nullptr;
+#endif
 }
 
 bool ChromeHidDelegate::CanRequestDevicePermission(
diff --git a/chrome/browser/intranet_redirect_detector.h b/chrome/browser/intranet_redirect_detector.h
index 19a86ab0ca..df63b8315d 100644
--- a/chrome/browser/intranet_redirect_detector.h
+++ b/chrome/browser/intranet_redirect_detector.h
@@ -28,7 +28,7 @@ class SimpleURLLoader;
 class PrefRegistrySimple;
 
 #if !(defined(OS_MAC) || defined(OS_WIN) || defined(OS_LINUX) || \
-      defined(OS_CHROMEOS))
+      defined(OS_CHROMEOS) || defined(OS_OHOS))
 #error "IntranetRedirectDetector should only be built on Desktop platforms."
 #endif
 
diff --git a/chrome/browser/media/router/discovery/discovery_network_list_posix.cc b/chrome/browser/media/router/discovery/discovery_network_list_posix.cc
index 6bae32098d..443f01efdc 100644
--- a/chrome/browser/media/router/discovery/discovery_network_list_posix.cc
+++ b/chrome/browser/media/router/discovery/discovery_network_list_posix.cc
@@ -40,6 +40,7 @@ using sll = struct sockaddr_dl;
 #define SOCKET_ADDRESS(s) (LLADDR(s))
 #endif
 
+#if !defined(OS_OHOS)
 void GetDiscoveryNetworkInfoListImpl(
     const struct ifaddrs* if_list,
     std::vector<DiscoveryNetworkInfo>* network_info_list) {
@@ -88,12 +89,14 @@ void GetDiscoveryNetworkInfoListImpl(
                                SOCKET_ADDRESS_LEN(ll_addr))});
   }
 }
+#endif
 
 }  // namespace
 
 std::vector<DiscoveryNetworkInfo> GetDiscoveryNetworkInfoList() {
   std::vector<DiscoveryNetworkInfo> network_ids;
 
+#if !defined(OS_OHOS)
   struct ifaddrs* if_list;
   if (getifaddrs(&if_list)) {
     return network_ids;
@@ -102,6 +105,9 @@ std::vector<DiscoveryNetworkInfo> GetDiscoveryNetworkInfoList() {
   GetDiscoveryNetworkInfoListImpl(if_list, &network_ids);
   StableSortDiscoveryNetworkInfo(network_ids.begin(), network_ids.end());
   freeifaddrs(if_list);
+#else
+  LOG(INFO) << "GetDiscoveryNetworkInfoList TODO in OS_OHOS";
+#endif
   return network_ids;
 }
 
diff --git a/chrome/browser/media/webrtc/display_media_access_handler.cc b/chrome/browser/media/webrtc/display_media_access_handler.cc
index 73e1390ca2..38f283718c 100644
--- a/chrome/browser/media/webrtc/display_media_access_handler.cc
+++ b/chrome/browser/media/webrtc/display_media_access_handler.cc
@@ -107,6 +107,7 @@ void DisplayMediaAccessHandler::HandleRequest(
     return;
   }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -121,6 +122,7 @@ void DisplayMediaAccessHandler::HandleRequest(
     observer->OnDesktopCaptureRequest();
     return;
   }
+#endif
 
 #if defined(OS_MAC)
   // Do not allow picker UI to be shown on a page that isn't in the foreground
diff --git a/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc b/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
index b8f2ec4114..cef108c8ac 100644
--- a/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
+++ b/chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
@@ -43,6 +43,8 @@ const char kProduct[] = "Chrome_ChromeOS";
 const char kProduct[] = "Chrome_Linux";
 #elif defined(OS_ANDROID)
 const char kProduct[] = "Chrome_Android";
+#elif defined(OS_OHOS)
+const char kProduct[] = "Chrome_Ohos";
 #else
 #error Platform not supported.
 #endif
diff --git a/chrome/browser/media/webrtc/webrtc_log_uploader.cc b/chrome/browser/media/webrtc/webrtc_log_uploader.cc
index bb05781a99..747f4e2d5f 100644
--- a/chrome/browser/media/webrtc/webrtc_log_uploader.cc
+++ b/chrome/browser/media/webrtc/webrtc_log_uploader.cc
@@ -360,6 +360,8 @@ void WebRtcLogUploader::SetupMultipart(
   const char product[] = "Chrome_Android";
 #elif BUILDFLAG(IS_CHROMEOS_ASH)
   const char product[] = "Chrome_ChromeOS";
+#elif defined(OS_OHOS)
+  const char product[] = "Chrome_Ohos";
 #else
 #error Platform not supported.
 #endif
diff --git a/chrome/browser/metrics/chrome_metrics_service_client.cc b/chrome/browser/metrics/chrome_metrics_service_client.cc
index 52c6a8e9b1..4e5e9a4c4d 100644
--- a/chrome/browser/metrics/chrome_metrics_service_client.cc
+++ b/chrome/browser/metrics/chrome_metrics_service_client.cc
@@ -800,8 +800,10 @@ void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<HttpsEngagementMetricsProvider>());
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<CertificateReportingMetricsProvider>());
+#endif
 
 #if !defined(OS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
   metrics_service_->RegisterMetricsProvider(
diff --git a/chrome/browser/net/profile_network_context_service.cc b/chrome/browser/net/profile_network_context_service.cc
index f0a12b07c4..339024e0d2 100644
--- a/chrome/browser/net/profile_network_context_service.cc
+++ b/chrome/browser/net/profile_network_context_service.cc
@@ -608,6 +608,9 @@ ProfileNetworkContextService::CreateClientCertStore() {
   // cert matching is done by the OS as part of the call to show the cert
   // selection dialog.
   return nullptr;
+#elif defined(OS_OHOS)
+  LOG(ERROR) << "ProfileNetworkContextService::CreateClientCertStore TODO for OS_OHOS";
+  return nullptr;
 #else
 #error Unknown platform.
 #endif
diff --git a/chrome/browser/notifications/notification_display_service_impl.cc b/chrome/browser/notifications/notification_display_service_impl.cc
index c50c2208e6..995f3c4631 100644
--- a/chrome/browser/notifications/notification_display_service_impl.cc
+++ b/chrome/browser/notifications/notification_display_service_impl.cc
@@ -29,7 +29,7 @@
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN)
+    defined(OS_WIN) || defined(OS_OHOS)
 #include "chrome/browser/send_tab_to_self/desktop_notification_handler.h"
 #include "chrome/browser/sharing/sharing_notification_handler.h"
 #endif
diff --git a/chrome/browser/password_manager/chrome_password_manager_client.cc b/chrome/browser/password_manager/chrome_password_manager_client.cc
index 5bccfec4e1..cbf20266f8 100644
--- a/chrome/browser/password_manager/chrome_password_manager_client.cc
+++ b/chrome/browser/password_manager/chrome_password_manager_client.cc
@@ -249,10 +249,11 @@ void ChromePasswordManagerClient::CreateForWebContentsWithAutofillClient(
     autofill::AutofillClient* autofill_client) {
   if (FromWebContents(contents))
     return;
-
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   contents->SetUserData(UserDataKey(),
                         base::WrapUnique(new ChromePasswordManagerClient(
                             contents, autofill_client)));
+#endif
 }
 
 ChromePasswordManagerClient::~ChromePasswordManagerClient() = default;
@@ -793,16 +794,22 @@ autofill::LanguageCode ChromePasswordManagerClient::GetPageLanguage() const {
   return autofill::LanguageCode();
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 safe_browsing::PasswordProtectionService*
 ChromePasswordManagerClient::GetPasswordProtectionService() const {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   return safe_browsing::ChromePasswordProtectionService::
       GetPasswordProtectionService(profile_);
+#else
+  return nullptr;
+#endif
 }
 
 #if defined(ON_FOCUS_PING_ENABLED)
 void ChromePasswordManagerClient::CheckSafeBrowsingReputation(
     const GURL& form_action,
     const GURL& frame_url) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::PasswordProtectionService* pps =
       GetPasswordProtectionService();
   if (pps) {
@@ -810,6 +817,7 @@ void ChromePasswordManagerClient::CheckSafeBrowsingReputation(
         web_contents(), web_contents()->GetLastCommittedURL(), form_action,
         frame_url, pps->GetAccountInfo().hosted_domain);
   }
+#endif  // BUILDFLAG(FULL_SAFE_BROWSING)
 }
 #endif  // defined(ON_FOCUS_PING_ENABLED)
 
@@ -819,6 +827,7 @@ void ChromePasswordManagerClient::CheckProtectedPasswordEntry(
     const std::vector<password_manager::MatchingReusedCredential>&
         matching_reused_credentials,
     bool password_field_exists) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::PasswordProtectionService* pps =
       GetPasswordProtectionService();
   if (!pps)
@@ -827,14 +836,18 @@ void ChromePasswordManagerClient::CheckProtectedPasswordEntry(
   pps->MaybeStartProtectedPasswordEntryRequest(
       web_contents(), web_contents()->GetLastCommittedURL(), username,
       password_type, matching_reused_credentials, password_field_exists);
+#endif
 }
+#endif // BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 
 void ChromePasswordManagerClient::LogPasswordReuseDetectedEvent() {
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::PasswordProtectionService* pps =
       GetPasswordProtectionService();
   if (pps) {
     pps->MaybeLogPasswordReuseDetectedEvent(web_contents());
   }
+#endif
 }
 
 ukm::SourceId ChromePasswordManagerClient::GetUkmSourceId() {
@@ -1274,6 +1287,7 @@ void ChromePasswordManagerClient::OnPaste() {
   }
 #endif
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!used_crosapi_workaround) {
     ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
     // Given that this clipboard data read happens in the background and not
@@ -1284,7 +1298,8 @@ void ChromePasswordManagerClient::OnPaste() {
         ui::EndpointType::kDefault, /*notify_if_restricted=*/false);
     clipboard->ReadText(ui::ClipboardBuffer::kCopyPaste, &data_dst, &text);
   }
-
+#endif
+  used_crosapi_workaround = false;
   was_on_paste_called_ = true;
   password_reuse_detection_manager_.OnPaste(std::move(text));
 }
@@ -1316,6 +1331,7 @@ void ChromePasswordManagerClient::OnInputEvent(
 #else   // !defined(OS_ANDROID)
   if (event.GetType() != blink::WebInputEvent::Type::kChar)
     return;
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   const blink::WebKeyboardEvent& key_event =
       static_cast<const blink::WebKeyboardEvent&>(event);
   // Key & 0x1f corresponds to the value of the key when either the control or
@@ -1325,6 +1341,7 @@ void ChromePasswordManagerClient::OnInputEvent(
   } else {
     password_reuse_detection_manager_.OnKeyPressedCommitted(key_event.text);
   }
+#endif  // full_safe_browsing
 #endif  // defined(OS_ANDROID)
 }
 
@@ -1362,6 +1379,7 @@ bool ChromePasswordManagerClient::IsPasswordManagementEnabledForCurrentPage(
     is_enabled = false;
   }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Disable password
@@ -1372,6 +1390,7 @@ bool ChromePasswordManagerClient::IsPasswordManagementEnabledForCurrentPage(
     observer->OnPasswordSaveOrAutofillDenied();
     is_enabled = false;
   }
+#endif
 
   if (log_manager_->IsLoggingActive()) {
     password_manager::BrowserSavePasswordProgressLogger logger(
diff --git a/chrome/browser/password_manager/chrome_password_manager_client.h b/chrome/browser/password_manager/chrome_password_manager_client.h
index f56c171960..dc2426521c 100644
--- a/chrome/browser/password_manager/chrome_password_manager_client.h
+++ b/chrome/browser/password_manager/chrome_password_manager_client.h
@@ -189,6 +189,7 @@ class ChromePasswordManagerClient
   void AnnotateNavigationEntry(bool has_password_field) override;
   autofill::LanguageCode GetPageLanguage() const override;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::PasswordProtectionService* GetPasswordProtectionService()
       const override;
 
@@ -202,7 +203,8 @@ class ChromePasswordManagerClient
       const std::string& username,
       const std::vector<password_manager::MatchingReusedCredential>&
           matching_reused_credentials,
-      bool password_field_exists) override;
+      bool password_field_exists);
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   void LogPasswordReuseDetectedEvent() override;
 
diff --git a/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc b/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
index 511d4d5a1a..8eb8175fdd 100644
--- a/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
+++ b/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
@@ -16,7 +16,12 @@
 #include "components/permissions/permission_uma_util.h"
 #include "components/permissions/permissions_client.h"
 #include "components/prefs/pref_service.h"
+#include "components/safe_browsing/buildflags.h"
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#endif
+
 #include "components/safe_browsing/core/db/database_manager.h"
 
 namespace {
@@ -76,6 +81,7 @@ void SetOriginStatus(Profile* profile,
           base::WrapUnique(dict.DeepCopy()));
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void RevokePermission(const GURL& origin, Profile* profile) {
   permissions::PermissionsClient::Get()
       ->GetSettingsMap(profile)
@@ -91,6 +97,7 @@ void RevokePermission(const GURL& origin, Profile* profile) {
       ContentSettingsType::NOTIFICATIONS,
       permissions::PermissionSourceUI::AUTO_REVOCATION, origin, profile);
 }
+#endif
 }  // namespace
 
 AbusiveOriginPermissionRevocationRequest::
@@ -136,6 +143,7 @@ void AbusiveOriginPermissionRevocationRequest::CheckAndRevokeIfAbusive() {
   DCHECK(profile_);
   DCHECK(callback_);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!AbusiveOriginNotificationsPermissionRevocationConfig::IsEnabled() ||
       !safe_browsing::IsSafeBrowsingEnabled(*profile_->GetPrefs()) ||
       IsOriginExemptedFromFutureRevocations(profile_, origin_)) {
@@ -169,6 +177,7 @@ void AbusiveOriginPermissionRevocationRequest::OnSiteReputationReady(
            CrowdDenyPreloadData::SiteReputation::ABUSIVE_PROMPTS ||
        site_reputation->notification_ux_quality() ==
            CrowdDenyPreloadData::SiteReputation::ABUSIVE_CONTENT)) {
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
     DCHECK(g_browser_process->safe_browsing_service());
 
     if (g_browser_process->safe_browsing_service()) {
@@ -180,12 +189,16 @@ void AbusiveOriginPermissionRevocationRequest::OnSiteReputationReady(
                          weak_factory_.GetWeakPtr()));
       return;
     }
+  #endif
   }
   NotifyCallback(Outcome::PERMISSION_NOT_REVOKED);
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
+
 }
 
 void AbusiveOriginPermissionRevocationRequest::OnSafeBrowsingVerdictReceived(
     CrowdDenySafeBrowsingRequest::Verdict verdict) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   DCHECK(safe_browsing_request_);
   DCHECK(profile_);
   DCHECK(callback_);
@@ -196,6 +209,7 @@ void AbusiveOriginPermissionRevocationRequest::OnSafeBrowsingVerdictReceived(
   } else {
     NotifyCallback(Outcome::PERMISSION_NOT_REVOKED);
   }
+#endif
 }
 
 void AbusiveOriginPermissionRevocationRequest::NotifyCallback(Outcome outcome) {
diff --git a/chrome/browser/permissions/abusive_origin_permission_revocation_request.h b/chrome/browser/permissions/abusive_origin_permission_revocation_request.h
index be61d528f0..177ff742e3 100644
--- a/chrome/browser/permissions/abusive_origin_permission_revocation_request.h
+++ b/chrome/browser/permissions/abusive_origin_permission_revocation_request.h
@@ -10,6 +10,7 @@
 #include "chrome/browser/permissions/crowd_deny_preload_data.h"
 #include "chrome/browser/permissions/crowd_deny_safe_browsing_request.h"
 #include "url/gurl.h"
+#include "components/safe_browsing/buildflags.h"
 
 class Profile;
 enum class ContentSettingsType;
@@ -62,8 +63,9 @@ class AbusiveOriginPermissionRevocationRequest {
   void OnSafeBrowsingVerdictReceived(
       CrowdDenySafeBrowsingRequest::Verdict verdict);
   void NotifyCallback(Outcome outcome);
-
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   base::Optional<CrowdDenySafeBrowsingRequest> safe_browsing_request_;
+#endif
   Profile* profile_;
   const GURL origin_;
   OutcomeCallback callback_;
diff --git a/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc b/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
index 97ceabe5fa..13437faabd 100644
--- a/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
+++ b/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
@@ -21,6 +21,7 @@
 #include "chrome/common/chrome_features.h"
 #include "components/permissions/permission_request.h"
 #include "components/safe_browsing/core/db/database_manager.h"
+#include "components/safe_browsing/buildflags.h"
 
 namespace {
 
@@ -107,6 +108,7 @@ base::Optional<Decision> GetDecisionBasedOnSiteReputation(
   return base::nullopt;
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 // Roll the dice to decide whether to use the normal UI even when the preload
 // data indicates that quiet UI should be used. This creates a control group of
 // normal UI prompt impressions, which facilitates comparing acceptance rates,
@@ -126,6 +128,7 @@ bool ShouldHoldBackQuietUI(QuietUiReason quiet_ui_reason) {
   base::UmaHistogramBoolean("Permissions.CrowdDeny.DidHoldbackQuietUi", result);
   return result;
 }
+#endif
 
 }  // namespace
 
@@ -150,9 +153,11 @@ void ContextualNotificationPermissionUiSelector::SelectUiToUse(
 }
 
 void ContextualNotificationPermissionUiSelector::Cancel() {
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // The computation either finishes synchronously above, or is waiting on the
   // Safe Browsing check.
   safe_browsing_request_.reset();
+#endif
 }
 
 ContextualNotificationPermissionUiSelector::
@@ -177,9 +182,11 @@ void ContextualNotificationPermissionUiSelector::OnSiteReputationReady(
   // Browsing to verify; but do not ping if it is not warranted.
   if (!decision || (!decision->quiet_ui_reason && !decision->warning_reason)) {
     Notify(Decision::UseNormalUiAndShowNoWarning());
-    return;
+  } else {
+    Notify(decision.value());
   }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   DCHECK(!safe_browsing_request_);
   DCHECK(g_browser_process->safe_browsing_service());
 
@@ -191,11 +198,13 @@ void ContextualNotificationPermissionUiSelector::OnSiteReputationReady(
       base::BindOnce(&ContextualNotificationPermissionUiSelector::
                          OnSafeBrowsingVerdictReceived,
                      base::Unretained(this), *decision));
+#endif
 }
 
 void ContextualNotificationPermissionUiSelector::OnSafeBrowsingVerdictReceived(
     Decision candidate_decision,
     CrowdDenySafeBrowsingRequest::Verdict verdict) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   DCHECK(safe_browsing_request_);
   DCHECK(callback_);
 
@@ -213,6 +222,7 @@ void ContextualNotificationPermissionUiSelector::OnSafeBrowsingVerdictReceived(
       Notify(candidate_decision);
       break;
   }
+#endif
 }
 
 void ContextualNotificationPermissionUiSelector::Notify(
diff --git a/chrome/browser/permissions/contextual_notification_permission_ui_selector.h b/chrome/browser/permissions/contextual_notification_permission_ui_selector.h
index a940831e80..32265ed9e0 100644
--- a/chrome/browser/permissions/contextual_notification_permission_ui_selector.h
+++ b/chrome/browser/permissions/contextual_notification_permission_ui_selector.h
@@ -10,6 +10,7 @@
 #include "chrome/browser/permissions/crowd_deny_preload_data.h"
 #include "chrome/browser/permissions/crowd_deny_safe_browsing_request.h"
 #include "components/permissions/notification_permission_ui_selector.h"
+#include "components/safe_browsing/buildflags.h"
 
 namespace permissions {
 class PermissionRequest;
@@ -55,8 +56,9 @@ class ContextualNotificationPermissionUiSelector
   void OnSiteReputationReady(
       const url::Origin& origin,
       const CrowdDenyPreloadData::SiteReputation* reputation);
-
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   base::Optional<CrowdDenySafeBrowsingRequest> safe_browsing_request_;
+#endif
   DecisionMadeCallback callback_;
   base::WeakPtrFactory<ContextualNotificationPermissionUiSelector>
       weak_factory_{this};
diff --git a/chrome/browser/permissions/prediction_based_permission_ui_selector.cc b/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
index d2e6710e42..54ae60306e 100644
--- a/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
+++ b/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
@@ -20,6 +20,7 @@
 #include "components/permissions/prediction_service/prediction_service_messages.pb.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
+#include "components/safe_browsing/buildflags.h"
 
 namespace {
 
@@ -181,9 +182,16 @@ void PredictionBasedPermissionUiSelector::LookupReponseReceived(
 bool PredictionBasedPermissionUiSelector::IsAllowedToUseAssistedPrompts() {
   // We need to also check `kQuietNotificationPrompts` here since there is no
   // generic safeguard anywhere else in the stack.
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   return base::FeatureList::IsEnabled(features::kQuietNotificationPrompts) &&
          base::FeatureList::IsEnabled(features::kPermissionPredictions) &&
          safe_browsing::IsSafeBrowsingEnabled(*(profile_->GetPrefs()));
+#else
+  return base::FeatureList::IsEnabled(features::kQuietNotificationPrompts) &&
+         base::FeatureList::IsEnabled(features::kPermissionPredictions);
+#endif
+
 }
 
 // static
diff --git a/chrome/browser/platform_util_linux.cc b/chrome/browser/platform_util_linux.cc
index cbe3372144..7ce0722c14 100644
--- a/chrome/browser/platform_util_linux.cc
+++ b/chrome/browser/platform_util_linux.cc
@@ -13,14 +13,18 @@
 #include "base/threading/scoped_blocking_call.h"
 #include "chrome/browser/chrome_notification_types.h"
 #include "chrome/browser/platform_util_internal.h"
+#if !defined(OS_OHOS)
 #include "components/dbus/thread_linux/dbus_thread_linux.h"
+#endif
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
 #include "content/public/browser/notification_service.h"
+#if !defined(OS_OHOS)
 #include "dbus/bus.h"
 #include "dbus/message.h"
 #include "dbus/object_proxy.h"
+#endif
 #include "url/gurl.h"
 
 using content::BrowserThread;
@@ -29,10 +33,12 @@ namespace platform_util {
 
 namespace {
 
+#if !defined(OS_OHOS)
 const char kFreedesktopFileManagerName[] = "org.freedesktop.FileManager1";
 const char kFreedesktopFileManagerPath[] = "/org/freedesktop/FileManager1";
 
 const char kMethodShowItems[] = "ShowItems";
+#endif
 
 class ShowItemHelper : public content::NotificationObserver {
  public:
@@ -54,14 +60,17 @@ class ShowItemHelper : public content::NotificationObserver {
                const content::NotificationDetails& details) override {
     DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
     DCHECK_EQ(chrome::NOTIFICATION_APP_TERMINATING, type);
+#if !defined(OS_OHOS)
     // The browser process is about to exit. Clean up while we still can.
     if (bus_)
       bus_->ShutdownOnDBusThreadAndBlock();
     bus_.reset();
     filemanager_proxy_ = nullptr;
+#endif
   }
 
   void ShowItemInFolder(Profile* profile, const base::FilePath& full_path) {
+  #if !defined(OS_OHOS)
     if (!bus_) {
       // Sets up the D-Bus connection.
       dbus::Bus::Options bus_options;
@@ -94,9 +103,11 @@ class ShowItemHelper : public content::NotificationObserver {
         &show_items_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT,
         base::BindOnce(&ShowItemHelper::ShowItemInFolderResponse,
                        weak_ptr_factory_.GetWeakPtr(), profile, full_path));
+  #endif
   }
 
  private:
+#if !defined(OS_OHOS)
   void ShowItemInFolderResponse(Profile* profile,
                                 const base::FilePath& full_path,
                                 dbus::Response* response) {
@@ -108,12 +119,12 @@ class ShowItemHelper : public content::NotificationObserver {
     OpenItem(profile, full_path.DirName(), OPEN_FOLDER,
              OpenOperationCallback());
   }
-
+#endif
   content::NotificationRegistrar registrar_;
-
+#if !defined(OS_OHOS)
   scoped_refptr<dbus::Bus> bus_;
   dbus::ObjectProxy* filemanager_proxy_ = nullptr;
-
+#endif
   base::WeakPtrFactory<ShowItemHelper> weak_ptr_factory_{this};
 };
 
diff --git a/chrome/browser/plugins/plugins_resource_service.cc b/chrome/browser/plugins/plugins_resource_service.cc
index dea3c4fc49..fae48278c3 100644
--- a/chrome/browser/plugins/plugins_resource_service.cc
+++ b/chrome/browser/plugins/plugins_resource_service.cc
@@ -66,6 +66,8 @@ GURL GetPluginsServerURL() {
   filename = "plugins_linux.json";
 #elif defined(OS_MAC)
   filename = "plugins_mac.json";
+#elif defined(OS_OHOS)
+  filename = "plugins_linux.json";
 #else
 #error Unknown platform
 #endif
diff --git a/chrome/browser/policy/BUILD.gn b/chrome/browser/policy/BUILD.gn
index 4093dac5b3..c2d7ad07dd 100644
--- a/chrome/browser/policy/BUILD.gn
+++ b/chrome/browser/policy/BUILD.gn
@@ -7,7 +7,7 @@ import("//build/config/features.gni")
 source_set("path_parser") {
   sources = [ "policy_path_parser.h" ]
 
-  if (is_chromeos || is_linux) {
+  if (is_chromeos || is_linux || is_ohos) {
     sources += [ "policy_path_parser_linux.cc" ]
   } else if (is_mac) {
     sources += [ "policy_path_parser_mac.mm" ]
diff --git a/chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc b/chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc
index a369688941..4163f26fd0 100644
--- a/chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc
+++ b/chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc
@@ -43,7 +43,7 @@
 #include "chrome/browser/policy/browser_dm_token_storage_mac.h"
 #endif  // defined(OS_MAC)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "chrome/browser/policy/browser_dm_token_storage_linux.h"
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
@@ -75,7 +75,7 @@ void ChromeBrowserCloudManagementControllerDesktop::
 
 #if defined(OS_MAC)
   storage_delegate = std::make_unique<BrowserDMTokenStorageMac>();
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   storage_delegate = std::make_unique<BrowserDMTokenStorageLinux>();
 #elif defined(OS_WIN)
   storage_delegate = std::make_unique<BrowserDMTokenStorageWin>();
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
index cb44a0300e..40e028eb42 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -270,7 +270,9 @@ void ChromeBrowserMainExtraPartsProfiles::
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   CertificateReportingServiceFactory::GetInstance();
+#endif
 #if !defined(OS_ANDROID)
   ChromeBrowsingDataLifetimeManagerFactory::GetInstance();
 #endif
diff --git a/chrome/browser/profiles/profile_impl.cc b/chrome/browser/profiles/profile_impl.cc
index f75b19f9ed..1b04a1e6a2 100644
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -628,6 +628,7 @@ void ProfileImpl::LoadPrefsForNormalStartup(bool async_prefs) {
 
   mojo::PendingRemote<prefs::mojom::TrackedPreferenceValidationDelegate>
       pref_validation_delegate;
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service(
       g_browser_process->safe_browsing_service());
   if (safe_browsing_service.get()) {
@@ -639,6 +640,7 @@ void ProfileImpl::LoadPrefsForNormalStartup(bool async_prefs) {
           pref_validation_delegate.InitWithNewPipeAndPassReceiver());
     }
   }
+#endif
 
   prefs_ =
       CreatePrefService(pref_registry_, CreateExtensionPrefStore(this, false),
diff --git a/chrome/browser/profiles/profiles_state.cc b/chrome/browser/profiles/profiles_state.cc
index 7aea889587..a5e8e56016 100644
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -316,6 +316,7 @@ bool SetActiveProfileToGuestIfLocked() {
 #endif  // !BUILDFLAG(IS_CHROMEOS_ASH)
 
 void RemoveBrowsingDataForProfile(const base::FilePath& profile_path) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // The BrowsingDataRemover relies on many objects that aren't created in unit
   // tests. Previously this code would depend on content::ResourceDispatcherHost
   // but that's gone, so do a similar hack for now.
@@ -332,6 +333,7 @@ void RemoveBrowsingDataForProfile(const base::FilePath& profile_path) {
     profile = profile->GetPrimaryOTRProfile();
 
   profile->Wipe();
+#endif
 }
 
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
diff --git a/chrome/browser/reputation/reputation_service.cc b/chrome/browser/reputation/reputation_service.cc
index 69a20d735d..e595f61973 100644
--- a/chrome/browser/reputation/reputation_service.cc
+++ b/chrome/browser/reputation/reputation_service.cc
@@ -119,6 +119,7 @@ void ReputationService::GetReputationStatus(const GURL& url,
                                             ReputationCheckCallback callback) {
   DCHECK(url.SchemeIsHTTPOrHTTPS());
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   bool has_delayed_warning =
       !!safe_browsing::SafeBrowsingUserInteractionObserver::FromWebContents(
           web_contents);
@@ -136,6 +137,7 @@ void ReputationService::GetReputationStatus(const GURL& url,
   GetReputationStatusWithEngagedSites(url, has_delayed_warning,
                                       std::move(callback),
                                       service->GetLatestEngagedSites());
+#endif
 }
 
 bool ReputationService::IsIgnored(const GURL& url) const {
diff --git a/chrome/browser/safe_browsing/chrome_password_protection_service.h b/chrome/browser/safe_browsing/chrome_password_protection_service.h
index 678746f2d5..3e6f64feef 100644
--- a/chrome/browser/safe_browsing/chrome_password_protection_service.h
+++ b/chrome/browser/safe_browsing/chrome_password_protection_service.h
@@ -213,8 +213,13 @@ class ChromePasswordProtectionService : public PasswordProtectionService,
   // policy, this function should always return PHISHING_REUSE. Otherwise,
   // returns the specified pref value adjusted for the given username's account
   // type.
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   PasswordProtectionTrigger GetPasswordProtectionWarningTriggerPref(
       ReusedPasswordAccountType password_type) const override;
+#else
+  PasswordProtectionTrigger GetPasswordProtectionWarningTriggerPref(
+      ReusedPasswordAccountType password_type) const;
+#endif
 
   // If |url| matches Safe Browsing allowlist domains, password protection
   // change password URL, or password protection login URLs in the enterprise
diff --git a/chrome/browser/safe_browsing/url_checker_delegate_impl.cc b/chrome/browser/safe_browsing/url_checker_delegate_impl.cc
index b1e9744173..07be890d41 100644
--- a/chrome/browser/safe_browsing/url_checker_delegate_impl.cc
+++ b/chrome/browser/safe_browsing/url_checker_delegate_impl.cc
@@ -51,6 +51,7 @@ void DestroyNoStatePrefetchContents(
   }
 }
 
+#if !defined(OS_OHOS)
 void CreateSafeBrowsingUserInteractionObserver(
     const content::WebContents::Getter& web_contents_getter,
     const security_interstitials::UnsafeResource& resource,
@@ -73,9 +74,13 @@ void CreateSafeBrowsingUserInteractionObserver(
     return;
   }
 #endif
+
+#if !defined(OS_OHOS)
   SafeBrowsingUserInteractionObserver::CreateForWebContents(
       web_contents, resource, is_main_frame, ui_manager);
+#endif
 }
+#endif
 
 }  // namespace
 
@@ -112,10 +117,12 @@ void UrlCheckerDelegateImpl::StartDisplayingBlockingPageHelper(
     const net::HttpRequestHeaders& headers,
     bool is_main_frame,
     bool has_user_gesture) {
+#if !defined(OS_OHOS)
   content::GetUIThreadTaskRunner({})->PostTask(
       FROM_HERE,
       base::BindOnce(&SafeBrowsingUIManager::StartDisplayingBlockingPage,
                      ui_manager_, resource));
+#endif
 }
 
 // Starts displaying the SafeBrowsing interstitial page.
@@ -123,10 +130,12 @@ void UrlCheckerDelegateImpl::
     StartObservingInteractionsForDelayedBlockingPageHelper(
         const security_interstitials::UnsafeResource& resource,
         bool is_main_frame) {
+#if !defined(OS_OHOS)
   content::GetUIThreadTaskRunner({})->PostTask(
       FROM_HERE, base::BindOnce(&CreateSafeBrowsingUserInteractionObserver,
                                 resource.web_contents_getter, resource,
                                 is_main_frame, ui_manager_));
+#endif
 }
 
 bool UrlCheckerDelegateImpl::IsUrlAllowlisted(const GURL& url) {
diff --git a/chrome/browser/safe_browsing/url_lookup_service_factory.cc b/chrome/browser/safe_browsing/url_lookup_service_factory.cc
index 52da66e37b..1f9b1026ba 100644
--- a/chrome/browser/safe_browsing/url_lookup_service_factory.cc
+++ b/chrome/browser/safe_browsing/url_lookup_service_factory.cc
@@ -54,6 +54,8 @@ RealTimeUrlLookupServiceFactory::RealTimeUrlLookupServiceFactory()
 
 KeyedService* RealTimeUrlLookupServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   if (!g_browser_process->safe_browsing_service()) {
     return nullptr;
   }
@@ -74,6 +76,10 @@ KeyedService* RealTimeUrlLookupServiceFactory::BuildServiceInstanceFor(
                           ProfileSyncServiceFactory::GetForProfile(profile),
                           IdentityManagerFactory::GetForProfile(profile)),
       profile->IsOffTheRecord(), g_browser_process->variations_service());
+#else
+  return nullptr;
+#endif
+
 }
 
 }  // namespace safe_browsing
diff --git a/chrome/browser/serial/chrome_serial_delegate.cc b/chrome/browser/serial/chrome_serial_delegate.cc
index 5c9cefe505..09b24d1cf2 100644
--- a/chrome/browser/serial/chrome_serial_delegate.cc
+++ b/chrome/browser/serial/chrome_serial_delegate.cc
@@ -34,9 +34,14 @@ std::unique_ptr<content::SerialChooser> ChromeSerialDelegate::RunChooser(
     content::RenderFrameHost* frame,
     std::vector<blink::mojom::SerialPortFilterPtr> filters,
     content::SerialChooser::Callback callback) {
+#if !defined(OS_OHOS)
   return std::make_unique<SerialChooser>(chrome::ShowDeviceChooserDialog(
       frame, std::make_unique<SerialChooserController>(
                  frame, std::move(filters), std::move(callback))));
+#else
+  LOG(INFO) << "ChromeSerialDelegate::RunChooser TODO for OS_OHOS";
+  return nullptr;
+#endif
 }
 
 bool ChromeSerialDelegate::CanRequestPortPermission(
diff --git a/chrome/browser/sharing/shared_clipboard/feature_flags.cc b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
index 0d17ad2381..cd78e50d74 100644
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.cc
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
@@ -8,7 +8,7 @@ const base::Feature kSharedClipboardUI{"SharedClipboardUI",
                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 const base::Feature kRemoteCopyReceiver{"RemoteCopyReceiver",
                                         base::FEATURE_ENABLED_BY_DEFAULT};
 
diff --git a/chrome/browser/sharing/shared_clipboard/feature_flags.h b/chrome/browser/sharing/shared_clipboard/feature_flags.h
index 65818f84ce..ea79077ad3 100644
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.h
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.h
@@ -15,7 +15,7 @@
 extern const base::Feature kSharedClipboardUI;
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Feature to enable handling remote copy messages.
 extern const base::Feature kRemoteCopyReceiver;
 
diff --git a/chrome/browser/ssl/chrome_security_blocking_page_factory.cc b/chrome/browser/ssl/chrome_security_blocking_page_factory.cc
index e89930881e..75e7903a8e 100644
--- a/chrome/browser/ssl/chrome_security_blocking_page_factory.cc
+++ b/chrome/browser/ssl/chrome_security_blocking_page_factory.cc
@@ -94,6 +94,7 @@ bool IsEnterpriseManaged() {
 // CaptivePortalBlockingPage to be invoked when the user has pressed the
 // connect button.
 void OpenLoginPage(content::WebContents* web_contents) {
+#if !defined(OS_OHOS)
 #if !BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   // OpenLoginTabForWebContents() is not available on Android (the only
   // platform on which captive portal detection is not enabled). Simply open
@@ -108,6 +109,9 @@ void OpenLoginPage(content::WebContents* web_contents) {
   ChromeSecurityBlockingPageFactory::OpenLoginTabForWebContents(web_contents,
                                                                 true);
 #endif  // !BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
+#else
+  LOG(ERROR) << "OpenLoginPage TODO for OS_OHOS";
+#endif
 }
 
 std::unique_ptr<ContentMetricsHelper> CreateMetricsHelperAndStartRecording(
diff --git a/chrome/browser/ssl/sct_reporting_service_factory.cc b/chrome/browser/ssl/sct_reporting_service_factory.cc
index 1319d0e475..aebe2cd4bc 100644
--- a/chrome/browser/ssl/sct_reporting_service_factory.cc
+++ b/chrome/browser/ssl/sct_reporting_service_factory.cc
@@ -32,6 +32,8 @@ SCTReportingServiceFactory::~SCTReportingServiceFactory() = default;
 
 KeyedService* SCTReportingServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* profile) const {
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::SafeBrowsingService* safe_browsing_service =
       g_browser_process->safe_browsing_service();
   // In unit tests the safe browsing service can be null, if this happens,
@@ -41,6 +43,9 @@ KeyedService* SCTReportingServiceFactory::BuildServiceInstanceFor(
 
   return new SCTReportingService(safe_browsing_service,
                                  static_cast<Profile*>(profile));
+#else
+  return nullptr;
+#endif
 }
 
 content::BrowserContext* SCTReportingServiceFactory::GetBrowserContextToUse(
diff --git a/chrome/browser/ssl/security_state_tab_helper.cc b/chrome/browser/ssl/security_state_tab_helper.cc
index 810fdd18c2..9f3c445aee 100644
--- a/chrome/browser/ssl/security_state_tab_helper.cc
+++ b/chrome/browser/ssl/security_state_tab_helper.cc
@@ -209,6 +209,7 @@ SecurityStateTabHelper::GetMaliciousContentStatus() const {
       web_contents()->GetController().GetVisibleEntry();
   if (!entry)
     return security_state::MALICIOUS_CONTENT_STATUS_NONE;
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingService* sb_service =
       g_browser_process->safe_browsing_service();
   if (!sb_service)
@@ -292,6 +293,9 @@ SecurityStateTabHelper::GetMaliciousContentStatus() const {
     }
   }
   return security_state::MALICIOUS_CONTENT_STATUS_NONE;
+#else
+  return security_state::MALICIOUS_CONTENT_STATUS_NONE;
+#endif
 }
 
 WEB_CONTENTS_USER_DATA_KEY_IMPL(SecurityStateTabHelper)
diff --git a/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc b/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
index 2312a63fb4..cf3f0a95eb 100644
--- a/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
+++ b/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
@@ -57,10 +57,14 @@ void ChromeSubresourceFilterClient::ShowNotification() {
 
 const scoped_refptr<safe_browsing::SafeBrowsingDatabaseManager>
 ChromeSubresourceFilterClient::GetSafeBrowsingDatabaseManager() {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingService* safe_browsing_service =
       g_browser_process->safe_browsing_service();
   return safe_browsing_service ? safe_browsing_service->database_manager()
                                : nullptr;
+#else
+  return nullptr;
+#endif
 }
 
 subresource_filter::ProfileInteractionManager*
diff --git a/chrome/browser/tracing/crash_service_uploader.cc b/chrome/browser/tracing/crash_service_uploader.cc
index e59f3a4d73..3a06d061e9 100644
--- a/chrome/browser/tracing/crash_service_uploader.cc
+++ b/chrome/browser/tracing/crash_service_uploader.cc
@@ -161,6 +161,8 @@ void TraceCrashServiceUploader::DoCompressOnBackgroundThread(
   const char product[] = "Chrome_Linux";
 #elif defined(OS_ANDROID)
   const char product[] = "Chrome_Android";
+#elif defined(OS_OHOS)
+  const char product[] = "Chrome_OHOS";
 #else
 #error Platform not supported.
 #endif
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 1dbbf65c02..a286ad7319 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -1648,7 +1648,7 @@ static_library("ui") {
       deps += [ "//ui/base/ime/linux" ]
     }
 
-    if (!toolkit_views) {
+    if (!toolkit_views && !is_ohos) {
       sources += [ "media_router/cloud_services_dialog.cc" ]
     }
 
@@ -2867,7 +2867,7 @@ static_library("ui") {
     ]
   }
 
-  if (is_win || is_mac || is_linux || is_chromeos) {
+  if (is_win || is_mac || is_linux || is_chromeos || is_ohos) {
     sources += [
       "autofill/payments/virtual_card_selection_dialog_controller.h",
       "autofill/payments/virtual_card_selection_dialog_controller_impl.cc",
@@ -2934,7 +2934,7 @@ static_library("ui") {
     deps += [ "//ui/webui" ]
   }
 
-  if (is_win || is_mac || (is_linux || is_chromeos_lacros)) {
+  if (is_win || is_mac || (is_linux || is_chromeos_lacros) || is_ohos) {
     sources += [
       "bookmarks/bookmark_bubble_sign_in_delegate.cc",
       "bookmarks/bookmark_bubble_sign_in_delegate.h",
@@ -3382,7 +3382,7 @@ static_library("ui") {
     }
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     sources += [
       "views/apps/chrome_app_window_client_views_linux.cc",
       "views/first_run_dialog.cc",
@@ -3484,7 +3484,7 @@ static_library("ui") {
     }
   }
 
-  if (toolkit_views) {
+  if (toolkit_views || is_ohos) {
     sources += [
       "autofill/address_editor_controller.cc",
       "autofill/address_editor_controller.h",
@@ -4367,7 +4367,7 @@ static_library("ui") {
 
     allow_circular_includes_from += [ "//chrome/browser/ui/views" ]
 
-    if (is_linux || is_chromeos_lacros) {
+    if (is_linux || is_chromeos_lacros || is_ohos) {
       sources += [
         "views/chrome_views_delegate_linux.cc",
         "views/frame/desktop_linux_browser_frame_view.cc",
@@ -4379,7 +4379,7 @@ static_library("ui") {
       ]
     }
 
-    if (is_linux || is_chromeos) {
+    if (is_linux || is_chromeos || is_ohos) {
       sources += [
         "views/process_singleton_dialog_linux.cc",
         "views/status_icons/status_tray_linux.cc",
@@ -4423,7 +4423,7 @@ static_library("ui") {
       ]
     }
 
-    if (is_win || (is_linux || is_chromeos_lacros)) {
+    if (is_win || (is_linux || is_chromeos_lacros) || is_ohos) {
       sources += [
         "views/native_widget_factory.cc",
         "views/native_widget_factory.h",
diff --git a/chrome/browser/ui/aura/tab_contents/web_drag_bookmark_handler_aura.cc b/chrome/browser/ui/aura/tab_contents/web_drag_bookmark_handler_aura.cc
index 2790cc07d6..a76512990f 100644
--- a/chrome/browser/ui/aura/tab_contents/web_drag_bookmark_handler_aura.cc
+++ b/chrome/browser/ui/aura/tab_contents/web_drag_bookmark_handler_aura.cc
@@ -41,11 +41,15 @@ void WebDragBookmarkHandlerAura::OnDragOver() {
 
 void WebDragBookmarkHandlerAura::OnReceiveDragData(
     const ui::OSExchangeData& data) {
+#if !defined(OS_OHOS)
   if (bookmark_tab_helper_ && bookmark_tab_helper_->bookmark_drag_delegate()) {
     // Read the bookmark drag data and save it for use in later events in this
     // drag.
     bookmark_drag_data_.Read(data);
   }
+#else
+  LOG(INFO) << "WebDragBookmarkHandlerAura::OnReceiveDragData TODO for OS_OHOS";
+#endif
 }
 
 void WebDragBookmarkHandlerAura::OnDragEnter() {
diff --git a/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.cc b/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.cc
index 41ff8996fb..97037e1abd 100644
--- a/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.cc
+++ b/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.cc
@@ -14,8 +14,12 @@ BluetoothChooserDesktop::BluetoothChooserDesktop(
   auto controller =
       std::make_unique<BluetoothChooserController>(frame, event_handler);
   bluetooth_chooser_controller_ = controller->GetWeakPtr();
+#if !defined(OS_OHOS)
   close_closure_ =
       chrome::ShowDeviceChooserDialog(frame, std::move(controller));
+#else
+  LOG(INFO) << "BluetoothChooserDesktop::BluetoothChooserDesktop TODO for OS_OHOS";
+#endif
 }
 
 BluetoothChooserDesktop::~BluetoothChooserDesktop() {
@@ -24,8 +28,10 @@ BluetoothChooserDesktop::~BluetoothChooserDesktop() {
   // instance.
   if (bluetooth_chooser_controller_)
     bluetooth_chooser_controller_->ResetEventHandler();
+#if !defined(OS_OHOS)
   if (close_closure_)
     std::move(close_closure_).Run();
+#endif
 }
 
 void BluetoothChooserDesktop::SetAdapterPresence(AdapterPresence presence) {
diff --git a/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.h b/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.h
index bfa6287756..067b423ff6 100644
--- a/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.h
+++ b/chrome/browser/ui/bluetooth/bluetooth_chooser_desktop.h
@@ -42,7 +42,9 @@ class BluetoothChooserDesktop : public content::BluetoothChooser {
 
   // Closes the displayed UI if it is still open. Used to ensure the bubble
   // closes if this controller is torn down.
+#if !defined(OS_OHOS)
   base::OnceClosure close_closure_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(BluetoothChooserDesktop);
 };
diff --git a/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.cc b/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.cc
index 6bf1e605f0..3203236cd9 100644
--- a/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.cc
+++ b/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.cc
@@ -14,8 +14,12 @@ BluetoothScanningPromptDesktop::BluetoothScanningPromptDesktop(
   auto controller =
       std::make_unique<BluetoothScanningPromptController>(frame, event_handler);
   bluetooth_scanning_prompt_controller_ = controller->GetWeakPtr();
+#if !defined(OS_OHOS)
   close_closure_ =
       chrome::ShowDeviceChooserDialog(frame, std::move(controller));
+#else
+  LOG(INFO) << "BluetoothScanningPromptDesktop::BluetoothScanningPromptDesktop TODO for OS_OHOS";
+#endif
 }
 
 BluetoothScanningPromptDesktop::~BluetoothScanningPromptDesktop() {
@@ -24,8 +28,10 @@ BluetoothScanningPromptDesktop::~BluetoothScanningPromptDesktop() {
   // BluetoothScanningPrompt instance.
   if (bluetooth_scanning_prompt_controller_)
     bluetooth_scanning_prompt_controller_->ResetEventHandler();
+#if !defined(OS_OHOS)
   if (close_closure_)
     std::move(close_closure_).Run();
+#endif
 }
 
 void BluetoothScanningPromptDesktop::AddOrUpdateDevice(
diff --git a/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.h b/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.h
index 20d897c05a..6d4a09ec02 100644
--- a/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.h
+++ b/chrome/browser/ui/bluetooth/bluetooth_scanning_prompt_desktop.h
@@ -38,8 +38,9 @@ class BluetoothScanningPromptDesktop : public content::BluetoothScanningPrompt {
 
   // Closes the displayed UI, if there is one. This is used to ensure the UI
   // closes if this controller is destroyed.
+#if !defined(OS_OHOS)
   base::OnceClosure close_closure_;
-
+#endif
   DISALLOW_COPY_AND_ASSIGN(BluetoothScanningPromptDesktop);
 };
 
diff --git a/chrome/browser/ui/bookmarks/bookmark_utils.cc b/chrome/browser/ui/bookmarks/bookmark_utils.cc
index 04dbba1200..51df5e6a67 100644
--- a/chrome/browser/ui/bookmarks/bookmark_utils.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils.cc
@@ -32,7 +32,7 @@
 #include "ui/base/dragdrop/mojom/drag_drop_types.mojom.h"
 #include "ui/base/pointer/touch_ui_controller.h"
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/image/image_skia_source.h"
@@ -53,7 +53,7 @@ using ::bookmarks::BookmarkModel;
 using ::bookmarks::BookmarkNode;
 using ::ui::mojom::DragOperation;
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 // Image source that flips the supplied source image in RTL.
 class RTLFlipSource : public gfx::ImageSkiaSource {
  public:
@@ -257,7 +257,7 @@ bool IsValidBookmarkDropLocation(Profile* profile,
   return true;
 }
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 // TODO(bsep): vectorize the Windows versions: crbug.com/564112
 ui::ImageModel GetBookmarkFolderIcon(SkColor text_color) {
   gfx::ImageSkia folder;
diff --git a/chrome/browser/ui/bookmarks/bookmark_utils.h b/chrome/browser/ui/bookmarks/bookmark_utils.h
index 60b699cbf0..523692d4f8 100644
--- a/chrome/browser/ui/bookmarks/bookmark_utils.h
+++ b/chrome/browser/ui/bookmarks/bookmark_utils.h
@@ -93,7 +93,7 @@ bool IsValidBookmarkDropLocation(Profile* profile,
                                  const bookmarks::BookmarkNode* drop_parent,
                                  size_t index);
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 // |text_color| is the color of associated text and is used to derive the icon's
 // color.
 ui::ImageModel GetBookmarkFolderIcon(SkColor text_color);
diff --git a/chrome/browser/ui/browser_commands.cc b/chrome/browser/ui/browser_commands.cc
index 5469cf1130..5ba23f6fb8 100644
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1655,7 +1655,7 @@ void ToggleCommander(Browser* browser) {
   commander::Commander::Get()->ToggleForBrowser(browser);
 }
 
-#if !defined(TOOLKIT_VIEWS)
+#if !defined(TOOLKIT_VIEWS) && !defined(OS_OHOS)
 base::Optional<int> GetKeyboardFocusedTabIndex(const Browser* browser) {
   return base::nullopt;
 }
diff --git a/chrome/browser/ui/browser_dialogs.cc b/chrome/browser/ui/browser_dialogs.cc
index 738a0c5602..475be6360f 100644
--- a/chrome/browser/ui/browser_dialogs.cc
+++ b/chrome/browser/ui/browser_dialogs.cc
@@ -14,7 +14,7 @@ void RecordDialogCreation(DialogIdentifier identifier) {
                             DialogIdentifier::MAX_VALUE);
 }
 
-#if !defined(TOOLKIT_VIEWS)
+#if !defined(TOOLKIT_VIEWS) && !defined(OS_OHOS)
 void ShowWindowNamePrompt(Browser* browser) {
   NOTIMPLEMENTED();
 }
@@ -27,7 +27,7 @@ void ShowWindowNamePromptForTesting(Browser* browser,
 
 }  // namespace chrome
 
-#if !defined(TOOLKIT_VIEWS)
+#if !defined(TOOLKIT_VIEWS) && !defined(OS_OHOS)
 // There's no dialog version of this available outside views, run callback as if
 // the dialog was instantly accepted.
 void ShowFolderUploadConfirmationDialog(
diff --git a/chrome/browser/ui/browser_dialogs.h b/chrome/browser/ui/browser_dialogs.h
index 8b2247ff0c..4b4d555b35 100644
--- a/chrome/browser/ui/browser_dialogs.h
+++ b/chrome/browser/ui/browser_dialogs.h
@@ -174,7 +174,7 @@ void HideTaskManagerViews();
 
 #endif  // OS_MAC
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 
 // Creates a toolkit-views based LoginHandler (e.g. HTTP-Auth dialog).
 std::unique_ptr<LoginHandler> CreateLoginHandlerViews(
diff --git a/chrome/browser/ui/file_system_access_dialogs.cc b/chrome/browser/ui/file_system_access_dialogs.cc
index 367f92f2a5..a527b3dfbd 100644
--- a/chrome/browser/ui/file_system_access_dialogs.cc
+++ b/chrome/browser/ui/file_system_access_dialogs.cc
@@ -6,7 +6,7 @@
 
 #include "components/permissions/permission_util.h"
 
-#if !defined(TOOLKIT_VIEWS)
+#if !defined(TOOLKIT_VIEWS) && !defined(OS_OHOS)
 void ShowFileSystemAccessPermissionDialog(
     const FileSystemAccessPermissionRequestManager::RequestData& request,
     base::OnceCallback<void(permissions::PermissionAction result)> callback,
diff --git a/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc b/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
index c0f114a947..abfa6b13b7 100644
--- a/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
+++ b/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
@@ -36,6 +36,8 @@ JavaScriptTabModalDialogManagerDelegateDesktop::
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::WillRunDialog() {
   BrowserList::AddObserver(this);
+
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -46,6 +48,8 @@ void JavaScriptTabModalDialogManagerDelegateDesktop::WillRunDialog() {
   if (observer) {
     observer->OnJavaScriptDialog();
   }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
+
 }
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::DidCloseDialog() {
diff --git a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
index 27a192e2ec..69e7530676 100644
--- a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
+++ b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
@@ -17,7 +17,9 @@
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_view_delegate.h"
 #include "content/public/common/drop_data.h"
+#include "components/safe_browsing/buildflags.h"
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 namespace {
 
 void CompletionCallback(
@@ -113,3 +115,16 @@ void HandleOnPerformDrop(
         base::BindOnce(&ScanData, web_contents, std::move(callback)));
   }
 }
+
+#else
+
+void HandleOnPerformDrop(
+    content::WebContents* web_contents,
+    const content::DropData& drop_data,
+    content::WebContentsViewDelegate::DropCompletionCallback callback) {
+  // In the original code, this ran safe_browsing::DeepScanningDialogDelegate
+  // Instead, run the code under "if (!safe_browsing::DeepScanningDialogDelegate::IsEnabled(...)) ..."
+  std::move(callback).Run(
+      content::WebContentsViewDelegate::DropCompletionResult::kContinue);
+}
+#endif
\ No newline at end of file
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
index d2b75343e8..1e59e4ed31 100644
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -153,7 +153,7 @@
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "chrome/browser/ui/blocked_content/framebust_block_tab_helper.h"
 #include "chrome/browser/ui/hats/hats_helper.h"
 #endif
@@ -325,11 +325,13 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
   //     See https://crbug.com/910288.
   resource_coordinator::ResourceCoordinatorTabHelper::CreateForWebContents(
       web_contents);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingNavigationObserver::MaybeCreateForWebContents(
       web_contents);
   safe_browsing::SafeBrowsingTabObserver::CreateForWebContents(web_contents);
   safe_browsing::TriggerCreator::MaybeCreateTriggersForWebContents(
       profile, web_contents);
+#endif
   ReputationWebContentsObserver::CreateForWebContents(web_contents);
   SearchEngineTabHelper::CreateForWebContents(web_contents);
   SecurityStateTabHelper::CreateForWebContents(web_contents);
diff --git a/chrome/browser/ui/views/BUILD.gn b/chrome/browser/ui/views/BUILD.gn
index 54829b2cb7..664277a34f 100644
--- a/chrome/browser/ui/views/BUILD.gn
+++ b/chrome/browser/ui/views/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/config/chromeos/ui_mode.gni")
 import("//build/config/ui.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
+assert(toolkit_views || is_ohos)
 
 component("views") {
   output_name = "browser_ui_views"
diff --git a/chrome/browser/ui/views/certificate_selector.cc b/chrome/browser/ui/views/certificate_selector.cc
index 5bce36c39a..71db0c5550 100644
--- a/chrome/browser/ui/views/certificate_selector.cc
+++ b/chrome/browser/ui/views/certificate_selector.cc
@@ -288,8 +288,12 @@ void CertificateSelector::ViewCertButtonPressed() {
   net::ClientCertIdentity* const cert = GetSelectedCert();
   if (!cert)
     return;
+#if !defined(OS_OHOS)
   ShowCertificateViewer(web_contents_, web_contents_->GetTopLevelNativeWindow(),
                         cert->certificate());
+#else
+  LOG(INFO) << "CertificateSelector::ViewCertButtonPressed TODO for OS_OHOS";
+#endif
 }
 
 void CertificateSelector::OnSelectionChanged() {
diff --git a/chrome/browser/ui/views/chrome_views_delegate.h b/chrome/browser/ui/views/chrome_views_delegate.h
index 393070d00b..c2c359bb14 100644
--- a/chrome/browser/ui/views/chrome_views_delegate.h
+++ b/chrome/browser/ui/views/chrome_views_delegate.h
@@ -50,7 +50,7 @@ class ChromeViewsDelegate : public views::ViewsDelegate {
                              base::OnceClosure callback) override;
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
   gfx::ImageSkia* GetDefaultWindowIcon() const override;
   bool WindowManagerProvidesTitleBar(bool maximized) override;
 #endif
diff --git a/chrome/browser/ui/views/download/download_danger_prompt_views.cc b/chrome/browser/ui/views/download/download_danger_prompt_views.cc
index 6e063d0b1d..94fc2659ae 100644
--- a/chrome/browser/ui/views/download/download_danger_prompt_views.cc
+++ b/chrome/browser/ui/views/download/download_danger_prompt_views.cc
@@ -271,11 +271,13 @@ void DownloadDangerPromptViews::RunDone(Action action) {
       if (!download_->GetURL().is_empty() &&
           !content::DownloadItemUtils::GetBrowserContext(download_)
                ->IsOffTheRecord()) {
+      #if BUILDFLAG(FULL_SAFE_BROWSING)
         ClientSafeBrowsingReportRequest::ReportType report_type
             = show_context_ ?
                 ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_BY_API :
                 ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_RECOVERY;
         SendSafeBrowsingDownloadReport(report_type, accept, *download_);
+      #endif
       }
     }
     download_->RemoveObserver(this);
diff --git a/chrome/browser/ui/views/download/download_item_view.cc b/chrome/browser/ui/views/download/download_item_view.cc
index fe92b1c432..de9214b6a0 100644
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -775,11 +775,19 @@ void DownloadItemView::UpdateLabels() {
 
   deep_scanning_label_->SetVisible(mode_ == Mode::kDeepScanning);
   if (deep_scanning_label_->GetVisible()) {
-    const int id = (model_->download() &&
+    int id;
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
+    id = (model_->download() &&
                     safe_browsing::DeepScanningRequest::ShouldUploadBinary(
                         model_->download()))
                        ? IDS_PROMPT_DEEP_SCANNING_DOWNLOAD
                        : IDS_PROMPT_DEEP_SCANNING_APP_DOWNLOAD;
+#else
+    id =  model_->download()
+                       ? IDS_PROMPT_DEEP_SCANNING_DOWNLOAD
+                       : IDS_PROMPT_DEEP_SCANNING_APP_DOWNLOAD;
+#endif
+
     const std::u16string filename = ElidedFilename(*deep_scanning_label_);
     size_t filename_offset;
     deep_scanning_label_->SetText(
@@ -801,11 +809,15 @@ void DownloadItemView::UpdateButtons() {
   }
 
   const bool allow_open_during_deep_scan =
+#if BUILDFLAG(FULL_SAFE_BROWSING)
       (mode_ == Mode::kDeepScanning) &&
       !enterprise_connectors::ConnectorsServiceFactory::GetForBrowserContext(
            model_->profile())
            ->DelayUntilVerdict(
                enterprise_connectors::AnalysisConnector::FILE_DOWNLOADED);
+#else
+      false;
+#endif
   open_button_->SetEnabled((mode_ == Mode::kNormal) || prompt_to_scan ||
                            allow_open_during_deep_scan);
 
@@ -1234,7 +1246,9 @@ void DownloadItemView::ShowContextMenuImpl(const gfx::Rect& rect,
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   model_->CompleteSafeBrowsingScan();
+#endif
   model_->SetOpenWhenComplete(true);
 }
 
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc
index 87b6ebe86d..041f5f7fe6 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc
@@ -151,7 +151,7 @@ void BrowserDesktopWindowTreeHostLinux::OnWindowStateChanged(
 ////////////////////////////////////////////////////////////////////////////////
 // BrowserDesktopWindowTreeHost, public:
 
-#if !BUILDFLAG(IS_CHROMEOS_LACROS)
+#if !BUILDFLAG(IS_CHROMEOS_LACROS) && !defined(OS_OHOS)
 // static
 BrowserDesktopWindowTreeHost*
 BrowserDesktopWindowTreeHost::CreateBrowserDesktopWindowTreeHost(
diff --git a/chrome/browser/ui/views/frame/desktop_browser_frame_aura_linux.cc b/chrome/browser/ui/views/frame/desktop_browser_frame_aura_linux.cc
index e459fd85b1..4f1aeb8492 100644
--- a/chrome/browser/ui/views/frame/desktop_browser_frame_aura_linux.cc
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_aura_linux.cc
@@ -67,7 +67,11 @@ bool DesktopBrowserFrameAuraLinux::UseCustomFrame() const {
 
 void DesktopBrowserFrameAuraLinux::TabDraggingKindChanged(
     TabDragKind tab_drag_kind) {
+#if !defined(OS_OHOS)
   host_->TabDraggingKindChanged(tab_drag_kind);
+#else
+  LOG(INFO) << "DesktopBrowserFrameAuraLinux::TabDraggingKindChanged TODO for OS_OHOS";
+#endif
 }
 
 void DesktopBrowserFrameAuraLinux::OnUseCustomChromeFrameChanged() {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc
index 6aee25a053..e91cea1674 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc
@@ -6,7 +6,7 @@
 
 #include "build/build_config.h"
 
-#if !defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_OHOS)
 
 // static
 std::unique_ptr<OpaqueBrowserFrameViewPlatformSpecific>
diff --git a/chrome/browser/ui/views/page_info/page_info_bubble_view.cc b/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
index 163aa4ac01..5cc8109549 100644
--- a/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
+++ b/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
@@ -1028,7 +1028,9 @@ void PageInfoBubbleView::HandleMoreInfoRequestAsync(int view_id) {
       if (certificate_ && top_window) {
         presenter_->RecordPageInfoAction(
             PageInfo::PAGE_INFO_CERTIFICATE_DIALOG_OPENED);
+#if !defined(OS_OHOS)
         ShowCertificateViewer(web_contents(), top_window, certificate_.get());
+#endif
       }
       break;
     }
diff --git a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index 037105a4c7..948340f99e 100644
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -590,8 +590,10 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
     return &NewWebUI<PredictorsUI>;
   if (url.host_piece() == chrome::kChromeUIQuotaInternalsHost)
     return &NewWebUI<QuotaInternalsUI>;
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   if (url.host_piece() == safe_browsing::kChromeUISafeBrowsingHost)
     return &NewWebUI<safe_browsing::SafeBrowsingUI>;
+#endif
   if (url.host_piece() == chrome::kChromeUISignInInternalsHost)
     return &NewWebUI<SignInInternalsUI>;
   if (url.host_piece() == chrome::kChromeUISuggestionsHost)
diff --git a/chrome/browser/ui/webui/chromeos/login/oobe_ui.h b/chrome/browser/ui/webui/chromeos/login/oobe_ui.h
index 82d442e425..e9f933e23d 100644
--- a/chrome/browser/ui/webui/chromeos/login/oobe_ui.h
+++ b/chrome/browser/ui/webui/chromeos/login/oobe_ui.h
@@ -62,7 +62,7 @@ class OobeUI : public ui::MojoWebUIController {
 
    protected:
     virtual ~Observer() {}
-    DISALLOW_COPY(Observer);
+    DISALLOW_COPY_BASE(Observer);
   };
 
   OobeUI(content::WebUI* web_ui, const GURL& url);
diff --git a/chrome/browser/ui/webui/discards/BUILD.gn b/chrome/browser/ui/webui/discards/BUILD.gn
index 1262bc6e40..757e99097c 100644
--- a/chrome/browser/ui/webui/discards/BUILD.gn
+++ b/chrome/browser/ui/webui/discards/BUILD.gn
@@ -4,7 +4,7 @@
 
 import("//mojo/public/tools/bindings/mojom.gni")
 
-if (is_win || is_mac || is_linux || is_chromeos) {
+if (is_win || is_mac || is_linux || is_chromeos || is_ohos) {
   mojom("mojo_bindings") {
     sources = [
       "discards.mojom",
diff --git a/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc b/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
index ee3461ee5c..98fba5e732 100644
--- a/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
+++ b/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
@@ -367,7 +367,9 @@ void DownloadsDOMHandler::OpenDuringScanningRequiringGesture(
   if (download) {
     DownloadItemModel model(download);
     model.SetOpenWhenComplete(true);
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
     model.CompleteSafeBrowsingScan();
+#endif
   }
 }
 
diff --git a/chrome/browser/ui/webui/favicon_source.cc b/chrome/browser/ui/webui/favicon_source.cc
index bbd2869208..0577e79432 100644
--- a/chrome/browser/ui/webui/favicon_source.cc
+++ b/chrome/browser/ui/webui/favicon_source.cc
@@ -220,7 +220,12 @@ bool FaviconSource::ShouldServiceRequest(
 
 ui::NativeTheme* FaviconSource::GetNativeTheme(
     const content::WebContents::Getter& wc_getter) {
+#if !defined(OS_OHOS)
   return webui::GetNativeTheme(wc_getter.Run());
+#else
+  LOG(INFO) << "FaviconSource::GetNativeTheme TODO for OS_OHOS";
+  return nullptr;
+#endif
 }
 
 void FaviconSource::OnFaviconDataAvailable(
diff --git a/chrome/browser/ui/webui/interstitials/interstitial_ui.cc b/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
index 61e783625f..9a94d5d7ce 100644
--- a/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
+++ b/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
@@ -262,6 +262,7 @@ std::unique_ptr<BadClockBlockingPage> CreateBadClockBlockingPage(
       clock_state, nullptr);
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 std::unique_ptr<LookalikeUrlBlockingPage> CreateLookalikeInterstitialPage(
     content::WebContents* web_contents) {
   GURL request_url("https://example.net");
@@ -277,6 +278,7 @@ std::unique_ptr<LookalikeUrlBlockingPage> CreateLookalikeInterstitialPage(
       std::make_unique<LookalikeUrlControllerClient>(web_contents, request_url,
                                                      safe_url));
 }
+#endif
 
 std::unique_ptr<security_interstitials::InsecureFormBlockingPage>
 CreateInsecureFormPage(content::WebContents* web_contents) {
@@ -287,6 +289,7 @@ CreateInsecureFormPage(content::WebContents* web_contents) {
                                                      request_url));
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 std::unique_ptr<safe_browsing::SafeBrowsingBlockingPage>
 CreateSafeBrowsingBlockingPage(content::WebContents* web_contents) {
   safe_browsing::SBThreatType threat_type =
@@ -393,6 +396,7 @@ CreateSafeBrowsingQuietBlockingPage(content::WebContents* web_contents) {
           g_browser_process->safe_browsing_service()->ui_manager().get(),
           web_contents, main_frame_url, resource, is_giant_webview));
 }
+#endif
 
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
 std::unique_ptr<CaptivePortalBlockingPage> CreateCaptivePortalBlockingPage(
@@ -510,12 +514,16 @@ void InterstitialHTMLSource::StartDataRequest(
     interstitial_delegate = CreateBlockedInterceptionBlockingPage(web_contents);
   } else if (path_without_query == "/legacy-tls") {
     interstitial_delegate = CreateLegacyTLSBlockingPage(web_contents);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   } else if (path_without_query == "/safebrowsing") {
     interstitial_delegate = CreateSafeBrowsingBlockingPage(web_contents);
+#endif
   } else if (path_without_query == "/clock") {
     interstitial_delegate = CreateBadClockBlockingPage(web_contents);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   } else if (path_without_query == "/lookalike") {
     interstitial_delegate = CreateLookalikeInterstitialPage(web_contents);
+#endif
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   } else if (path_without_query == "/captiveportal") {
     interstitial_delegate = CreateCaptivePortalBlockingPage(web_contents);
@@ -527,10 +535,12 @@ void InterstitialHTMLSource::StartDataRequest(
   }
 
   if (path_without_query == "/quietsafebrowsing") {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
     std::unique_ptr<TestSafeBrowsingBlockingPageQuiet> blocking_page =
         CreateSafeBrowsingQuietBlockingPage(web_contents);
     html = blocking_page->GetHTML();
     interstitial_delegate = std::move(blocking_page);
+#endif
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   } else if (path_without_query == "/supervised_user") {
     html = GetSupervisedUserInterstitialHTML(path);
diff --git a/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_handler.cc b/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_handler.cc
index fd7415abd6..86aa5acb13 100644
--- a/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_handler.cc
+++ b/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_handler.cc
@@ -194,9 +194,13 @@ void NewTabPageThirdPartyHandler::NotifyAboutTheme() {
   theme->shortcut_use_white_tile_icon =
       color_utils::IsDark(theme->shortcut_background_color);
   theme->shortcut_use_title_pill = false;
+#if !defined(OS_OHOS)
   theme->color_background = color_utils::SkColorToRgbaString(
       GetThemeColor(webui::GetNativeTheme(web_contents_), theme_provider,
                     ThemeProperties::COLOR_NTP_BACKGROUND));
+#else
+  LOG(INFO) << "NewTabPageThirdPartyHandler::NotifyAboutTheme TODO for OS_OHOS";
+#endif
   if (theme_provider.HasCustomImage(IDR_THEME_NTP_BACKGROUND)) {
     theme->background_tiling = GetNewTabBackgroundTilingCSS(theme_provider);
     theme->bookmark_bar_attached =
diff --git a/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_ui.cc b/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_ui.cc
index 68372f0e87..2fcca35923 100644
--- a/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_ui.cc
+++ b/chrome/browser/ui/webui/new_tab_page_third_party/new_tab_page_third_party_ui.cc
@@ -70,10 +70,14 @@ content::WebUIDataSource* CreateNewTabPageThirdPartyUiHtmlSource(
                     GetNewTabBackgroundTilingCSS(theme_provider));
   source->AddString("bookmarkbarattached",
                     bookmarkBarAttached ? "bookmark-bar-attached" : "");
+#if !defined(OS_OHOS)
   source->AddString("colorBackground",
                     color_utils::SkColorToRgbaString(GetThemeColor(
                         webui::GetNativeTheme(web_contents), theme_provider,
                         ThemeProperties::COLOR_NTP_BACKGROUND)));
+#else
+  LOG(INFO) << "CreateNewTabPageThirdPartyUiHtmlSource TODO for OS_OHOS";
+#endif
   source->AddString("themeId",
                     profile->GetPrefs()->GetString(prefs::kCurrentThemeID));
   source->AddString("hascustombackground",
diff --git a/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc b/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
index e771fa5215..51f122afca 100644
--- a/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
+++ b/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
@@ -473,7 +473,11 @@ scoped_refptr<base::RefCountedString> NTPResourceCache::CreateNewTabGuestHTML(
 
 void NTPResourceCache::CreateNewTabIncognitoCSS(
     const content::WebContents::Getter wc_getter) {
+#if !defined(OS_OHOS)
   const ui::NativeTheme* native_theme = webui::GetNativeTheme(wc_getter.Run());
+#else
+  LOG(INFO) << "NTPResourceCache::CreateNewTabIncognitoCSS TODO for OS_OHOS";
+#endif
   const ui::ThemeProvider& tp = ThemeService::GetThemeProviderForProfile(
       profile_->GetPrimaryOTRProfile());
 
@@ -485,8 +489,10 @@ void NTPResourceCache::CreateNewTabIncognitoCSS(
       profile_->GetPrefs()->GetString(prefs::kCurrentThemeID);
 
   // Colors.
+#if !defined(OS_OHOS)
   substitutions["colorBackground"] = color_utils::SkColorToRgbaString(
       GetThemeColor(native_theme, tp, ThemeProperties::COLOR_NTP_BACKGROUND));
+#endif
   substitutions["backgroundBarDetached"] = GetNewTabBackgroundCSS(tp, false);
   substitutions["backgroundBarAttached"] = GetNewTabBackgroundCSS(tp, true);
   substitutions["backgroundTiling"] = GetNewTabBackgroundTilingCSS(tp);
@@ -507,7 +513,12 @@ void NTPResourceCache::CreateNewTabIncognitoCSS(
 
 void NTPResourceCache::CreateNewTabCSS(
     const content::WebContents::Getter wc_getter) {
+#if !defined(OS_OHOS)
   const ui::NativeTheme* native_theme = webui::GetNativeTheme(wc_getter.Run());
+#else
+  const ui::NativeTheme* native_theme = nullptr;
+  LOG(INFO) << "NTPResourceCache::CreateNewTabCSS TODO for OS_OHOS";
+#endif
   const ui::ThemeProvider& tp =
       ThemeService::GetThemeProviderForProfile(profile_);
 
diff --git a/chrome/browser/ui/webui/signin/profile_picker_handler.cc b/chrome/browser/ui/webui/signin/profile_picker_handler.cc
index 8186c8638d..1393ecfe21 100644
--- a/chrome/browser/ui/webui/signin/profile_picker_handler.cc
+++ b/chrome/browser/ui/webui/signin/profile_picker_handler.cc
@@ -122,6 +122,7 @@ base::Value GetAutogeneratedProfileThemeInfoValue(int color_id,
   return dict;
 }
 
+#if !defined(OS_OHOS)
 base::Value CreateDefaultProfileThemeInfo(int avatar_icon_size,
                                           bool dark_mode) {
   SkColor frame_color = ThemeProperties::GetDefaultColor(
@@ -135,6 +136,7 @@ base::Value CreateDefaultProfileThemeInfo(int avatar_icon_size,
       kDefaultThemeColorId, base::nullopt, frame_color, active_tab_color,
       frame_text_color, avatar_icon_size);
 }
+#endif
 
 base::Value CreateAutogeneratedProfileThemeInfo(int color_id,
                                                 SkColor color,
@@ -406,9 +408,13 @@ void ProfilePickerHandler::HandleGetProfileThemeInfo(
   base::Value dict;
   switch (color_id) {
     case kDefaultThemeColorId:
+#if !defined(OS_OHOS)
       dict = CreateDefaultProfileThemeInfo(
           avatar_icon_size, webui::GetNativeTheme(web_ui()->GetWebContents())
                                 ->ShouldUseDarkColors());
+#else
+      LOG(INFO) << "ProfilePickerHandler::HandleGetProfileThemeInfo kDefaultThemeColorId TODO for OS_OHOS";
+#endif
       break;
     case kManuallyPickedColorId:
       dict = CreateAutogeneratedProfileThemeInfo(color_id, *color,
diff --git a/chrome/browser/ui/webui/theme_handler.cc b/chrome/browser/ui/webui/theme_handler.cc
index eca1912068..68b87e1c01 100644
--- a/chrome/browser/ui/webui/theme_handler.cc
+++ b/chrome/browser/ui/webui/theme_handler.cc
@@ -40,11 +40,13 @@ void ThemeHandler::OnJavascriptAllowed() {
   // Listen for theme installation.
   ThemeServiceFactory::GetForProfile(GetProfile())->AddObserver(this);
 
+#if defined(TOOLKIT_VIEWS)
   // Or native theme change.
   if (web_ui()) {
     theme_observation_.Observe(
         webui::GetNativeTheme(web_ui()->GetWebContents()));
   }
+#endif
 }
 
 void ThemeHandler::OnJavascriptDisallowed() {
@@ -60,12 +62,14 @@ void ThemeHandler::OnNativeThemeUpdated(ui::NativeTheme* observed_theme) {
   // There are two types of theme update. a) The observed theme change. e.g.
   // switch between light/dark mode. b) A different theme is enabled. e.g.
   // switch between GTK and classic theme on Linux. Reset observer in case b).
+#if defined(TOOLKIT_VIEWS)
   ui::NativeTheme* current_theme =
       webui::GetNativeTheme(web_ui()->GetWebContents());
   if (observed_theme != current_theme) {
     theme_observation_.Reset();
     theme_observation_.Observe(current_theme);
   }
+#endif
   SendThemeChanged();
 }
 
diff --git a/chrome/browser/usb/web_usb_chooser_desktop.cc b/chrome/browser/usb/web_usb_chooser_desktop.cc
index 92616165a1..8dba126ad2 100644
--- a/chrome/browser/usb/web_usb_chooser_desktop.cc
+++ b/chrome/browser/usb/web_usb_chooser_desktop.cc
@@ -20,8 +20,10 @@ WebUsbChooserDesktop::~WebUsbChooserDesktop() = default;
 void WebUsbChooserDesktop::ShowChooser(
     std::unique_ptr<UsbChooserController> controller) {
   closure_runner_.RunAndReset();
+#if !defined(OS_OHOS)
   closure_runner_.ReplaceClosure(chrome::ShowDeviceChooserDialog(
       render_frame_host(), std::move(controller)));
+#endif
 }
 
 base::WeakPtr<WebUsbChooser> WebUsbChooserDesktop::GetWeakPtr() {
diff --git a/chrome/browser/web_applications/components/BUILD.gn b/chrome/browser/web_applications/components/BUILD.gn
index c4fb300ebd..c8ef022537 100644
--- a/chrome/browser/web_applications/components/BUILD.gn
+++ b/chrome/browser/web_applications/components/BUILD.gn
@@ -108,7 +108,7 @@ source_set("components") {
     sources += [ "web_app_shortcut_chromeos.cc" ]
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     # Desktop linux, doesn't count ChromeOS.
     sources += [
       "web_app_file_handler_registration_linux.cc",
diff --git a/chrome/browser/web_applications/components/web_app_file_handler_registration.h b/chrome/browser/web_applications/components/web_app_file_handler_registration.h
index 788a767ef7..1292e8850a 100644
--- a/chrome/browser/web_applications/components/web_app_file_handler_registration.h
+++ b/chrome/browser/web_applications/components/web_app_file_handler_registration.h
@@ -42,7 +42,7 @@ void UnregisterFileHandlersWithOs(const AppId& app_id,
                                   std::unique_ptr<ShortcutInfo> info,
                                   base::OnceCallback<void()> callback);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 using RegisterMimeTypesOnLinuxCallback =
     base::OnceCallback<bool(base::FilePath profile_path,
                             std::string file_contents)>;
diff --git a/chrome/browser/web_applications/components/web_app_run_on_os_login.cc b/chrome/browser/web_applications/components/web_app_run_on_os_login.cc
index 7166cbde95..61d3b51072 100644
--- a/chrome/browser/web_applications/components/web_app_run_on_os_login.cc
+++ b/chrome/browser/web_applications/components/web_app_run_on_os_login.cc
@@ -34,7 +34,7 @@ namespace internals {
 
 // TODO(crbug.com/1052397): Revisit once build flag switch of lacros-chrome is
 // complete.
-#if !(defined(OS_WIN) || defined(OS_MAC) || (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)))
+#if !(defined(OS_WIN) || defined(OS_MAC) || (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS))
 // This boilerplate function is used for platforms that don't support Run On OS
 // Login. Currently the feature is supported on Windows, Linux and MacOS.
 bool RegisterRunOnOsLogin(const ShortcutInfo& shortcut_info) {
diff --git a/chrome/browser/web_applications/components/web_application_info.cc b/chrome/browser/web_applications/components/web_application_info.cc
index 8b460a6ac5..25a4a201f9 100644
--- a/chrome/browser/web_applications/components/web_application_info.cc
+++ b/chrome/browser/web_applications/components/web_application_info.cc
@@ -14,11 +14,11 @@ IconBitmaps::~IconBitmaps() = default;
 
 IconBitmaps::IconBitmaps(const IconBitmaps&) = default;
 
-IconBitmaps::IconBitmaps(IconBitmaps&&) = default;
+IconBitmaps::IconBitmaps(IconBitmaps&&) noexcept = default;
 
 IconBitmaps& IconBitmaps::operator=(const IconBitmaps&) = default;
 
-IconBitmaps& IconBitmaps::operator=(IconBitmaps&&) = default;
+IconBitmaps& IconBitmaps::operator=(IconBitmaps&&) noexcept = default;
 
 void IconBitmaps::SetBitmapsForPurpose(
     IconPurpose purpose,
@@ -51,7 +51,7 @@ WebApplicationIconInfo::WebApplicationIconInfo(const GURL& url,
 WebApplicationIconInfo::WebApplicationIconInfo(const WebApplicationIconInfo&) =
     default;
 
-WebApplicationIconInfo::WebApplicationIconInfo(WebApplicationIconInfo&&) =
+WebApplicationIconInfo::WebApplicationIconInfo(WebApplicationIconInfo&&) noexcept =
     default;
 
 WebApplicationIconInfo::~WebApplicationIconInfo() = default;
@@ -60,7 +60,7 @@ WebApplicationIconInfo& WebApplicationIconInfo::operator=(
     const WebApplicationIconInfo&) = default;
 
 WebApplicationIconInfo& WebApplicationIconInfo::operator=(
-    WebApplicationIconInfo&&) = default;
+    WebApplicationIconInfo&&) noexcept = default;
 
 // WebApplicationShortcutsMenuItemInfo::Icon
 WebApplicationShortcutsMenuItemInfo::Icon::Icon() = default;
diff --git a/chrome/chrome_paks.gni b/chrome/chrome_paks.gni
index 6050d17099..fa26d2dc9d 100644
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -56,7 +56,7 @@ template("chrome_repack_percent") {
       deps += invoker.deps
     }
 
-    if (toolkit_views) {
+    if (toolkit_views || is_ohos) {
       sources += [ "$root_gen_dir/ui/views/resources/views_resources_${percent}_percent.pak" ]
       deps += [ "//ui/views/resources" ]
     }
diff --git a/chrome/common/BUILD.gn b/chrome/common/BUILD.gn
index 79d548cceb..692dda0565 100644
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -376,7 +376,7 @@ static_library("common") {
         "service_process_util.cc",
         "service_process_util.h",
       ]
-      if (is_linux || is_chromeos) {
+      if (is_linux || is_chromeos || is_ohos) {
         sources += [ "service_process_util_linux.cc" ]
       }
       if (is_mac) {
@@ -480,7 +480,7 @@ static_library("common") {
     public_deps += [ "//chrome/common/safe_browsing" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "auto_start_linux.cc",
       "auto_start_linux.h",
@@ -627,7 +627,7 @@ static_library("constants") {
       "chrome_paths_lacros.h",
     ]
     deps += [ "//chromeos/crosapi/cpp" ]
-  } else if (is_linux || is_chromeos) {
+  } else if (is_linux || is_chromeos || is_ohos) {
     sources += [ "chrome_paths_linux.cc" ]
   }
   if (is_mac) {
diff --git a/chrome/common/channel_info.h b/chrome/common/channel_info.h
index 8881e314d0..75cf8ed776 100644
--- a/chrome/common/channel_info.h
+++ b/chrome/common/channel_info.h
@@ -93,7 +93,7 @@ std::string GetChannelSuffixForDataDir();
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 // Returns the channel-specific filename of the desktop shortcut used to launch
 // the browser.
 std::string GetDesktopName(base::Environment* env);
diff --git a/chrome/common/channel_info_posix.cc b/chrome/common/channel_info_posix.cc
index 62ff67422f..b5b1dac943 100644
--- a/chrome/common/channel_info_posix.cc
+++ b/chrome/common/channel_info_posix.cc
@@ -90,7 +90,7 @@ std::string GetChannelSuffixForDataDir() {
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 std::string GetDesktopName(base::Environment* env) {
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   // Google Chrome packaged as a snap is a special case: the application name
diff --git a/chrome/common/chrome_features.cc b/chrome/common/chrome_features.cc
index 543a1ad197..5a0fcf9539 100644
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -81,7 +81,7 @@ const base::Feature kAsyncDns {
 #endif
 };
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Enables the Restart background mode optimization. When all Chrome UI is
 // closed and it goes in the background, allows to restart the browser to
 // discard memory.
@@ -339,7 +339,7 @@ const base::Feature kEnableAllSystemWebApps{"EnableAllSystemWebApps",
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
 #if defined(OS_WIN) || (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_OHOS)
 COMPONENT_EXPORT(CHROME_FEATURES)
 // Enables ephemeral Guest profiles on desktop.
 extern const base::Feature kEnableEphemeralGuestProfilesOnDesktop{
@@ -515,7 +515,7 @@ const base::Feature kIncompatibleApplicationsWarning{
 #endif
 
 #if defined(OS_MAC) || defined(OS_WIN) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 // When enabled, removes any theme or background customization done by the user
 // and also overrides any dark/light mode treatment on the Incognito UI.
 const base::Feature kIncognitoBrandConsistencyForDesktop{
diff --git a/chrome/common/chrome_features.h b/chrome/common/chrome_features.h
index 2bc88bc829..e2f1b81a12 100644
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -70,7 +70,7 @@ extern const base::Feature kAppShimNewCloseBehavior;
 
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kAsyncDns;
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kBackgroundModeAllowRestart;
 #endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS)
@@ -228,7 +228,7 @@ extern const base::Feature kEnableAmbientAuthenticationInIncognito;
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
 #if defined(OS_WIN) || (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_OHOS)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnableEphemeralGuestProfilesOnDesktop;
 #endif  // defined(OS_WIN) || (defined(OS_LINUX) ||
@@ -343,7 +343,7 @@ extern const base::Feature kIncompatibleApplicationsWarning;
 #endif  // defined(OS_ANDROID)
 
 #if defined(OS_MAC) || defined(OS_WIN) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kIncognitoBrandConsistencyForDesktop;
 #endif
diff --git a/chrome/common/chrome_paths.h b/chrome/common/chrome_paths.h
index 0dfe8a6652..d19697ae35 100644
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -111,7 +111,7 @@ enum {
   DIR_CHROMEOS_CUSTOM_WALLPAPERS,     // Directory where custom wallpapers
                                       // reside.
 #endif
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_OHOS)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 99346c8012..446867010f 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -809,7 +809,7 @@ const char kAllowNaClSocketAPI[]            = "allow-nacl-socket-api";
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN)
+    defined(OS_WIN) || defined(OS_OHOS)
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 
 // Causes the browser to launch directly in guest mode.
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index fd5496c91f..6e90b0c427 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -256,7 +256,7 @@ extern const char kAllowNaClSocketAPI[];
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN)
+    defined(OS_WIN) || defined(OS_OHOS)
 extern const char kEnableNewAppMenuIcon[];
 extern const char kGuest[];
 #endif
diff --git a/chrome/common/features.gni b/chrome/common/features.gni
index 4452a2ec88..275786d440 100644
--- a/chrome/common/features.gni
+++ b/chrome/common/features.gni
@@ -40,7 +40,7 @@ declare_args() {
   enable_basic_print_dialog = enable_basic_printing && !is_chromeos_ash
 
   # Enables the Click to Call feature on desktop platforms.
-  enable_click_to_call = is_mac || is_win || is_linux || is_chromeos
+  enable_click_to_call = is_mac || is_win || is_linux || is_chromeos || is_ohos
 
   # Hangout services is an extension that adds extra features to Hangouts.
   # It is enableable separately to facilitate testing.
diff --git a/chrome/common/importer/BUILD.gn b/chrome/common/importer/BUILD.gn
index 1dc45cbeeb..9b189d98e1 100644
--- a/chrome/common/importer/BUILD.gn
+++ b/chrome/common/importer/BUILD.gn
@@ -91,7 +91,7 @@ source_set("importer") {
     "importer_url_row.h",
     "pstore_declarations.h",
   ]
-  if (is_chromeos || is_linux) {
+  if (is_chromeos || is_linux || is_ohos) {
     sources += [ "firefox_importer_utils_linux.cc" ]
   } else if (is_mac) {
     sources += [
diff --git a/chrome/common/importer/importer_data_types.cc b/chrome/common/importer/importer_data_types.cc
index 9715826b7d..c922096453 100644
--- a/chrome/common/importer/importer_data_types.cc
+++ b/chrome/common/importer/importer_data_types.cc
@@ -34,7 +34,7 @@ ImportedPasswordForm::ImportedPasswordForm() = default;
 ImportedPasswordForm::ImportedPasswordForm(const ImportedPasswordForm& form) =
     default;
 
-ImportedPasswordForm::ImportedPasswordForm(ImportedPasswordForm&& form) =
+ImportedPasswordForm::ImportedPasswordForm(ImportedPasswordForm&& form) noexcept =
     default;
 
 ImportedPasswordForm& ImportedPasswordForm::operator=(
diff --git a/chrome/common/pref_names.cc b/chrome/common/pref_names.cc
index 7dfc0103e9..fa3f2cc91b 100644
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -1113,7 +1113,7 @@ const char kAllowedDomainsForApps[] = "settings.allowed_domains_for_apps";
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 // Linux specific preference on whether we should match the system theme.
 const char kUsesSystemTheme[] = "extensions.theme.use_system";
 #endif
@@ -1264,7 +1264,7 @@ const char kShowUpdatePromotionInfoBar[] =
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 // Boolean that is false if we should show window manager decorations.  If
 // true, we draw a custom chrome frame (thicker title bar and blue border).
 const char kUseCustomChromeFrame[] = "browser.custom_chrome_frame";
@@ -1723,7 +1723,7 @@ const char kDownloadDefaultDirectory[] = "download.default_directory";
 const char kDownloadDirUpgraded[] = "download.directory_upgrade";
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_OHOS)
 const char kOpenPdfDownloadInSystemReader[] =
     "download.open_pdf_in_system_reader";
 #endif
@@ -1993,7 +1993,7 @@ const char kWebAppsUninstalledDefaultChromeApps[] =
 const char kWebAppsPreferences[] = "web_apps.web_app_ids";
 
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_LACROS))
+    (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 // Dictionary that maps origins to web apps that can act as URL handlers.
 const char kWebAppsUrlHandlerInfo[] = "web_apps.url_handler_info";
 #endif
@@ -2109,7 +2109,7 @@ const char kAmbientAuthenticationInPrivateModesEnabled[] =
 // requests.
 const char kBasicAuthOverHttpEnabled[] = "auth.basic_over_http_enabled";
 
-#if defined(OS_LINUX) || defined(OS_MAC) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_MAC) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Boolean that specifies whether OK-AS-DELEGATE flag from KDC is respected
 // along with kAuthNegotiateDelegateAllowlist.
 const char kAuthNegotiateDelegateByKdcPolicy[] =
@@ -2746,7 +2746,7 @@ const char kSigninInterceptionEnabled[] = "signin.interception_enabled";
 
 // TODO(crbug.com/1179280): Remove OS_LINUX once https://crbug.com/1169547 is
 // done.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Boolean pref indicating whether the user is allowed to create secondary
 // profiles in Lacros browser. This is set by a policy, and the default value
 // for managed users is false.
@@ -3007,7 +3007,7 @@ const char kBlockAutoplayEnabled[] = "media.block_autoplay";
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 // Boolean that indicates if native notifications are allowed to be used in
 // place of Chrome notifications. Will be replaced by kAllowSystemNotifications.
 const char kAllowNativeNotifications[] = "native_notifications.allowed";
diff --git a/chrome/common/pref_names.h b/chrome/common/pref_names.h
index 4b8a9737e9..e32bc99b29 100644
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -366,7 +366,7 @@ extern const char kForceYouTubeRestrict[];
 extern const char kAllowedDomainsForApps[];
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 extern const char kUsesSystemTheme[];
 #endif
 extern const char kCurrentThemePackFilename[];
@@ -395,7 +395,7 @@ extern const char kShowUpdatePromotionInfoBar[];
 #endif
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 extern const char kUseCustomChromeFrame[];
 #endif
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -568,7 +568,7 @@ extern const char kDownloadExtensionsToOpenByPolicy[];
 extern const char kDownloadAllowedURLsForOpenByPolicy[];
 extern const char kDownloadDirUpgraded[];
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_OHOS)
 extern const char kOpenPdfDownloadInSystemReader[];
 #endif
 #if defined(OS_ANDROID)
@@ -671,7 +671,7 @@ extern const char kWebAppsUninstalledDefaultChromeApps[];
 extern const char kWebAppsPreferences[];
 
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_LACROS))
+    (defined(OS_LINUX) && !BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 extern const char kWebAppsUrlHandlerInfo[];
 #endif
 
@@ -807,7 +807,7 @@ extern const char kGloballyScopeHTTPAuthCacheEnabled[];
 extern const char kAmbientAuthenticationInPrivateModesEnabled[];
 extern const char kBasicAuthOverHttpEnabled[];
 
-#if defined(OS_LINUX) || defined(OS_MAC) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_MAC) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const char kAuthNegotiateDelegateByKdcPolicy[];
 #endif  // defined(OS_LINUX) || defined(OS_MAC) || defined(OS_CHROMEOS)
 
@@ -926,7 +926,7 @@ extern const char kSigninAllowedOnNextStartup[];
 extern const char kSigninInterceptionEnabled[];
 // TODO(crbug.com/1179280): Remove OS_LINUX once https://crbug.com/1169547 is
 // done.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const char kLacrosSecondaryProfilesAllowed[];
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
@@ -1040,7 +1040,7 @@ extern const char kBlockAutoplayEnabled[];
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 extern const char kAllowNativeNotifications[];
 extern const char kAllowSystemNotifications[];
 #endif
diff --git a/chrome/common/service_process_util_posix.cc b/chrome/common/service_process_util_posix.cc
index 059174502d..48bfa7dd46 100644
--- a/chrome/common/service_process_util_posix.cc
+++ b/chrome/common/service_process_util_posix.cc
@@ -117,8 +117,14 @@ ServiceProcessState::CreateServiceProcessDataRegion(size_t size) {
   // Everything has worked out so far, so open a read-only handle to the region
   // in order to be able to create a writable region (which needs a read-only
   // handle in order to convert to a read-only region.
+#if !defined(OS_OHOS)
   base::ScopedFD read_only_fd(
       HANDLE_EINTR(open(path.value().c_str(), O_RDONLY, kOwnerOnly)));
+#else
+  base::ScopedFD read_only_fd(
+      HANDLE_EINTR(open(path.value().c_str(), O_RDONLY | O_CREAT, kOwnerOnly)));
+  LOG(INFO) << "ServiceProcessState::CreateServiceProcessDataRegion read_only_fd TODO for OS_OHOS";
+#endif
   if (!read_only_fd.is_valid()) {
     DPLOG(ERROR) << "Could not reopen shared memory region as read-only";
     return {};
diff --git a/chrome/common/webui_url_constants.cc b/chrome/common/webui_url_constants.cc
index ebfd4062fc..f9509098f4 100644
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -361,7 +361,7 @@ const char kChromeUIWebUIJsErrorURL[] = "chrome://webuijserror/";
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 #endif
@@ -383,7 +383,7 @@ const char kChromeUISandboxHost[] = "sandbox";
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
+    (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
 const char kChromeUIEnterpriseProfileWelcomeHost[] =
diff --git a/chrome/common/webui_url_constants.h b/chrome/common/webui_url_constants.h
index cd2bebc4cf..633ca04d3f 100644
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -306,13 +306,13 @@ extern const char kChromeUIOSSettingsHost[];
 extern const char kChromeUIOSSettingsURL[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const char kChromeUIWebUIJsErrorHost[];
 extern const char kChromeUIWebUIJsErrorURL[];
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 #endif
@@ -327,14 +327,14 @@ extern const char kChromeUILinuxProxyConfigHost[];
 #endif
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_OHOS)
 extern const char kChromeUISandboxHost[];
 #endif
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
 #if defined(OS_WIN) || defined(OS_MAC) || \
-    (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
+    (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
 extern const char kChromeUIEnterpriseProfileWelcomeHost[];
@@ -347,7 +347,7 @@ extern const char kChromeUIProfilePickerStartupQuery[];
 #endif
 
 #if ((defined(OS_LINUX) || defined(OS_CHROMEOS)) && defined(TOOLKIT_VIEWS)) || \
-    defined(USE_AURA)
+    defined(USE_AURA) || defined(OS_OHOS)
 extern const char kChromeUITabModalConfirmDialogHost[];
 #endif
 
diff --git a/chrome/service/cloud_print/print_system.cc b/chrome/service/cloud_print/print_system.cc
index 277ec4236a..cba6e4a1d0 100644
--- a/chrome/service/cloud_print/print_system.cc
+++ b/chrome/service/cloud_print/print_system.cc
@@ -36,7 +36,7 @@ std::string PrintSystem::GenerateProxyId() {
   return base::GenerateGUID();
 }
 
-#if (defined(OS_LINUX) || defined(OS_CHROMEOS)) && !defined(USE_CUPS)
+#if (defined(OS_LINUX) || defined(OS_CHROMEOS)) && !defined(USE_CUPS) || defined(OS_OHOS)
 scoped_refptr<PrintSystem> PrintSystem::CreateInstance(
     const base::DictionaryValue*) {
   return nullptr;
diff --git a/chrome/services/printing/public/mojom/BUILD.gn b/chrome/services/printing/public/mojom/BUILD.gn
index aa96e58b58..143a19cc32 100644
--- a/chrome/services/printing/public/mojom/BUILD.gn
+++ b/chrome/services/printing/public/mojom/BUILD.gn
@@ -35,7 +35,7 @@ mojom("mojom") {
     sources += [ "pdf_to_emf_converter.mojom" ]
   }
 
-  if (is_win || is_mac || is_linux || is_chromeos) {
+  if (is_win || is_mac || is_linux || is_chromeos || is_ohos) {
     sources += [ "print_backend_service.mojom" ]
     deps += [ "//printing/backend/mojom" ]
   }
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 3165971e9e..a2ecab3635 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -1755,7 +1755,7 @@ if (!is_android) {
         "//ash/keyboard/ui:test_support",
         "//chrome/browser/chromeos:arc_test_support",
         "//chrome/browser/chromeos:test_support",
-        "//chrome/browser/media/router:test_support",
+        ##"//chrome/browser/media/router:test_support",
         "//chrome/browser/resources/chromeos/accessibility:browser_tests",
         "//chrome/browser/ui/ash/holding_space:browser_tests",
         "//chrome/services/file_util/public/cpp:browser_tests",
@@ -3392,7 +3392,7 @@ template("performance_test_suite_template") {
     data_deps = [
       "//base:base_perftests",
       "//chrome/test:telemetry_perf_tests",
-      "//components:components_perftests",
+      #"//components:components_perftests",
       "//components/tracing:tracing_perftests",
       "//gpu:command_buffer_perftests",
       "//gpu:gpu_perftests",
@@ -3408,7 +3408,7 @@ template("performance_test_suite_template") {
       data_deps += [ "//third_party/angle/src/tests:angle_perftests" ]
     }
 
-    if (!is_android && !is_fuchsia) {
+    if (!is_android && !is_fuchsia && !is_ohos) {
       data_deps += [
         "//chrome/test:load_library_perf_tests",
         "//ui/views:views_perftests",
diff --git a/chrome/utility/BUILD.gn b/chrome/utility/BUILD.gn
index 3c1c93059d..de5e50c90f 100644
--- a/chrome/utility/BUILD.gn
+++ b/chrome/utility/BUILD.gn
@@ -77,7 +77,35 @@ static_library("utility") {
     deps += [ "//chrome/services/mac_notifications" ]
   }
 
-  if (!is_android) {
+  if (is_ohos) {
+    sources += [
+      "importer/bookmark_html_reader.cc",
+      "importer/bookmark_html_reader.h",
+      "importer/bookmarks_file_importer.cc",
+      "importer/bookmarks_file_importer.h",
+      "importer/external_process_importer_bridge.cc",
+      "importer/external_process_importer_bridge.h",
+      "importer/favicon_reencode.cc",
+      "importer/favicon_reencode.h",
+      "importer/firefox_importer.cc",
+      "importer/firefox_importer.h",
+      "importer/importer.cc",
+      "importer/importer.h",
+      "importer/importer_creator.cc",
+      "importer/importer_creator.h",
+      "importer/profile_import_impl.cc",
+      "importer/profile_import_impl.h",
+    ]
+    deps += [
+      "//chrome/common:mojo_bindings",
+      "//chrome/common/importer:interfaces",
+      "//chrome/services/speech:lib",
+      "//components/autofill/core/common",
+      "//services/proxy_resolver:lib",
+    ]
+  }
+
+  if (!is_android && !is_ohos) {
     sources += [
       "importer/bookmark_html_reader.cc",
       "importer/bookmark_html_reader.h",
diff --git a/chrome/utility/importer/firefox_importer.cc b/chrome/utility/importer/firefox_importer.cc
index 2682b3d386..504e2dece0 100644
--- a/chrome/utility/importer/firefox_importer.cc
+++ b/chrome/utility/importer/firefox_importer.cc
@@ -27,7 +27,7 @@
 #include "sql/statement.h"
 #include "url/gurl.h"
 
-#if !defined(OS_MAC)
+#if !defined(OS_MAC) && !defined(OS_OHOS)
 #include "chrome/utility/importer/nss_decryptor.h"
 #endif
 
@@ -150,7 +150,7 @@ void FirefoxImporter::StartImport(const importer::SourceProfile& source_profile,
     ImportBookmarks();
     bridge_->NotifyItemEnded(importer::FAVORITES);
   }
-#if !defined(OS_MAC)
+#if !defined(OS_MAC) && !defined(OS_OHOS)
   if ((items & importer::PASSWORDS) && !cancelled()) {
     bridge_->NotifyItemStarted(importer::PASSWORDS);
     ImportPasswords();
@@ -375,7 +375,7 @@ void FirefoxImporter::ImportBookmarks() {
   }
 }
 
-#if !defined(OS_MAC)
+#if !defined(OS_MAC) && !defined(OS_OHOS)
 void FirefoxImporter::ImportPasswords() {
   // Initializes NSS3.
   NSSDecryptor decryptor;
diff --git a/chrome/utility/importer/firefox_importer.h b/chrome/utility/importer/firefox_importer.h
index 456da624fe..1a3e4b4a51 100644
--- a/chrome/utility/importer/firefox_importer.h
+++ b/chrome/utility/importer/firefox_importer.h
@@ -60,7 +60,7 @@ class FirefoxImporter : public Importer {
 
   FRIEND_TEST_ALL_PREFIXES(FirefoxImporterTest, ImportBookmarksV25);
   void ImportBookmarks();
-#if !defined(OS_MAC)
+#if !defined(OS_MAC) && !defined(OS_OHOS)
   void ImportPasswords();
 #endif
   void ImportHistory();
diff --git a/components/BUILD.gn b/components/BUILD.gn
index c8d828c205..28e3e365e3 100644
--- a/components/BUILD.gn
+++ b/components/BUILD.gn
@@ -49,7 +49,7 @@ if (is_ios) {
 test("components_unittests") {
   use_xvfb = use_xvfb_in_this_config
 
-  if (is_android || is_linux || is_chromeos || is_mac || is_win) {
+  if (is_android || is_linux || is_chromeos || is_mac || is_win || is_ohos) {
     data = [ "test/data/" ]
   }
 
@@ -421,7 +421,7 @@ test("components_unittests") {
   }
 
   # Desktop-only deps.
-  if (!is_android && !is_ios) {
+  if (!is_android && !is_ios && !is_ohos) {
     deps += [
       # See comment in components/guest_view/browser/BUILD.gn for why
       # guest_view is currently non-mobile.
diff --git a/components/bookmarks/browser/BUILD.gn b/components/bookmarks/browser/BUILD.gn
index abbb395c67..8d8756f578 100644
--- a/components/bookmarks/browser/BUILD.gn
+++ b/components/bookmarks/browser/BUILD.gn
@@ -79,7 +79,7 @@ static_library("browser") {
     all_dependent_configs = [ "//ui/views:flags" ]
   }
 
-  if (toolkit_views && !is_mac) {
+  if (toolkit_views && !is_mac || is_ohos) {
     sources += [ "bookmark_node_data_views.cc" ]
   }
 
diff --git a/components/bookmarks/browser/bookmark_node_data.h b/components/bookmarks/browser/bookmark_node_data.h
index 36cf5ee89d..ca07845a7c 100644
--- a/components/bookmarks/browser/bookmark_node_data.h
+++ b/components/bookmarks/browser/bookmark_node_data.h
@@ -18,7 +18,7 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #include "url/gurl.h"
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 #include "ui/base/clipboard/clipboard_format_type.h"
 #endif
 
@@ -27,7 +27,7 @@ class Pickle;
 class PickleIterator;
 }
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
 namespace ui {
 class OSExchangeData;
 }
@@ -114,7 +114,7 @@ struct BookmarkNodeData {
 
   ~BookmarkNodeData();
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
   static const ui::ClipboardFormatType& GetBookmarkFormatType();
 #endif
 
@@ -133,7 +133,7 @@ struct BookmarkNodeData {
   // WriteToClipboard() but will also attempt to read a plain bookmark.
   bool ReadFromClipboard(ui::ClipboardBuffer buffer);
 
-#if defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS) || defined(OS_OHOS)
   // Writes elements to data. If there is only one element and it is a URL
   // the URL and title are written to the clipboard in a format other apps can
   // use.
diff --git a/components/captive_portal/core/features.gni b/components/captive_portal/core/features.gni
index 9b277f56f4..f4903f333f 100644
--- a/components/captive_portal/core/features.gni
+++ b/components/captive_portal/core/features.gni
@@ -6,5 +6,5 @@ import("//build/config/compiler/compiler.gni")
 
 # Please keep features in alphabetical order.
 declare_args() {
-  enable_captive_portal_detection = !is_android && !is_chromecast && !is_ios
+  enable_captive_portal_detection = !is_android && !is_chromecast && !is_ios && !is_ohos
 }
diff --git a/components/content_settings/core/browser/website_settings_registry.cc b/components/content_settings/core/browser/website_settings_registry.cc
index e2900ed03e..d812b8d7c1 100644
--- a/components/content_settings/core/browser/website_settings_registry.cc
+++ b/components/content_settings/core/browser/website_settings_registry.cc
@@ -96,6 +96,8 @@ const WebsiteSettingsInfo* WebsiteSettingsRegistry::Register(
   if (!(platform & PLATFORM_FUCHSIA))
     return nullptr;
   sync_status = WebsiteSettingsInfo::UNSYNCABLE;
+#elif defined(OS_OHOS)
+  sync_status = WebsiteSettingsInfo::UNSYNCABLE;
 #else
 #error "Unsupported platform"
 #endif
diff --git a/components/crash/content/browser/BUILD.gn b/components/crash/content/browser/BUILD.gn
index 5d51207878..ae3f74a5ea 100644
--- a/components/crash/content/browser/BUILD.gn
+++ b/components/crash/content/browser/BUILD.gn
@@ -21,7 +21,7 @@ source_set("browser") {
     "//content/public/common",
   ]
 
-  if (is_linux || is_chromeos || is_android) {
+  if (is_linux || is_chromeos || is_android || is_ohos) {
     # Want this file on both Linux and Android.
     sources += [
       "crash_handler_host_linux.cc",
diff --git a/components/crash/core/app/BUILD.gn b/components/crash/core/app/BUILD.gn
index 29ff6a8adc..96fa3f199d 100644
--- a/components/crash/core/app/BUILD.gn
+++ b/components/crash/core/app/BUILD.gn
@@ -52,7 +52,7 @@ static_library("app") {
     "crashpad.h",
   ]
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "breakpad_linux.cc",
       "breakpad_linux.h",
@@ -88,7 +88,7 @@ static_library("app") {
     libs = [ "log" ]
   }
 
-  if (is_android || is_linux || is_chromeos) {
+  if (is_android || is_linux || is_chromeos || is_ohos) {
     deps += [
       "//base:base_static",
       "//components/crash/core/common",
@@ -96,7 +96,7 @@ static_library("app") {
     ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     deps += [ "//third_party/breakpad:client" ]
   }
 
@@ -129,7 +129,7 @@ static_library("app") {
     sources += [ "crashpad_ios.mm" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     data_deps = [ "//third_party/crashpad/crashpad/handler:crashpad_handler" ]
   }
 }
diff --git a/components/crash/core/app/crash_switches.cc b/components/crash/core/app/crash_switches.cc
index dfcb6bd37c..04307930ab 100644
--- a/components/crash/core/app/crash_switches.cc
+++ b/components/crash/core/app/crash_switches.cc
@@ -17,7 +17,7 @@ namespace switches {
 // is a standalone executable.
 const char kCrashpadHandler[] = "crashpad-handler";
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // The process ID of the Crashpad handler.
 const char kCrashpadHandlerPid[] = "crashpad-handler-pid";
 #endif
diff --git a/components/crash/core/app/crash_switches.h b/components/crash/core/app/crash_switches.h
index 1855b80d18..bb617ce855 100644
--- a/components/crash/core/app/crash_switches.h
+++ b/components/crash/core/app/crash_switches.h
@@ -13,7 +13,7 @@ namespace switches {
 
 extern const char kCrashpadHandler[];
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const char kCrashpadHandlerPid[];
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
diff --git a/components/crash/core/app/crashpad.cc b/components/crash/core/app/crashpad.cc
index 851fc33b89..b7c71a8f30 100644
--- a/components/crash/core/app/crashpad.cc
+++ b/components/crash/core/app/crashpad.cc
@@ -124,7 +124,7 @@ void InitializeCrashpadImpl(bool initial_client,
     DCHECK(browser_process || process_type == "Chrome Installer" ||
            process_type == "notification-helper" ||
            process_type == "GCPW Installer" || process_type == "GCPW DLL");
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
     DCHECK(browser_process);
 #else
 #error Port.
@@ -199,7 +199,7 @@ void InitializeCrashpadImpl(bool initial_client,
   // other "main, first process" to initialize things. There is no "relauncher"
   // on Windows, so this is synonymous with initial_client.
   const bool should_initialize_database_and_set_upload_policy = initial_client;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   const bool should_initialize_database_and_set_upload_policy = browser_process;
 #endif
   if (should_initialize_database_and_set_upload_policy) {
@@ -277,7 +277,8 @@ void DumpWithoutCrashing() {
 }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 void CrashWithoutDumping(const std::string& message) {
   crashpad::CrashpadClient::CrashWithoutDump(message);
 }
diff --git a/components/crash/core/app/crashpad.h b/components/crash/core/app/crashpad.h
index 032e78128e..c2730b99e0 100644
--- a/components/crash/core/app/crashpad.h
+++ b/components/crash/core/app/crashpad.h
@@ -38,7 +38,7 @@ class CrashReportDatabase;
 
 namespace crash_reporter {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 bool IsCrashpadEnabled();
 #endif
 
@@ -146,7 +146,7 @@ void RequestSingleCrashUpload(const std::string& local_id);
 
 void DumpWithoutCrashing();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 // Logs message and immediately crashes the current process without triggering a
 // crash dump.
 void CrashWithoutDumping(const std::string& message);
@@ -197,10 +197,13 @@ bool DumpWithoutCrashingForClient(CrashReporterClient* client);
 void AllowMemoryRange(void* begin, size_t size);
 #endif  // OS_ANDROID
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
+
+#if !defined(__MUSL__)
 // Install a handler that gets a chance to handle faults before Crashpad. This
 // is used by V8 for trap-based bounds checks.
 void SetFirstChanceExceptionHandler(bool (*handler)(int, siginfo_t*, void*));
+#endif
 
 // Gets the socket and process ID of the Crashpad handler connected to this
 // process, valid if this function returns `true`.
diff --git a/components/crash/core/app/crashpad_linux.cc b/components/crash/core/app/crashpad_linux.cc
index 8eb3f40775..2c570912f2 100644
--- a/components/crash/core/app/crashpad_linux.cc
+++ b/components/crash/core/app/crashpad_linux.cc
@@ -28,6 +28,7 @@ namespace crash_reporter {
 
 namespace {
 
+#if !defined(__MUSL__)
 // TODO(jperaza): This is the first chance handler type used by Breakpad and v8.
 // The Crashpad FirstChanceHandler type explicitly declares the third parameter
 // to be a ucontext_t* instead of a void*. Using a reinterpret cast to convert
@@ -42,15 +43,18 @@ bool FirstChanceHandlerHelper(int signo,
                               ucontext_t* context) {
   return g_first_chance_handler(signo, siginfo, context);
 }
+#endif
 
 }  // namespace
 
+#if !defined(__MUSL__)
 void SetFirstChanceExceptionHandler(bool (*handler)(int, siginfo_t*, void*)) {
   DCHECK(!g_first_chance_handler);
   g_first_chance_handler = handler;
   crashpad::CrashpadClient::SetFirstChanceExceptionHandler(
       FirstChanceHandlerHelper);
 }
+#endif
 
 bool IsCrashpadEnabled() {
   return base::CommandLine::ForCurrentProcess()->HasSwitch(
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index 3fe061b30f..7d93a65fdb 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -46,7 +46,7 @@ std::string GetUserAgent() {
   }
 
   std::string product = GetProduct();
-#if defined(OS_ANDROID)
+#if (defined(OS_ANDROID) || defined(OS_OHOS))
   if (command_line->HasSwitch(switches::kUseMobileUserAgent))
     product += " Mobile";
 #endif
diff --git a/components/feature_engagement/public/event_constants.cc b/components/feature_engagement/public/event_constants.cc
index 1c675326b6..684b2e4b76 100644
--- a/components/feature_engagement/public/event_constants.cc
+++ b/components/feature_engagement/public/event_constants.cc
@@ -11,13 +11,13 @@ namespace feature_engagement {
 namespace events {
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 const char kNewTabOpened[] = "new_tab_opened";
 #endif  // defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) ||
         // defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 const char kSixthTabOpened[] = "sixth_tab_opened";
 const char kTabGroupCreated[] = "tab_group_created";
 
diff --git a/components/feature_engagement/public/event_constants.h b/components/feature_engagement/public/event_constants.h
index f541f1e59c..cb68a8c411 100644
--- a/components/feature_engagement/public/event_constants.h
+++ b/components/feature_engagement/public/event_constants.h
@@ -13,7 +13,7 @@ namespace events {
 
 // Desktop and IOS.
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 // The user has explicitly opened a new tab via an entry point from inside of
 // Chrome.
 extern const char kNewTabOpened[];
@@ -22,7 +22,7 @@ extern const char kNewTabOpened[];
 
 // Desktop
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 // A new tab was opened when 5 (or more) tabs were already open.
 extern const char kSixthTabOpened[];
 // The user made a new tab group.
diff --git a/components/feature_engagement/public/feature_constants.cc b/components/feature_engagement/public/feature_constants.cc
index d7dc1e411a..ea59364a75 100644
--- a/components/feature_engagement/public/feature_constants.cc
+++ b/components/feature_engagement/public/feature_constants.cc
@@ -13,7 +13,7 @@ const base::Feature kIPHDummyFeature{"IPH_Dummy",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 const base::Feature kIPHDesktopTabGroupsNewGroupFeature{
     "IPH_DesktopTabGroupsNewGroup", base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kIPHFocusModeFeature{"IPH_FocusMode",
diff --git a/components/feature_engagement/public/feature_constants.h b/components/feature_engagement/public/feature_constants.h
index 3f75bc7503..d31f91e4c5 100644
--- a/components/feature_engagement/public/feature_constants.h
+++ b/components/feature_engagement/public/feature_constants.h
@@ -17,7 +17,7 @@ extern const base::Feature kIPHDemoMode;
 extern const base::Feature kIPHDummyFeature;
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 extern const base::Feature kIPHDesktopTabGroupsNewGroupFeature;
 extern const base::Feature kIPHFocusModeFeature;
 extern const base::Feature kIPHGlobalMediaControlsFeature;
diff --git a/components/feature_engagement/public/feature_list.cc b/components/feature_engagement/public/feature_list.cc
index ca8078ef00..e17aae8492 100644
--- a/components/feature_engagement/public/feature_list.cc
+++ b/components/feature_engagement/public/feature_list.cc
@@ -81,7 +81,7 @@ const base::Feature* const kAllFeatures[] = {
     &kIPHDiscoverFeedHeaderFeature,
 #endif  // defined(OS_IOS)
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
     &kIPHDesktopTabGroupsNewGroupFeature,
     &kIPHFocusModeFeature,
     &kIPHGlobalMediaControlsFeature,
diff --git a/components/feature_engagement/public/feature_list.h b/components/feature_engagement/public/feature_list.h
index 4a396d2b68..faeb61ebaf 100644
--- a/components/feature_engagement/public/feature_list.h
+++ b/components/feature_engagement/public/feature_list.h
@@ -151,7 +151,7 @@ DEFINE_VARIATION_PARAM(kIPHDiscoverFeedHeaderFeature,
 #endif  // defined(OS_IOS)
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 DEFINE_VARIATION_PARAM(kIPHDesktopTabGroupsNewGroupFeature,
                        "IPH_DesktopTabGroupsNewGroup");
 DEFINE_VARIATION_PARAM(kIPHFocusModeFeature, "IPH_FocusMode");
@@ -240,7 +240,7 @@ constexpr flags_ui::FeatureEntry::FeatureVariation
         VARIATION_ENTRY(kIPHBadgedTranslateManualTriggerFeature),
         VARIATION_ENTRY(kIPHDiscoverFeedHeaderFeature),
 #elif defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
         VARIATION_ENTRY(kIPHDesktopTabGroupsNewGroupFeature),
         VARIATION_ENTRY(kIPHFocusModeFeature),
         VARIATION_ENTRY(kIPHGlobalMediaControls),
diff --git a/components/flags_ui/flags_state.cc b/components/flags_ui/flags_state.cc
index ada1da69c7..c28edea370 100644
--- a/components/flags_ui/flags_state.cc
+++ b/components/flags_ui/flags_state.cc
@@ -108,6 +108,7 @@ const struct {
     {kOsLinux, "Linux"},     {kOsCrOS, "Chrome OS"},
     {kOsAndroid, "Android"}, {kOsCrOSOwnerOnly, "Chrome OS (owner only)"},
     {kOsIos, "iOS"},         {kOsFuchsia, "Fuchsia"},
+    {kOsOhOS, "OhOS"}
 };
 
 // Adds a |StringValue| to |list| for each platform where |bitmask| indicates
@@ -695,6 +696,8 @@ int FlagsState::GetCurrentPlatform() {
   return kOsAndroid;
 #elif defined(OS_FUCHSIA)
   return kOsFuchsia;
+#elif defined(OS_OHOS)
+  return kOsOhOS;
 #else
 #error Unknown platform
 #endif
diff --git a/components/flags_ui/flags_state.h b/components/flags_ui/flags_state.h
index 5e2ecd999c..356bc564e1 100644
--- a/components/flags_ui/flags_state.h
+++ b/components/flags_ui/flags_state.h
@@ -46,10 +46,11 @@ enum {
   kOsIos = 1 << 6,
   kDeprecated = 1 << 7,
   kOsFuchsia = 1 << 8,
+  kOsOhOS = 1 << 9,
 
   // Flags marked with this are internal to the flags system. Never set this on
   // a manually-added flag.
-  kFlagInfrastructure = 1 << 9,
+  kFlagInfrastructure = 1 << 10,
 };
 
 // A flag controlling the behavior of the |ConvertFlagsToSwitches| function -
diff --git a/components/javascript_dialogs/BUILD.gn b/components/javascript_dialogs/BUILD.gn
index 9403425594..ff109d2a53 100644
--- a/components/javascript_dialogs/BUILD.gn
+++ b/components/javascript_dialogs/BUILD.gn
@@ -41,7 +41,7 @@ static_library("javascript_dialogs") {
     deps += [ "//ui/aura" ]
   }
 
-  if (toolkit_views) {
+  if (toolkit_views || is_ohos) {
     sources += [
       "views/app_modal_dialog_view_views.cc",
       "views/app_modal_dialog_view_views.h",
diff --git a/components/metrics/BUILD.gn b/components/metrics/BUILD.gn
index 2e7364c47c..48da7db8e3 100644
--- a/components/metrics/BUILD.gn
+++ b/components/metrics/BUILD.gn
@@ -142,7 +142,7 @@ static_library("metrics") {
     sources += [ "drive_metrics_provider_ios.mm" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "drive_metrics_provider_linux.cc",
       "system_memory_stats_recorder_linux.cc",
diff --git a/components/offline_pages/buildflags/features.gni b/components/offline_pages/buildflags/features.gni
index 2c8c75b1f4..09b6a0e609 100644
--- a/components/offline_pages/buildflags/features.gni
+++ b/components/offline_pages/buildflags/features.gni
@@ -5,7 +5,7 @@
 declare_args() {
   # Whether to enable OfflinePages support. Currently user-visible features
   # are Android-only.
-  enable_offline_pages = is_android
+  enable_offline_pages = is_android || is_ohos
 
   # This enables test API for locally-built harness which is used for quality
   # evaluations. Requires setting this variable manually at local environment.
diff --git a/components/optimization_guide/features.gni b/components/optimization_guide/features.gni
index 7c43da5f2f..25a29e5478 100644
--- a/components/optimization_guide/features.gni
+++ b/components/optimization_guide/features.gni
@@ -8,5 +8,5 @@ declare_args() {
   # Disable tflite build on Windows on ARM
   # http://crbug.com/1169611
   build_with_tflite_lib = is_android || (is_win && target_cpu != "arm64") ||
-                          is_linux || is_mac || is_chromeos
+                          is_linux || is_mac || is_chromeos || is_ohos
 }
diff --git a/components/os_crypt/BUILD.gn b/components/os_crypt/BUILD.gn
index 79f9744a94..5f20ee306a 100644
--- a/components/os_crypt/BUILD.gn
+++ b/components/os_crypt/BUILD.gn
@@ -52,7 +52,7 @@ component("os_crypt") {
   defines = [ "IS_OS_CRYPT_IMPL" ]
 
   if ((is_posix || is_fuchsia) && !is_apple &&
-      (!(is_linux || is_chromeos_lacros) || is_chromecast)) {
+      (!(is_linux || is_chromeos_lacros || is_ohos) || is_chromecast)) {
     sources += [ "os_crypt_posix.cc" ]
   }
 
@@ -69,7 +69,7 @@ component("os_crypt") {
     libs = [ "crypt32.lib" ]
   }
 
-  if ((is_linux || is_chromeos_lacros) && !is_chromecast) {
+  if ((is_linux || is_chromeos_lacros || is_ohos) && !is_chromecast) {
     sources += [
       "key_storage_config_linux.cc",
       "key_storage_config_linux.h",
diff --git a/components/os_crypt/os_crypt.h b/components/os_crypt/os_crypt.h
index e5ac0cfd3a..c2f49e1d2a 100644
--- a/components/os_crypt/os_crypt.h
+++ b/components/os_crypt/os_crypt.h
@@ -38,7 +38,7 @@ class OSCrypt {
  public:
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
   // Set the configuration of OSCrypt.
   static COMPONENT_EXPORT(OS_CRYPT) void SetConfig(
       std::unique_ptr<os_crypt::Config> config);
@@ -47,7 +47,7 @@ class OSCrypt {
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
 #if defined(OS_APPLE) || defined(OS_WIN) || \
-    (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
+    (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || defined(OS_OHOS)
   // On Linux returns true iff the real secret key (not hardcoded one) is
   // available. On MacOS returns true if Keychain is available (for mock
   // Keychain it returns true if not using locked Keychain, false if using
diff --git a/components/paint_preview/common/serial_utils.cc b/components/paint_preview/common/serial_utils.cc
index 8fd6f25be7..e5566fb147 100644
--- a/components/paint_preview/common/serial_utils.cc
+++ b/components/paint_preview/common/serial_utils.cc
@@ -167,9 +167,9 @@ PictureSerializationContext::PictureSerializationContext() = default;
 PictureSerializationContext::~PictureSerializationContext() = default;
 
 PictureSerializationContext::PictureSerializationContext(
-    PictureSerializationContext&&) = default;
+    PictureSerializationContext&&) noexcept = default;
 PictureSerializationContext& PictureSerializationContext::operator=(
-    PictureSerializationContext&&) = default;
+    PictureSerializationContext&&) noexcept = default;
 
 TypefaceSerializationContext::TypefaceSerializationContext(
     TypefaceUsageMap* usage)
diff --git a/components/password_manager/content/browser/content_password_manager_driver.cc b/components/password_manager/content/browser/content_password_manager_driver.cc
index eacdd7d1ac..9273b805d5 100644
--- a/components/password_manager/content/browser/content_password_manager_driver.cc
+++ b/components/password_manager/content/browser/content_password_manager_driver.cc
@@ -316,7 +316,7 @@ void ContentPasswordManagerDriver::CheckSafeBrowsingReputation(
   if (client_->GetMetricsRecorder()) {
     client_->GetMetricsRecorder()->RecordUserFocusedPasswordField();
   }
-#if defined(ON_FOCUS_PING_ENABLED)
+#if defined(ON_FOCUS_PING_ENABLED) && BUILDFLAG(FULL_SAFE_BROWSING)
   client_->CheckSafeBrowsingReputation(form_action, frame_url);
 #endif
 }
diff --git a/components/password_manager/core/browser/password_manager_client.h b/components/password_manager/core/browser/password_manager_client.h
index c293bf6ed9..099adbdc8b 100644
--- a/components/password_manager/core/browser/password_manager_client.h
+++ b/components/password_manager/core/browser/password_manager_client.h
@@ -334,7 +334,7 @@ class PasswordManagerClient {
   virtual safe_browsing::PasswordProtectionService*
   GetPasswordProtectionService() const = 0;
 
-#if defined(ON_FOCUS_PING_ENABLED)
+#if defined(ON_FOCUS_PING_ENABLED) && BUILDFLAG(FULL_SAFE_BROWSING)
   // Checks the safe browsing reputation of the webpage when the
   // user focuses on a username/password field. This is used for reporting
   // only, and won't trigger a warning.
diff --git a/components/policy/BUILD.gn b/components/policy/BUILD.gn
index fe41262bb1..23647319f5 100644
--- a/components/policy/BUILD.gn
+++ b/components/policy/BUILD.gn
@@ -21,7 +21,7 @@ gen_policy_templates_local = false
 # enable these flags (but don't check that in!).
 gen_policy_templates_common = true
 gen_policy_templates_win = is_win
-gen_policy_templates_linux = is_linux || is_chromeos
+gen_policy_templates_linux = is_linux || is_chromeos || is_ohos
 gen_policy_templates_android = is_android
 gen_policy_templates_mac = is_mac
 gen_policy_templates_chromeos = is_chromeos_ash
diff --git a/components/renderer_context_menu/BUILD.gn b/components/renderer_context_menu/BUILD.gn
index ab75890d2a..2998febc70 100644
--- a/components/renderer_context_menu/BUILD.gn
+++ b/components/renderer_context_menu/BUILD.gn
@@ -29,7 +29,7 @@ static_library("renderer_context_menu") {
     "//ui/base",
   ]
 
-  if (toolkit_views) {
+  if (toolkit_views || is_ohos) {
     sources += [
       "views/toolkit_delegate_views.cc",
       "views/toolkit_delegate_views.h",
diff --git a/components/safe_browsing/content/browser/client_side_detection_host.cc b/components/safe_browsing/content/browser/client_side_detection_host.cc
index 76852c30a3..b2b850cbdb 100644
--- a/components/safe_browsing/content/browser/client_side_detection_host.cc
+++ b/components/safe_browsing/content/browser/client_side_detection_host.cc
@@ -343,6 +343,7 @@ void ClientSideDetectionHost::DidFinishNavigation(
 
   current_url_ = navigation_handle->GetURL();
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Check whether we can cassify the current URL for phishing.
   classification_request_ = new ShouldClassifyUrlRequest(
       navigation_handle,
@@ -350,10 +351,12 @@ void ClientSideDetectionHost::DidFinishNavigation(
                      weak_factory_.GetWeakPtr()),
       web_contents(), csd_service_, database_manager_.get(), this);
   classification_request_->Start();
+#endif
 }
 
 void ClientSideDetectionHost::SendModelToRenderFrame() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!web_contents() || web_contents() != tab_ || !csd_service_)
     return;
 
@@ -366,6 +369,7 @@ void ClientSideDetectionHost::SendModelToRenderFrame() {
         phishing_detector_.BindNewPipeAndPassReceiver());
     phishing_detector_->SetPhishingModel(csd_service_->GetModelStr());
   }
+#endif
 }
 
 void ClientSideDetectionHost::WebContentsDestroyed() {
@@ -379,16 +383,19 @@ void ClientSideDetectionHost::WebContentsDestroyed() {
 
 void ClientSideDetectionHost::RenderFrameCreated(
     content::RenderFrameHost* render_frame_host) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (phishing_detector_)
     phishing_detector_.reset();
   render_frame_host->GetRemoteInterfaces()->GetInterface(
       phishing_detector_.BindNewPipeAndPassReceiver());
   phishing_detector_->SetPhishingModel(csd_service_->GetModelStr());
+#endif
 }
 
 void ClientSideDetectionHost::OnPhishingPreClassificationDone(
     bool should_classify) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (should_classify) {
     content::RenderFrameHost* rfh = web_contents()->GetMainFrame();
     phishing_detector_.reset();
@@ -400,6 +407,7 @@ void ClientSideDetectionHost::OnPhishingPreClassificationDone(
         base::BindOnce(&ClientSideDetectionHost::PhishingDetectionDone,
                        weak_factory_.GetWeakPtr()));
   }
+#endif
 }
 
 void ClientSideDetectionHost::PhishingDetectionDone(
@@ -468,7 +476,7 @@ void ClientSideDetectionHost::MaybeShowPhishingWarning(bool is_from_cache,
     base::UmaHistogramBoolean("SBClientPhishing.ServerModelDetectsPhishing",
                               is_phishing);
   }
-
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (is_phishing) {
     DCHECK(web_contents());
     if (ui_manager_.get()) {
@@ -494,6 +502,7 @@ void ClientSideDetectionHost::MaybeShowPhishingWarning(bool is_from_cache,
     // consider the malware vedict.
     weak_factory_.InvalidateWeakPtrs();
   }
+#endif
 }
 
 void ClientSideDetectionHost::set_client_side_detection_service(
diff --git a/components/safe_browsing/content/browser/client_side_detection_host.h b/components/safe_browsing/content/browser/client_side_detection_host.h
index 061788805f..d1a01438a2 100644
--- a/components/safe_browsing/content/browser/client_side_detection_host.h
+++ b/components/safe_browsing/content/browser/client_side_detection_host.h
@@ -17,6 +17,7 @@
 #include "components/safe_browsing/content/common/safe_browsing.mojom-shared.h"
 #include "components/safe_browsing/content/common/safe_browsing.mojom.h"
 #include "components/safe_browsing/core/db/database_manager.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/service_manager/public/cpp/binder_registry.h"
@@ -129,8 +130,11 @@ class ClientSideDetectionHost : public content::WebContentsObserver {
   scoped_refptr<ShouldClassifyUrlRequest> classification_request_;
   // The current URL
   GURL current_url_;
+
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // The currently active message pipe to the renderer PhishingDetector.
   mojo::Remote<mojom::PhishingDetector> phishing_detector_;
+  #endif
 
   // Records the start time of when phishing detection started.
   base::TimeTicks phishing_detection_start_time_;
diff --git a/components/safe_browsing/content/common/safe_browsing.mojom b/components/safe_browsing/content/common/safe_browsing.mojom
index fc814aa58c..e1fdb4f3a3 100644
--- a/components/safe_browsing/content/common/safe_browsing.mojom
+++ b/components/safe_browsing/content/common/safe_browsing.mojom
@@ -117,7 +117,7 @@ enum PhishingDetectorResult {
   INVALID_SCORE = 4,
 };
 
-[EnableIf=full_safe_browsing]
+// [EnableIf=full_safe_browsing]  // remove safe browsing
 // Interface for setting the CSD model and to start phishing classification.
 interface PhishingDetector {
   // A classification model for client-side phishing detection.
diff --git a/components/safe_browsing/core/file_type_policies.cc b/components/safe_browsing/core/file_type_policies.cc
index 30df9b49f2..f1f10b6fab 100644
--- a/components/safe_browsing/core/file_type_policies.cc
+++ b/components/safe_browsing/core/file_type_policies.cc
@@ -10,6 +10,7 @@
 #include "base/strings/string_util.h"
 #include "components/grit/components_resources.h"
 #include "ui/base/resource/resource_bundle.h"
+#include "components/safe_browsing/buildflags.h"
 
 namespace safe_browsing {
 
@@ -21,7 +22,9 @@ struct FileTypePoliciesSingletonTrait
     : public base::DefaultSingletonTraits<FileTypePolicies> {
   static FileTypePolicies* New() {
     FileTypePolicies* instance = new FileTypePolicies();
+#if BUILDFLAG(FULL_SAFE_BROWSING)
     instance->PopulateFromResourceBundle();
+#endif
     return instance;
   }
 };
@@ -48,10 +51,12 @@ FileTypePolicies::~FileTypePolicies() {
   AutoLock lock(lock_);  // DCHECK fail if the lock is held.
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 std::string FileTypePolicies::ReadResourceBundle() {
   ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
   return bundle.LoadDataResourceString(IDR_DOWNLOAD_FILE_TYPES_PB);
 }
+#endif
 
 void FileTypePolicies::RecordUpdateMetrics(UpdateResult result,
                                            const std::string& src_name) {
@@ -67,12 +72,14 @@ void FileTypePolicies::RecordUpdateMetrics(UpdateResult result,
   }
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void FileTypePolicies::PopulateFromResourceBundle() {
   AutoLock lock(lock_);
   std::string binary_pb = ReadResourceBundle();
   UpdateResult result = PopulateFromBinaryPb(binary_pb);
   RecordUpdateMetrics(result, "ResourceBundle");
 }
+#endif
 
 void FileTypePolicies::PopulateFromDynamicUpdate(const std::string& binary_pb) {
   AutoLock lock(lock_);
diff --git a/components/safe_browsing/core/file_type_policies.h b/components/safe_browsing/core/file_type_policies.h
index 45f0c09226..49f8f09d6b 100644
--- a/components/safe_browsing/core/file_type_policies.h
+++ b/components/safe_browsing/core/file_type_policies.h
@@ -11,6 +11,7 @@
 #include "base/files/file_path.h"
 #include "base/gtest_prod_util.h"
 #include "base/synchronization/lock.h"
+#include "components/safe_browsing/buildflags.h"
 #include "components/safe_browsing/core/proto/download_file_types.pb.h"
 
 namespace safe_browsing {
@@ -105,8 +106,10 @@ class FileTypePolicies {
   // only if it passes integrity checks.
   virtual UpdateResult PopulateFromBinaryPb(const std::string& binary_pb);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Fetch the blob from the main resource bundle.
   virtual std::string ReadResourceBundle();
+#endif
 
   // Record the result of an update attempt.
   virtual void RecordUpdateMetrics(UpdateResult result,
@@ -124,10 +127,12 @@ class FileTypePolicies {
   void SwapConfig(std::unique_ptr<DownloadFileTypeConfig>& new_config);
   void SwapConfigLocked(std::unique_ptr<DownloadFileTypeConfig>& new_config);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   // Read data from the main ResourceBundle. This updates the internal list
   // only if the data passes integrity checks. This is normally called once
   // after construction.
   void PopulateFromResourceBundle();
+#endif
 
   // The latest config we've committed. Starts out null.
   // Protected by lock_.
diff --git a/components/safe_browsing/core/password_protection/password_protection_service_base.cc b/components/safe_browsing/core/password_protection/password_protection_service_base.cc
index de89abb02f..478303c095 100644
--- a/components/safe_browsing/core/password_protection/password_protection_service_base.cc
+++ b/components/safe_browsing/core/password_protection/password_protection_service_base.cc
@@ -23,6 +23,7 @@
 #include "components/safe_browsing/core/db/database_manager.h"
 #include "components/safe_browsing/core/features.h"
 #include "components/safe_browsing/core/password_protection/password_protection_request.h"
+#include "components/safe_browsing/buildflags.h"
 #include "google_apis/google_api_keys.h"
 #include "net/base/escape.h"
 #include "net/base/url_util.h"
@@ -83,9 +84,15 @@ bool PasswordProtectionServiceBase::ShouldShowModalWarning(
     return false;
   }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   return (verdict_type == LoginReputationClientResponse::PHISHING ||
           verdict_type == LoginReputationClientResponse::LOW_REPUTATION) &&
          IsWarningEnabled(password_type);
+#else
+  return (verdict_type == LoginReputationClientResponse::PHISHING ||
+          verdict_type == LoginReputationClientResponse::LOW_REPUTATION);
+#endif
+
 }
 
 LoginReputationClientResponse::VerdictType
@@ -249,11 +256,13 @@ void PasswordProtectionServiceBase::HistoryServiceBeingDeleted(
   history_service_observation_.Reset();
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 bool PasswordProtectionServiceBase::IsWarningEnabled(
     ReusedPasswordAccountType password_type) {
   return GetPasswordProtectionWarningTriggerPref(password_type) ==
          PHISHING_REUSE;
 }
+#endif
 
 // static
 ReusedPasswordType
diff --git a/components/safe_browsing/core/password_protection/password_protection_service_base.h b/components/safe_browsing/core/password_protection/password_protection_service_base.h
index 4339f763c6..4f24f9b5e9 100644
--- a/components/safe_browsing/core/password_protection/password_protection_service_base.h
+++ b/components/safe_browsing/core/password_protection/password_protection_service_base.h
@@ -130,9 +130,11 @@ class PasswordProtectionServiceBase : public history::HistoryServiceObserver {
   // Returns if the warning UI is enabled.
   bool IsWarningEnabled(ReusedPasswordAccountType password_type);
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Returns the pref value of password protection warning trigger.
   virtual PasswordProtectionTrigger GetPasswordProtectionWarningTriggerPref(
       ReusedPasswordAccountType password_type) const = 0;
+#endif
 
   // If |url| matches Safe Browsing allowlist domains, password protection
   // change password URL, or password protection login URLs in the enterprise
diff --git a/components/safe_browsing/core/resources/BUILD.gn b/components/safe_browsing/core/resources/BUILD.gn
index c0b0acc2d5..0dea3b4ec0 100644
--- a/components/safe_browsing/core/resources/BUILD.gn
+++ b/components/safe_browsing/core/resources/BUILD.gn
@@ -24,7 +24,7 @@ python2_action("make_file_types_protobuf") {
 
   # Pick an architecture to generate for. These string match those
   # in the python script.
-  if (is_android) {
+  if (is_android || is_ohos) {
     target_arch = "android"
   } else if (is_chromeos_ash) {
     target_arch = "chromeos"
diff --git a/components/security_interstitials/content/utils.cc b/components/security_interstitials/content/utils.cc
index bbfc938352..bce97c1ef5 100644
--- a/components/security_interstitials/content/utils.cc
+++ b/components/security_interstitials/content/utils.cc
@@ -33,7 +33,7 @@ void LaunchDateAndTimeSettings() {
 #if defined(OS_ANDROID)
   JNIEnv* env = base::android::AttachCurrentThread();
   Java_DateAndTimeSettingsHelper_openDateAndTimeSettings(env);
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   struct ClockCommand {
     const char* const pathname;
     const char* const argument;
diff --git a/components/signin/features.gni b/components/signin/features.gni
index dea221ef95..238dbfaba9 100644
--- a/components/signin/features.gni
+++ b/components/signin/features.gni
@@ -5,7 +5,7 @@
 import("//build/config/chromeos/ui_mode.gni")
 
 # Dice is supported on the platform (but not necessarily enabled).
-enable_dice_support = is_linux || is_chromeos_lacros || is_mac || is_win
+enable_dice_support = is_linux || is_chromeos_lacros || is_mac || is_win || is_ohos
 
 # Mirror is enabled and other account consistency mechanisms are not available.
 enable_mirror = is_android || is_ios
diff --git a/components/storage_monitor/BUILD.gn b/components/storage_monitor/BUILD.gn
index 28c1453f96..20a7efccd3 100644
--- a/components/storage_monitor/BUILD.gn
+++ b/components/storage_monitor/BUILD.gn
@@ -70,7 +70,7 @@ static_library("storage_monitor") {
       ]
       deps += [ "//services/device/public/mojom" ]
     }
-  } else if (is_linux || is_chromeos_lacros) {
+  } else if (is_linux || is_chromeos_lacros || is_ohos) {
     if (use_udev) {
       sources += [
         "mtab_watcher_linux.cc",
diff --git a/components/sync_device_info/BUILD.gn b/components/sync_device_info/BUILD.gn
index 1ddebb1293..8b3da1fa8a 100644
--- a/components/sync_device_info/BUILD.gn
+++ b/components/sync_device_info/BUILD.gn
@@ -58,7 +58,7 @@ static_library("sync_device_info") {
     sources += [ "local_device_info_util_ios.mm" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "local_device_info_util_linux.cc" ]
   }
 
diff --git a/components/update_client/update_query_params.cc b/components/update_client/update_query_params.cc
index 7c3946afb1..52b11abc95 100644
--- a/components/update_client/update_query_params.cc
+++ b/components/update_client/update_query_params.cc
@@ -40,6 +40,8 @@ const char kOs[] =
     "fuchsia";
 #elif defined(OS_OPENBSD)
     "openbsd";
+#elif defined(OS_OHOS)
+    "ohos";
 #else
 #error "unknown os"
 #endif
diff --git a/components/variations/client_filterable_state.cc b/components/variations/client_filterable_state.cc
index 35883cd5b1..6dce1258af 100644
--- a/components/variations/client_filterable_state.cc
+++ b/components/variations/client_filterable_state.cc
@@ -28,7 +28,7 @@ Study::Platform ClientFilterableState::GetCurrentPlatform() {
   return Study::PLATFORM_ANDROID;
 #elif defined(OS_FUCHSIA)
   return Study::PLATFORM_FUCHSIA;
-#elif defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
+#elif defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS) || defined(OS_OHOS)
   // Default BSD and SOLARIS to Linux to not break those builds, although these
   // platforms are not officially supported by Chrome.
   return Study::PLATFORM_LINUX;
diff --git a/components/variations/service/variations_service.cc b/components/variations/service/variations_service.cc
index d4611738ef..34558c5870 100644
--- a/components/variations/service/variations_service.cc
+++ b/components/variations/service/variations_service.cc
@@ -119,6 +119,8 @@ std::string GetPlatformString() {
   // Default BSD and SOLARIS to Linux to not break those builds, although these
   // platforms are not officially supported by Chrome.
   return "linux";
+#elif defined(OS_OHOS)
+  return "ohos";
 #else
 #error Unknown platform
 #endif
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 84578ff8b9..a63f357a8a 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2178,6 +2178,22 @@ source_set("browser") {
     ]
   }
 
+  if (is_ohos) {
+    sources += [
+      "child_process_launcher_helper_linux.cc",
+      "sandbox_host_linux.cc",
+      "sandbox_host_linux.h",
+      "sandbox_ipc_linux.cc",
+      "sandbox_ipc_linux.h",
+      "zygote_host/zygote_host_impl_linux.cc",
+      "zygote_host/zygote_host_impl_linux.h",
+      "memory/swap_metrics_driver_impl_linux.cc",
+      "memory/swap_metrics_driver_impl_linux.h",
+      "speech/tts_ohos.cc",
+    ]
+    public_deps += [ "//components/services/font/public/mojom" ]
+  }
+
   if (is_chromeos_ash) {
     sources += [
       "handwriting/handwriting_recognition_service_impl_cros.cc",
diff --git a/content/browser/direct_sockets/direct_sockets_service_impl.cc b/content/browser/direct_sockets/direct_sockets_service_impl.cc
index c6970c5bd5..5d0735c907 100644
--- a/content/browser/direct_sockets/direct_sockets_service_impl.cc
+++ b/content/browser/direct_sockets/direct_sockets_service_impl.cc
@@ -68,10 +68,12 @@ base::Optional<net::IPEndPoint> GetLocalAddr(
   return local_addr;
 }
 
+#if BUILDFLAG(ENABLE_MDNS)
 bool ResemblesMulticastDNSName(const std::string& hostname) {
   return base::EndsWith(hostname, ".local") ||
          base::EndsWith(hostname, ".local.");
 }
+#endif
 
 bool ContainNonPubliclyRoutableAddress(const net::AddressList& addresses) {
   DCHECK(!addresses.empty());
diff --git a/content/browser/file_system_access/fake_file_system_access_permission_context.cc b/content/browser/file_system_access/fake_file_system_access_permission_context.cc
index 1839c8e860..9d7e5272e1 100644
--- a/content/browser/file_system_access/fake_file_system_access_permission_context.cc
+++ b/content/browser/file_system_access/fake_file_system_access_permission_context.cc
@@ -45,12 +45,14 @@ void FakeFileSystemAccessPermissionContext::ConfirmSensitiveDirectoryAccess(
   std::move(callback).Run(SensitiveDirectoryResult::kAllowed);
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 void FakeFileSystemAccessPermissionContext::PerformAfterWriteChecks(
     std::unique_ptr<FileSystemAccessWriteItem> item,
     GlobalFrameRoutingId frame_id,
     base::OnceCallback<void(AfterWriteCheckResult)> callback) {
   std::move(callback).Run(AfterWriteCheckResult::kAllow);
 }
+#endif
 
 bool FakeFileSystemAccessPermissionContext::CanObtainReadPermission(
     const url::Origin& origin) {
diff --git a/content/browser/file_system_access/fake_file_system_access_permission_context.h b/content/browser/file_system_access/fake_file_system_access_permission_context.h
index 1cf5f476fc..49fdd84054 100644
--- a/content/browser/file_system_access/fake_file_system_access_permission_context.h
+++ b/content/browser/file_system_access/fake_file_system_access_permission_context.h
@@ -40,10 +40,12 @@ class FakeFileSystemAccessPermissionContext
       GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) override;
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   void PerformAfterWriteChecks(
       std::unique_ptr<FileSystemAccessWriteItem> item,
       GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(AfterWriteCheckResult)> callback) override;
+#endif
 
   bool CanObtainReadPermission(const url::Origin& origin) override;
   bool CanObtainWritePermission(const url::Origin& origin) override;
diff --git a/content/browser/file_system_access/file_system_access_file_writer_impl.cc b/content/browser/file_system_access/file_system_access_file_writer_impl.cc
index ee60c5e2e5..ec35da5b40 100644
--- a/content/browser/file_system_access/file_system_access_file_writer_impl.cc
+++ b/content/browser/file_system_access/file_system_access_file_writer_impl.cc
@@ -143,7 +143,9 @@ FileSystemAccessFileWriterImpl::FileSystemAccessFileWriterImpl(
       swap_url_(swap_url),
       quarantine_connection_callback_(
           std::move(quarantine_connection_callback)),
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
       has_transient_user_activation_(has_transient_user_activation),
+#endif
       auto_close_(auto_close) {
   DCHECK_EQ(swap_url.type(), url.type());
   receiver_.set_disconnect_handler(base::BindOnce(
@@ -335,6 +337,7 @@ void FileSystemAccessFileWriterImpl::CloseImpl(CloseCallback callback) {
 
   close_callback_ = std::move(callback);
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   if (!RequireSecurityChecks() || !manager()->permission_context()) {
     DidAfterWriteCheck(
         FileSystemAccessPermissionContext::AfterWriteCheckResult::kAllow);
@@ -344,6 +347,11 @@ void FileSystemAccessFileWriterImpl::CloseImpl(CloseCallback callback) {
   ComputeHashForSwapFile(
       base::BindOnce(&FileSystemAccessFileWriterImpl::DoAfterWriteCheck,
                      weak_factory_.GetWeakPtr()));
+#else
+  DidAfterWriteCheck(
+      FileSystemAccessPermissionContext::AfterWriteCheckResult::kAllow);
+#endif
+
 }
 
 void FileSystemAccessFileWriterImpl::AbortImpl(AbortCallback callback) {
@@ -363,6 +371,7 @@ void FileSystemAccessFileWriterImpl::AbortImpl(AbortCallback callback) {
   manager()->RemoveFileWriter(this);
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 // static
 void FileSystemAccessFileWriterImpl::DoAfterWriteCheck(
     base::File::Error hash_result,
@@ -391,6 +400,7 @@ void FileSystemAccessFileWriterImpl::DoAfterWriteCheck(
       base::BindOnce(&FileSystemAccessFileWriterImpl::DidAfterWriteCheck,
                      weak_factory_.GetWeakPtr()));
 }
+#endif
 
 void FileSystemAccessFileWriterImpl::DidAfterWriteCheck(
     FileSystemAccessPermissionContext::AfterWriteCheckResult result) {
diff --git a/content/browser/file_system_access/file_system_access_file_writer_impl.h b/content/browser/file_system_access/file_system_access_file_writer_impl.h
index 58e8c33c8d..817876eb48 100644
--- a/content/browser/file_system_access/file_system_access_file_writer_impl.h
+++ b/content/browser/file_system_access/file_system_access_file_writer_impl.h
@@ -99,9 +99,11 @@ class CONTENT_EXPORT FileSystemAccessFileWriterImpl
   void TruncateImpl(uint64_t length, TruncateCallback callback);
   void CloseImpl(CloseCallback callback);
   void AbortImpl(AbortCallback callback);
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   void DoAfterWriteCheck(base::File::Error hash_result,
                          const std::string& hash,
                          int64_t size);
+#endif
   void DidAfterWriteCheck(
       FileSystemAccessPermissionContext::AfterWriteCheckResult result);
   void DidSwapFileSkipQuarantine(base::File::Error result);
@@ -134,9 +136,11 @@ class CONTENT_EXPORT FileSystemAccessFileWriterImpl
 
   download::QuarantineConnectionCallback quarantine_connection_callback_;
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Keeps track of user activation state at creation time for after write
   // checks.
   bool has_transient_user_activation_ = false;
+#endif
 
   // Changes will be written to the target file even if the stream isn't
   // explicitly closed.
diff --git a/content/browser/file_system_access/mock_file_system_access_permission_context.cc b/content/browser/file_system_access/mock_file_system_access_permission_context.cc
index 990073d609..9dc66a2a46 100644
--- a/content/browser/file_system_access/mock_file_system_access_permission_context.cc
+++ b/content/browser/file_system_access/mock_file_system_access_permission_context.cc
@@ -22,11 +22,13 @@ void MockFileSystemAccessPermissionContext::ConfirmSensitiveDirectoryAccess(
                                    frame_id, callback);
 }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 void MockFileSystemAccessPermissionContext::PerformAfterWriteChecks(
     std::unique_ptr<FileSystemAccessWriteItem> item,
     GlobalFrameRoutingId frame_id,
     base::OnceCallback<void(AfterWriteCheckResult)> callback) {
   PerformAfterWriteChecks_(item.get(), frame_id, callback);
 }
+#endif
 
 }  // namespace content
diff --git a/content/browser/file_system_access/mock_file_system_access_permission_context.h b/content/browser/file_system_access/mock_file_system_access_permission_context.h
index 7f97f21069..4cf279fae2 100644
--- a/content/browser/file_system_access/mock_file_system_access_permission_context.h
+++ b/content/browser/file_system_access/mock_file_system_access_permission_context.h
@@ -49,10 +49,12 @@ class MockFileSystemAccessPermissionContext
                GlobalFrameRoutingId frame_id,
                base::OnceCallback<void(SensitiveDirectoryResult)>& callback));
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   void PerformAfterWriteChecks(
       std::unique_ptr<FileSystemAccessWriteItem> item,
       GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(AfterWriteCheckResult)> callback) override;
+#endif
   MOCK_METHOD(void,
               PerformAfterWriteChecks_,
               (FileSystemAccessWriteItem * item,
diff --git a/content/browser/scheduler/browser_task_executor.cc b/content/browser/scheduler/browser_task_executor.cc
index 4616c1caf4..71ff583c17 100644
--- a/content/browser/scheduler/browser_task_executor.cc
+++ b/content/browser/scheduler/browser_task_executor.cc
@@ -201,7 +201,7 @@ void BrowserTaskExecutor::CreateInternal(
   g_browser_task_executor->browser_ui_thread_handle_
       ->EnableAllExceptBestEffortQueues();
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) && !defined(OS_OHOS)
   base::PostTaskAndroid::SignalNativeSchedulerReady();
 #endif
 }
diff --git a/content/browser/scheduler/responsiveness/native_event_observer.cc b/content/browser/scheduler/responsiveness/native_event_observer.cc
index 68ca528440..708b9d2caa 100644
--- a/content/browser/scheduler/responsiveness/native_event_observer.cc
+++ b/content/browser/scheduler/responsiveness/native_event_observer.cc
@@ -15,7 +15,7 @@
 
 #include "ui/events/platform/platform_event_source.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "ui/aura/env.h"
 #include "ui/events/event.h"
 #endif
@@ -39,7 +39,7 @@ NativeEventObserver::~NativeEventObserver() {
   DeregisterObserver();
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 void NativeEventObserver::RegisterObserver() {
   aura::Env::GetInstance()->AddWindowEventDispatcherObserver(this);
 }
diff --git a/content/browser/scheduler/responsiveness/native_event_observer.h b/content/browser/scheduler/responsiveness/native_event_observer.h
index be8a5e077f..600ca105bb 100644
--- a/content/browser/scheduler/responsiveness/native_event_observer.h
+++ b/content/browser/scheduler/responsiveness/native_event_observer.h
@@ -14,7 +14,7 @@
 #include "content/public/browser/native_event_processor_observer_mac.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "ui/aura/window_event_dispatcher_observer.h"
 #endif
 
@@ -39,7 +39,7 @@ namespace responsiveness {
 class CONTENT_EXPORT NativeEventObserver
 #if defined(OS_MAC)
     : public NativeEventProcessorObserver
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     : public aura::WindowEventDispatcherObserver
 #elif defined(OS_WIN)
     : public base::MessagePumpForUI::Observer
@@ -56,7 +56,7 @@ class CONTENT_EXPORT NativeEventObserver
   NativeEventObserver(WillRunEventCallback will_run_event_callback,
                       DidRunEventCallback did_run_event_callback);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   ~NativeEventObserver() override;
 #else
   virtual ~NativeEventObserver();
@@ -68,7 +68,7 @@ class CONTENT_EXPORT NativeEventObserver
   // Exposed for tests.
   void WillRunNativeEvent(const void* opaque_identifier) override;
   void DidRunNativeEvent(const void* opaque_identifier) override;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // aura::WindowEventDispatcherObserver overrides:
   void OnWindowEventDispatcherStartedProcessing(
       aura::WindowEventDispatcher* dispatcher,
@@ -85,7 +85,7 @@ class CONTENT_EXPORT NativeEventObserver
   void RegisterObserver();
   void DeregisterObserver();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   struct EventInfo {
     const void* unique_id;
   };
diff --git a/content/browser/speech/tts_ohos.cc b/content/browser/speech/tts_ohos.cc
new file mode 100644
index 0000000000..c4ba8612d9
--- /dev/null
+++ b/content/browser/speech/tts_ohos.cc
@@ -0,0 +1,47 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/speech/tts_platform_impl.h"
+
+#include "base/no_destructor.h"
+
+namespace content {
+
+// Dummy implementation to prevent a browser crash
+class TtsPlatformImplOHOS : public TtsPlatformImpl {
+ public:
+  TtsPlatformImplOHOS() = default;
+  TtsPlatformImplOHOS(const TtsPlatformImplOHOS&) = delete;
+  TtsPlatformImplOHOS& operator=(const TtsPlatformImplOHOS&) = delete;
+
+  // TtsPlatform implementation.
+  bool PlatformImplSupported() override { return false; }
+  bool PlatformImplInitialized() override { return false; }
+  void Speak(int utterance_id,
+             const std::string& utterance,
+             const std::string& lang,
+             const VoiceData& voice,
+             const UtteranceContinuousParameters& params,
+             base::OnceCallback<void(bool)> on_speak_finished) override {
+    std::move(on_speak_finished).Run(false);
+  }
+  bool StopSpeaking() override { return false; }
+  bool IsSpeaking() override { return false; }
+  void GetVoices(std::vector<VoiceData>* out_voices) override {}
+  void Pause() override {}
+  void Resume() override {}
+
+  // Get the single instance of this class.
+  static TtsPlatformImplOHOS* GetInstance() {
+    static base::NoDestructor<TtsPlatformImplOHOS> tts_platform;
+    return tts_platform.get();
+  }
+};
+
+// static
+TtsPlatformImpl* TtsPlatformImpl::GetInstance() {
+  return TtsPlatformImplOHOS::GetInstance();
+}
+
+}  // namespace content
diff --git a/content/browser/storage_partition_impl.cc b/content/browser/storage_partition_impl.cc
index 515df1ae27..65c4f1049f 100644
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -2501,11 +2501,14 @@ void StoragePartitionImpl::InitNetworkContext() {
   GetContentClient()->browser()->ConfigureNetworkContextParams(
       browser_context_, is_in_memory_, relative_partition_path_,
       context_params.get(), cert_verifier_creation_params.get());
+#if !defined(OS_OHOS)
   if (context_params->context_name &&
       *context_params->context_name == "magic_shutting_down") {
     // Don't re-initialize the network context during shutdown.
+    LOG(INFO) << "StoragePartitionImpl::InitNetworkContext magic_shutting_down , return";
     return;
   }
+#endif
   devtools_instrumentation::ApplyNetworkContextParamsOverrides(
       browser_context_, context_params.get());
   DCHECK(!context_params->cert_verifier_params)
diff --git a/content/common/BUILD.gn b/content/common/BUILD.gn
index 42f8eeb814..808e912eee 100644
--- a/content/common/BUILD.gn
+++ b/content/common/BUILD.gn
@@ -340,6 +340,22 @@ source_set("common") {
     sources -= [ "cursors/webcursor_aura.cc" ]
   }
 
+  if (is_ohos) {
+    sources += [
+      "common_sandbox_support_linux.cc",
+      "sandbox_init_linux.cc",
+      "zygote/sandbox_support_linux.cc",
+      "zygote/send_zygote_child_ping_linux.cc",
+      "zygote/zygote_commands_linux.h",
+      "zygote/zygote_communication_linux.cc",
+      "zygote/zygote_communication_linux.h",
+      "font_list_android.cc",
+    ]
+    deps += [
+      ":set_process_title_linux",
+    ]
+  }
+
   if (is_linux || is_chromeos) {
     sources += [
       "common_sandbox_support_linux.cc",
@@ -363,7 +379,7 @@ source_set("common") {
     ]
   }
 
-  if (is_mac || is_win || is_android || is_fuchsia) {
+  if (is_mac || is_win || is_android || is_fuchsia || is_ohos) {
     sources -= [ "font_list_fontconfig.cc" ]
   }
 
@@ -405,7 +421,7 @@ source_set("common") {
   }
 }
 
-if (is_linux || is_chromeos) {
+if (is_linux || is_chromeos || is_ohos) {
   source_set("set_process_title_linux") {
     public = [ "set_process_title_linux.h" ]
     sources = [ "set_process_title_linux.cc" ]
diff --git a/content/common/common_sandbox_support_linux.cc b/content/common/common_sandbox_support_linux.cc
index 507c3558b5..d008ab0257 100644
--- a/content/common/common_sandbox_support_linux.cc
+++ b/content/common/common_sandbox_support_linux.cc
@@ -8,6 +8,7 @@
 
 #include <limits>
 #include <memory>
+#include <unistd.h>
 
 #include "base/numerics/safe_conversions.h"
 #include "base/posix/eintr_wrapper.h"
diff --git a/content/common/features.gni b/content/common/features.gni
index 08e1e8709a..98c595d576 100644
--- a/content/common/features.gni
+++ b/content/common/features.gni
@@ -6,7 +6,7 @@ import("//build/config/chromecast_build.gni")
 
 declare_args() {
   # Whether or not to use external popup menu.
-  use_external_popup_menu = is_android || is_mac
+  use_external_popup_menu = is_android || is_mac || is_ohos
 
   # Whether to perform critical memory pressure handling when in foreground (if
   # false, critical memory pressure is treated like moderate pressure in foreground).
@@ -14,8 +14,8 @@ declare_args() {
 
   # Whether or not MBI mode (Multiple Blink Isolates) should be enabled,
   # depending on the build argument.
-  mbi_mode = is_linux || is_chromeos || is_mac || is_win || is_android
+  mbi_mode = is_linux || is_chromeos || is_mac || is_win || is_android || is_ohos
 }
 
 enable_screen_capture =
-    is_linux || is_chromeos || is_mac || is_win || is_android
+    is_linux || is_chromeos || is_mac || is_win || is_android || is_ohos
diff --git a/content/common/set_process_title.cc b/content/common/set_process_title.cc
index a69a088697..b62a81f0a6 100644
--- a/content/common/set_process_title.cc
+++ b/content/common/set_process_title.cc
@@ -38,13 +38,14 @@
 #include "base/threading/platform_thread.h"
 // Linux/glibc doesn't natively have setproctitle().
 #include "content/common/set_process_title_linux.h"
+#include "content/public/common/content_switches.h"
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 namespace content {
 
 // TODO(jrg): Find out if setproctitle or equivalent is available on Android.
 #if defined(OS_POSIX) && !defined(OS_MAC) && !defined(OS_SOLARIS) && \
-    !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
+    !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && !defined(OS_OHOS)
 
 void SetProcessTitleFromCommandLine(const char** main_argv) {
   // Build a single string which consists of all the arguments separated
@@ -92,11 +93,19 @@ void SetProcessTitleFromCommandLine(const char** main_argv) {
 
   const base::CommandLine* command_line =
       base::CommandLine::ForCurrentProcess();
+#if !defined(OS_OHOS)
   for (size_t i = 1; i < command_line->argv().size(); ++i) {
     if (!title.empty())
       title += " ";
     title += command_line->argv()[i];
   }
+#else
+  const std::string& process_type =
+    command_line->GetSwitchValueASCII(switches::kProcessType);
+  if (!process_type.empty()) {
+    title = "webview-" + process_type;
+  }
+#endif
   // Disable prepending argv[0] with '-' if we prepended it ourselves above.
   setproctitle(have_argv0 ? "-%s" : "%s", title.c_str());
 }
diff --git a/content/common/zygote/zygote_communication_linux.cc b/content/common/zygote/zygote_communication_linux.cc
index bdc2b0a5df..dfc4229aa6 100644
--- a/content/common/zygote/zygote_communication_linux.cc
+++ b/content/common/zygote/zygote_communication_linux.cc
@@ -236,6 +236,13 @@ void ZygoteCommunication::Init(
     cmd_line.PrependWrapper(
         browser_command_line.GetSwitchValueNative(switches::kZygoteCmdPrefix));
   }
+
+  if (browser_command_line.HasSwitch(switches::kLogFile)) {
+    cmd_line.AppendSwitchPath(
+        switches::kLogFile,
+        browser_command_line.GetSwitchValuePath(switches::kLogFile));
+  }
+
   // Append any switches from the service manager that need to be forwarded on
   // to the zygote/renderers.
   static const char* const kForwardSwitches[] = {
diff --git a/content/public/app/content_main_delegate.cc b/content/public/app/content_main_delegate.cc
index 17d256b852..8dd67207a3 100644
--- a/content/public/app/content_main_delegate.cc
+++ b/content/public/app/content_main_delegate.cc
@@ -24,7 +24,7 @@ int ContentMainDelegate::RunProcess(
   return -1;
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 
 void ContentMainDelegate::ZygoteStarting(
     std::vector<std::unique_ptr<ZygoteForkDelegate>>* delegates) {}
diff --git a/content/public/app/content_main_delegate.h b/content/public/app/content_main_delegate.h
index 4162083f78..fcc6e75a4b 100644
--- a/content/public/app/content_main_delegate.h
+++ b/content/public/app/content_main_delegate.h
@@ -49,7 +49,7 @@ class CONTENT_EXPORT ContentMainDelegate {
   // Called right before the process exits.
   virtual void ProcessExiting(const std::string& process_type) {}
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Tells the embedder that the zygote process is starting, and allows it to
   // specify one or more zygote delegates if it wishes by storing them in
   // |*delegates|.
diff --git a/content/public/browser/file_system_access_permission_context.h b/content/public/browser/file_system_access_permission_context.h
index 63d5e5606b..d7827e4d54 100644
--- a/content/public/browser/file_system_access_permission_context.h
+++ b/content/public/browser/file_system_access_permission_context.h
@@ -11,6 +11,7 @@
 #include "content/public/browser/global_routing_id.h"
 #include "third_party/blink/public/mojom/file_system_access/file_system_access_manager.mojom-shared.h"
 #include "url/origin.h"
+#include "components/safe_browsing/buildflags.h"
 
 namespace content {
 
@@ -107,12 +108,15 @@ class FileSystemAccessPermissionContext {
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) = 0;
 
   enum class AfterWriteCheckResult { kAllow, kBlock };
+
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   // Runs a recently finished write operation through checks such as malware
   // or other security checks to determine if the write should be allowed.
   virtual void PerformAfterWriteChecks(
       std::unique_ptr<FileSystemAccessWriteItem> item,
       GlobalFrameRoutingId frame_id,
       base::OnceCallback<void(AfterWriteCheckResult)> callback) = 0;
+#endif
 
   // Returns whether the give |origin| already allows read permission, or it is
   // possible to request one. This is used to block file dialogs from being
diff --git a/content/public/common/content_constants.cc b/content/public/common/content_constants.cc
index 88f1e915a9..096defba10 100644
--- a/content/public/common/content_constants.cc
+++ b/content/public/common/content_constants.cc
@@ -50,7 +50,7 @@ std::string GetCorsExemptRequestedWithHeaderName() {
   return base::JoinString(pieces, "-");
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 const int kLowestRendererOomScore = 300;
 const int kHighestRendererOomScore = 1000;
 
diff --git a/content/public/common/content_constants.h b/content/public/common/content_constants.h
index 6b8e119a40..89662982e5 100644
--- a/content/public/common/content_constants.h
+++ b/content/public/common/content_constants.h
@@ -61,7 +61,7 @@ CONTENT_EXPORT extern const char kCorsExemptPurposeHeaderName[];
 // it at run time.
 CONTENT_EXPORT std::string GetCorsExemptRequestedWithHeaderName();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // The OOM score adj constants
 // The highest and lowest assigned OOM score adjustment (oom_score_adj) for
 // renderers and extensions used by the OomPriority Manager.
diff --git a/content/public/common/content_features.cc b/content/public/common/content_features.cc
index b2fe2c5cad..3e6645553b 100644
--- a/content/public/common/content_features.cc
+++ b/content/public/common/content_features.cc
@@ -447,7 +447,7 @@ const base::Feature kMouseSubframeNoImplicitCapture{
 // If the network service is enabled, runs it in process.
 const base::Feature kNetworkServiceInProcess {
   "NetworkServiceInProcess",
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       base::FEATURE_ENABLED_BY_DEFAULT
 #else
       base::FEATURE_DISABLED_BY_DEFAULT
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index 9e995c4939..f543db60a3 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -964,13 +964,17 @@ const char kEnableAutomation[] = "enable-automation";
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 // Allows sending text-to-speech requests to speech-dispatcher, a common
 // Linux speech service. Because it's buggy, the user must explicitly
 // enable it so that visiting a random webpage can't cause instability.
 const char kEnableSpeechDispatcher[] = "enable-speech-dispatcher";
 #endif
 
+#if defined(OS_OHOS)
+const char kEnableMultiRendererProcess[] = "enable-multi-renderer-process";
+#endif
+
 #if defined(OS_WIN)
 // /prefetch:# arguments to use when launching various process types. It has
 // been observed that when file reads are consistent for 3 process launches with
diff --git a/content/public/common/content_switches.h b/content/public/common/content_switches.h
index 00cc8c3a93..31d0a72c4b 100644
--- a/content/public/common/content_switches.h
+++ b/content/public/common/content_switches.h
@@ -265,10 +265,14 @@ CONTENT_EXPORT extern const char kRendererWaitForJavaDebugger[];
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#if defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 CONTENT_EXPORT extern const char kEnableSpeechDispatcher[];
 #endif
 
+#if defined(OS_OHOS)
+CONTENT_EXPORT extern const char kEnableMultiRendererProcess[];
+#endif
+
 #if defined(OS_WIN)
 CONTENT_EXPORT extern const char kPrefetchArgumentRenderer[];
 CONTENT_EXPORT extern const char kPrefetchArgumentGpu[];
diff --git a/content/renderer/BUILD.gn b/content/renderer/BUILD.gn
index 9425dc5637..3cdc94634e 100644
--- a/content/renderer/BUILD.gn
+++ b/content/renderer/BUILD.gn
@@ -215,7 +215,8 @@ target(link_target_type, "renderer") {
     ]
   }
 
-  if (is_linux || is_chromeos) {
+
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "renderer_main_platform_delegate_linux.cc" ]
   }
 
@@ -536,7 +537,7 @@ target(link_target_type, "renderer") {
     ]
   }
 
-  if (is_linux || is_chromeos || is_android) {
+  if (is_linux || is_chromeos || is_android || is_ohos) {
     deps += [ "//sandbox:sandbox_buildflags" ]
   }
 
diff --git a/content/shell/app/shell_main_delegate.cc b/content/shell/app/shell_main_delegate.cc
index 553dd2f7ac..ff09383120 100644
--- a/content/shell/app/shell_main_delegate.cc
+++ b/content/shell/app/shell_main_delegate.cc
@@ -186,7 +186,7 @@ bool ShellMainDelegate::BasicStartupComplete(int* exit_code) {
 
 void ShellMainDelegate::PreSandboxStartup() {
 #if defined(ARCH_CPU_ARM_FAMILY) && \
-    (defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS))
+    (defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS))
   // Create an instance of the CPU class to parse /proc/cpuinfo and cache
   // cpu_brand info.
   base::CPU cpu_info;
@@ -205,9 +205,9 @@ void ShellMainDelegate::PreSandboxStartup() {
     // Reporting for sub-processes will be initialized in ZygoteForked.
     if (process_type != switches::kZygoteProcess) {
       crash_reporter::InitializeCrashpad(process_type.empty(), process_type);
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
-      crash_reporter::SetFirstChanceExceptionHandler(
-          v8::TryHandleWebAssemblyTrapPosix);
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
+      //crash_reporter::SetFirstChanceExceptionHandler(
+      //    v8::TryHandleWebAssemblyTrapPosix);
 #endif
     }
   }
@@ -263,7 +263,7 @@ int ShellMainDelegate::RunProcess(
 #endif
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 void ShellMainDelegate::ZygoteForked() {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableCrashReporter)) {
@@ -271,10 +271,15 @@ void ShellMainDelegate::ZygoteForked() {
         base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
             switches::kProcessType);
     crash_reporter::InitializeCrashpad(false, process_type);
-    crash_reporter::SetFirstChanceExceptionHandler(
-        v8::TryHandleWebAssemblyTrapPosix);
+    //crash_reporter::SetFirstChanceExceptionHandler(
+    //    v8::TryHandleWebAssemblyTrapPosix);
   }
 }
+
+
+void ShellMainDelegate::ZygoteStarting(
+  std::vector<std::unique_ptr<content::ZygoteForkDelegate>>* delegates) {
+}
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 void ShellMainDelegate::InitializeResourceBundle() {
diff --git a/content/shell/app/shell_main_delegate.h b/content/shell/app/shell_main_delegate.h
index ff32beccd6..69313e25d3 100644
--- a/content/shell/app/shell_main_delegate.h
+++ b/content/shell/app/shell_main_delegate.h
@@ -33,8 +33,10 @@ class ShellMainDelegate : public ContentMainDelegate {
   void PreSandboxStartup() override;
   int RunProcess(const std::string& process_type,
                  const MainFunctionParams& main_function_params) override;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   void ZygoteForked() override;
+  void ZygoteStarting(
+    std::vector<std::unique_ptr<content::ZygoteForkDelegate>>* delegates) override;
 #endif
   void PreCreateMainMessageLoop() override;
   ContentClient* CreateContentClient() override;
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index f74fc18742..2687d4783b 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -679,9 +679,11 @@ if (is_fuchsia) {
 
 group("telemetry_gpu_integration_test_scripts_only") {
   testonly = true
-  deps = [
-    "//tools/perf/chrome_telemetry_build:telemetry_chrome_test_without_chrome",
-  ]
+  if (!is_ohos) {
+    deps = [
+      "//tools/perf/chrome_telemetry_build:telemetry_chrome_test_without_chrome",
+    ]
+  }
 
   data = [
     "//content/test/gpu/",
diff --git a/content/web_test/BUILD.gn b/content/web_test/BUILD.gn
index a814031680..196e58fbcf 100644
--- a/content/web_test/BUILD.gn
+++ b/content/web_test/BUILD.gn
@@ -7,7 +7,7 @@ import("//build/config/ui.gni")  # For the use_x11 and toolkit_views variables.
 import("//mojo/public/tools/bindings/mojom.gni")
 import("//ppapi/buildflags/buildflags.gni")  # For the enable_plugins variable.
 
-if (is_android) {
+if (is_android || is_ohos) {
   import("//build/config/android/config.gni")
 } else if (is_mac) {
   import("//build/apple/tweak_info_plist.gni")
diff --git a/content/zygote/BUILD.gn b/content/zygote/BUILD.gn
index 27381b9a00..b95830aedf 100644
--- a/content/zygote/BUILD.gn
+++ b/content/zygote/BUILD.gn
@@ -5,7 +5,7 @@
 import("//build/config/nacl/config.gni")
 import("//content/public/common/zygote/features.gni")
 
-if (is_linux || is_chromeos) {
+if (is_linux || is_chromeos || is_ohos) {
   source_set("zygote") {
     sources = [
       "zygote_linux.cc",
diff --git a/device/gamepad/BUILD.gn b/device/gamepad/BUILD.gn
index 4f2ddf5f9c..70a9b89127 100644
--- a/device/gamepad/BUILD.gn
+++ b/device/gamepad/BUILD.gn
@@ -122,7 +122,7 @@ component("gamepad") {
     deps += [ ":jni_headers" ]
   }
 
-  if (!is_android && !is_fuchsia) {
+  if (!is_android && !is_fuchsia && !is_ohos) {
     sources += [
       "nintendo_controller.cc",
       "nintendo_controller.h",
diff --git a/extensions/browser/api/system_cpu/BUILD.gn b/extensions/browser/api/system_cpu/BUILD.gn
index 9f907cfe24..bf054dedc0 100644
--- a/extensions/browser/api/system_cpu/BUILD.gn
+++ b/extensions/browser/api/system_cpu/BUILD.gn
@@ -26,7 +26,7 @@ source_set("system_cpu") {
     sources += [ "cpu_info_provider_mac.cc" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "cpu_info_provider_linux.cc" ]
   }
 
diff --git a/extensions/browser/updater/update_service.cc b/extensions/browser/updater/update_service.cc
index 1f4c80cdf9..fe6e4dcd37 100644
--- a/extensions/browser/updater/update_service.cc
+++ b/extensions/browser/updater/update_service.cc
@@ -14,6 +14,7 @@
 #include "base/metrics/histogram_macros.h"
 #include "components/update_client/crx_update_item.h"
 #include "components/update_client/update_client_errors.h"
+#include "components/safe_browsing/buildflags.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/notification_details.h"
@@ -111,6 +112,7 @@ void UpdateService::OnEvent(Events event, const std::string& extension_id) {
       break;
   }
 
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   if (should_perform_action_on_omaha_attributes) {
     base::Value attributes = GetExtensionOmahaAttributes(extension_id);
     // Note that it's important to perform actions even if |attributes| is
@@ -118,6 +120,7 @@ void UpdateService::OnEvent(Events event, const std::string& extension_id) {
     ExtensionSystem::Get(browser_context_)
         ->PerformActionBasedOnOmahaAttributes(extension_id, attributes);
   }
+#endif
 }
 
 UpdateService::UpdateService(
diff --git a/extensions/common/install_warning.h b/extensions/common/install_warning.h
index be1937edb1..8f4fb5dcb2 100644
--- a/extensions/common/install_warning.h
+++ b/extensions/common/install_warning.h
@@ -43,7 +43,7 @@ struct InstallWarning {
   // (e.g., an unrecognized permission "foo" in "permissions").
   std::string specific;
 
-  DISALLOW_COPY(InstallWarning);
+  DISALLOW_COPY_BASE(InstallWarning);
 };
 
 // Let gtest print InstallWarnings.
diff --git a/gin/array_buffer.h b/gin/array_buffer.h
index 086371af29..1a5e944ca9 100644
--- a/gin/array_buffer.h
+++ b/gin/array_buffer.h
@@ -42,7 +42,7 @@ class GIN_EXPORT ArrayBuffer {
 
  private:
   std::shared_ptr<v8::BackingStore> backing_store_;
-  DISALLOW_COPY(ArrayBuffer);
+  DISALLOW_COPY_BASE(ArrayBuffer);
 };
 
 template<>
@@ -68,7 +68,7 @@ class GIN_EXPORT ArrayBufferView {
   size_t offset_;
   size_t num_bytes_;
 
-  DISALLOW_COPY(ArrayBufferView);
+  DISALLOW_COPY_BASE(ArrayBufferView);
 };
 
 template<>
diff --git a/gpu/command_buffer/common/gpu_memory_buffer_support.cc b/gpu/command_buffer/common/gpu_memory_buffer_support.cc
index 388de9f400..6976730735 100644
--- a/gpu/command_buffer/common/gpu_memory_buffer_support.cc
+++ b/gpu/command_buffer/common/gpu_memory_buffer_support.cc
@@ -55,7 +55,7 @@ bool IsImageSizeValidForGpuMemoryBufferFormat(const gfx::Size& size,
 uint32_t GetPlatformSpecificTextureTarget() {
 #if defined(OS_MAC)
   return macos_specific_texture_target;
-#elif defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   return GL_TEXTURE_EXTERNAL_OES;
 #elif defined(OS_WIN) || defined(OS_FUCHSIA)
   return GL_TEXTURE_2D;
diff --git a/gpu/command_buffer/service/BUILD.gn b/gpu/command_buffer/service/BUILD.gn
index b8bec7d5cd..81283e3b36 100644
--- a/gpu/command_buffer/service/BUILD.gn
+++ b/gpu/command_buffer/service/BUILD.gn
@@ -339,7 +339,7 @@ target(link_target_type, "gles2_sources") {
       "//gpu/vulkan",
     ]
 
-    if (is_linux || is_chromeos || is_fuchsia || is_android || is_win) {
+    if (is_linux || is_chromeos || is_fuchsia || is_android || is_win || is_ohos) {
       sources += [
         "external_semaphore.cc",
         "external_semaphore.h",
diff --git a/gpu/command_buffer/service/external_semaphore.cc b/gpu/command_buffer/service/external_semaphore.cc
index ca828b681a..6ea5593b0f 100644
--- a/gpu/command_buffer/service/external_semaphore.cc
+++ b/gpu/command_buffer/service/external_semaphore.cc
@@ -39,7 +39,7 @@ GLuint ImportSemaphoreHandleToGLSemaphore(SemaphoreHandle handle) {
       },
       base::Time::Now()));
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   if (handle.vk_handle_type() !=
       VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT) {
     DLOG(ERROR) << "Importing semaphore handle of unexpected type:"
diff --git a/gpu/command_buffer/service/external_vk_image_backing.cc b/gpu/command_buffer/service/external_vk_image_backing.cc
index 5e8c09cfb7..0e918e62b3 100644
--- a/gpu/command_buffer/service/external_vk_image_backing.cc
+++ b/gpu/command_buffer/service/external_vk_image_backing.cc
@@ -648,7 +648,7 @@ GLuint ExternalVkImageBacking::ProduceGLTextureInternal() {
   gl::GLApi* api = gl::g_current_gl_context;
   base::Optional<ScopedDedicatedMemoryObject> memory_object;
   if (!use_separate_gl_texture()) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
     auto memory_fd = image_->GetMemoryFd();
     if (!memory_fd.is_valid())
       return 0;
diff --git a/gpu/config/BUILD.gn b/gpu/config/BUILD.gn
index 9e291e8874..ce0faa980d 100644
--- a/gpu/config/BUILD.gn
+++ b/gpu/config/BUILD.gn
@@ -55,7 +55,7 @@ python2_action("process_json") {
     args += [ "win" ]
   } else if (is_mac) {
     args += [ "macosx" ]
-  } else if (is_android) {
+  } else if (is_android || is_ohos) {
     args += [ "android" ]
   } else if (is_chromeos_ash) {
     args += [ "chromeos" ]
@@ -225,10 +225,10 @@ source_set("config_sources") {
     sources += [ "gpu_info_collector_mac.mm" ]
     frameworks = [ "OpenGL.framework" ]
   }
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "gpu_info_collector_linux.cc" ]
   }
-  if (is_linux || is_chromeos || is_mac) {
+  if (is_linux || is_chromeos || is_mac || is_ohos) {
     deps += [ "//third_party/angle:angle_gpu_info_util" ]
   }
   if (use_x11) {
diff --git a/gpu/config/gpu_info_collector.cc b/gpu/config/gpu_info_collector.cc
index 22b65603e1..0f7902d494 100644
--- a/gpu/config/gpu_info_collector.cc
+++ b/gpu/config/gpu_info_collector.cc
@@ -316,7 +316,7 @@ bool CollectGraphicsInfoGL(GPUInfo* gpu_info) {
   gpu_info->max_msaa_samples = base::NumberToString(max_samples);
   base::UmaHistogramSparse("GPU.MaxMSAASampleCount", max_samples);
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   gpu_info->can_support_threaded_texture_mailbox =
       gl::GLSurfaceEGL::HasEGLExtension("EGL_KHR_fence_sync") &&
       gl::GLSurfaceEGL::HasEGLExtension("EGL_KHR_image_base") &&
@@ -481,7 +481,7 @@ void FillGPUInfoFromSystemInfo(GPUInfo* gpu_info,
 
 void CollectGraphicsInfoForTesting(GPUInfo* gpu_info) {
   DCHECK(gpu_info);
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   CollectContextGraphicsInfo(gpu_info);
 #else
   CollectBasicGraphicsInfo(gpu_info);
diff --git a/gpu/config/gpu_test_config.cc b/gpu/config/gpu_test_config.cc
index 592f71243e..992222b866 100644
--- a/gpu/config/gpu_test_config.cc
+++ b/gpu/config/gpu_test_config.cc
@@ -29,7 +29,7 @@ GPUTestConfig::OS GetCurrentOS() {
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   return GPUTestConfig::kOsChromeOS;
 #elif (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) || \
-    defined(OS_OPENBSD)
+    defined(OS_OPENBSD) || defined(OS_OHOS)
   return GPUTestConfig::kOsLinux;
 #elif defined(OS_WIN)
   int32_t major_version = 0;
diff --git a/gpu/ipc/common/gpu_memory_buffer_support.cc b/gpu/ipc/common/gpu_memory_buffer_support.cc
index 4ff68ba071..bc3d82eea0 100644
--- a/gpu/ipc/common/gpu_memory_buffer_support.cc
+++ b/gpu/ipc/common/gpu_memory_buffer_support.cc
@@ -105,6 +105,8 @@ bool GpuMemoryBufferSupport::IsNativeGpuMemoryBufferConfigurationSupported(
   }
   NOTREACHED();
   return false;
+#elif defined(OS_OHOS)
+  return false;
 #elif defined(OS_ANDROID)
   if (!base::AndroidHardwareBufferCompat::IsSupportAvailable()) {
     return false;
diff --git a/gpu/ipc/service/BUILD.gn b/gpu/ipc/service/BUILD.gn
index 68c08ac4c8..160e035e87 100644
--- a/gpu/ipc/service/BUILD.gn
+++ b/gpu/ipc/service/BUILD.gn
@@ -123,7 +123,7 @@ component("service") {
     ]
     libs += [ "android" ]
   }
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "image_transport_surface_linux.cc" ]
   }
   if (is_linux || is_chromeos || use_ozone) {
diff --git a/gpu/vulkan/BUILD.gn b/gpu/vulkan/BUILD.gn
index b91be74241..24f1e42c05 100644
--- a/gpu/vulkan/BUILD.gn
+++ b/gpu/vulkan/BUILD.gn
@@ -123,7 +123,7 @@ if (enable_vulkan) {
     if (is_posix) {
       sources += [ "vulkan_util_posix.cc" ]
 
-      if (is_linux || is_chromeos) {
+      if (is_linux || is_chromeos || is_ohos) {
         sources += [ "vulkan_image_linux.cc" ]
       }
     }
diff --git a/gpu/vulkan/features.gni b/gpu/vulkan/features.gni
index 7a98011f98..fbb07272ec 100644
--- a/gpu/vulkan/features.gni
+++ b/gpu/vulkan/features.gni
@@ -8,7 +8,7 @@ import("//build/config/ui.gni")
 # For details see declare_args() in build/config/BUILDCONFIG.gn.
 declare_args() {
   # Enable experimental vulkan backend.
-  enable_vulkan = is_linux || is_chromeos || is_android || is_fuchsia || is_win
+  enable_vulkan = is_linux || is_chromeos || is_android || is_fuchsia || is_win || is_ohos
 
   # Enable swiftshader vulkan. Disabling it can save build time, however
   # --use-vulkan=swiftshader and some tests which use swiftshader vulkan will
diff --git a/gpu/vulkan/vulkan_function_pointers.cc b/gpu/vulkan/vulkan_function_pointers.cc
index f1377f99f9..7a08d7b406 100644
--- a/gpu/vulkan/vulkan_function_pointers.cc
+++ b/gpu/vulkan/vulkan_function_pointers.cc
@@ -898,7 +898,7 @@ bool VulkanFunctionPointers::BindDeviceFunctionPointers(
   }
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   if (gfx::HasExtension(enabled_extensions,
                         VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME)) {
     vkGetSemaphoreFdKHR = reinterpret_cast<PFN_vkGetSemaphoreFdKHR>(
@@ -942,7 +942,7 @@ bool VulkanFunctionPointers::BindDeviceFunctionPointers(
   }
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   if (gfx::HasExtension(enabled_extensions,
                         VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME)) {
     vkGetMemoryFdKHR = reinterpret_cast<PFN_vkGetMemoryFdKHR>(
diff --git a/gpu/vulkan/vulkan_function_pointers.h b/gpu/vulkan/vulkan_function_pointers.h
index 1ec6898e82..ba6173df9c 100644
--- a/gpu/vulkan/vulkan_function_pointers.h
+++ b/gpu/vulkan/vulkan_function_pointers.h
@@ -241,7 +241,7 @@ struct COMPONENT_EXPORT(VULKAN) VulkanFunctionPointers {
       vkGetAndroidHardwareBufferPropertiesANDROID;
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   VulkanFunction<PFN_vkGetSemaphoreFdKHR> vkGetSemaphoreFdKHR;
   VulkanFunction<PFN_vkImportSemaphoreFdKHR> vkImportSemaphoreFdKHR;
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
@@ -252,7 +252,7 @@ struct COMPONENT_EXPORT(VULKAN) VulkanFunctionPointers {
       vkImportSemaphoreWin32HandleKHR;
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   VulkanFunction<PFN_vkGetMemoryFdKHR> vkGetMemoryFdKHR;
   VulkanFunction<PFN_vkGetMemoryFdPropertiesKHR> vkGetMemoryFdPropertiesKHR;
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
@@ -292,7 +292,7 @@ struct COMPONENT_EXPORT(VULKAN) VulkanFunctionPointers {
   VulkanFunction<PFN_vkGetSwapchainImagesKHR> vkGetSwapchainImagesKHR;
   VulkanFunction<PFN_vkQueuePresentKHR> vkQueuePresentKHR;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   VulkanFunction<PFN_vkGetImageDrmFormatModifierPropertiesEXT>
       vkGetImageDrmFormatModifierPropertiesEXT;
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
@@ -997,7 +997,7 @@ ALWAYS_INLINE VkResult vkGetAndroidHardwareBufferPropertiesANDROID(
 }
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 ALWAYS_INLINE VkResult
 vkGetSemaphoreFdKHR(VkDevice device,
                     const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
@@ -1030,7 +1030,7 @@ vkImportSemaphoreWin32HandleKHR(VkDevice device,
 }
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 ALWAYS_INLINE VkResult vkGetMemoryFdKHR(VkDevice device,
                                         const VkMemoryGetFdInfoKHR* pGetFdInfo,
                                         int* pFd) {
@@ -1125,7 +1125,7 @@ ALWAYS_INLINE VkResult vkQueuePresentKHR(VkQueue queue,
                                                              pPresentInfo);
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 ALWAYS_INLINE VkResult vkGetImageDrmFormatModifierPropertiesEXT(
     VkDevice device,
     VkImage image,
diff --git a/gpu/vulkan/vulkan_image.h b/gpu/vulkan/vulkan_image.h
index 3afbbd4746..d8f43c8c03 100644
--- a/gpu/vulkan/vulkan_image.h
+++ b/gpu/vulkan/vulkan_image.h
@@ -84,7 +84,7 @@ class COMPONENT_EXPORT(VULKAN) VulkanImage {
       VkImageUsageFlags usage,
       VkImageCreateFlags flags);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   static std::unique_ptr<VulkanImage> CreateWithExternalMemoryAndModifiers(
       VulkanDeviceQueue* device_queue,
       const gfx::Size& size,
@@ -166,7 +166,7 @@ class COMPONENT_EXPORT(VULKAN) VulkanImage {
       VkImageCreateFlags flags,
       VkImageTiling image_tiling);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   bool InitializeWithExternalMemoryAndModifiers(VulkanDeviceQueue* device_queue,
                                                 const gfx::Size& size,
                                                 VkFormat format,
diff --git a/ios/chrome/browser/dom_distiller/dom_distiller_service_factory.h b/ios/chrome/browser/dom_distiller/dom_distiller_service_factory.h
index 870222a9a7..07ae167538 100644
--- a/ios/chrome/browser/dom_distiller/dom_distiller_service_factory.h
+++ b/ios/chrome/browser/dom_distiller/dom_distiller_service_factory.h
@@ -37,7 +37,7 @@ class DomDistillerServiceFactory : public BrowserStateKeyedServiceFactory {
   web::BrowserState* GetBrowserStateToUse(
       web::BrowserState* context) const override;
 
-  DISALLOW_COPY(DomDistillerServiceFactory);
+  DISALLOW_COPY_BASE(DomDistillerServiceFactory);
 };
 
 }  // namespace dom_distiller
diff --git a/ipc/ipc_channel.h b/ipc/ipc_channel.h
index 48436e8f42..5d9cf2e65a 100644
--- a/ipc/ipc_channel.h
+++ b/ipc/ipc_channel.h
@@ -244,7 +244,7 @@ class COMPONENT_EXPORT(IPC) Channel : public Sender {
   static std::string GenerateUniqueRandomChannelID();
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Sandboxed processes live in a PID namespace, so when sending the IPC hello
   // message from client to server we need to send the PID from the global
   // PID namespace.
diff --git a/ipc/ipc_channel_common.cc b/ipc/ipc_channel_common.cc
index 8990eee6bc..38e796d574 100644
--- a/ipc/ipc_channel_common.cc
+++ b/ipc/ipc_channel_common.cc
@@ -10,7 +10,7 @@
 
 namespace IPC {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 
 namespace {
 int g_global_pid = 0;
diff --git a/ipc/ipc_message_utils.cc b/ipc/ipc_message_utils.cc
index 473fb1407c..84dede531e 100644
--- a/ipc/ipc_message_utils.cc
+++ b/ipc/ipc_message_utils.cc
@@ -361,7 +361,7 @@ void ParamTraits<unsigned int>::Log(const param_type& p, std::string* l) {
   l->append(base::NumberToString(p));
 }
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS) || \
     defined(OS_FUCHSIA) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 void ParamTraits<long>::Log(const param_type& p, std::string* l) {
   l->append(base::NumberToString(p));
diff --git a/ipc/ipc_message_utils.h b/ipc/ipc_message_utils.h
index 97e7f0aa56..343f9da178 100644
--- a/ipc/ipc_message_utils.h
+++ b/ipc/ipc_message_utils.h
@@ -207,7 +207,7 @@ struct ParamTraits<unsigned int> {
 //   3) Android 64 bit and Fuchsia also have int64_t typedef'd to long.
 // Since we want to support Android 32<>64 bit IPC, as long as we don't have
 // these traits for 32 bit ARM then that'll catch any errors.
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS) || \
     defined(OS_FUCHSIA) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 template <>
 struct ParamTraits<long> {
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index c68099d5ba..7cabe2c6d5 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -236,7 +236,7 @@ source_set("audio") {
     ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "linux/audio_manager_linux.cc" ]
   }
 
diff --git a/media/base/BUILD.gn b/media/base/BUILD.gn
index 54e6842abd..56786f8ef1 100644
--- a/media/base/BUILD.gn
+++ b/media/base/BUILD.gn
@@ -440,7 +440,7 @@ source_set("base") {
 
   # TODO(ziyangch): Check |is_chromecast| first when using cast media pipeline
   # on Android cast devices.
-  if (is_android) {
+  if (is_android || is_ohos) {
     sources += [ "demuxer_memory_limit_android.cc" ]
   } else if (is_chromecast) {
     sources += [ "demuxer_memory_limit_cast.cc" ]
diff --git a/media/base/android_overlay_config.h b/media/base/android_overlay_config.h
index d51131024e..317456c56b 100644
--- a/media/base/android_overlay_config.h
+++ b/media/base/android_overlay_config.h
@@ -80,7 +80,7 @@ struct MEDIA_EXPORT AndroidOverlayConfig {
   // Optional, may be empty.
   PowerEfficientCB power_cb;
 
-  DISALLOW_COPY(AndroidOverlayConfig);
+  DISALLOW_COPY_BASE(AndroidOverlayConfig);
 };
 
 // Common factory type.
diff --git a/media/base/demuxer_memory_limit.h b/media/base/demuxer_memory_limit.h
index 2492eca1dd..4377878c1a 100644
--- a/media/base/demuxer_memory_limit.h
+++ b/media/base/demuxer_memory_limit.h
@@ -45,7 +45,7 @@ constexpr size_t kDemuxerStreamVideoMemoryLimitDefault = 150 * 1024 * 1024;
 constexpr size_t kDemuxerStreamVideoMemoryLimitMedium = 80 * 1024 * 1024;
 constexpr size_t kDemuxerStreamVideoMemoryLimitLow = 30 * 1024 * 1024;
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 // Special "very low" settings for 512MiB Android Go devices:
 // * audio memory limit: 1MB (30 seconds of 256Kbps content).
 // * video memory limit: 15MB (30 seconds of 4Mbps content).
diff --git a/media/base/demuxer_memory_limit_android.cc b/media/base/demuxer_memory_limit_android.cc
index 3ea849942e..a6935af0d1 100644
--- a/media/base/demuxer_memory_limit_android.cc
+++ b/media/base/demuxer_memory_limit_android.cc
@@ -4,7 +4,9 @@
 
 #include "media/base/demuxer_memory_limit.h"
 
+#if !defined(OS_OHOS)
 #include "base/android/build_info.h"
+#endif
 #include "base/system/sys_info.h"
 
 namespace media {
@@ -17,12 +19,14 @@ size_t SelectLimit(size_t default_limit,
   if (!base::SysInfo::IsLowEndDevice()) {
     return default_limit;
   }
+#if !defined(OS_OHOS)
   // Use very low limit on 512MiB Android Go devices only.
   if (base::android::BuildInfo::GetInstance()->sdk_int() >=
           base::android::SDK_VERSION_OREO &&
       base::SysInfo::AmountOfPhysicalMemoryMB() <= 512) {
     return very_low_limit;
   }
+#endif
   return low_limit;
 }
 
diff --git a/media/capture/BUILD.gn b/media/capture/BUILD.gn
index 81f0559d73..ad4a451de9 100644
--- a/media/capture/BUILD.gn
+++ b/media/capture/BUILD.gn
@@ -262,7 +262,7 @@ component("capture_lib") {
   # This includes the case of ChromeOS
   # TODO: As we move to separately version Chrome from ChromeOS, we may need to split
   # these sources into linux, chromeos, and common.
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "video/linux/scoped_v4l2_device_fd.cc",
       "video/linux/scoped_v4l2_device_fd.h",
@@ -394,7 +394,7 @@ source_set("test_support") {
     "//ui/gfx:test_support",
   ]
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "video/linux/fake_device_provider.cc",
       "video/linux/fake_device_provider.h",
diff --git a/media/capture/video/fake_video_capture_device_factory.cc b/media/capture/video/fake_video_capture_device_factory.cc
index b96840f0a6..5f5976b456 100644
--- a/media/capture/video/fake_video_capture_device_factory.cc
+++ b/media/capture/video/fake_video_capture_device_factory.cc
@@ -208,7 +208,7 @@ void FakeVideoCaptureDeviceFactory::GetDevicesInfo(
   int entry_index = 0;
   for (const auto& entry : devices_config_) {
     VideoCaptureApi api =
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
         VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
 #elif defined(OS_MAC)
         VideoCaptureApi::MACOSX_AVFOUNDATION;
diff --git a/media/media_options.gni b/media/media_options.gni
index d24c662534..b3e22d553b 100644
--- a/media/media_options.gni
+++ b/media/media_options.gni
@@ -61,7 +61,7 @@ declare_args() {
   # Enable usage of OpenH264 within the media library. Used for software based
   # encoding of H264 content.
   media_use_openh264 = true
-  if (is_ios || is_android || !proprietary_codecs) {
+  if (is_ios || is_android || is_ohos || !proprietary_codecs) {
     media_use_openh264 = false
   }
 
@@ -102,7 +102,7 @@ declare_args() {
 
   # Enable browser managed persistent metadata storage for EME persistent
   # session and persistent usage record session.
-  enable_media_drm_storage = is_android || is_chromecast
+  enable_media_drm_storage = is_android || is_chromecast || is_ohos
 }
 
 declare_args() {
@@ -126,7 +126,7 @@ declare_args() {
 
   # Alsa should be used on non-Android, non-Mac POSIX systems.
   # Alsa should be used on desktop Chromecast and audio-only Chromecast builds.
-  if (is_posix && !is_android && !is_mac &&
+  if (is_posix && !is_android && !is_mac && !is_ohos &&
       (!is_chromecast || is_cast_desktop_build || is_cast_audio_only)) {
     use_alsa = true
 
@@ -200,7 +200,7 @@ _default_mojo_media_host = ""
 if (is_chromecast) {
   _default_mojo_media_services = cast_mojo_media_services
   _default_mojo_media_host = cast_mojo_media_host
-} else if (is_android) {
+} else if (is_android || is_ohos) {
   _default_mojo_media_services = [
     "cdm",
     "audio_decoder",
@@ -255,7 +255,7 @@ declare_args() {
 declare_args() {
   # Media Remoting RPC is disabled on Android since it's unused but increases
   # the native binary size by ~70Kb.
-  enable_media_remoting_rpc = enable_media_remoting && !is_android
+  enable_media_remoting_rpc = enable_media_remoting && !is_android && !is_ohos
 }
 
 # TODO(ddorwin): Reorder this file so that all media_subcomponent_deps
diff --git a/mojo/public/tools/bindings/mojom.gni b/mojo/public/tools/bindings/mojom.gni
index 089e2699ff..17ac481c88 100644
--- a/mojo/public/tools/bindings/mojom.gni
+++ b/mojo/public/tools/bindings/mojom.gni
@@ -643,6 +643,8 @@ template("mojom") {
       enabled_features += [ "is_mac" ]
     } else if (is_win) {
       enabled_features += [ "is_win" ]
+    } else if (is_ohos) {
+      enabled_features += [ "is_ohos" ]
     }
 
     action(parser_target_name) {
diff --git a/net/BUILD.gn b/net/BUILD.gn
index d3bed2a4ff..edc7e8f38d 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -1203,6 +1203,13 @@ component("net") {
       ]
     }
 
+    if (is_ohos) {
+      sources += [
+        "cert/cert_verify_proc_ohos.cc",
+        "cert/cert_verify_proc_ohos.h",
+      ]
+    }
+
     if (is_chromeos_ash && use_nss_certs) {
       sources += [
         "cert/nss_cert_database_chromeos.cc",
@@ -1224,7 +1231,7 @@ component("net") {
       ]
     }
 
-    if (is_linux || is_chromeos_lacros) {
+    if (is_linux || is_chromeos_lacros || is_ohos) {
       sources += [
         "base/network_change_notifier_linux.cc",
         "base/network_change_notifier_linux.h",
@@ -1233,7 +1240,7 @@ component("net") {
       ]
     }
 
-    if (is_linux || is_chromeos || is_android) {
+    if (is_linux || is_chromeos || is_android || is_ohos) {
       sources += [
         "base/address_tracker_linux.cc",
         "base/address_tracker_linux.h",
@@ -1379,7 +1386,7 @@ component("net") {
       }
     }
 
-    if (is_android || is_chromeos_ash) {
+    if (is_android || is_chromeos_ash || is_ohos) {
       sources += [
         "base/network_change_notifier_posix.cc",
         "base/network_change_notifier_posix.h",
@@ -1412,13 +1419,19 @@ component("net") {
     }
 
     # Use getifaddrs() on POSIX platforms, except Linux.
-    if (is_posix && !is_linux && !is_chromeos) {
+    if (is_posix && !is_linux && !is_chromeos && !is_ohos) {
       sources += [
         "base/network_interfaces_getifaddrs.cc",
         "base/network_interfaces_getifaddrs.h",
       ]
     }
 
+    if (is_ohos) {
+      sources += [
+        "cert/test_root_certs_builtin.cc",
+      ]
+    }
+
     if (use_nss_certs) {
       sources += [
         "cert/internal/system_trust_store_nss.h",
@@ -2541,7 +2554,7 @@ if (is_android) {
   }
 }
 
-if (is_android || is_linux || is_chromeos) {
+if (is_android || is_linux || is_chromeos || is_ohos) {
   executable("disk_cache_memory_test") {
     testonly = true
     sources = [ "tools/disk_cache_memory_test/disk_cache_memory_test.cc" ]
@@ -4749,7 +4762,7 @@ test("net_unittests") {
   }
 
   # Use getifaddrs() on POSIX platforms, except Linux and Android.
-  if (is_posix && !is_linux && !is_chromeos && !is_android) {
+  if (is_posix && !is_linux && !is_chromeos && !is_android && !is_ohos) {
     sources += [ "base/network_interfaces_getifaddrs_unittest.cc" ]
   }
 
diff --git a/net/base/network_change_notifier.cc b/net/base/network_change_notifier.cc
index f98d4a7038..f385822f1d 100644
--- a/net/base/network_change_notifier.cc
+++ b/net/base/network_change_notifier.cc
@@ -34,7 +34,7 @@
 #include "net/base/network_change_notifier_win.h"
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
-#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
 #include "net/base/network_change_notifier_linux.h"
 #elif defined(OS_APPLE)
 #include "net/base/network_change_notifier_mac.h"
@@ -244,7 +244,7 @@ std::unique_ptr<NetworkChangeNotifier> NetworkChangeNotifier::CreateIfNeeded(
 #elif BUILDFLAG(IS_CHROMEOS_ASH)
   return std::make_unique<NetworkChangeNotifierPosix>(initial_type,
                                                       initial_subtype);
-#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
+#elif defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS) || defined(OS_OHOS)
   return std::make_unique<NetworkChangeNotifierLinux>(
       std::unordered_set<std::string>());
 #elif defined(OS_APPLE)
@@ -435,7 +435,7 @@ const char* NetworkChangeNotifier::ConnectionTypeToString(
   return kConnectionTypeNames[type];
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // static
 const internal::AddressTrackerLinux*
 NetworkChangeNotifier::GetAddressTracker() {
@@ -773,7 +773,7 @@ NetworkChangeNotifier::NetworkChangeNotifier(
   can_add_observers_ = true;
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 const internal::AddressTrackerLinux*
 NetworkChangeNotifier::GetAddressTrackerInternal() const {
   return NULL;
diff --git a/net/base/network_change_notifier.h b/net/base/network_change_notifier.h
index 577c2bc91a..83f3e08287 100644
--- a/net/base/network_change_notifier.h
+++ b/net/base/network_change_notifier.h
@@ -22,7 +22,7 @@ struct NetworkInterface;
 class SystemDnsConfigChangeNotifier;
 typedef std::vector<NetworkInterface> NetworkInterfaceList;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 namespace internal {
 class AddressTrackerLinux;
 }
@@ -415,7 +415,7 @@ class NET_EXPORT NetworkChangeNotifier {
   // Chrome net code.
   static SystemDnsConfigChangeNotifier* GetSystemDnsConfigNotifier();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Returns the AddressTrackerLinux if present.
   static const internal::AddressTrackerLinux* GetAddressTracker();
 #endif
@@ -571,7 +571,7 @@ class NET_EXPORT NetworkChangeNotifier {
       SystemDnsConfigChangeNotifier* system_dns_config_notifier = nullptr,
       bool omit_observers_in_constructor_for_testing = false);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Returns the AddressTrackerLinux if present.
   // TODO(szym): Retrieve AddressMap from NetworkState. http://crbug.com/144212
   virtual const internal::AddressTrackerLinux*
diff --git a/net/base/network_interfaces_getifaddrs.cc b/net/base/network_interfaces_getifaddrs.cc
index a848dec3c1..b7d2734f64 100644
--- a/net/base/network_interfaces_getifaddrs.cc
+++ b/net/base/network_interfaces_getifaddrs.cc
@@ -40,6 +40,13 @@ void freeifaddrs(struct ifaddrs* __ptr) __attribute__((weak_import));
 }
 #endif  // OS_ANDROID
 
+#if defined(OS_OHOS)
+extern "C" {
+int getifaddrs(struct ifaddrs** __list_ptr) __attribute__((weak_import));
+void freeifaddrs(struct ifaddrs* __ptr) __attribute__((weak_import));
+}
+#endif
+
 namespace net {
 namespace internal {
 
diff --git a/net/cert/cert_verify_proc.cc b/net/cert/cert_verify_proc.cc
index 6135c24fe8..e6e463a24a 100644
--- a/net/cert/cert_verify_proc.cc
+++ b/net/cert/cert_verify_proc.cc
@@ -53,6 +53,8 @@
 
 #if defined(OS_ANDROID)
 #include "net/cert/cert_verify_proc_android.h"
+#elif defined(OS_OHOS)
+#include "net/cert/cert_verify_proc_ohos.h"
 #elif defined(OS_IOS)
 #include "net/cert/cert_verify_proc_ios.h"
 #elif defined(OS_MAC)
@@ -499,6 +501,8 @@ scoped_refptr<CertVerifyProc> CertVerifyProc::CreateSystemVerifyProc(
     scoped_refptr<CertNetFetcher> cert_net_fetcher) {
 #if defined(OS_ANDROID)
   return new CertVerifyProcAndroid(std::move(cert_net_fetcher));
+#elif defined(OS_OHOS)
+  return new CertVerifyProcOHOS(std::move(cert_net_fetcher));
 #elif defined(OS_IOS)
   return new CertVerifyProcIOS();
 #elif defined(OS_MAC)
diff --git a/net/cert/cert_verify_proc_ohos.cc b/net/cert/cert_verify_proc_ohos.cc
new file mode 100644
index 0000000000..08010f9f4d
--- /dev/null
+++ b/net/cert/cert_verify_proc_ohos.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/cert/cert_verify_proc_ohos.h"
+
+#include "net/cert/cert_net_fetcher.h"
+
+namespace net {
+CertVerifyProcOHOS::CertVerifyProcOHOS(
+    scoped_refptr<CertNetFetcher> cert_net_fetcher)
+    : cert_net_fetcher_(std::move(cert_net_fetcher)) {}
+
+CertVerifyProcOHOS::~CertVerifyProcOHOS() {}
+
+bool CertVerifyProcOHOS::SupportsAdditionalTrustAnchors() const {
+  return false;
+}
+
+int CertVerifyProcOHOS::VerifyInternal(
+    X509Certificate* cert,
+    const std::string& hostname,
+    const std::string& ocsp_response,
+    const std::string& sct_list,
+    int flags,
+    CRLSet* crl_set,
+    const CertificateList& additional_trust_anchors,
+    CertVerifyResult* verify_result,
+    const NetLogWithSource& net_log) {
+  //TODO: no implement
+  return OK;
+}
+
+}  // namespace net
\ No newline at end of file
diff --git a/net/cert/cert_verify_proc_ohos.h b/net/cert/cert_verify_proc_ohos.h
new file mode 100644
index 0000000000..05fb1b6dfe
--- /dev/null
+++ b/net/cert/cert_verify_proc_ohos.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_CERT_CERT_VERIFY_PROC_OHOS_H_
+#define NET_CERT_CERT_VERIFY_PROC_OHOS_H_
+
+#include "base/macros.h"
+#include "net/base/net_export.h"
+#include "net/cert/cert_verify_proc.h"
+
+namespace net {
+
+class CertNetFetcher;
+
+class NET_EXPORT CertVerifyProcOHOS : public CertVerifyProc {
+ public:
+  explicit CertVerifyProcOHOS(scoped_refptr<CertNetFetcher> net_fetcher);
+
+  bool SupportsAdditionalTrustAnchors() const override;
+
+ protected:
+  ~CertVerifyProcOHOS() override;
+
+ private:
+  int VerifyInternal(X509Certificate* cert,
+                     const std::string& hostname,
+                     const std::string& ocsp_response,
+                     const std::string& sct_list,
+                     int flags,
+                     CRLSet* crl_set,
+                     const CertificateList& additional_trust_anchors,
+                     CertVerifyResult* verify_result,
+                     const NetLogWithSource& net_log) override;
+
+  scoped_refptr<CertNetFetcher> cert_net_fetcher_;
+
+  DISALLOW_COPY_AND_ASSIGN(CertVerifyProcOHOS);
+};
+
+}  // namespace net
+
+#endif  // NET_CERT_CERT_VERIFY_PROC_OHOS_H_
\ No newline at end of file
diff --git a/net/cert/test_root_certs.h b/net/cert/test_root_certs.h
index 836f29f242..27b3125ae5 100644
--- a/net/cert/test_root_certs.h
+++ b/net/cert/test_root_certs.h
@@ -75,7 +75,7 @@ class NET_EXPORT TestRootCerts {
   // engine is appropriate. The caller is responsible for freeing the
   // returned HCERTCHAINENGINE.
   HCERTCHAINENGINE GetChainEngine() const;
-#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   TrustStore* test_trust_store() { return &test_trust_store_; }
 #endif
 
@@ -93,12 +93,12 @@ class NET_EXPORT TestRootCerts {
 #elif defined(OS_APPLE)
   base::ScopedCFTypeRef<CFMutableArrayRef> temporary_roots_;
   TrustStoreInMemory test_trust_store_;
-#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_FUCHSIA) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   TrustStoreInMemory test_trust_store_;
 #endif
 
 #if defined(OS_WIN) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // True if there are no temporarily trusted root certificates.
   bool empty_ = true;
 #endif
diff --git a/net/der/parser.h b/net/der/parser.h
index 410a5aeb3d..53b7a8d786 100644
--- a/net/der/parser.h
+++ b/net/der/parser.h
@@ -207,7 +207,7 @@ class NET_EXPORT Parser {
   CBS cbs_;
   size_t advance_len_;
 
-  DISALLOW_COPY(Parser);
+  DISALLOW_COPY_BASE(Parser);
 };
 
 }  // namespace der
diff --git a/net/dns/BUILD.gn b/net/dns/BUILD.gn
index 482b2b93d7..d779de9edd 100644
--- a/net/dns/BUILD.gn
+++ b/net/dns/BUILD.gn
@@ -423,7 +423,7 @@ source_set("tests") {
     sources += [ "dns_config_service_win_unittest.cc" ]
   }
 
-  if (is_android) {
+  if (is_android || is_ohos) {
     sources += [ "dns_config_service_android_unittest.cc" ]
   } else if (is_posix) {
     sources += [ "dns_config_service_posix_unittest.cc" ]
diff --git a/net/dns/dns_config_service_posix.cc b/net/dns/dns_config_service_posix.cc
index dddd4a98a9..4b14ee7ac8 100644
--- a/net/dns/dns_config_service_posix.cc
+++ b/net/dns/dns_config_service_posix.cc
@@ -99,7 +99,7 @@ base::Optional<DnsConfig> ReadDnsConfig() {
   memset(&_res, 0, sizeof(_res));
   if (res_init() == 0)
     dns_config = ConvertResStateToDnsConfig(_res);
-#else  // all other OS_POSIX
+#elif !defined(OS_OHOS)  // all other OS_POSIX
   struct __res_state res;
   memset(&res, 0, sizeof(res));
   if (res_ninit(&res) == 0)
@@ -241,6 +241,7 @@ void DnsConfigServicePosix::CreateReader() {
   config_reader_ = base::MakeRefCounted<ConfigReader>(*this);
 }
 
+#if !defined(OS_OHOS)
 base::Optional<DnsConfig> ConvertResStateToDnsConfig(
     const struct __res_state& res) {
   DnsConfig dns_config;
@@ -344,6 +345,7 @@ base::Optional<DnsConfig> ConvertResStateToDnsConfig(
   }
   return dns_config;
 }
+#endif
 
 }  // namespace internal
 
diff --git a/net/dns/dns_reloader.cc b/net/dns/dns_reloader.cc
index 0672e711af..01cb9aae7c 100644
--- a/net/dns/dns_reloader.cc
+++ b/net/dns/dns_reloader.cc
@@ -5,7 +5,7 @@
 #include "net/dns/dns_reloader.h"
 
 #if defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_OPENBSD) && \
-    !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
+    !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && !defined(OS_OHOS)
 
 #include <resolv.h>
 
diff --git a/net/dns/host_resolver_manager.cc b/net/dns/host_resolver_manager.cc
index 6450e1e96e..b56a9312bd 100644
--- a/net/dns/host_resolver_manager.cc
+++ b/net/dns/host_resolver_manager.cc
@@ -12,7 +12,7 @@
 #include <netinet/in.h>
 #if !defined(OS_NACL)
 #include <net/if.h>
-#if !defined(OS_ANDROID)
+#if !defined(OS_ANDROID) && !defined(OS_OHOS)
 #include <ifaddrs.h>
 #endif  // !defined(OS_ANDROID)
 #endif  // !defined(OS_NACL)
@@ -243,7 +243,7 @@ bool HaveOnlyLoopbackAddresses() {
 #elif defined(OS_NACL)
   NOTIMPLEMENTED();
   return false;
-#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
+#elif (defined(OS_POSIX) && !defined(OS_OHOS)) || defined(OS_FUCHSIA)
   struct ifaddrs* interface_addr = NULL;
   int rv = getifaddrs(&interface_addr);
   if (rv != 0) {
@@ -277,6 +277,8 @@ bool HaveOnlyLoopbackAddresses() {
   }
   freeifaddrs(interface_addr);
   return result;
+#else
+  return false;
 #endif  // defined(various platforms)
 }
 
@@ -2524,7 +2526,7 @@ HostResolverManager::HostResolverManager(
 #if defined(OS_WIN)
   EnsureWinsockInit();
 #endif
-#if (defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_ANDROID)) || \
+#if (defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_ANDROID) && !defined(OS_OHOS)) || \
     defined(OS_FUCHSIA)
   RunLoopbackProbeJob();
 #endif
@@ -2533,7 +2535,7 @@ HostResolverManager::HostResolverManager(
   if (system_dns_config_notifier_)
     system_dns_config_notifier_->AddObserver(this);
 #if defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_OPENBSD) && \
-    !defined(OS_ANDROID)
+    !defined(OS_ANDROID) && !defined(OS_OHOS)
   EnsureDnsReloaderInit();
 #endif
 
@@ -3472,7 +3474,7 @@ void HostResolverManager::OnIPAddressChanged() {
   // Abandon all ProbeJobs.
   probe_weak_ptr_factory_.InvalidateWeakPtrs();
   InvalidateCaches();
-#if (defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_ANDROID)) || \
+#if (defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_ANDROID) && !defined(OS_OHOS)) || \
     defined(OS_FUCHSIA)
   RunLoopbackProbeJob();
 #endif
diff --git a/net/dns/host_resolver_proc.cc b/net/dns/host_resolver_proc.cc
index 3da9fb4325..cf681caf54 100644
--- a/net/dns/host_resolver_proc.cc
+++ b/net/dns/host_resolver_proc.cc
@@ -177,7 +177,7 @@ int SystemHostResolverCall(const std::string& host,
                                                 base::BlockingType::WILL_BLOCK);
 
 #if defined(OS_POSIX) && !defined(OS_APPLE) && !defined(OS_OPENBSD) && \
-    !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
+    !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && !defined(OS_OHOS)
   DnsReloaderMaybeReload();
 #endif
   base::Optional<AddressInfo> ai;
diff --git a/net/reporting/reporting_test_util.h b/net/reporting/reporting_test_util.h
index 629e765105..86554e4021 100644
--- a/net/reporting/reporting_test_util.h
+++ b/net/reporting/reporting_test_util.h
@@ -302,7 +302,7 @@ class TestReportingService : public ReportingService {
     int depth;
 
    private:
-    DISALLOW_COPY(Report);
+    DISALLOW_COPY_BASE(Report);
   };
 
   TestReportingService();
diff --git a/net/socket/unix_domain_server_socket_posix.cc b/net/socket/unix_domain_server_socket_posix.cc
index 8b2e29b8d2..eb243b718b 100644
--- a/net/socket/unix_domain_server_socket_posix.cc
+++ b/net/socket/unix_domain_server_socket_posix.cc
@@ -34,7 +34,7 @@ UnixDomainServerSocket::~UnixDomainServerSocket() = default;
 bool UnixDomainServerSocket::GetPeerCredentials(SocketDescriptor socket,
                                                 Credentials* credentials) {
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
   struct ucred user_cred;
   socklen_t len = sizeof(user_cred);
   if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &user_cred, &len) < 0)
diff --git a/net/socket/unix_domain_server_socket_posix.h b/net/socket/unix_domain_server_socket_posix.h
index 9da6bc0d5d..169a68cf2c 100644
--- a/net/socket/unix_domain_server_socket_posix.h
+++ b/net/socket/unix_domain_server_socket_posix.h
@@ -30,7 +30,7 @@ class NET_EXPORT UnixDomainServerSocket : public ServerSocket {
   // Credentials of a peer process connected to the socket.
   struct NET_EXPORT Credentials {
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
     // Linux and Fuchsia provide more information about the connected peer
     // than Windows/OS X. It's useful for permission-based authorization on
     // Android.
diff --git a/printing/BUILD.gn b/printing/BUILD.gn
index 90bfb18012..9f50881dbc 100644
--- a/printing/BUILD.gn
+++ b/printing/BUILD.gn
@@ -153,7 +153,7 @@ component("printing") {
     ]
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     sources += [
       "printed_document_linux.cc",
       "printing_context_linux.cc",
diff --git a/printing/printing_features.cc b/printing/printing_features.cc
index 237a9d9f7f..1293efdb8f 100644
--- a/printing/printing_features.cc
+++ b/printing/printing_features.cc
@@ -44,7 +44,7 @@ bool ShouldPrintUsingXps(bool source_is_pdf) {
 #endif  // defined(OS_WIN)
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Enables printing interactions with the operating system to be performed
 // out-of-process.
 const base::Feature kEnableOopPrintDrivers{"EnableOopPrintDrivers",
diff --git a/printing/printing_features.h b/printing/printing_features.h
index 72b155a3e7..6f20497a5c 100644
--- a/printing/printing_features.h
+++ b/printing/printing_features.h
@@ -35,7 +35,7 @@ PRINTING_EXPORT bool ShouldPrintUsingXps(bool source_is_pdf);
 #endif  // defined(OS_WIN)
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_OHOS)
 PRINTING_EXPORT extern const base::Feature kEnableOopPrintDrivers;
 #endif  // defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) ||
         // defined(OS_CHROMEOS)
diff --git a/sandbox/BUILD.gn b/sandbox/BUILD.gn
index 5bfd4d5aef..ee79c215b2 100644
--- a/sandbox/BUILD.gn
+++ b/sandbox/BUILD.gn
@@ -27,7 +27,7 @@ group("sandbox") {
       "//sandbox/mac:system_services",
       "//sandbox/mac/mojom",
     ]
-  } else if (is_linux || is_chromeos || is_android) {
+  } else if (is_linux || is_chromeos || is_android || is_ohos) {
     public_deps = [ "//sandbox/linux:sandbox" ]
   }
 }
diff --git a/sandbox/features.gni b/sandbox/features.gni
index db30ae6d63..094a2f22d9 100644
--- a/sandbox/features.gni
+++ b/sandbox/features.gni
@@ -8,7 +8,7 @@ import("//build/config/nacl/config.gni")
 # currently.
 # Do not disable seccomp_bpf anywhere without talking to
 # security@chromium.org!
-use_seccomp_bpf = (is_linux || is_chromeos || is_android) &&
+use_seccomp_bpf = (is_linux || is_chromeos || is_android || is_ohos) &&
                   (current_cpu == "x86" || current_cpu == "x64" ||
                    current_cpu == "arm" || current_cpu == "arm64" ||
                    current_cpu == "mipsel" || current_cpu == "mips64el")
@@ -18,4 +18,4 @@ use_seccomp_bpf = use_seccomp_bpf || is_nacl_nonsfi
 # SSBD (Speculative Store Bypass Disable) is a mitigation of Spectre Variant 4.
 # As Spectre Variant 4 can be mitigated by site isolation, opt-out SSBD on site
 # isolation fully applied platform.
-disable_seccomp_ssbd = use_seccomp_bpf && !is_android
+disable_seccomp_ssbd = use_seccomp_bpf && !is_android && !is_ohos
diff --git a/sandbox/linux/BUILD.gn b/sandbox/linux/BUILD.gn
index 2f778dd0bc..da1e2f70e1 100644
--- a/sandbox/linux/BUILD.gn
+++ b/sandbox/linux/BUILD.gn
@@ -12,9 +12,9 @@ if (is_android) {
 }
 
 declare_args() {
-  compile_suid_client = is_linux || is_chromeos
+  compile_suid_client = is_linux || is_chromeos || is_ohos
 
-  compile_credentials = is_linux || is_chromeos
+  compile_credentials = is_linux || is_chromeos || is_ohos
 
   # On Android, use plain GTest.
   use_base_test_suite = is_linux || is_chromeos
diff --git a/sandbox/linux/services/credentials.h b/sandbox/linux/services/credentials.h
index 0cf99973c1..1d6514a109 100644
--- a/sandbox/linux/services/credentials.h
+++ b/sandbox/linux/services/credentials.h
@@ -13,6 +13,10 @@
 
 #include <string>
 #include <vector>
+#if defined(__MUSL__)
+#include <sys/types.h>
+#include <unistd.h>
+#endif
 
 #include "base/compiler_specific.h"
 #include "base/macros.h"
diff --git a/sandbox/policy/BUILD.gn b/sandbox/policy/BUILD.gn
index cd8f38e845..00a2c7aff8 100644
--- a/sandbox/policy/BUILD.gn
+++ b/sandbox/policy/BUILD.gn
@@ -29,7 +29,7 @@ component("policy") {
     "//sandbox:common",
   ]
   public_deps = []
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "linux/bpf_audio_policy_linux.cc",
       "linux/bpf_audio_policy_linux.h",
diff --git a/sandbox/policy/sandbox.cc b/sandbox/policy/sandbox.cc
index 95482e83b8..d4fedf8a5c 100644
--- a/sandbox/policy/sandbox.cc
+++ b/sandbox/policy/sandbox.cc
@@ -12,7 +12,7 @@
 #include "base/android/jni_android.h"
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "sandbox/policy/linux/sandbox_linux.h"
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
@@ -30,7 +30,7 @@
 namespace sandbox {
 namespace policy {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 bool Sandbox::Initialize(SandboxType sandbox_type,
                          SandboxLinux::PreSandboxHook hook,
                          const SandboxLinux::Options& options) {
@@ -109,7 +109,7 @@ bool Sandbox::IsProcessSandboxed() {
   // launching controls the sandbox and there are no ambient capabilities, so
   // basically everything but the browser is considered sandboxed.
   return !is_browser;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   int status = SandboxLinux::GetInstance()->GetStatus();
   constexpr int kLayer1Flags = SandboxLinux::Status::kSUID |
                                SandboxLinux::Status::kPIDNS |
diff --git a/sandbox/policy/sandbox.h b/sandbox/policy/sandbox.h
index c842e1d19c..965e6ba90d 100644
--- a/sandbox/policy/sandbox.h
+++ b/sandbox/policy/sandbox.h
@@ -9,7 +9,7 @@
 #include "sandbox/policy/export.h"
 #include "sandbox/policy/sandbox_type.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "sandbox/policy/linux/sandbox_linux.h"
 #endif
 
@@ -34,7 +34,7 @@ namespace policy {
 
 class SANDBOX_POLICY_EXPORT Sandbox {
  public:
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   static bool Initialize(SandboxType sandbox_type,
                          SandboxLinux::PreSandboxHook hook,
                          const SandboxLinux::Options& options);
diff --git a/sandbox/policy/sandbox_type.cc b/sandbox/policy/sandbox_type.cc
index 8d6c520b7b..71ae35b40a 100644
--- a/sandbox/policy/sandbox_type.cc
+++ b/sandbox/policy/sandbox_type.cc
@@ -62,7 +62,7 @@ bool IsUnsandboxedSandboxType(SandboxType sandbox_type) {
 #if !defined(OS_MAC)
     case SandboxType::kSharingService:
 #endif
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     case SandboxType::kZygoteIntermediateSandbox:
 #endif
     case SandboxType::kSpeechRecognition:
@@ -144,7 +144,7 @@ void SetCommandLineFlagsForSandboxType(base::CommandLine* command_line,
     case SandboxType::kNaClLoader:
       break;
 #endif  // defined(OS_MAC)
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     case SandboxType::kZygoteIntermediateSandbox:
       break;
 #endif
@@ -193,7 +193,7 @@ SandboxType SandboxTypeFromCommandLine(const base::CommandLine& command_line) {
   if (process_type == switches::kNaClBrokerProcess)
     return SandboxType::kNoSandbox;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Intermediate process gains a sandbox later.
   if (process_type == switches::kZygoteProcessType)
     return SandboxType::kZygoteIntermediateSandbox;
@@ -265,7 +265,7 @@ std::string StringFromUtilitySandboxType(SandboxType sandbox_type) {
 #if defined(OS_FUCHSIA)
     case SandboxType::kWebContext:
 #endif  // defined(OS_FUCHSIA)
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     case SandboxType::kZygoteIntermediateSandbox:
 #endif
       NOTREACHED();
diff --git a/sandbox/policy/sandbox_type.h b/sandbox/policy/sandbox_type.h
index 38dc1718ab..4ad78c5697 100644
--- a/sandbox/policy/sandbox_type.h
+++ b/sandbox/policy/sandbox_type.h
@@ -85,7 +85,7 @@ enum class SandboxType {
   kTts,
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // Indicates that a process is a zygote and will get a real sandbox later.
   kZygoteIntermediateSandbox,
 #endif
diff --git a/sandbox/policy/switches.cc b/sandbox/policy/switches.cc
index 7e33328df4..edbf3fdfbf 100644
--- a/sandbox/policy/switches.cc
+++ b/sandbox/policy/switches.cc
@@ -83,7 +83,7 @@ const char kGpuSandboxFailuresFatal[] = "gpu-sandbox-failures-fatal";
 // Meant to be used as a browser-level switch for testing purposes only.
 const char kNoSandbox[] = "no-sandbox";
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // Instructs the zygote to launch without a sandbox. Processes forked from this
 // type of zygote will apply their own custom sandboxes later.
 const char kNoZygoteSandbox[] = "no-zygote-sandbox";
diff --git a/sandbox/policy/switches.h b/sandbox/policy/switches.h
index a2c9e9dd08..6bcf5ba897 100644
--- a/sandbox/policy/switches.h
+++ b/sandbox/policy/switches.h
@@ -55,7 +55,7 @@ SANDBOX_POLICY_EXPORT extern const char kDisableSetuidSandbox[];
 SANDBOX_POLICY_EXPORT extern const char kGpuSandboxAllowSysVShm[];
 SANDBOX_POLICY_EXPORT extern const char kGpuSandboxFailuresFatal[];
 SANDBOX_POLICY_EXPORT extern const char kNoSandbox[];
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 SANDBOX_POLICY_EXPORT extern const char kNoZygoteSandbox[];
 #endif
 #if defined(OS_WIN)
diff --git a/services/device/geolocation/location_arbitrator.cc b/services/device/geolocation/location_arbitrator.cc
index df0c7df2dc..527cff5fbb 100644
--- a/services/device/geolocation/location_arbitrator.cc
+++ b/services/device/geolocation/location_arbitrator.cc
@@ -162,7 +162,7 @@ LocationArbitrator::NewNetworkLocationProvider(
 
 std::unique_ptr<LocationProvider>
 LocationArbitrator::NewSystemLocationProvider() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   return nullptr;
 #else
   return device::NewSystemLocationProvider();
diff --git a/services/device/time_zone_monitor/BUILD.gn b/services/device/time_zone_monitor/BUILD.gn
index 00d3464033..2c8c208968 100644
--- a/services/device/time_zone_monitor/BUILD.gn
+++ b/services/device/time_zone_monitor/BUILD.gn
@@ -40,7 +40,7 @@ source_set("time_zone_monitor") {
     deps += [ "//ui/gfx" ]
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     sources += [ "time_zone_monitor_linux.cc" ]
   }
 
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/BUILD.gn b/services/resource_coordinator/public/cpp/memory_instrumentation/BUILD.gn
index 908dfec2d4..41e8f72ab6 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/BUILD.gn
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/BUILD.gn
@@ -29,7 +29,7 @@ component("memory_instrumentation") {
     sources += [ "os_metrics_win.cc" ]
   }
 
-  if (is_android || is_linux || is_chromeos) {
+  if (is_android || is_linux || is_chromeos || is_ohos) {
     sources += [ "os_metrics_linux.cc" ]
   }
 
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
index 1fdd28fbef..84980130e0 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
@@ -45,7 +45,7 @@ class COMPONENT_EXPORT(
                                     mojom::RawOSMemDump*);
   static std::vector<mojom::VmRegionPtr> GetProcessMemoryMaps(base::ProcessId);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   static void SetProcSmapsForTesting(FILE*);
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
 
@@ -61,7 +61,7 @@ class COMPONENT_EXPORT(
   static std::vector<mojom::VmRegionPtr> GetProcessModules(base::ProcessId);
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   // Provides information on the dump state of resident pages. These values are
   // written to logs. New enum values can be added, but existing enums must
   // never be renumbered or deleted and reused.
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index 28066d335a..cab3a89378 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -115,6 +115,13 @@ config("skia_config") {
     ]
   }
 
+  # TODO: ohos use skia to be adapted
+  if (is_ohos) {
+    defines += [
+      "USE_CHROMIUM_SKIA",
+    ]
+  }
+
   if (is_mac) {
     defines += [
       "SK_BUILD_FOR_MAC",
@@ -151,7 +158,7 @@ config("skia_library_config") {
       "SK_GAMMA_EXPONENT=1.2",
       "SK_GAMMA_CONTRAST=0.2",
     ]
-  } else if (is_android) {
+  } else if (is_android || is_ohos) {
     defines += [
       "SK_GAMMA_APPLY_TO_A8",
       "SK_GAMMA_EXPONENT=1.4",
@@ -169,7 +176,7 @@ config("skia_library_config") {
     ]
   }
 
-  if (is_android) {
+  if (is_android || is_ohos) {
     defines += [
       # Android devices are typically more memory constrained, so default to a
       # smaller glyph cache (it may be overriden at runtime when the renderer
@@ -274,6 +281,9 @@ component("skia") {
   if (is_android) {
     sources += [ "ext/fontmgr_default_android.cc" ]
   }
+  if (is_ohos) {
+    sources += [ "ext/fontmgr_default_ohos.cc" ]
+  }
   if (is_linux || is_chromeos) {
     sources += [ "ext/fontmgr_default_linux.cc" ]
   }
@@ -486,6 +496,19 @@ component("skia") {
     ]
   }
 
+  if (is_ohos) {
+    sources += [
+      "//third_party/skia/src/ports/skia_ohos/FontConfig_ohos.cpp",
+      "//third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.cpp",
+      "//third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.cpp",
+      "//third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.cpp",
+    ]
+    include_dirs = [
+      "//third_party/skia/src/ports/skia_ohos",
+      "//third_party/jsoncpp/source/include",
+    ]
+  }
+
   if (is_win || is_mac) {
     sources += [
       # Add the FreeType custom font manager as a fallback backend for variable fonts.
diff --git a/skia/config/SkUserConfig.h b/skia/config/SkUserConfig.h
index 83a41864e4..d9417a16f7 100644
--- a/skia/config/SkUserConfig.h
+++ b/skia/config/SkUserConfig.h
@@ -161,10 +161,17 @@ SK_API void SkDebugf_FileLine(const char* file,
                                           ...);
 
 #if !defined(ANDROID)   // On Android, we use the skia default settings.
+#if defined(SK_CPU_LENDIAN)  // on OHOS, B and R will exchange.
 #define SK_A32_SHIFT    24
-#define SK_R32_SHIFT    16
+#define SK_B32_SHIFT    16
 #define SK_G32_SHIFT    8
-#define SK_B32_SHIFT    0
+#define SK_R32_SHIFT    0
+#else
+#define SK_A32_SHIFT 24
+#define SK_R32_SHIFT 16
+#define SK_G32_SHIFT 8
+#define SK_B32_SHIFT 0
+#endif
 #endif
 
 #if defined(SK_BUILD_FOR_MAC)
diff --git a/skia/ext/fontmgr_default_ohos.cc b/skia/ext/fontmgr_default_ohos.cc
new file mode 100644
index 0000000000..6558bbebea
--- /dev/null
+++ b/skia/ext/fontmgr_default_ohos.cc
@@ -0,0 +1,16 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "skia/ext/fontmgr_default.h"
+
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "SkFontMgr_ohos.h"
+
+namespace skia {
+
+SK_API sk_sp<SkFontMgr> CreateDefaultSkFontMgr() {
+  return SkFontMgr_New_OHOS(nullptr);
+}
+
+}  // namespace skia
\ No newline at end of file
diff --git a/third_party/angle/BUILD.gn b/third_party/angle/BUILD.gn
index 238ad677eb..0aab18aea2 100644
--- a/third_party/angle/BUILD.gn
+++ b/third_party/angle/BUILD.gn
@@ -448,7 +448,7 @@ angle_static_library("angle_gpu_info_util") {
     libs += [ "dxgi.lib" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += libangle_gpu_info_util_linux_sources
 
     if (angle_use_x11 && angle_has_build) {
diff --git a/third_party/angle/gni/angle.gni b/third_party/angle/gni/angle.gni
index aab30d53a9..42ee6145d1 100644
--- a/third_party/angle/gni/angle.gni
+++ b/third_party/angle/gni/angle.gni
@@ -21,7 +21,7 @@ if (angle_has_build) {
   import("//build/config/ui.gni")  # import the use_x11 variable
   import("//build_overrides/build.gni")
   import("//testing/test.gni")
-  if (is_android) {
+  if (is_android || is_ohos) {
     import("//build/config/android/config.gni")
   }
 
@@ -85,7 +85,7 @@ declare_args() {
   angle_is_winuwp = is_win && target_os == "winuwp"
 
   # Default to using "_angle" suffix on Android
-  if (is_android) {
+  if (is_android || is_ohos) {
     angle_libs_suffix = "_angle"
   } else {
     angle_libs_suffix = ""
@@ -115,11 +115,11 @@ declare_args() {
       angle_has_build &&
       ((is_win && !angle_is_winuwp) ||
        (is_linux && (angle_use_x11 || angle_use_vulkan_display) &&
-        !is_chromeos) || is_android || is_fuchsia || is_ggp || is_mac)
+        !is_chromeos) || is_android || is_fuchsia || is_ggp || is_mac || is_ohos)
 
   # Disable null backend to save space for official build.
   angle_enable_null = !is_official_build
-  angle_enable_gl_desktop = !is_android && !is_ios
+  angle_enable_gl_desktop = !is_android && !is_ios && !is_ohos
 
   # http://anglebug.com/2634
   angle_enable_metal = is_mac
@@ -130,7 +130,7 @@ declare_args() {
   # SwiftShader is not needed on Fuchsia because Vulkan is supported on all
   # devices that run Fuchsia.
   angle_enable_swiftshader =
-      angle_enable_vulkan && !is_android && !is_fuchsia && !is_ggp
+      angle_enable_vulkan && !is_android && !is_fuchsia && !is_ggp && !is_ohos
 
   angle_enable_hlsl = angle_enable_d3d9 || angle_enable_d3d11
   angle_enable_essl = angle_enable_gl || use_ozone
@@ -145,7 +145,7 @@ declare_args() {
   angle_enable_vulkan_validation_layers =
       angle_enable_vulkan && !is_ubsan && !is_tsan && !is_asan &&
       (is_debug || dcheck_always_on) && !is_mac &&
-      (!is_android || ndk_api_level_at_least_26)
+      ((!is_android && !is_ohos) || ndk_api_level_at_least_26)
 
   # Disable overlay by default
   angle_enable_overlay = false
diff --git a/third_party/angle/src/common/vulkan/BUILD.gn b/third_party/angle/src/common/vulkan/BUILD.gn
index e7cd440265..8cfa9531f1 100644
--- a/third_party/angle/src/common/vulkan/BUILD.gn
+++ b/third_party/angle/src/common/vulkan/BUILD.gn
@@ -35,7 +35,7 @@ group("angle_vulkan_entry_points") {
       "//third_party/fuchsia-sdk:vulkan_base",
       "//third_party/fuchsia-sdk/sdk/pkg/vulkan",
     ]
-  } else if (!is_android && !is_ggp) {
+  } else if (!is_android && !is_ggp && !is_ohos) {
     if (angle_shared_libvulkan) {
       data_deps = [ "$angle_vulkan_loader_dir:libvulkan" ]
     } else {
@@ -65,7 +65,7 @@ angle_source_set("vulkan") {
   deps = []
   data_deps = []
 
-  if (!is_android && !is_fuchsia && !is_ggp) {
+  if (!is_android && !is_fuchsia && !is_ggp && !is_ohos) {
     if (angle_shared_libvulkan) {
       data_deps += [ "$angle_vulkan_loader_dir:libvulkan" ]
     } else {
@@ -98,7 +98,7 @@ if (angle_enable_vulkan_validation_layers) {
     } else {
       data_deps +=
           [ "$angle_vulkan_validation_layers_dir:vulkan_validation_layers" ]
-      if (!is_android) {
+      if (!is_android && !is_ohos) {
         data_deps +=
             [ "$angle_vulkan_validation_layers_dir:vulkan_gen_json_files" ]
       }
diff --git a/third_party/angle/src/libGLESv2.gni b/third_party/angle/src/libGLESv2.gni
index 0350c28ac4..fae0228f77 100644
--- a/third_party/angle/src/libGLESv2.gni
+++ b/third_party/angle/src/libGLESv2.gni
@@ -70,7 +70,7 @@ xxhash_sources = [
   "src/common/third_party/xxhash/xxhash.h",
 ]
 
-if (is_linux || is_chromeos || is_android || is_fuchsia) {
+if (is_linux || is_chromeos || is_android || is_fuchsia || is_ohos) {
   libangle_common_sources += [
     "src/common/system_utils_linux.cpp",
     "src/common/system_utils_posix.cpp",
diff --git a/third_party/angle/src/tests/BUILD.gn b/third_party/angle/src/tests/BUILD.gn
index e571ab0beb..077ad37f73 100644
--- a/third_party/angle/src/tests/BUILD.gn
+++ b/third_party/angle/src/tests/BUILD.gn
@@ -13,7 +13,7 @@ declare_args() {
   build_angle_gles1_conform_tests = false
   build_angle_trace_perf_tests = false
   build_angle_perftests =
-      is_win || is_linux || is_chromeos || is_android || is_apple || is_fuchsia
+      is_win || is_linux || is_chromeos || is_android || is_apple || is_fuchsia || is_ohos
 }
 
 angle_test("test_utils_unittest_helper") {
@@ -155,7 +155,7 @@ angle_test("angle_unittests") {
   }
 }
 
-if (is_win || is_linux || is_chromeos || is_android || is_fuchsia || is_apple) {
+if (is_win || is_linux || is_chromeos || is_android || is_fuchsia || is_apple || is_ohos) {
   import("angle_end2end_tests.gni")
 
   angle_test("angle_end2end_tests") {
@@ -186,7 +186,7 @@ if (is_win || is_linux || is_chromeos || is_android || is_fuchsia || is_apple) {
       "$angle_root:angle_image_util",
     ]
 
-    if (is_android) {
+    if (is_android || is_ohos) {
       include_dirs += [ "${android_ndk_root}/sysroot/usr/includes" ]
     }
 
@@ -224,7 +224,7 @@ if (is_win || is_linux || is_chromeos || is_android || is_fuchsia || is_apple) {
   }
 }
 
-if (is_win || is_linux || is_chromeos || is_android || is_fuchsia || is_apple) {
+if (is_win || is_linux || is_chromeos || is_android || is_fuchsia || is_apple || is_ohos) {
   import("angle_white_box_tests.gni")
 
   angle_test("angle_white_box_tests") {
@@ -302,7 +302,7 @@ angle_perftests_common("angle_perftests_static") {
   test_utils = ":angle_common_test_utils_static"
 }
 
-if (is_win || is_linux || is_chromeos || is_android || is_apple) {
+if (is_win || is_linux || is_chromeos || is_android || is_apple || is_ohos) {
   import("angle_perftests.gni")
 
   # This test suite is for perf tests that use ANGLE's internals in some direct way.
diff --git a/third_party/blink/public/common/web_preferences/web_preferences.h b/third_party/blink/public/common/web_preferences/web_preferences.h
index ba58c8626d..08ed976ad4 100644
--- a/third_party/blink/public/common/web_preferences/web_preferences.h
+++ b/third_party/blink/public/common/web_preferences/web_preferences.h
@@ -220,7 +220,7 @@ struct BLINK_COMMON_EXPORT WebPreferences {
   // Representation of the Web App Manifest scope if any.
   GURL web_app_scope;
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   float font_scale_factor;
   float device_scale_adjustment;
   bool force_enable_zoom;
diff --git a/third_party/blink/renderer/BUILD.gn b/third_party/blink/renderer/BUILD.gn
index b06bf2b8e1..75473421f5 100644
--- a/third_party/blink/renderer/BUILD.gn
+++ b/third_party/blink/renderer/BUILD.gn
@@ -146,7 +146,7 @@ config("config") {
 config("non_test_config") {
   cflags = []
 
-  if (is_clang) {
+  if (is_clang && !is_ohos) {
     cflags += [ "-Wglobal-constructors" ]
   }
 }
diff --git a/third_party/blink/renderer/config.gni b/third_party/blink/renderer/config.gni
index 89689ad370..ec02b05ca1 100644
--- a/third_party/blink/renderer/config.gni
+++ b/third_party/blink/renderer/config.gni
@@ -33,10 +33,10 @@ declare_args() {
   blink_symbol_level = -1
 
   # If true, defaults image interpolation to low quality.
-  use_low_quality_image_interpolation = is_android
+  use_low_quality_image_interpolation = is_android || is_ohos
 
   # If true, ffmpeg will be used for computing FFTs for WebAudio
-  use_webaudio_ffmpeg = !is_mac && !is_android && !use_webaudio_pffft
+  use_webaudio_ffmpeg = !is_mac && !is_android && !use_webaudio_pffft && !is_ohos
 
   # If true, the new implementation (experimental) of Blink-V8 bindings
   # (of IDL callback function) is used.
diff --git a/third_party/blink/renderer/core/frame/local_frame_view.cc b/third_party/blink/renderer/core/frame/local_frame_view.cc
index a520308e5d..58fc719381 100644
--- a/third_party/blink/renderer/core/frame/local_frame_view.cc
+++ b/third_party/blink/renderer/core/frame/local_frame_view.cc
@@ -43,6 +43,7 @@
 #include "cc/trees/layer_tree_host.h"
 #include "components/paint_preview/common/paint_preview_tracker.h"
 #include "third_party/blink/public/common/features.h"
+#include "third_party/abseil-cpp/absl/base/macros.h"
 #include "third_party/blink/public/mojom/scroll/scroll_into_view_params.mojom-blink.h"
 #include "third_party/blink/public/mojom/scroll/scrollbar_mode.mojom-blink.h"
 #include "third_party/blink/public/platform/task_type.h"
diff --git a/third_party/blink/renderer/core/layout/build.gni b/third_party/blink/renderer/core/layout/build.gni
index 4e2863ae2a..3d63ff889c 100644
--- a/third_party/blink/renderer/core/layout/build.gni
+++ b/third_party/blink/renderer/core/layout/build.gni
@@ -738,7 +738,7 @@ if (is_linux || is_chromeos) {
   ]
 }
 
-if (is_android) {
+if (is_android || is_ohos) {
   blink_core_sources_layout += [
     "layout_theme_android.cc",
     "layout_theme_android.h",
diff --git a/third_party/blink/renderer/core/page/scrolling/text_fragment_selector_generator.h b/third_party/blink/renderer/core/page/scrolling/text_fragment_selector_generator.h
index d4af08daba..b41aed1c8e 100644
--- a/third_party/blink/renderer/core/page/scrolling/text_fragment_selector_generator.h
+++ b/third_party/blink/renderer/core/page/scrolling/text_fragment_selector_generator.h
@@ -7,6 +7,7 @@
 
 #include "base/optional.h"
 #include "components/shared_highlighting/core/common/shared_highlighting_metrics.h"
+#include "third_party/abseil-cpp/absl/base/macros.h"
 #include "third_party/blink/public/mojom/link_to_text/link_to_text.mojom-blink.h"
 #include "third_party/blink/renderer/core/editing/forward.h"
 #include "third_party/blink/renderer/core/page/scrolling/text_fragment_finder.h"
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 4b88d30a40..e0b3b8305a 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1743,6 +1743,12 @@ component("platform") {
     ]
   }
 
+  if (is_ohos) {
+    sources += [
+      "fonts/android/font_cache_android.cc",
+    ]
+  }
+
   if (is_android) {
     sources += [
       "fonts/android/font_cache_android.cc",
@@ -1882,7 +1888,7 @@ static_library("test_support") {
   ]
 
   # fuzzed_data_provider may not work with a custom toolchain.
-  if (custom_toolchain == "" && is_clang) {
+  if (custom_toolchain == "" && is_clang && !is_ohos) {
     sources += [
       "testing/fuzzed_data_provider.cc",
       "testing/fuzzed_data_provider.h",
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index df794d75c1..f9354241e7 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -80,7 +80,7 @@ const char kColorEmojiLocale[] = "und-Zsye";
 
 SkFontMgr* FontCache::static_font_manager_ = nullptr;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 float FontCache::device_scale_factor_ = 1.0;
 #endif
 
@@ -120,7 +120,7 @@ FontCache::FontCache()
 FontPlatformData* FontCache::SystemFontPlatformData(
     const FontDescription& font_description) {
   const AtomicString& family = FontCache::SystemFontFamily();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   if (family.IsEmpty() || family == font_family_names::kSystemUi)
     return nullptr;
 #else
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index e87551ae40..264a9e8df3 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -242,7 +242,7 @@ class PLATFORM_EXPORT FontCache {
 
   static void AcceptLanguagesChanged(const String&);
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   static AtomicString GetGenericFamilyNameForScript(
       const AtomicString& family_name,
       const FontDescription&);
@@ -326,7 +326,7 @@ class PLATFORM_EXPORT FontCache {
                                    const FontFaceCreationParams&,
                                    std::string& name);
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   static AtomicString GetFamilyNameForCharacter(SkFontMgr*,
                                                 UChar32,
                                                 const FontDescription&,
@@ -371,7 +371,7 @@ class PLATFORM_EXPORT FontCache {
   std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   static float device_scale_factor_;
 #endif
 
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_platform_data.cc
index ad318e8a22..600ac72a2c 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data.cc
@@ -266,7 +266,7 @@ WebFontRenderStyle FontPlatformData::QuerySystemRenderStyle(
     SkFontStyle font_style) {
   WebFontRenderStyle result;
 
-#if !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
+#if !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && !defined(OS_OHOS)
   // If the font name is missing (i.e. probably a web font) or the sandbox is
   // disabled, use the system defaults.
   if (family.length() && Platform::Current()->GetSandboxSupport()) {
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index b962b210a9..0e3124aab6 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -61,7 +61,7 @@ AtomicString ToAtomicString(const SkString& str) {
   return AtomicString::FromUTF8(str.c_str(), str.size());
 }
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // This function is called on android or when we are emulating android fonts on
 // linux and the embedder has overriden the default fontManager with
 // WebFontRendering::setSkiaFontMgr.
@@ -229,7 +229,7 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_WIN) || defined(OS_OHOS)
   // On linux if the fontManager has been overridden then we should be calling
   // the embedder provided font Manager rather than calling
   // SkTypeface::CreateFromName which may redirect the call to the default font
diff --git a/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
index 1537330f5b..40587acbdb 100644
--- a/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
@@ -16,7 +16,7 @@ sk_sp<SkTypeface> SkTypeface_Factory::FromFontConfigInterfaceIdAndTtcIndex(
     int config_id,
     int ttc_index) {
 #if !defined(OS_MAC) && !defined(OS_ANDROID) && !defined(OS_WIN) && \
-    !defined(OS_FUCHSIA)
+    !defined(OS_FUCHSIA) && !defined(OS_OHOS)
   sk_sp<SkFontConfigInterface> fci(SkFontConfigInterface::RefGlobal());
   SkFontConfigInterface::FontIdentity font_identity;
   font_identity.fID = config_id;
@@ -33,7 +33,7 @@ sk_sp<SkTypeface> SkTypeface_Factory::FromFilenameAndTtcIndex(
     const std::string& filename,
     int ttc_index) {
 #if !defined(OS_WIN) && !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && \
-    !defined(OS_MAC)
+    !defined(OS_MAC) && !defined(OS_OHOS)
   return SkTypeface::MakeFromFile(filename.c_str(), ttc_index);
 #else
   NOTREACHED();
diff --git a/third_party/blink/renderer/platform/scheduler/common/tracing_helper.h b/third_party/blink/renderer/platform/scheduler/common/tracing_helper.h
index ba5136874e..a4f2506d3f 100644
--- a/third_party/blink/renderer/platform/scheduler/common/tracing_helper.h
+++ b/third_party/blink/renderer/platform/scheduler/common/tracing_helper.h
@@ -223,7 +223,7 @@ class TraceableState : public TraceableVariable, private StateTracer<category> {
   const ConverterFuncPtr converter_;
   T state_;
 
-  DISALLOW_COPY(TraceableState);
+  DISALLOW_COPY_BASE(TraceableState);
 };
 
 template <const char* category, typename TypedValue>
@@ -407,7 +407,7 @@ class TraceableCounter : public TraceableVariable {
   const ConverterFuncPtr converter_;
 
   T value_;
-  DISALLOW_COPY(TraceableCounter);
+  DISALLOW_COPY_BASE(TraceableCounter);
 };
 
 // Add operators when it's needed.
diff --git a/third_party/blink/renderer/platform/wtf/stack_util.cc b/third_party/blink/renderer/platform/wtf/stack_util.cc
index 71b901f404..484bde86b1 100644
--- a/third_party/blink/renderer/platform/wtf/stack_util.cc
+++ b/third_party/blink/renderer/platform/wtf/stack_util.cc
@@ -30,7 +30,7 @@ size_t GetUnderestimatedStackSize() {
 // correctly for the main thread.
 
 #elif defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
   // pthread_getattr_np() can fail if the thread is not invoked by
   // pthread_create() (e.g., the main thread of blink_unittests).
   // If so, a conservative size estimate is returned.
@@ -98,7 +98,7 @@ return Threading::ThreadStackSize();
 
 void* GetStackStart() {
 #if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
   pthread_attr_t attr;
   int error;
 #if defined(OS_FREEBSD)
diff --git a/third_party/breakpad/BUILD.gn b/third_party/breakpad/BUILD.gn
index d173445bcd..e545f029aa 100644
--- a/third_party/breakpad/BUILD.gn
+++ b/third_party/breakpad/BUILD.gn
@@ -16,7 +16,7 @@ config("tools_config") {
     "breakpad/src",
     "breakpad/src/third_party",
   ]
-  if (is_android) {
+  if (is_android || is_ohos) {
     defines = [ "__ANDROID__" ]
   }
   if (is_clang) {
@@ -31,14 +31,14 @@ config("internal_config") {
     # This is needed for GTMLogger to work correctly.
     defines += [ "DEBUG" ]
   }
-  if (is_android) {
+  if (is_android || is_ohos) {
     defines += [ "__ANDROID__" ]
   }
 }
 
 config("client_config") {
   include_dirs = [ "breakpad/src" ]
-  if (is_android) {
+  if (is_android || is_ohos && !use_musl) {
     include_dirs += [ "breakpad/src/common/android/include" ]
   }
   if (is_chromeos_ash) {
@@ -484,7 +484,7 @@ if (is_mac) {
   }
 }
 
-if (is_linux || is_chromeos || is_android) {
+if (is_linux || is_chromeos || is_android || is_ohos) {
   if (current_toolchain == host_toolchain) {
     executable("symupload") {
       sources = [
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
index ca353c4099..0452da47e7 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
@@ -234,7 +234,7 @@ ExceptionHandler::ExceptionHandler(const MinidumpDescriptor& descriptor,
       !minidump_descriptor_.IsMicrodumpOnConsole())
     minidump_descriptor_.UpdatePath();
 
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
   if (minidump_descriptor_.IsMicrodumpOnConsole())
     logger::initializeCrashLogWriter();
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/log/log.cc b/third_party/breakpad/breakpad/src/client/linux/log/log.cc
index 318794095b..c96c1fc5c2 100644
--- a/third_party/breakpad/breakpad/src/client/linux/log/log.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/log/log.cc
@@ -29,7 +29,7 @@
 
 #include "client/linux/log/log.h"
 
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
 #include <android/log.h>
 #include <dlfcn.h>
 #else
@@ -38,7 +38,7 @@
 
 namespace logger {
 
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
 namespace {
 
 // __android_log_buf_write() is not exported in the NDK and is being used by
@@ -74,7 +74,7 @@ int writeToCrashLog(const char* buf) {
 #endif
 
 int write(const char* buf, size_t nbytes) {
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
   return __android_log_write(ANDROID_LOG_WARN, kAndroidLogTag, buf);
 #else
   return sys_write(2, buf, nbytes);
diff --git a/third_party/breakpad/breakpad/src/client/linux/log/log.h b/third_party/breakpad/breakpad/src/client/linux/log/log.h
index f94bbd5fb7..0d353959e3 100644
--- a/third_party/breakpad/breakpad/src/client/linux/log/log.h
+++ b/third_party/breakpad/breakpad/src/client/linux/log/log.h
@@ -39,7 +39,7 @@ int write(const char* buf, size_t nbytes);
 // In the case of Android the log can be written to the default system log
 // (default behavior of write() above, or to the crash log (see
 // writeToCrashLog() below).
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
 
 // The logger must be initialized in a non-compromised context.
 void initializeCrashLogWriter();
diff --git a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
index fa3c1713a5..4a8e616d87 100644
--- a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
@@ -198,7 +198,7 @@ class MicrodumpWriter {
 
   // Writes one line to the system log.
   void LogLine(const char* msg) {
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
     logger::writeToCrashLog(msg);
 #else
     logger::write(msg, my_strlen(msg));
diff --git a/third_party/crashpad/crashpad/BUILD.gn b/third_party/crashpad/crashpad/BUILD.gn
index 264c10d81e..1326043821 100644
--- a/third_party/crashpad/crashpad/BUILD.gn
+++ b/third_party/crashpad/crashpad/BUILD.gn
@@ -43,7 +43,6 @@ if (crashpad_is_in_chromium || crashpad_is_in_fuchsia) {
       deps += [ "//build/config/sanitizers:suppress-lsan.DO-NOT-USE-THIS" ]
     }
     if (crashpad_is_android) {
-      use_raw_android_executable = true
 
       copy("crashpad_test_data") {
         testonly = true
@@ -58,11 +57,14 @@ if (crashpad_is_in_chromium || crashpad_is_in_fuchsia) {
 
       deps += [ ":crashpad_test_data" ]
 
+      if (!is_ohos) {
+      use_raw_android_executable = true
       extra_dist_files = [
         "$root_out_dir/crashpad_handler",
         "$root_out_dir/crashpad_test_test_multiprocess_exec_test_child",
         "$root_out_dir/crashpad_test_data",
       ]
+      }
     }
   }
 
diff --git a/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni b/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
index 51b99c3b93..4e3ec42ff0 100644
--- a/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
+++ b/third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
@@ -39,7 +39,7 @@ if (crashpad_is_in_chromium) {
   crashpad_is_ios = is_ios
   crashpad_is_win = is_win
   crashpad_is_linux = is_linux || is_chromeos
-  crashpad_is_android = is_android
+  crashpad_is_android = is_android || is_ohos
   crashpad_is_fuchsia = is_fuchsia
 
   crashpad_is_posix = is_posix
@@ -68,6 +68,11 @@ if (crashpad_is_in_chromium) {
   crashpad_is_clang = mini_chromium_is_clang
 }
 
+if (use_musl) {
+  crashpad_is_android = false
+  crashpad_is_linux = true
+}
+
 template("crashpad_executable") {
   executable(target_name) {
     forward_variables_from(invoker,
diff --git a/third_party/crashpad/crashpad/client/crashpad_client.h b/third_party/crashpad/crashpad/client/crashpad_client.h
index cbe05516f2..8cd2eb04ac 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client.h
+++ b/third_party/crashpad/crashpad/client/crashpad_client.h
@@ -34,7 +34,7 @@
 #elif defined(OS_WIN)
 #include <windows.h>
 #include "util/win/scoped_handle.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include <signal.h>
 #include <ucontext.h>
 #endif
@@ -122,7 +122,7 @@ class CrashpadClient {
                     bool asynchronous_start,
                     const std::vector<base::FilePath>& attachments = {});
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || DOXYGEN
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS) || DOXYGEN
   //! \brief Retrieve the socket and process ID for the handler.
   //!
   //! `StartHandler()` must have successfully been called before calling this
@@ -338,7 +338,7 @@ class CrashpadClient {
       int socket);
 #endif  // OS_ANDROID || DOXYGEN
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_CHROMEOS) || DOXYGEN
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_CHROMEOS) || defined(OS_OHOS) || DOXYGEN
   //! \brief Installs a signal handler to launch a handler process in reponse to
   //!     a crash.
   //!
@@ -688,7 +688,7 @@ class CrashpadClient {
 #elif defined(OS_WIN)
   std::wstring ipc_pipe_;
   ScopedKernelHANDLE handler_start_thread_;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   std::set<int> unhandled_signals_;
 #endif  // OS_APPLE
 
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
index cf94e6bd31..295770d473 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
@@ -412,7 +412,7 @@ bool CrashpadClient::StartHandler(
       std::move(client_sock), handler_pid, &unhandled_signals_);
 }
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 // static
 bool CrashpadClient::GetHandlerSocket(int* sock, pid_t* pid) {
   auto signal_handler = RequestCrashDumpHandler::Get();
diff --git a/third_party/crashpad/crashpad/client/crashpad_info.cc b/third_party/crashpad/crashpad/client/crashpad_info.cc
index 929c0df11f..b0a4bff325 100644
--- a/third_party/crashpad/crashpad/client/crashpad_info.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_info.cc
@@ -95,7 +95,7 @@ extern "C" int* CRASHPAD_NOTE_REFERENCE;
 // static
 CrashpadInfo* CrashpadInfo::GetCrashpadInfo() {
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
   // This otherwise-unused reference is used so that any module that
   // references GetCrashpadInfo() will also include the note in the
   // .note.crashpad.info section. That note in turn contains the address of
diff --git a/third_party/crashpad/crashpad/client/simulate_crash.h b/third_party/crashpad/crashpad/client/simulate_crash.h
index d01e1682d7..d3c2298f31 100644
--- a/third_party/crashpad/crashpad/client/simulate_crash.h
+++ b/third_party/crashpad/crashpad/client/simulate_crash.h
@@ -23,7 +23,7 @@
 #include "client/simulate_crash_ios.h"
 #elif defined(OS_WIN)
 #include "client/simulate_crash_win.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include "client/simulate_crash_linux.h"
 #endif
 
diff --git a/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h b/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
index f8be372cc6..292f782b78 100644
--- a/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
+++ b/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
@@ -17,7 +17,9 @@
 
 #include_next <sys/ptrace.h>
 
+#if !defined(__MUSL__)
 #include <sys/cdefs.h>
+#endif
 
 // https://sourceware.org/bugzilla/show_bug.cgi?id=22433
 #if !defined(PTRACE_GET_THREAD_AREA) && !defined(PT_GET_THREAD_AREA) && \
diff --git a/third_party/crashpad/crashpad/handler/handler_main.cc b/third_party/crashpad/crashpad/handler/handler_main.cc
index f5a8727f7e..3e04d2ebb3 100644
--- a/third_party/crashpad/crashpad/handler/handler_main.cc
+++ b/third_party/crashpad/crashpad/handler/handler_main.cc
@@ -62,7 +62,7 @@
 #include "handler/linux/cros_crash_report_exception_handler.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include <unistd.h>
 
 #include "handler/linux/crash_report_exception_handler.h"
@@ -99,7 +99,7 @@ namespace crashpad {
 namespace {
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_OHOS)
 #define ATTACHMENTS_SUPPORTED 1
 #endif  // OS_WIN || OS_LINUX || OS_CHROMEOS || OS_ANDROID
 
@@ -146,7 +146,7 @@ void Usage(const base::FilePath& me) {
 "      --no-periodic-tasks     don't scan for new reports or prune the database\n"
 "      --no-rate-limit         don't rate limit crash uploads\n"
 "      --no-upload-gzip        don't use gzip compression when uploading\n"
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 "      --no-write-minidump-to-database\n"
 "                              don't write minidump to database\n"
 #endif  // OS_ANDROID
@@ -157,7 +157,7 @@ void Usage(const base::FilePath& me) {
 "      --reset-own-crash-exception-port-to-system-default\n"
 "                              reset the server's exception handler to default\n"
 #endif  // OS_APPLE
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 "      --sanitization-information=SANITIZATION_INFORMATION_ADDRESS\n"
 "                              the address of a SanitizationInformation struct.\n"
 "      --shared-client-connection the file descriptor provided by\n"
@@ -180,7 +180,7 @@ void Usage(const base::FilePath& me) {
 "                              crash_reporter, thus skipping metrics consent\n"
 "                              checks\n"
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 "      --write-minidump-to-log write minidump to log\n"
 #endif  // OS_ANDROID
 "      --help                  display this help and exit\n"
@@ -200,12 +200,12 @@ struct Options {
   std::string mach_service;
   int handshake_fd;
   bool reset_own_crash_exception_port_to_system_default;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   VMAddress exception_information_address;
   VMAddress sanitization_information_address;
   int initial_client_fd;
   bool shared_client_connection;
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   bool write_minidump_to_log;
   bool write_minidump_to_database;
 #endif  // OS_ANDROID
@@ -287,7 +287,7 @@ class CallMetricsRecordNormalExit {
 };
 
 #if defined(OS_APPLE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-  defined(OS_ANDROID)
+  defined(OS_ANDROID) || defined(OS_OHOS)
 
 void HandleCrashSignal(int sig, siginfo_t* siginfo, void* context) {
   MetricsRecordExit(Metrics::LifetimeMilestone::kCrashed);
@@ -466,7 +466,7 @@ void MonitorSelf(const Options& options) {
   // instance of crashpad_handler to be writing metrics at a time, and it should
   // be the primary instance.
   CrashpadClient crashpad_client;
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   if (!crashpad_client.StartHandlerAtCrash(executable_path,
                                            options.database,
                                            base::FilePath(),
@@ -546,7 +546,7 @@ int HandlerMain(int argc,
     kOptionLastChar = 255,
     kOptionAnnotation,
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_OHOS)
     kOptionAttachment,
 #endif  // OS_WIN || OS_LINUX
     kOptionDatabase,
@@ -556,7 +556,7 @@ int HandlerMain(int argc,
 #if defined(OS_WIN)
     kOptionInitialClientData,
 #endif  // OS_WIN
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     kOptionInitialClientFD,
 #endif  // OS_ANDROID || OS_LINUX || OS_CHROMEOS
 #if defined(OS_APPLE)
@@ -570,7 +570,7 @@ int HandlerMain(int argc,
     kOptionNoPeriodicTasks,
     kOptionNoRateLimit,
     kOptionNoUploadGzip,
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
     kOptionNoWriteMinidumpToDatabase,
 #endif  // OS_ANDROID
 #if defined(OS_WIN)
@@ -579,7 +579,7 @@ int HandlerMain(int argc,
 #if defined(OS_APPLE)
     kOptionResetOwnCrashExceptionPortToSystemDefault,
 #endif  // OS_APPLE
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
     kOptionSanitizationInformation,
     kOptionSharedClientConnection,
     kOptionTraceParentWithException,
@@ -593,7 +593,7 @@ int HandlerMain(int argc,
     kOptionMinidumpDirForTests,
     kOptionAlwaysAllowFeedback,
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
     kOptionWriteMinidumpToLog,
 #endif  // OS_ANDROID
 
@@ -617,7 +617,7 @@ int HandlerMain(int argc,
      nullptr,
      kOptionInitialClientData},
 #endif  // OS_APPLE
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     {"initial-client-fd", required_argument, nullptr, kOptionInitialClientFD},
 #endif  // OS_ANDROID || OS_LINUX || OS_CHROMEOS
 #if defined(OS_APPLE)
@@ -640,7 +640,7 @@ int HandlerMain(int argc,
     {"no-periodic-tasks", no_argument, nullptr, kOptionNoPeriodicTasks},
     {"no-rate-limit", no_argument, nullptr, kOptionNoRateLimit},
     {"no-upload-gzip", no_argument, nullptr, kOptionNoUploadGzip},
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
     {"no-write-minidump-to-database",
      no_argument,
      nullptr,
@@ -655,7 +655,7 @@ int HandlerMain(int argc,
      nullptr,
      kOptionResetOwnCrashExceptionPortToSystemDefault},
 #endif  // OS_APPLE
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
     {"sanitization-information",
      required_argument,
      nullptr,
@@ -684,7 +684,7 @@ int HandlerMain(int argc,
       nullptr,
       kOptionAlwaysAllowFeedback},
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
     {"write-minidump-to-log", no_argument, nullptr, kOptionWriteMinidumpToLog},
 #endif  // OS_ANDROID
     {"help", no_argument, nullptr, kOptionHelp},
@@ -700,13 +700,13 @@ int HandlerMain(int argc,
   options.handshake_fd = -1;
 #endif
   options.identify_client_via_url = true;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   options.initial_client_fd = kInvalidFileHandle;
 #endif
   options.periodic_tasks = true;
   options.rate_limit = true;
   options.upload_gzip = true;
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   options.write_minidump_to_database = true;
 #endif
 
@@ -756,7 +756,7 @@ int HandlerMain(int argc,
         break;
       }
 #endif  // OS_WIN
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
       case kOptionInitialClientFD: {
         if (!base::StringToInt(optarg, &options.initial_client_fd)) {
           ToolSupport::UsageHint(me, "failed to parse --initial-client-fd");
@@ -802,7 +802,7 @@ int HandlerMain(int argc,
         options.upload_gzip = false;
         break;
       }
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       case kOptionNoWriteMinidumpToDatabase: {
         options.write_minidump_to_database = false;
         break;
@@ -820,7 +820,7 @@ int HandlerMain(int argc,
         break;
       }
 #endif  // OS_APPLE
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
       case kOptionSanitizationInformation: {
         if (!StringToNumber(optarg,
                             &options.sanitization_information_address)) {
@@ -883,7 +883,7 @@ int HandlerMain(int argc,
         break;
       }
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       case kOptionWriteMinidumpToLog: {
         options.write_minidump_to_log = true;
         break;
@@ -929,7 +929,7 @@ int HandlerMain(int argc,
         me, "--initial-client-data and --pipe-name are incompatible");
     return ExitFailure();
   }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   if (!options.exception_information_address &&
       options.initial_client_fd == kInvalidFileHandle) {
     ToolSupport::UsageHint(
@@ -949,7 +949,7 @@ int HandlerMain(int argc,
         me, "--shared-client-connection requires --initial-client-fd");
     return ExitFailure();
   }
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
   if (!options.write_minidump_to_log && !options.write_minidump_to_database) {
     ToolSupport::UsageHint(me,
                            "--no_write_minidump_to_database is required to use "
@@ -1028,7 +1028,7 @@ int HandlerMain(int argc,
     upload_thread.Get()->Start();
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   std::unique_ptr<ExceptionHandlerServer::Delegate> exception_handler;
 #else
   std::unique_ptr<CrashReportExceptionHandler> exception_handler;
@@ -1068,7 +1068,7 @@ int HandlerMain(int argc,
 #if defined(ATTACHMENTS_SUPPORTED)
       &options.attachments,
 #endif  // ATTACHMENTS_SUPPORTED
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
       options.write_minidump_to_database,
       options.write_minidump_to_log,
 #endif  // OS_ANDROID
@@ -1079,7 +1079,7 @@ int HandlerMain(int argc,
       user_stream_sources);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(IS_CHROMEOS_LACROS)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   if (options.exception_information_address) {
     ExceptionHandlerProtocol::ClientInformation info;
     info.exception_information_address = options.exception_information_address;
@@ -1152,7 +1152,7 @@ int HandlerMain(int argc,
   if (!options.pipe_name.empty()) {
     exception_handler_server.SetPipeName(base::UTF8ToWide(options.pipe_name));
   }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   ExceptionHandlerServer exception_handler_server;
 #endif  // OS_APPLE
 
@@ -1174,7 +1174,7 @@ int HandlerMain(int argc,
     exception_handler_server.InitializeWithInheritedDataForInitialClient(
         options.initial_client_data, exception_handler.get());
   }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   if (options.initial_client_fd == kInvalidFileHandle ||
       !exception_handler_server.InitializeWithClient(
           ScopedFileHandle(options.initial_client_fd),
diff --git a/third_party/crashpad/crashpad/handler/handler_main.h b/third_party/crashpad/crashpad/handler/handler_main.h
index 252654118a..483e4108ed 100644
--- a/third_party/crashpad/crashpad/handler/handler_main.h
+++ b/third_party/crashpad/crashpad/handler/handler_main.h
@@ -35,7 +35,7 @@ int HandlerMain(int argc,
                 char* argv[],
                 const UserStreamDataSources* user_stream_sources);
 
-#if defined(OS_ANDROID)
+#if defined(OS_ANDROID) || defined(OS_OHOS)
 //! \brief The `main()` entry point for Android libraries.
 //!
 //! This symbol is the entry point for crashpad when it is dynamically loaded
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 0974e3ddf5..dbc5dabd7f 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -119,6 +119,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kOS[] = "win";
 #elif defined(OS_FUCHSIA)
   static constexpr char kOS[] = "fuchsia";
+#elif defined(OS_OHOS)
+  static constexpr char kOS[] = "ohos";
 #else
 #error define kOS for this operating system
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/crashpad_types/crashpad_info_reader.cc b/third_party/crashpad/crashpad/snapshot/crashpad_types/crashpad_info_reader.cc
index cedab59a72..195374c2d4 100644
--- a/third_party/crashpad/crashpad/snapshot/crashpad_types/crashpad_info_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/crashpad_types/crashpad_info_reader.cc
@@ -22,7 +22,7 @@
 
 #if defined(OS_WIN)
 #include "util/win/traits.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include "util/linux/traits.h"
 #elif defined(OS_FUCHSIA)
 #include "util/fuchsia/traits.h"
diff --git a/third_party/crashpad/crashpad/util/file/file_io.h b/third_party/crashpad/crashpad/util/file/file_io.h
index 1f502ad4b1..1dd6eb37d0 100644
--- a/third_party/crashpad/crashpad/util/file/file_io.h
+++ b/third_party/crashpad/crashpad/util/file/file_io.h
@@ -398,7 +398,7 @@ FileHandle LoggingOpenFileForWrite(const base::FilePath& path,
                                    FileWriteMode mode,
                                    FilePermissions permissions);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
 //! \brief Opens an in-memory file for input and output.
 //!
 //! This function first attempts to open the file with `memfd_create()`. If
diff --git a/third_party/crashpad/crashpad/util/file/file_io_posix.cc b/third_party/crashpad/crashpad/util/file/file_io_posix.cc
index 2baa8114fd..6a736404e7 100644
--- a/third_party/crashpad/crashpad/util/file/file_io_posix.cc
+++ b/third_party/crashpad/crashpad/util/file/file_io_posix.cc
@@ -153,7 +153,7 @@ FileHandle LoggingOpenFileForWrite(const base::FilePath& path,
   return fd;
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
 FileHandle LoggingOpenMemoryFileForReadAndWrite(const base::FilePath& name) {
   DCHECK(name.value().find('/') == std::string::npos);
 
diff --git a/third_party/crashpad/crashpad/util/file/file_writer.cc b/third_party/crashpad/crashpad/util/file/file_writer.cc
index 73fe708796..6343fe0919 100644
--- a/third_party/crashpad/crashpad/util/file/file_writer.cc
+++ b/third_party/crashpad/crashpad/util/file/file_writer.cc
@@ -171,7 +171,7 @@ bool FileWriter::Open(const base::FilePath& path,
   return true;
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
 bool FileWriter::OpenMemfd(const base::FilePath& path) {
   CHECK(!file_.is_valid());
   file_.reset(LoggingOpenMemoryFileForReadAndWrite(path));
diff --git a/third_party/crashpad/crashpad/util/file/file_writer.h b/third_party/crashpad/crashpad/util/file/file_writer.h
index 987c0f59d5..f27e9abd68 100644
--- a/third_party/crashpad/crashpad/util/file/file_writer.h
+++ b/third_party/crashpad/crashpad/util/file/file_writer.h
@@ -131,7 +131,7 @@ class FileWriter : public FileWriterInterface {
             FileWriteMode write_mode,
             FilePermissions permissions);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
   //! \brief Wraps LoggingOpenMemoryFileForWrite().
   //!
   //! \return `true` if the operation succeeded, `false` if it failed, with an
diff --git a/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.cc b/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.cc
index 27f180c6e1..4c2543d991 100644
--- a/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.cc
+++ b/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.cc
@@ -19,7 +19,7 @@ namespace crashpad {
 ExceptionHandlerProtocol::ClientInformation::ClientInformation()
     : exception_information_address(0),
       sanitization_information_address(0)
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
       , crash_loop_before_time(0)
 #endif  // OS_LINUX || OS_CHROMEOS
 {}
diff --git a/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.h b/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.h
index 60b0b1b7ed..1efd79b495 100644
--- a/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.h
+++ b/third_party/crashpad/crashpad/util/linux/exception_handler_protocol.h
@@ -52,7 +52,7 @@ class ExceptionHandlerProtocol {
     //!     SanitizationInformation struct, or 0 if there is no such struct.
     VMAddress sanitization_information_address;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
     //! \brief Indicates that the client is likely in a crash loop if a crash
     //!     occurs before this timestamp. This value is only used by ChromeOS's
     //!     `/sbin/crash_reporter`.
diff --git a/third_party/crashpad/crashpad/util/linux/thread_info.h b/third_party/crashpad/crashpad/util/linux/thread_info.h
index 5b55c24a76..c2ad0407ae 100644
--- a/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -273,7 +273,7 @@ union FloatContext {
                 "Size mismatch");
 #elif defined(ARCH_CPU_ARMEL)
   static_assert(sizeof(f32_t::fpregs) == sizeof(user_fpregs), "Size mismatch");
-#if !defined(__GLIBC__)
+#if !defined(__GLIBC__) && !defined(__MUSL__)
   static_assert(sizeof(f32_t::vfp) == sizeof(user_vfp), "Size mismatch");
 #endif
 #elif defined(ARCH_CPU_ARM64)
diff --git a/third_party/crashpad/crashpad/util/misc/address_types.h b/third_party/crashpad/crashpad/util/misc/address_types.h
index 14942bd8ea..31b83e821c 100644
--- a/third_party/crashpad/crashpad/util/misc/address_types.h
+++ b/third_party/crashpad/crashpad/util/misc/address_types.h
@@ -25,7 +25,7 @@
 #include <mach/mach_types.h>
 #elif defined(OS_WIN)
 #include "util/win/address_types.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include "util/linux/address_types.h"
 #elif defined(OS_FUCHSIA)
 #include <zircon/types.h>
@@ -55,7 +55,7 @@ using VMSize = mach_vm_size_t;
 using VMAddress = WinVMAddress;
 using VMSize = WinVMSize;
 
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 
 using VMAddress = LinuxVMAddress;
 using VMSize = LinuxVMSize;
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context.h b/third_party/crashpad/crashpad/util/misc/capture_context.h
index d21a24f19f..2456a937fd 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context.h
+++ b/third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -21,7 +21,7 @@
 #include <mach/mach.h>
 #elif defined(OS_WIN)
 #include <windows.h>
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include <ucontext.h>
 #elif defined(OS_FUCHSIA)
 #include <signal.h>
@@ -38,7 +38,7 @@ using NativeCPUContext = arm_unified_thread_state;
 #elif defined(OS_WIN)
 using NativeCPUContext = CONTEXT;
 #elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_OHOS)
 using NativeCPUContext = ucontext_t;
 #endif  // OS_APPLE
 
diff --git a/third_party/crashpad/crashpad/util/misc/metrics.cc b/third_party/crashpad/crashpad/util/misc/metrics.cc
index 4b87f107df..07569de6cb 100644
--- a/third_party/crashpad/crashpad/util/misc/metrics.cc
+++ b/third_party/crashpad/crashpad/util/misc/metrics.cc
@@ -29,6 +29,8 @@
 #define METRICS_OS_NAME "Linux"
 #elif defined(OS_FUCHSIA)
 #define METRICS_OS_NAME "Fuchsia"
+#elif defined(OS_OHOS)
+#define METRICS_OS_NAME "Ohos"
 #endif
 
 namespace crashpad {
diff --git a/third_party/crashpad/crashpad/util/misc/time.h b/third_party/crashpad/crashpad/util/misc/time.h
index dc992bdcce..bba90ee10b 100644
--- a/third_party/crashpad/crashpad/util/misc/time.h
+++ b/third_party/crashpad/crashpad/util/misc/time.h
@@ -69,7 +69,7 @@ void GetTimeOfDay(timeval* tv);
 
 #endif  // OS_WIN
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || DOXYGEN
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || DOXYGEN || defined(OS_OHOS)
 //! \brief Get the kernel boot time. Subsequent calls to this function may
 //!     return different results due to the system clock being changed or
 //!     imprecision in measuring the boot time.
diff --git a/third_party/crashpad/crashpad/util/misc/uuid.cc b/third_party/crashpad/crashpad/util/misc/uuid.cc
index 32ffea5259..432fac3f1c 100644
--- a/third_party/crashpad/crashpad/util/misc/uuid.cc
+++ b/third_party/crashpad/crashpad/util/misc/uuid.cc
@@ -96,7 +96,7 @@ bool UUID::InitializeWithNew() {
   InitializeFromBytes(uuid);
   return true;
 #elif defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_ANDROID) || defined(OS_FUCHSIA)
+    defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   // Linux, Android, and Fuchsia do not provide a UUID generator in a
   // widely-available system library. On Linux and Android, uuid_generate()
   // from libuuid is not available everywhere.
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_socket.cc b/third_party/crashpad/crashpad/util/net/http_transport_socket.cc
index ba9c25d024..45acb390e7 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_socket.cc
+++ b/third_party/crashpad/crashpad/util/net/http_transport_socket.cc
@@ -123,7 +123,7 @@ class SSLStream : public Stream {
         return false;
       }
     } else {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(__MUSL__)
       if (SSL_CTX_load_verify_locations(
               ctx_.get(), nullptr, "/etc/ssl/certs") <= 0) {
         LOG(ERROR) << "SSL_CTX_load_verify_locations";
diff --git a/third_party/crashpad/crashpad/util/numeric/checked_address_range.cc b/third_party/crashpad/crashpad/util/numeric/checked_address_range.cc
index 4ba7ff3900..cdaae7e800 100644
--- a/third_party/crashpad/crashpad/util/numeric/checked_address_range.cc
+++ b/third_party/crashpad/crashpad/util/numeric/checked_address_range.cc
@@ -22,7 +22,7 @@
 #include <mach/mach.h>
 #elif defined(OS_WIN)
 #include "util/win/address_types.h"
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include "util/linux/address_types.h"
 #elif defined(OS_FUCHSIA)
 #include <zircon/types.h>
@@ -130,7 +130,7 @@ std::string CheckedAddressRangeGeneric<ValueType, SizeType>::AsString() const {
 template class CheckedAddressRangeGeneric<mach_vm_address_t, mach_vm_size_t>;
 #elif defined(OS_WIN)
 template class CheckedAddressRangeGeneric<WinVMAddress, WinVMSize>;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 template class CheckedAddressRangeGeneric<LinuxVMAddress, LinuxVMSize>;
 #elif defined(OS_FUCHSIA)
 template class CheckedAddressRangeGeneric<zx_vaddr_t, size_t>;
diff --git a/third_party/crashpad/crashpad/util/posix/close_multiple.cc b/third_party/crashpad/crashpad/util/posix/close_multiple.cc
index 0c078329b7..f4c68b5536 100644
--- a/third_party/crashpad/crashpad/util/posix/close_multiple.cc
+++ b/third_party/crashpad/crashpad/util/posix/close_multiple.cc
@@ -74,7 +74,7 @@ void CloseNowOrOnExec(int fd, bool ebadf_ok) {
 bool CloseMultipleNowOrOnExecUsingFDDir(int min_fd, int preserve_fd) {
 #if defined(OS_APPLE)
   static constexpr char kFDDir[] = "/dev/fd";
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   static constexpr char kFDDir[] = "/proc/self/fd";
 #endif
 
@@ -128,14 +128,14 @@ void CloseMultipleNowOrOnExec(int fd, int preserve_fd) {
   // bionic/libc/bionic/ndk_cruft.cpp getdtablesize().
   int max_fd = implicit_cast<int>(sysconf(_SC_OPEN_MAX));
 
-#if !defined(OS_ANDROID)
+#if !defined(OS_ANDROID) && !defined(OS_OHOS)
   // getdtablesize() was removed effective Android 5.0.0 (API 21). Since it
   // returns the same thing as the sysconf() above, just skip it. See
   // https://android.googlesource.com/platform/bionic/+/462abab12b074c62c0999859e65d5a32ebb41951.
   max_fd = std::max(max_fd, getdtablesize());
 #endif
 
-#if !(defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)) || \
+#if !(defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)) || \
     defined(OPEN_MAX)
   // Linux does not provide OPEN_MAX. See
   // https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/include/linux/limits.h?id=77293034696e3e0b6c8b8fc1f96be091104b3d2b.
@@ -163,7 +163,7 @@ void CloseMultipleNowOrOnExec(int fd, int preserve_fd) {
   } else {
     PLOG(WARNING) << "sysctl";
   }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   // See linux-4.4.27/fs/file.c sysctl_nr_open, referenced by kernel/sys.c
   // do_prlimit() and kernel/sysctl.c fs_table. Inability to open this file is
   // not considered an error, because /proc may not be available or usable.
diff --git a/third_party/crashpad/crashpad/util/posix/drop_privileges.cc b/third_party/crashpad/crashpad/util/posix/drop_privileges.cc
index 75650d5a68..9d94f21ebc 100644
--- a/third_party/crashpad/crashpad/util/posix/drop_privileges.cc
+++ b/third_party/crashpad/crashpad/util/posix/drop_privileges.cc
@@ -73,7 +73,7 @@ void DropPrivileges() {
       CHECK_EQ(setegid(egid), -1);
     }
   }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   PCHECK(setresgid(gid, gid, gid) == 0) << "setresgid";
   PCHECK(setresuid(uid, uid, uid) == 0) << "setresuid";
 
diff --git a/third_party/crashpad/crashpad/util/posix/process_info.h b/third_party/crashpad/crashpad/util/posix/process_info.h
index d144c04b55..b6b0a7e405 100644
--- a/third_party/crashpad/crashpad/util/posix/process_info.h
+++ b/third_party/crashpad/crashpad/util/posix/process_info.h
@@ -33,7 +33,7 @@
 #include <sys/sysctl.h>
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #include "util/linux/ptrace_connection.h"
 #endif
 
@@ -44,7 +44,7 @@ class ProcessInfo {
   ProcessInfo();
   ~ProcessInfo();
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || DOXYGEN
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || DOXYGEN || defined(OS_OHOS)
   //! \brief Initializes this object with information about the process whose ID
   //!     is \a pid using a PtraceConnection \a connection.
   //!
@@ -168,7 +168,7 @@ class ProcessInfo {
  private:
 #if defined(OS_APPLE)
   kinfo_proc kern_proc_info_;
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
   // Some members are marked mutable so that they can be lazily initialized by
   // const methods. These are always InitializationState-protected so that
   // multiple successive calls will always produce the same return value and out
diff --git a/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc b/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
index c6e0fec77f..116dc723ac 100644
--- a/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
+++ b/third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
@@ -64,7 +64,7 @@ constexpr const char* kSignalNames[] = {
     "INFO",
     "USR1",
     "USR2",
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 #if defined(ARCH_CPU_MIPS_FAMILY)
     "HUP",
     "INT",
@@ -135,7 +135,7 @@ constexpr const char* kSignalNames[] = {
 #endif  // defined(ARCH_CPU_MIPS_FAMILY)
 #endif
 };
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_OHOS)
 // NSIG is 64 to account for real-time signals.
 static_assert(base::size(kSignalNames) == 32, "kSignalNames length");
 #else
diff --git a/third_party/dawn/scripts/dawn_features.gni b/third_party/dawn/scripts/dawn_features.gni
index 8477480c29..d9b6d7f367 100644
--- a/third_party/dawn/scripts/dawn_features.gni
+++ b/third_party/dawn/scripts/dawn_features.gni
@@ -63,7 +63,7 @@ declare_args() {
 
   # Enables the compilation of Dawn's Vulkan backend
   dawn_enable_vulkan = is_linux || is_chromeos || is_win || is_fuchsia ||
-                       is_android || dawn_use_swiftshader
+                       is_android || dawn_use_swiftshader || is_ohos
 
   # Enable support WGSL for shaders.
   dawn_enable_wgsl = true
diff --git a/third_party/dawn/src/common/BUILD.gn b/third_party/dawn/src/common/BUILD.gn
index a401a72de3..2293961a8f 100644
--- a/third_party/dawn/src/common/BUILD.gn
+++ b/third_party/dawn/src/common/BUILD.gn
@@ -148,7 +148,7 @@ config("dawn_internal") {
 # This GN file is discovered by all Chromium builds, but common doesn't support
 # all of Chromium's OSes so we explicitly make the target visible only on
 # systems we know Dawn is able to compile on.
-if (is_win || is_linux || is_chromeos || is_mac || is_fuchsia || is_android) {
+if (is_win || is_linux || is_chromeos || is_mac || is_fuchsia || is_android || is_ohos) {
   static_library("common") {
     sources = [
       "Alloc.h",
diff --git a/third_party/ffmpeg/BUILD.gn b/third_party/ffmpeg/BUILD.gn
index f7f34ea414..cf93c07ded 100755
--- a/third_party/ffmpeg/BUILD.gn
+++ b/third_party/ffmpeg/BUILD.gn
@@ -328,7 +328,7 @@ target(link_target_type, "ffmpeg_internal") {
       "-L",
       rebase_path(target_gen_dir, root_build_dir),
     ]
-    if (!is_android && !is_fuchsia) {
+    if (!is_android && !is_fuchsia && !is_ohos) {
       # OS=android requires that both -lz and -lm occur after
       # -lc++_shared on the link command line. Android link rules
       # already include -lm, and we get -lz as a transitive dependency
diff --git a/third_party/ffmpeg/ffmpeg_generated.gni b/third_party/ffmpeg/ffmpeg_generated.gni
index 88f513b32c..394efcabd9 100644
--- a/third_party/ffmpeg/ffmpeg_generated.gni
+++ b/third_party/ffmpeg/ffmpeg_generated.gni
@@ -12,9 +12,9 @@ ffmpeg_c_sources = []
 ffmpeg_gas_sources = []
 ffmpeg_asm_sources = []
 
-use_linux_config = is_linux || is_chromeos || is_fuchsia
+use_linux_config = is_linux || is_chromeos || is_fuchsia || use_musl
 
-if ((is_android && current_cpu == "arm" && arm_use_neon) || (is_android && current_cpu == "arm64") || (is_android && current_cpu == "x64") || (is_android && current_cpu == "x86") || (is_mac) || (is_win) || (use_linux_config)) {
+if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon) || (is_android && current_cpu == "arm64") || (is_android && current_cpu == "x64") || (is_android && current_cpu == "x86") || (is_mac) || (is_win) || (use_linux_config)) {
   ffmpeg_c_sources += [
     "libavcodec/ac3_parser.c",
     "libavcodec/ac3tab.c",
@@ -194,7 +194,7 @@ if ((is_android && current_cpu == "arm" && arm_use_neon) || (is_android && curre
   ]
 }
 
-if ((is_mac) || (is_win) || (use_linux_config)) {
+if ((is_mac) || (is_win) || (use_linux_config) || use_musl) {
   ffmpeg_c_sources += [
     "libavcodec/autorename_libavcodec_hpeldsp.c",
     "libavcodec/autorename_libavcodec_videodsp.c",
@@ -209,7 +209,7 @@ if ((is_mac) || (is_win) || (use_linux_config)) {
   ]
 }
 
-if ((current_cpu == "arm64" && ffmpeg_branding == "Chrome") || (current_cpu == "x64" && ffmpeg_branding == "Chrome") || (is_android && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (is_android && current_cpu == "x86" && ffmpeg_branding == "Chrome") || (is_mac && ffmpeg_branding == "Chrome") || (is_win && ffmpeg_branding == "Chrome") || (use_linux_config && ffmpeg_branding == "Chrome") || (use_linux_config && ffmpeg_branding == "ChromeOS")) {
+if ((current_cpu == "arm64" && ffmpeg_branding == "Chrome") || (current_cpu == "x64" && ffmpeg_branding == "Chrome") || ((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (is_android && current_cpu == "x86" && ffmpeg_branding == "Chrome") || (is_mac && ffmpeg_branding == "Chrome") || (is_win && ffmpeg_branding == "Chrome") || (use_linux_config && ffmpeg_branding == "Chrome") || (use_linux_config && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_c_sources += [
     "libavcodec/aac_ac3_parser.c",
     "libavcodec/aac_parser.c",
@@ -291,7 +291,7 @@ if ((is_android && current_cpu == "arm64") || (is_mac && current_cpu == "arm64")
   ]
 }
 
-if ((is_android && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm")) {
+if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm")) {
   ffmpeg_c_sources += [
     "libavcodec/arm/fft_init_arm.c",
     "libavcodec/arm/flacdsp_init_arm.c",
@@ -356,7 +356,7 @@ if ((current_cpu == "x64" && ffmpeg_branding == "Chrome") || (is_android && curr
   ]
 }
 
-if ((is_android && current_cpu == "arm" && arm_use_neon) || (is_android && current_cpu == "arm64") || (is_android && current_cpu == "x64") || (is_android && current_cpu == "x86")) {
+if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon) || (is_android && current_cpu == "arm64") || (is_android && current_cpu == "x64") || (is_android && current_cpu == "x86")) {
   ffmpeg_c_sources += [
     "compat/strtod.c",
   ]
@@ -420,7 +420,7 @@ if (use_linux_config && ffmpeg_branding == "ChromeOS") {
   ]
 }
 
-if ((use_linux_config && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm")) {
+if ((use_linux_config && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm")  || (use_musl && current_cpu == "arm")) {
   ffmpeg_c_sources += [
     "libavcodec/arm/h264pred_init_arm.c",
     "libavcodec/arm/hpeldsp_init_arm.c",
@@ -492,14 +492,14 @@ if ((is_mac && current_cpu == "arm64" && ffmpeg_branding == "Chrome") || (is_win
   ]
 }
 
-if ((is_android && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "ChromeOS")) {
+if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_c_sources += [
     "libavcodec/arm/aacpsdsp_init_arm.c",
     "libavcodec/arm/sbrdsp_init_arm.c",
   ]
 }
 
-if ((is_android && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm" && arm_use_neon)) {
+if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm" && arm_use_neon)) {
   ffmpeg_c_sources += [
     "libavutil/arm/float_dsp_init_neon.c",
   ]
@@ -569,7 +569,7 @@ if (use_linux_config && current_cpu == "arm" && arm_use_neon) {
   ]
 }
 
-if ((is_android && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS")) {
+if (((is_android || is_ohos) && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_gas_sources += [
     "libavcodec/arm/aacpsdsp_neon.S",
     "libavcodec/arm/sbrdsp_neon.S",
diff --git a/third_party/ffmpeg/ffmpeg_options.gni b/third_party/ffmpeg/ffmpeg_options.gni
index 026e955058..532391358b 100644
--- a/third_party/ffmpeg/ffmpeg_options.gni
+++ b/third_party/ffmpeg/ffmpeg_options.gni
@@ -70,4 +70,8 @@ if ((is_linux || is_chromeos) && is_msan) {
   os_config = "linux"
 } else if (is_win && !is_clang) {
   os_config = "win-msvc"
+} else if (is_ohos && !use_musl) {
+  os_config = "android"
+} else if(use_musl) {
+  os_config = "linux"
 }
diff --git a/third_party/libjpeg_turbo/BUILD.gn b/third_party/libjpeg_turbo/BUILD.gn
index 5befffd782..f3cefb6a7b 100644
--- a/third_party/libjpeg_turbo/BUILD.gn
+++ b/third_party/libjpeg_turbo/BUILD.gn
@@ -128,7 +128,7 @@ if (current_cpu == "x86" || current_cpu == "x64") {
       }
     } else if (is_mac || is_ios) {
       defines += [ "MACHO" ]
-    } else if (is_linux || is_android || is_fuchsia || is_chromeos) {
+    } else if (is_linux || is_android || is_fuchsia || is_chromeos || is_ohos) {
       defines += [ "ELF" ]
     }
   }
diff --git a/third_party/libsync/src/include/sync/sync.h b/third_party/libsync/src/include/sync/sync.h
index 50ed0ac57b..9f0375d71e 100644
--- a/third_party/libsync/src/include/sync/sync.h
+++ b/third_party/libsync/src/include/sync/sync.h
@@ -19,7 +19,17 @@
 #ifndef __SYS_CORE_SYNC_H
 #define __SYS_CORE_SYNC_H
 
+#ifdef __MUSL__
+#ifdef	__cplusplus
+# define __BEGIN_DECLS	extern "C" {
+# define __END_DECLS	}
+#else
+# define __BEGIN_DECLS
+# define __END_DECLS
+#endif
+#else
 #include <sys/cdefs.h>
+#endif
 #include <stdint.h>
 
 #include <linux/types.h>
diff --git a/third_party/libxml/BUILD.gn b/third_party/libxml/BUILD.gn
index 2fc10cf03b..c5ebd5aa8a 100644
--- a/third_party/libxml/BUILD.gn
+++ b/third_party/libxml/BUILD.gn
@@ -4,7 +4,7 @@
 
 # Define an "os_include" variable that points at the OS-specific generated
 # headers.  These were generated by running the configure script offline.
-if (is_linux || is_chromeos || is_android || is_nacl || is_fuchsia) {
+if (is_linux || is_chromeos || is_android || is_nacl || is_fuchsia || is_ohos) {
   os_include = "linux"
 } else if (is_apple) {
   os_include = "mac"
diff --git a/third_party/libxslt/BUILD.gn b/third_party/libxslt/BUILD.gn
index d0254b9f7b..189dd80fe1 100644
--- a/third_party/libxslt/BUILD.gn
+++ b/third_party/libxslt/BUILD.gn
@@ -86,7 +86,7 @@ static_library("libxslt") {
   }
 
   cflags = []
-  if (is_linux || is_chromeos || is_android || is_fuchsia) {
+  if (is_linux || is_chromeos || is_android || is_fuchsia || is_ohos) {
     include_dirs = [ "linux" ]
   } else if (is_win) {
     include_dirs = [ "win32" ]
diff --git a/third_party/lss/linux_syscall_support.h b/third_party/lss/linux_syscall_support.h
index e4ac22644c..49f65da394 100644
--- a/third_party/lss/linux_syscall_support.h
+++ b/third_party/lss/linux_syscall_support.h
@@ -89,7 +89,7 @@
 #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) ||   \
      defined(__mips__) || defined(__PPC__) || defined(__ARM_EABI__) || \
      defined(__aarch64__) || defined(__s390__)) \
-  && (defined(__linux) || defined(__ANDROID__))
+  && (defined(__linux) || defined(__ANDROID__) || defined(__MUSL__))
 
 #ifndef SYS_CPLUSPLUS
 #ifdef __cplusplus
@@ -4240,7 +4240,7 @@ struct kernel_statfs {
       return LSS_NAME(socketcall)(8, d, type, protocol, sv);
     }
   #endif
-  #if defined(__NR_fstatat64)
+  #if defined(__NR_fstatat64) && !defined(__MUSL__)
     LSS_INLINE _syscall4(int,   fstatat64,        int,   d,
                          const char *,      p,
                          struct kernel_stat64 *,   b,    int,   f)
diff --git a/third_party/pdfium/core/fxcrt/cfx_datetime.cpp b/third_party/pdfium/core/fxcrt/cfx_datetime.cpp
index fcf9eb0b76..4cf3069ff6 100644
--- a/third_party/pdfium/core/fxcrt/cfx_datetime.cpp
+++ b/third_party/pdfium/core/fxcrt/cfx_datetime.cpp
@@ -11,7 +11,7 @@
 #include "third_party/base/check.h"
 
 #if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_APPLE) || defined(OS_ASMJS)
+    defined(OS_APPLE) || defined(OS_ASMJS) || defined(OS_OHOS)
 #include <sys/time.h>
 #include <time.h>
 #endif
diff --git a/third_party/pdfium/core/fxge/BUILD.gn b/third_party/pdfium/core/fxge/BUILD.gn
index 0ec54f337b..4a272cec66 100644
--- a/third_party/pdfium/core/fxge/BUILD.gn
+++ b/third_party/pdfium/core/fxge/BUILD.gn
@@ -160,7 +160,7 @@ source_set("fxge") {
     ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "fx_ge_linux.cpp" ]
   }
 
diff --git a/third_party/pdfium/core/fxge/fx_ge_linux.cpp b/third_party/pdfium/core/fxge/fx_ge_linux.cpp
index bfd43755a2..8308a6e5af 100644
--- a/third_party/pdfium/core/fxge/fx_ge_linux.cpp
+++ b/third_party/pdfium/core/fxge/fx_ge_linux.cpp
@@ -17,7 +17,7 @@
 #include "third_party/base/check.h"
 #include "third_party/base/stl_util.h"
 
-#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_ASMJS)
+#if !defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_ASMJS) && !defined(OS_OHOS)
 #error "Included on the wrong platform"
 #endif
 
diff --git a/third_party/perfetto/buildtools/BUILD.gn b/third_party/perfetto/buildtools/BUILD.gn
index 3e2df10738..cbb2e4df34 100644
--- a/third_party/perfetto/buildtools/BUILD.gn
+++ b/third_party/perfetto/buildtools/BUILD.gn
@@ -74,7 +74,7 @@ config("libunwindstack_config") {
     perfetto_isystem_cflag,
     rebase_path("android-core/demangle/include", root_build_dir),
   ]
-  if (is_android) {
+  if (is_android || is_ohos) {
     cflags += [
       perfetto_isystem_cflag,
       rebase_path("bionic/libc/include", root_build_dir),
@@ -653,7 +653,7 @@ if (use_custom_libcxx) {
     ]
 
     # On linux this seems to introduce an unwanted glibc 2.18 dependency.
-    if (is_android) {
+    if (is_android || is_ohos) {
       sources += [ "libcxxabi/src/cxa_thread_atexit.cpp" ]
     }
     configs -= [
@@ -724,7 +724,7 @@ if (use_custom_libcxx) {
       "//gn/standalone/sanitizers:sanitizer_options_link_helper",
     ]
     defines = [ "_LIBCPP_BUILDING_LIBRARY" ]
-    if ((is_linux || is_android) && (is_asan || is_tsan || is_msan)) {
+    if ((is_linux || is_android || is_ohos) && (is_asan || is_tsan || is_msan)) {
       # In {a,t,m}san configurations, operator new and operator delete will be
       # provided by the sanitizer runtime library.  Since libc++ defines these
       # symbols with weak linkage, and the *san runtime uses strong linkage, it
@@ -794,7 +794,7 @@ source_set("benchmark") {
 }
 
 # On Linux/Android use libbacktrace in debug builds for better stacktraces.
-if (is_linux || is_android) {
+if (is_linux || is_android || is_ohos) {
   config("libbacktrace_config") {
     visibility = _buildtools_visibility
     include_dirs = [
@@ -1019,7 +1019,7 @@ source_set("libunwindstack") {
     "android-unwinding/libunwindstack/Symbols.cpp",
     "android-unwinding/libunwindstack/Unwinder.cpp",
   ]
-  if (!is_android) {
+  if (!is_android && !is_ohos) {
     sources += [
       "android-libbase/liblog_symbols.cpp",
       "android-libbase/logging.cpp",
diff --git a/third_party/perfetto/include/perfetto/base/build_config.h b/third_party/perfetto/include/perfetto/base/build_config.h
index bd3623f3df..bca04cf8a0 100644
--- a/third_party/perfetto/include/perfetto/base/build_config.h
+++ b/third_party/perfetto/include/perfetto/base/build_config.h
@@ -24,9 +24,26 @@
 #define PERFETTO_BUILDFLAG(flag) \
   (PERFETTO_BUILDFLAG_CAT(PERFETTO_BUILDFLAG_DEFINE_, flag)())
 
-#if defined(__ANDROID__)
+#if defined(OSOHOS)
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_IOS() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_NACL() 0
+#endif
+
+#if defined(__ANDROID__) && !defined(OSOHOS)
+#if defined(__MUSL__)
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
+#else
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#endif
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MAC() 0
diff --git a/third_party/perfetto/include/perfetto/ext/base/thread_utils.h b/third_party/perfetto/include/perfetto/ext/base/thread_utils.h
index fb47d3d5ff..8b53870dba 100644
--- a/third_party/perfetto/include/perfetto/ext/base/thread_utils.h
+++ b/third_party/perfetto/include/perfetto/ext/base/thread_utils.h
@@ -61,6 +61,8 @@ inline bool GetThreadName(std::string& out_result) {
 #if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
   if (prctl(PR_GET_NAME, buf) != 0)
     return false;
+#elif defined(__MUSL__)
+  sprintf(buf, "thread_%d", (int) pthread_self());
 #else
   if (pthread_getname_np(pthread_self(), buf, sizeof(buf)) != 0)
     return false;
diff --git a/third_party/protobuf/src/google/protobuf/stubs/common.cc b/third_party/protobuf/src/google/protobuf/stubs/common.cc
index 30802b1bb4..af9f47fbfa 100644
--- a/third_party/protobuf/src/google/protobuf/stubs/common.cc
+++ b/third_party/protobuf/src/google/protobuf/stubs/common.cc
@@ -49,7 +49,7 @@
 #else
 #error "No suitable threading library available."
 #endif
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
 #include <android/log.h>
 #endif
 
@@ -125,7 +125,7 @@ string VersionString(int version) {
 
 namespace internal {
 
-#if defined(__ANDROID__)
+#if defined(__ANDROID__) && !defined(OSOHOS)
 inline void DefaultLogHandler(LogLevel level, const char* filename, int line,
                               const string& message) {
   if (level < GOOGLE_PROTOBUF_MIN_LOG_LEVEL) {
diff --git a/third_party/skia/src/ports/skia_ohos/FontConfig_ohos.cpp b/third_party/skia/src/ports/skia_ohos/FontConfig_ohos.cpp
new file mode 100644
index 0000000000..3011940cfd
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/FontConfig_ohos.cpp
@@ -0,0 +1,1256 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "FontConfig_ohos.h"
+
+#include <dirent.h>
+#include <libgen.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "base/logging.h"
+
+#include "include/core/SkFontStyle.h"
+#include "include/core/SkString.h"
+
+using namespace ErrorCode;
+
+static const char* OHOS_DEFAULT_CONFIG = "/system/etc/fontconfig.json";
+
+/*! Constructor
+ * \param fontScanner the scanner to get the font information from a font file
+ * \param fname the full name of system font configuration document.
+ *     \n The default value is '/system/etc/fontconfig.json', if fname is given null
+ */
+FontConfig_OHOS::FontConfig_OHOS(const SkTypeface_FreeType::Scanner& fontScanner,
+    const char* fname)
+{
+    int err = parseConfig(fname);
+    if (err != NO_ERROR) {
+        return;
+    }
+    scanFonts(fontScanner);
+    resetGenericValue();
+    resetFallbackValue();
+}
+
+/*! To get the fallbackForMap
+ *  \return The reference of fallbackForMap
+ */
+const FallbackForMap& FontConfig_OHOS::getFallbackForMap() const
+{
+    return fallbackForMap;
+}
+
+/*! To get the fallback set
+ *  \return The reference of fallbackSet
+ */
+const FallbackSet& FontConfig_OHOS::getFallbackSet() const
+{
+    return fallbackSet;
+}
+
+/*! To get the count of font style sets supported in the system
+ *  \return The count of font style sets in generic family
+ */
+int FontConfig_OHOS::getFamilyCount() const
+{
+    return genericFamilySet.size();
+}
+
+/*! To get the family name of the default font style set
+ *  \param[out] familyName a pointer of SkString object, to which the family value will be set.
+ *  \return The count of typeface in this font style set
+ *  \n Return -1, if there is no any font style set in the system.
+ */
+int FontConfig_OHOS::getDefaultFamily(SkString* familyName) const
+{
+    return getFamilyName(0, familyName);
+}
+
+/*! To get the family name of a font style set
+ * \param index the index of a font style set in generic family
+ * \param[out] familyName a pointer of SkString object, to which the family value will be set
+ * \return The count of typeface in the font style set
+ * \n      Return -1, if the 'index' is out of range
+ */
+int FontConfig_OHOS::getFamilyName(int index, SkString* familyName) const
+{
+    if (index < 0 || index >= this->getFamilyCount()) {
+        if (familyName) {
+            familyName->reset();
+        }
+        return -1;
+    }
+    if (familyName) {
+        *familyName = genericFamilySet[index]->familyName;
+    }
+    return genericFamilySet[index]->typefaceSet->size();
+}
+
+/*! To get the count of a font style set
+ * \param styleIndex the index of a font style set
+ * \param isFallback to indicate the font style set is from generic family or fallback family
+ * \n                 false , the font style set is from generic family list
+ * \n                 true, the font style set is from fallback family list
+ * \return The count of typeface in the font style set
+ */
+int FontConfig_OHOS::getTypefaceCount(int styleIndex, bool isFallback) const
+{
+    if (styleIndex < 0) {
+        return -1;
+    }
+    if (isFallback) {
+        if ((unsigned int)styleIndex < fallbackSet.size()) {
+            return fallbackSet[styleIndex]->typefaceSet->size();
+        }
+    } else {
+        if ((unsigned int)styleIndex < genericFamilySet.size()) {
+            return genericFamilySet[styleIndex]->typefaceSet->size();
+        }
+    }
+    return -1;
+}
+
+/*! To get a typeface
+ * \param styleIndex the index of a font style set
+ * \param index the index of a typeface in its style set
+ * \param isFallback false, the font style set is generic
+ * \n          true, the font style set is fallback
+ * \return The pointer of a typeface
+ * \n       Return null, if 'styleIndex' or 'index' is out of range
+ */
+SkTypeface_OHOS* FontConfig_OHOS::getTypeface(int styleIndex, int index,
+    bool isFallback) const
+{
+    if (styleIndex < 0 || index < 0 ||
+        (isFallback && (unsigned int)styleIndex >= fallbackSet.size()) ||
+        (!isFallback && (unsigned int)styleIndex >= genericFamilySet.size())) {
+        return nullptr;
+    }
+    if (isFallback) {
+        const TypefaceSet& tpSet = *(fallbackSet[styleIndex]->typefaceSet.get());
+        if ((unsigned int)index < tpSet.size()) {
+            return tpSet[index].get();
+        }
+    } else {
+        const TypefaceSet& tpSet = *(genericFamilySet[styleIndex]->typefaceSet.get());
+        if ((unsigned int)index < tpSet.size()) {
+            return tpSet[index].get();
+        }
+    }
+    return nullptr;
+}
+
+/*! To get a typeface
+ * \param styleIndex the index a font style set
+ * \param style the font style to be matching
+ * \param isFallback false, the font style set is generic
+ * \n                true, the font style set is fallback
+ * \return An object of typeface whose font style is the closest matching to 'style'
+ * \n      Return null, if 'styleIndex' is out of range
+ */
+SkTypeface_OHOS* FontConfig_OHOS::getTypeface(int styleIndex, const SkFontStyle& style,
+    bool isFallback) const
+{
+    if (styleIndex < 0 ||
+        (isFallback && (unsigned int)styleIndex >= fallbackSet.size()) ||
+        (!isFallback && (unsigned int)styleIndex >= genericFamilySet.size())) {
+        return nullptr;
+    }
+    const TypefaceSet* pSet = nullptr;
+    if (isFallback) {
+        pSet = fallbackSet[styleIndex]->typefaceSet.get();
+    } else {
+        pSet = genericFamilySet[styleIndex]->typefaceSet.get();
+    }
+    sk_sp<SkTypeface_OHOS> tp = matchFontStyle(*pSet, style);
+    if (tp.get() != nullptr) {
+        return tp.get();
+    }
+    return nullptr;
+}
+
+/*! To get the index of a font style set
+ *  \param familyName the family name of the font style set
+ *  \n     get the index of default font style set, if 'familyName' is null
+ *  \param[out] isFallback to tell if the family is from generic or fallback to the caller.
+ *  \n          isFallback is false, if the font style is from generic family list
+ *  \n          isFallback is true, if the font style is from fallback family list
+ *  \return The index of the font style set
+ *  \n      Return -1, if 'familyName' is not found in the system
+ */
+int FontConfig_OHOS::getStyleIndex(const char* familyName, bool& isFallback) const
+{
+    if (familyName == nullptr) {
+        isFallback = false;
+        return 0;
+    }
+    SkString fname(familyName);
+    int* p = genericNames.find(fname);
+    if (p) {
+        isFallback = false;
+        return *p;
+    } else {
+        p = fallbackNames.find(fname);
+        if (p) {
+            isFallback = true;
+            return *p;
+        }
+    }
+    return -1;
+}
+
+/*! Find the closest matching typeface
+ * \param typefaceSet a typeface set belonging to the same font style set
+ * \param pattern the font style to be matching
+ * \return The typeface object which is the closest matching to 'pattern'
+ * \n      Return null, if the count of typeface is 0
+ */
+sk_sp<SkTypeface_OHOS> FontConfig_OHOS::matchFontStyle(const TypefaceSet& typefaceSet,
+    const SkFontStyle& pattern)
+{
+    int count = typefaceSet.size();
+    if (count == 0) {
+        return nullptr;
+    } else if (count == 1) {
+        return typefaceSet[0];
+    }
+    uint32_t minDiff = 0xFFFFFFFF;
+    int index = 0;
+    for (int i = 0; i < count; i++) {
+        const SkFontStyle& fontStyle = typefaceSet[i]->fontStyle();
+        uint32_t diff = getFontStyleDifference(pattern, fontStyle);
+        if (diff < minDiff) {
+            minDiff = diff;
+            index = i;
+        }
+    }
+    return typefaceSet[index];
+}
+
+/*! To get the difference between a font style and the matching font style
+ * \param dstStyle the style to be matching
+ * \param srcStyle a font style
+ * \return The difference value of a specified style with the matching style
+ */
+uint32_t FontConfig_OHOS::getFontStyleDifference(const SkFontStyle& dstStyle,
+    const SkFontStyle& srcStyle)
+{
+    int normalWidth = SkFontStyle::kNormal_Width;
+    int dstWidth = dstStyle.width();
+    int srcWidth = srcStyle.width();
+
+    uint32_t widthDiff = 0;
+    // The maximum font width is kUltraExpanded_Width i.e. '9'.
+    // If dstWidth <= kNormal_Width (5), first check narrower values, then wider values.
+    // If dstWidth > kNormal_Width, first check wider values, then narrower values.
+    // When dstWidth and srcWidth are at different side of kNormal_Width,
+    // the width difference between them should be more than 5 (9/2+1)
+    if (dstWidth <= normalWidth) {
+        if (srcWidth <= dstWidth) {
+            widthDiff = dstWidth - srcWidth;
+        } else {
+            widthDiff = srcWidth - dstWidth + 5;
+        }
+    } else {
+        if (srcWidth >= dstWidth) {
+            widthDiff = srcWidth - dstWidth;
+        } else {
+            widthDiff = dstWidth - srcWidth + 5;
+        }
+    }
+
+    int diffSlantValue[3][3] = {
+        {0, 2, 1},
+        {2, 0, 1},
+        {2, 1, 0}
+    };
+    uint32_t slantDiff = diffSlantValue[dstStyle.slant()][srcStyle.slant()];
+
+    int dstWeight = dstStyle.weight();
+    int srcWeight = srcStyle.weight();
+    uint32_t weightDiff = 0;
+    // If dstWeight == kNormal_Weight (400), first check kMedium_Weight (500), then smaller values,
+    // and then bigger values.
+    // If dstWeight == kMedium_Weight, first check kNormal_Weight, then bigger values, and then smaller values.
+    // so we set the difference of kNormal_Weight and kMedium_Weight is 50 in order to differ from other cases.
+    // If dstWeight < kNormal_Weight, first check smaller values, then bigger values.
+    // If dstWeight > kNormal_Weight, first check bigger values, then smaller values.
+    // The maximum weight is kExtraBlack_Weight (1000), when dstWeight and srcWeight are at the different
+    // side of kNormal_Weight, the weight difference between them should be more than 500 (1000/2)
+    if ((dstWeight == SkFontStyle::kNormal_Weight && srcWeight == SkFontStyle::kMedium_Weight) ||
+        (dstWeight == SkFontStyle::kMedium_Weight && srcWeight == SkFontStyle::kNormal_Weight)) {
+        weightDiff = 50;
+    } else if (dstWeight <= SkFontStyle::kNormal_Weight) {
+        if (srcWeight <= dstWeight) {
+            weightDiff = dstWeight - srcWeight;
+        } else {
+            weightDiff = srcWeight - dstWeight + 500;
+        }
+    } else if (dstWeight > SkFontStyle::kNormal_Weight) {
+        if (srcWeight >= dstWeight) {
+            weightDiff = srcWeight - dstWeight;
+        } else {
+            weightDiff = dstWeight - srcWeight + 500;
+        }
+    }
+    // The first 2 bytes to save weight difference, the third byte to save slant difference,
+    // and the fourth byte to save width difference
+    uint32_t diff = (widthDiff << 24) + (slantDiff << 16) + weightDiff;
+    return diff;
+}
+
+/*! To get the data of font configuration file
+ * \param fname the full name of the font configuration file
+ * \param[out] size the size of data returned to the caller
+ * \return The pointer of content of the file
+ * \note The returned pointer should be freed by the caller
+ */
+char* FontConfig_OHOS::getFileData(const char* fname, int& size)
+{
+    FILE* fp = fopen(fname, "r");
+    if (fp == nullptr) {
+        return nullptr;
+    }
+    fseek(fp, 0L, SEEK_END);
+    size = ftell(fp) + 1;
+    rewind(fp);
+    void* data = malloc(size);
+    if (data == nullptr) {
+        fclose(fp);
+        return nullptr;
+    }
+    memset(data, 0, size);
+    (void) fread(data, size, 1, fp);
+    fclose(fp);
+    return (char*)data;
+}
+
+/*! parse the system font configuration document
+ * \param fname the full name of the font configuration document
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_NOT_FOUND config document is not found
+ * \return ERROR_CONFIG_FORMAT_NOT_SUPPORTED config document format is not supported
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE wrong type of value in the configuration
+ */
+
+int FontConfig_OHOS::parseConfig(const char* fname)
+{
+    if (fname == nullptr) {
+        fname = OHOS_DEFAULT_CONFIG;
+    }
+    Json::Value root;
+    int err = checkConfigFile(fname, root);
+    if (err != NO_ERROR) {
+        return err;
+    }
+    // "fontdir" - optional, the data type should be string
+    const char* key = "fontdir";
+    if (root.isMember(key)) {
+        if (root[key].isArray()) {
+            parseFontDir(root[key]);
+        } else {
+            return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key);
+        }
+    }
+    // "generic", "fallback" - necessary, the data type should be array
+    const char* keys[] = {"generic", "fallback", nullptr};
+    int index = 0;
+
+    while (true) {
+        if (keys[index] == nullptr) {
+            break;
+        }
+        key = keys[index++];
+        if (!root.isMember(key)) {
+            return logErrInfo(ERROR_CONFIG_MISSING_TAG, key);
+        } else if (!root[key].isArray()) {
+            return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::arrayValue, root[key].type());
+        }
+        const Json::Value& arr = root[key];
+        for (unsigned int i = 0; i < arr.size(); i++) {
+            if (arr[i].isObject()) {
+                if (!strcmp(key, "generic")) {
+                    parseGeneric(arr[i]);
+                } else if (!strcmp(key, "fallback")) {
+                    parseFallback(arr[i]);
+                }
+            } else {
+                SkString errKey;
+                errKey.appendf("%s#%d", key, i + 1);
+                (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, errKey.c_str(),
+                    Json::objectValue, arr[i].type());
+            }
+        }
+    }
+    root.clear();
+    return NO_ERROR;
+}
+
+/*! check the system font configuration document
+ * \param fname the full name of the font configuration document
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_NOT_FOUND config document is not found
+ * \return ERROR_CONFIG_FORMAT_NOT_SUPPORTED config document format is not supported
+ */
+int FontConfig_OHOS::checkConfigFile(const char* fname, Json::Value& root)
+{
+    int size = 0;
+    char* data = getFileData(fname, size);
+    if (data == nullptr) {
+        return logErrInfo(ERROR_CONFIG_NOT_FOUND, fname);
+    }
+    JSONCPP_STRING errs;
+    Json::CharReaderBuilder charReaderBuilder;
+    std::unique_ptr<Json::CharReader> jsonReader(charReaderBuilder.newCharReader());
+    bool isJson = jsonReader->parse(data, data + size, &root, &errs);
+    free((void*)data);
+    data = nullptr;
+
+    if (!isJson || !errs.empty()) {
+        return logErrInfo(ERROR_CONFIG_FORMAT_NOT_SUPPORTED, fname);
+    }
+    return NO_ERROR;
+}
+#if ENABLE_DEBUG
+/*! To print out the font information
+ * \param font the font object to be printed
+ */
+void FontConfig_OHOS::dumpFont(const FontInfo& font) const
+{
+    LOGI("name=%s, family=%s, weight=%d, width=%d, slant=%d, index=%d, stream=%p\n",
+        font.fname.c_str(), font.familyName.c_str(), font.style.weight(), font.style.width(), font.style.slant(),
+        font.index, font.stream.get());
+    int count = font.axisSet.axis.size();
+    if (count > 0) {
+        SkString str;
+        for (unsigned int i = 0; i < count; i++) {
+            str.appendU32(SkFixedFloorToInt(font.axisSet.axis[i]));
+            if (i < count - 1) {
+                str.append(",");
+            }
+        }
+        LOGI("axis={%s}\n", str.c_str());
+    }
+}
+
+/*! To print out the information of generic font style set
+ */
+void FontConfig_OHOS::dumpGeneric() const
+{
+    LOGI("\n");
+    for (unsigned int i = 0; i < genericFamilySet.size(); i++) {
+        LOGI("[%d] familyName : %s - %d\n", i, genericFamilySet[i]->familyName.c_str(),
+            static_cast<int>(genericFamilySet[i]->typefaceSet->size()));
+        for (int j = 0; j < genericFamilySet[i]->typefaceSet->size(); j++) {
+            if ((*(genericFamilySet[i]->typefaceSet))[j].get()) {
+                const FontInfo* font = (*(genericFamilySet[i]->typefaceSet))[j]->getFontInfo();
+                if (font) {
+                    dumpFont(*font);
+                } else {
+                    LOGE("font [%d] is null\n", j);
+                }
+            } else {
+                LOGE("typefeace [%d] is null\n", j);
+            }
+        }
+    }
+}
+
+/*! To print out the information of fallback font style set
+ */
+void FontConfig_OHOS::dumpFallback() const
+{
+    LOGI("\n");
+    int count = 0;
+    fallbackForMap.foreach([this, &count](const SkString& key,
+        const FallbackSetPos& setIndex) {
+        LOGI("[%d] family : %s - %d\n", count++, key.c_str(), setIndex.count);
+        for (unsigned int i = setIndex.index; i < setIndex.index + setIndex.count; i++) {
+            const TypefaceSet& tpSet = *(fallbackSet[i]->typefaceSet.get());
+            LOGI("[%s] - %d\n", fallbackSet[i]->familyName.c_str(), static_cast<int>(tpSet.size()));
+
+            for (unsigned int j = 0; j < tpSet.size(); j++) {
+                const FontInfo* font = tpSet[j]->getFontInfo();
+                if (font) {
+                    this->dumpFont(*font);
+                } else {
+                    LOGE("font [%d] is null\n", j);
+                }
+            }
+        }
+    });
+}
+#endif
+
+/*! To parse 'fontdir' attribute
+ * \param root the root node of 'fontdir'
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type
+ */
+int FontConfig_OHOS::parseFontDir(const Json::Value& root)
+{
+    for (unsigned int i = 0; i < root.size(); i++) {
+        if (root[i].isString()) {
+            const char* dir = root[i].asCString();
+            fontDirSet.emplace_back(SkString(dir));
+        } else {
+            SkString text;
+            text.appendf("fontdir#%d", i + 1);
+            return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, text.c_str(), Json::stringValue, root[i].type());
+        }
+    }
+    return NO_ERROR;
+}
+
+/*! To parse an item of 'generic' family
+ * \param root the root node of an item in 'generic' list
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ * \return ERROR_CONFIG_MISSING_TAG missing tag of 'family' or 'alias'
+ */
+int FontConfig_OHOS::parseGeneric(const Json::Value& root)
+{
+    // "family" - necessary, the data type should be String
+    const char* key = "family";
+    if (!root.isMember(key)) {
+        return logErrInfo(ERROR_CONFIG_MISSING_TAG, key);
+    } else if (!root[key].isString()) {
+        return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::stringValue, root[key].type());
+    }
+    SkString familyName = SkString(root[key].asCString());
+    // "alias" - necessary, the data type should be Array
+    if (!root.isMember("alias")) {
+        return logErrInfo(ERROR_CONFIG_MISSING_TAG, "alias");
+    }
+    // "adjust", "variation" - optional
+    const char* tags[] = {"alias", "adjust", "variations", "index"};
+    std::vector<AliasInfo> aliasSet;
+    std::vector<AdjustInfo> adjustSet;
+    std::vector<VariationInfo> variationSet;
+    for (unsigned int i = 0; i < sizeof(tags) / sizeof(char*); i++) {
+        key = tags[i];
+        if (!root.isMember(key)) {
+            continue;
+        }
+        if (root[key].isArray()) {
+            if (!strcmp(key, "index")) {
+                parseTtcIndex(root[key], familyName);
+                continue;
+            }
+            const Json::Value& arr = root[key];
+            for (unsigned int j = 0; j < arr.size(); j++) {
+                if (arr[j].isObject()) {
+                    if (!strcmp(key, "alias")) {
+                        parseAlias(arr[j], aliasSet);
+                    } else if (!strcmp(key, "adjust")) {
+                        parseAdjust(arr[j], adjustSet);
+                    } else {
+                        parseVariation(arr[j], variationSet);
+                    }
+                } else {
+                    SkString text;
+                    text.appendf("%s#%d", key, j + 1);
+                    (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, text.c_str(), Json::objectValue,
+                        arr[j].type());
+                }
+            }
+        } else {
+            (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::arrayValue, root[key].type());
+        }
+        if (root.size() == 2) {
+            break;
+        }
+    }
+    if (aliasSet.size()) {
+        aliasMap.set(SkString(familyName), aliasSet);
+    }
+    if (adjustSet.size()) {
+        adjustMap.set(SkString(familyName), adjustSet);
+    }
+    if (variationSet.size()) {
+        variationMap.set(SkString(familyName), variationSet);
+    }
+    return NO_ERROR;
+}
+
+/*! To parse an item of 'alias' attribute
+ * \param root the root node of an item in an 'alias' list
+ * \param[out] aliasSet the value of AliasInfo will be written to and returned to the caller
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ * \return ERROR_CONFIG_MISSING_TAG missing tag of alias name
+ */
+int FontConfig_OHOS::parseAlias(const Json::Value& root, std::vector<AliasInfo>& aliasSet)
+{
+    if (root.empty()) {
+        return logErrInfo(ERROR_CONFIG_MISSING_TAG, "generic-alias-name");
+    }
+    Json::Value::Members members = root.getMemberNames();
+    const char* key = members[0].c_str();
+    if (!root[key].isInt()) {
+        return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, "generic-alias-weight",
+            Json::intValue, root[key].type());
+    }
+
+    SkString aliasName = SkString(key);
+    int weight = root[key].asInt();
+    std::unique_ptr<GenericFamily> genericFamily = std::make_unique<GenericFamily>();
+    genericFamily->familyName = SkString(key);
+    if (aliasSet.size() == 0 || weight > 0) {
+        genericFamily->typefaceSet = std::make_shared<TypefaceSet>();
+    } else {
+        int index = aliasSet[0].pos;
+        genericFamily->typefaceSet = genericFamilySet[index]->typefaceSet;
+    }
+    genericNames.set(SkString(genericFamily->familyName), genericFamilySet.size());
+
+    AliasInfo info = {static_cast<int>(genericFamilySet.size()), weight};
+    aliasSet.emplace_back(std::move(info));
+    genericFamilySet.emplace_back(std::move(genericFamily));
+    return NO_ERROR;
+}
+
+/*! To parse an item of 'adjust' attribute
+ * \param root the root node of an item in an 'adjust' list
+ * \param[out] adjustSet the value of AdjustInfo will be written to and returned to the caller
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ * \return ERROR_CONFIG_MISSING_TAG missing tag of 'weight' or 'to'
+ */
+int FontConfig_OHOS::parseAdjust(const Json::Value& root, std::vector<AdjustInfo>& adjustSet)
+{
+    const char* tags[] = {"weight", "to"};
+    int values[2]; // value[0] - to save 'weight', value[1] - to save 'to'
+    for (unsigned int i = 0; i < sizeof(tags) / sizeof(char*); i++) {
+        const char* key = tags[i];
+        if (!root.isMember(key)) {
+            return logErrInfo(ERROR_CONFIG_MISSING_TAG, key);
+        } else if (!root[key].isInt()) {
+            return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key,
+                Json::intValue, root[key].type());
+        } else {
+            values[i] = root[key].asInt();
+        }
+    }
+    AdjustInfo info = {values[0], values[1]};
+    adjustSet.push_back(info);
+    return NO_ERROR;
+}
+
+/*! To parse an item of 'fallback' attribute
+ * \param root the root node of an item in 'fallback' list
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ * \return ERROR_CONFIG_MISSING_TAG missing tag of fallbackFor
+ */
+int FontConfig_OHOS::parseFallback(const Json::Value& root)
+{
+    if (root.empty()) {
+        return logErrInfo(ERROR_CONFIG_MISSING_TAG, "fallback-fallbackFor");
+    }
+    Json::Value::Members members = root.getMemberNames();
+    const char* key = members[0].c_str();
+    if (!root[key].isArray()) {
+        return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, "fallback-items",
+            Json::arrayValue, root[key].type());
+    }
+    unsigned int startPos = fallbackSet.size();
+    SkString fallbackFor = SkString(key);
+    const Json::Value& fallbackArr = root[key];
+    for (unsigned int i = 0; i < fallbackArr.size(); i++) {
+        if (!fallbackArr[i].isObject()) {
+            SkString text;
+            text.appendf("fallback-%s#%d", key, i + 1);
+            (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, text.c_str(), Json::objectValue,
+                fallbackArr[i].type());
+            continue;
+        }
+        parseFallbackItem(fallbackArr[i]);
+    }
+    FallbackSetPos setPos = {startPos, (unsigned int)(fallbackSet.size() - startPos)};
+    fallbackForMap.set(fallbackFor, setPos);
+    return NO_ERROR;
+}
+
+/*! To parse an item of fallback family
+ * \param root the root node of a fallback item
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ * \return ERROR_CONFIG_MISSING_TAG missing tag of language
+ */
+int FontConfig_OHOS::parseFallbackItem(const Json::Value& root)
+{
+    if (root.empty()) {
+        return logErrInfo(ERROR_CONFIG_MISSING_TAG, "fallback-item-lang");
+    }
+    Json::Value::Members members = root.getMemberNames();
+    const char* key = nullptr;
+    bool hasIndex = false;
+    bool hasVariations = false;
+    for (unsigned int i = 0; i < members.size(); i++) {
+        if (members[i] == "variations") {
+            hasVariations = true;
+        } else if (members[i] == "index") {
+            hasIndex = true;
+        } else {
+            key = members[i].c_str();
+        }
+    }
+    if (key == nullptr) {
+        return logErrInfo(ERROR_CONFIG_MISSING_TAG, "fallback-item-lang");
+    }
+    if (!root[key].isString()) {
+        return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, "fallback-item-family",
+            Json::stringValue, root[key].type());
+    }
+    SkString lang = SkString(key);
+    SkString familyName = SkString(root[key].asCString());
+    if (hasVariations) {
+        key = "variations";
+        if (root[key].isArray()) {
+            const Json::Value& varArr = root[key];
+            std::vector<VariationInfo> variationSet;
+            for (unsigned int i = 0; i < varArr.size(); i++) {
+                if (varArr[i].isObject()) {
+                    parseVariation(varArr[i], variationSet);
+                } else {
+                    SkString text = SkString("variations#");
+                    text.appendU32(i + 1);
+                    (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, text.c_str(),
+                        Json::objectValue, varArr[i].type());
+                }
+            }
+            if (variationSet.size()) {
+                variationMap.set(SkString(familyName), variationSet);
+            }
+        } else {
+            (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::arrayValue,
+                root[key].type());
+        }
+    }
+    if (hasIndex) {
+        key = "index";
+        if (root[key].isArray()) {
+            parseTtcIndex(root[key], familyName);
+        } else {
+            (void) logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::arrayValue, root[key].type());
+        }
+    }
+    std::unique_ptr<FallbackInfo> fallback = std::make_unique<FallbackInfo>();
+    fallback->familyName = familyName;
+    fallback->langs = lang;
+    fallback->typefaceSet = std::make_shared<TypefaceSet>();
+    fallbackNames.set(SkString(familyName), fallbackSet.size());
+    fallbackSet.emplace_back(std::move(fallback));
+    return NO_ERROR;
+}
+
+/*! To parse an item of 'variations' attribute
+ * \param root the root node of an item in 'variations' list
+ * \param[out] variationSet the value of VariationInfo is written to and returned to the caller
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ * \return ERROR_CONFIG_MISSING_TAG missing tag of 'weight' or 'wght'
+ */
+int FontConfig_OHOS::parseVariation(const Json::Value& root, std::vector<VariationInfo>& variationSet)
+{
+    const char* key = nullptr;
+    const char* tags[] = {"wght", "wdth", "slnt", "weight", "width", "slant"};
+    VariationInfo info;
+    for (unsigned int i = 0; i < sizeof(tags) / sizeof(char*); i++) {
+        key = tags[i];
+        if ((!strcmp(key, "wght") || !strcmp(key, "weight")) &&
+            !root.isMember(key)) {
+            return logErrInfo(ERROR_CONFIG_MISSING_TAG, key);
+        }
+        if (!root.isMember(key)) {
+            continue;
+        }
+        if (!strcmp(key, "weight")) {
+            if (root[key].isInt()) {
+                return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::intValue, root[key].type());
+            }
+            info.weight = root[key].asInt();
+        } else if (!strcmp(key, "width")) {
+            if (!root[key].isInt()) {
+                return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::intValue, root[key].type());
+            }
+            info.width = root[key].asInt();
+        } else if (!strcmp(key, "slant")) {
+            if (!root[key].isString()) {
+                return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::stringValue, root[key].type());
+            }
+            const char* str = root[key].asCString();
+            if (!strcmp(str, "normal")) {
+                info.slant = static_cast<int>(SkFontStyle::kUpright_Slant);
+            } else if (!strcmp(str, "italic")) {
+                info.slant = static_cast<int>(SkFontStyle::kItalic_Slant);
+            } else if (!strcmp(str, "oblique")) {
+                info.slant = static_cast<int>(SkFontStyle::kOblique_Slant);
+            }
+        } else {
+            if (!root[key].isNumeric()) {
+                return logErrInfo(ERROR_CONFIG_INVALID_VALUE_TYPE, key, Json::realValue, root[key].type());
+            }
+            Coordinate axis;
+            axis.axis = SkSetFourByteTag(key[0], key[1], key[2], key[3]);
+            axis.value = root[key].asFloat();
+            info.axis.emplace_back(axis);
+        }
+    }
+    variationSet.emplace_back(info);
+    return NO_ERROR;
+}
+
+/*! To parse  'index' attribute
+ * \param root the root node of 'index' attribute
+ * \param familyName the name of the family which the root node belongs to
+ * \return NO_ERROR successful
+ * \return ERROR_CONFIG_INVALID_VALUE_TYPE invalid value type for an attribute
+ */
+int FontConfig_OHOS::parseTtcIndex(const Json::Value& root, const SkString& familyName)
+{
+    unsigned int keyCount = 2; // the value of 'index' is an array with 2 items.
+    if (root.size() == keyCount && root[0].isString() && root[1].isNumeric()) {
+        TtcIndexInfo item = { SkString(root[0].asCString()), root[1].asInt() };
+        if (item.ttcIndex != 0 && ttcIndexMap.find(item.familyName) == nullptr) {
+            ttcIndexMap.set(SkString(item.familyName), {SkString(item.familyName), 0});
+        }
+        ttcIndexMap.set(SkString(familyName), item);
+    } else {
+        int ret = ERROR_CONFIG_INVALID_VALUE_TYPE;
+        SkString text;
+        const char* key = "index";
+        if (root.size() != keyCount) {
+            text.appendf("%s#0", key);
+            errSet.emplace_back(ret, text.c_str());
+            LOGE("%s : '%s' size should be 2, but here it's %d\n", errToString(ret), key, root.size());
+            return ret;
+        } else if (!root[0].isString()) {
+            text.appendf("%s#1", key);
+            return logErrInfo(ret, text.c_str(), Json::stringValue, root[0].type());
+        } else {
+            text.appendf("%s#2", key);
+            return logErrInfo(ret, text.c_str(), Json::intValue, root[1].type());
+        }
+    }
+    return NO_ERROR;
+}
+
+/*! To get the axis value and set to 'font'
+ * \param axisDefs the axis ranges of a font
+ * \param variation the variation data from which axis values are generated
+ * \param[out] font the axis values will be written to and returned to the caller
+ */
+void FontConfig_OHOS::getAxisValues(const AxisDefinitions& axisDefs,
+    const VariationInfo& variation, FontInfo& font) const
+{
+    SkFontArguments::VariationPosition position;
+    position.coordinateCount = variation.axis.size();
+    position.coordinates = variation.axis.data();
+
+    int count = axisDefs.count();
+    SkFixed axisValues[count];
+    SkTypeface_FreeType::Scanner::computeAxisValues(axisDefs, position,
+        axisValues, font.familyName);
+    font.axisSet.axis.clear();
+    font.axisSet.range.clear();
+    for (int i = 0; i < count; i++) {
+        font.axisSet.axis.emplace_back(axisValues[i]);
+        font.axisSet.range.emplace_back(axisDefs[i]);
+    }
+}
+
+/*! To insert a ttc font into a font style set
+ * \param count the count of typeface in a ttc font
+ * \param font an object of the FontInfo with font information
+ * \return true, if the font is a ttc font and added to corresponding font style set
+ * \return false, if the font is not a ttc font
+ */
+bool FontConfig_OHOS::insertTtcFont(int count, FontInfo& font)
+{
+    bool ret = false;
+    ttcIndexMap.foreach([this, count, &font, &ret]
+        (const SkString& familyName, TtcIndexInfo* info) {
+        if (info->familyName == font.familyName && info->ttcIndex < count) {
+            SkString specifiedName;
+            TypefaceSet* tpSet = this->getTypefaceSet(familyName, specifiedName);
+            if (tpSet) {
+                FontInfo newFont(font);
+                newFont.familyName = familyName;
+                newFont.index = info->ttcIndex;
+                sk_sp<SkTypeface_OHOS> typeface = sk_make_sp<SkTypeface_OHOS>(specifiedName, newFont);
+                tpSet->push_back(std::move(typeface));
+                ret = true;
+            }
+        }
+    });
+    return ret;
+}
+
+/*! To insert a variable font into a font style set
+ * \param axisDefs the axis ranges of a variable font
+ * \param font an object of the FontInfo with font information
+ * \return true, if the font is a variable and some typefaces are added to the corresponding font style set
+ * \return false, if the font is not variable
+ */
+bool FontConfig_OHOS::insertVariableFont(const AxisDefinitions& axisDefs, FontInfo& font)
+{
+    const SkString& key = font.familyName;
+    if (variationMap.find(key) == nullptr || axisDefs.count() == 0) {
+        return false;
+    }
+    SkString specifiedName;
+    TypefaceSet* tpSet = getTypefaceSet(key, specifiedName);
+    if (tpSet == nullptr) {
+        return false;
+    }
+    const std::vector<VariationInfo>& variationSet = *(variationMap.find(key));
+    for (unsigned int i = 0; i < variationSet.size(); i++) {
+        FontInfo newFont(font);
+        getAxisValues(axisDefs, variationSet[i], newFont);
+        int width = font.style.width();
+        SkFontStyle::Slant slant = font.style.slant();
+        if (variationSet[i].width != -1) {
+            width = variationSet[i].width;
+        }
+        if (variationSet[i].slant != -1) {
+            slant = (SkFontStyle::Slant) variationSet[i].slant;
+        }
+        newFont.style = SkFontStyle(variationSet[i].weight, width, slant);
+        sk_sp<SkTypeface_OHOS> typeface = sk_make_sp<SkTypeface_OHOS>(specifiedName, newFont);
+        tpSet->push_back(std::move(typeface));
+    }
+    return true;
+}
+
+/*! To get the typeface set of a font style set
+ * \param familyName the family name of a font style set
+ * \param[out] specifiedName the specified family name of a font style set returned to the caller
+ * \return The object of typeface set
+ * \n      Return null, if the family name is not found in the system
+ */
+TypefaceSet* FontConfig_OHOS::getTypefaceSet(const SkString& familyName,
+    SkString& specifiedName) const
+{
+    if (aliasMap.find(familyName) != nullptr) {
+        const std::vector<AliasInfo>& aliasSet = *(aliasMap.find(familyName));
+        if (aliasSet.size()) {
+            int index = aliasSet[0].pos;
+            specifiedName = genericFamilySet[index]->familyName;
+            return genericFamilySet[index]->typefaceSet.get();
+        }
+    } else if (fallbackNames.find(familyName) != nullptr) {
+        int index = *(fallbackNames.find(familyName));
+        return fallbackSet[index]->typefaceSet.get();
+    }
+    return nullptr;
+}
+
+/*! To load font information from a font file
+ * \param scanner a scanner used to parse the font file
+ * \param fname the full name of a font file
+ * \return NO_ERROR successful
+ * \return ERROR_FONT_NOT_EXIST font file is not exist
+ * \return ERROR_FONT_INVALID_STREAM the stream is not recognized
+ */
+int FontConfig_OHOS::loadFont(const SkTypeface_FreeType::Scanner& scanner, const char* fname)
+{
+    std::unique_ptr<SkStreamAsset> stream = SkStream::MakeFromFile(fname);
+    int count = 1;
+    SkTypeface_FreeType::Scanner::AxisDefinitions axisDefs;
+    FontInfo font(fname, 0);
+    if (stream == nullptr ||
+        scanner.recognizedFont(stream.get(), &count) == false ||
+        scanner.scanFont(stream.get(), 0, &font.familyName, &font.style,
+            &font.isFixedWidth, &axisDefs) == false) {
+        int err = NO_ERROR;
+        if (stream == nullptr) {
+            err = ERROR_FONT_NOT_EXIST;
+        } else {
+            err = ERROR_FONT_INVALID_STREAM;
+        }
+        LOGE("%s : %s\n", errToString(err), fname);
+        char* fnameCopy = strdup(fname);
+        errSet.emplace_back(err, basename(fnameCopy));
+        free(fnameCopy);
+        return err;
+    }
+    // for adjustMap - update weight
+    if (adjustMap.find(font.familyName) != nullptr) {
+        const std::vector<AdjustInfo> adjustSet = *(adjustMap.find(font.familyName));
+        for (unsigned int i = 0; i < adjustSet.size(); i++) {
+            if (font.style.weight() == adjustSet[i].origValue) {
+                font.style = SkFontStyle(adjustSet[i].newValue, font.style.width(), font.style.slant());
+                break;
+            }
+        }
+    }
+    bool ret = false;
+    if (count > 1) {
+        ret = insertTtcFont(count, font);
+    } else if (axisDefs.count() > 0) {
+        ret = insertVariableFont(axisDefs, font);
+    }
+    if (!ret) {
+        SkString specifiedName;
+        TypefaceSet* tpSet = getTypefaceSet(font.familyName, specifiedName);
+        if (tpSet) {
+            sk_sp<SkTypeface_OHOS> typeface = sk_make_sp<SkTypeface_OHOS>(specifiedName, font);
+            tpSet->push_back(std::move(typeface));
+        }
+    }
+    return NO_ERROR;
+}
+
+/*! To scan the system font directories
+ * \param fontScanner the scanner used to parse a font file
+ * \return NO_ERROR success
+ * \return ERROR_DIR_NOT_FOUND a font directory is not exist
+ */
+int FontConfig_OHOS::scanFonts(const SkTypeface_FreeType::Scanner& fontScanner)
+{
+    int err = NO_ERROR;
+    if (fontDirSet.size() == 0) {
+        fontDirSet.emplace_back(SkString("/system/fonts/"));
+    }
+    for (unsigned int i = 0; i < fontDirSet.size(); i++) {
+        DIR* dir = opendir(fontDirSet[i].c_str());
+        if (dir == nullptr) {
+            err = logErrInfo(ERROR_DIR_NOT_FOUND, fontDirSet[i].c_str());
+            continue;
+        }
+        struct dirent* node = nullptr;
+        while ((node = readdir(dir))) {
+            if (node->d_type != DT_REG) {
+                continue;
+            }
+            const char* fname = node->d_name;
+            int len = strlen(fname);
+            int suffixLen = strlen(".ttf");
+            if (len < suffixLen || (strncmp(fname + len - suffixLen, ".ttf", suffixLen) &&
+                strncmp(fname + len - suffixLen, ".otf", suffixLen) &&
+                strncmp(fname + len - suffixLen, ".ttc", suffixLen) &&
+                strncmp(fname + len - suffixLen, ".otc", suffixLen))) {
+                continue;
+            }
+            len += (fontDirSet[i].size() + 2); // 2 more characters for '/' and '\0'
+            char fullname[len];
+            memset(fullname, 0, len);
+            strcpy(fullname, fontDirSet[i].c_str());
+            if (fontDirSet[i][fontDirSet[i].size() - 1] != '/') {
+                strcat(fullname, "/");
+            }
+            strcat(fullname, fname);
+            loadFont(fontScanner, fullname);
+        }
+        closedir(dir);
+    }
+    fontDirSet.clear();
+    return err;
+}
+
+/*! To reset the generic family
+ * \n 1. To sort the typefaces for each font style set in generic list
+ * \n 2. To build typeface set for those font style sets which have single weight value
+ */
+void FontConfig_OHOS::resetGenericValue()
+{
+    aliasMap.foreach([this](SkString& key, std::vector<AliasInfo>* pAliasSet) {
+        std::vector<AliasInfo>& aliasSet = *pAliasSet;
+        int index = aliasSet[0].pos;
+        if (genericFamilySet[index]->typefaceSet->size() == 0) {
+            this->logErrInfo(ERROR_FAMILY_NOT_FOUND, key.c_str());
+        } else {
+            sortTypefaceSet(genericFamilySet[index]->typefaceSet);
+            for (unsigned int i = 1; i < aliasSet.size(); i++) {
+                if (aliasSet[i].weight == 0) {
+                    continue;
+                }
+                buildSubTypefaceSet(genericFamilySet[index]->typefaceSet,
+                    genericFamilySet[index + i]->typefaceSet,
+                    genericFamilySet[index + i]->familyName,
+                    aliasSet[i].weight);
+                if (genericFamilySet[index + i]->typefaceSet->size() == 0) {
+                    this->logErrInfo(ERROR_FAMILY_NOT_FOUND,
+                        genericFamilySet[index + i]->familyName.c_str());
+                }
+            }
+        }
+    });
+
+    aliasMap.reset();
+    adjustMap.reset();
+    variationMap.reset();
+    ttcIndexMap.reset();
+}
+
+/*! To build a sub typeface set according to weight from a typeface set
+ * \param typefaceSet the parent typeface set
+ * \param[out] subSet the sub typeface set returned to the caller
+ * \param familyName the family name of the sub typeface set
+ * \param weight the weight of the sub typeface set
+ */
+void FontConfig_OHOS::buildSubTypefaceSet(const std::shared_ptr<TypefaceSet>& typefaceSet,
+    std::shared_ptr<TypefaceSet>& subSet, const SkString& familyName, int weight)
+{
+    if (typefaceSet->size() == 0) {
+        return;
+    }
+    for (unsigned int i = 0; i < typefaceSet->size(); i++) {
+        const SkTypeface_OHOS* typeface = (*typefaceSet)[i].get();
+        if (typeface && typeface->fontStyle().weight() == weight) {
+            const FontInfo* pFont = typeface->getFontInfo();
+            if (pFont == nullptr) {
+                continue;
+            }
+            FontInfo font(*pFont);
+            sk_sp<SkTypeface_OHOS> newTypeface = sk_make_sp<SkTypeface_OHOS>(familyName, font);
+            subSet->push_back(std::move(newTypeface));
+        }
+    }
+}
+
+/*! To reset the fallback value
+ * \n To sort the typefaces for each font style set in fallback list.
+ */
+void FontConfig_OHOS::resetFallbackValue()
+{
+    for (unsigned int i = 0; i < fallbackSet.size(); i++) {
+        if (fallbackSet[i]->typefaceSet->size() == 0) {
+            logErrInfo(ERROR_FAMILY_NOT_FOUND, fallbackSet[i]->familyName.c_str());
+        }
+        sortTypefaceSet(fallbackSet[i]->typefaceSet);
+    }
+}
+
+/*! To check if an error happened
+ * \param err the id of an error
+ * \param text the key to indicate the part with the error happened
+ * \return false, this kind of error did not happen
+ * \return true, the error happened
+ */
+bool FontConfig_OHOS::hasError(int err, const SkString& text) const
+{
+    for (unsigned int i = 0; i < errSet.size(); i++) {
+        if (errSet[i].err == err && errSet[i].text == text) {
+            return true;
+        }
+    }
+    return false;
+}
+
+/*! To get the total count of errors happened
+ * \return The count of errors
+ */
+int FontConfig_OHOS::getErrorCount() const
+{
+    return errSet.size();
+}
+
+/*! To sort the typeface set
+ * \param typefaceSet the typeface set to be sorted
+ */
+void FontConfig_OHOS::sortTypefaceSet(std::shared_ptr<TypefaceSet>& typefaceSet)
+{
+    if (typefaceSet.get() == nullptr || typefaceSet->size() <= 1) {
+        return;
+    }
+    TypefaceSet& tpSet = *(typefaceSet.get());
+    for (unsigned int i = 0; i < tpSet.size(); i++)
+    for (unsigned int j = 0; j < tpSet.size() - 1; j++) {
+        if ((tpSet[j]->fontStyle().weight() > tpSet[j + 1]->fontStyle().weight()) ||
+            (tpSet[j]->fontStyle().weight() == tpSet[j + 1]->fontStyle().weight() &&
+            tpSet[j]->fontStyle().slant() > tpSet[j + 1]->fontStyle().slant())) {
+            tpSet[j].swap(tpSet[j + 1]);
+        }
+    }
+}
+
+/*! To get the display text of an error
+ * \param err the id of an error
+ * \return The text to explain the error
+ */
+const char* FontConfig_OHOS::errToString(int err)
+{
+    switch (err) {
+      case NO_ERROR: {
+        return "successful";
+      }
+      case ERROR_CONFIG_NOT_FOUND: {
+        return "config file is not found";
+      }
+      case ERROR_CONFIG_FORMAT_NOT_SUPPORTED: {
+        return "the format of config file is not supported";
+      }
+      case ERROR_CONFIG_MISSING_TAG: {
+        return "missing tag";
+      }
+      case ERROR_CONFIG_INVALID_VALUE_TYPE: {
+        return "invalid value type";
+      }
+      case ERROR_FONT_NOT_EXIST: {
+        return "font file is not exist";
+      }
+      case ERROR_FONT_NO_STREAM: {
+        return "no font stream";
+      }
+      case ERROR_FONT_INVALID_STREAM: {
+        return "invalid font stream";
+      }
+      case ERROR_FAMILY_NOT_FOUND: {
+        return "family is not found";
+      }
+      case ERROR_NO_AVAILABLE_FAMILY: {
+        return "no available family in the system";
+      }
+      case ERROR_DIR_NOT_FOUND: {
+        return "no such directory";
+      }
+      default: {
+        return "unknown error";
+      }
+    }
+    return "unknown error";
+}
+
+/*! To log the error information
+ * \param err the id of an error
+ * \param key the key which indicates the the part with the error
+ * \param expected the expected type of json node.
+ * \n     It's used only for err 'ERROR_CONFIG_INVALID_VALUE_TYPE'
+ * \param actual the actual type of json node.
+ * \n     It's used only for err 'ERROR_CONFIG_INVALID_VALUE_TYPE'
+ * \return err
+ */
+int FontConfig_OHOS::logErrInfo(int err, const char* key, Json::ValueType expected,
+    Json::ValueType actual)
+{
+    errSet.emplace_back(err, key);
+    if (err != ERROR_CONFIG_INVALID_VALUE_TYPE) {
+        LOGE("%s : %s\n", errToString(err), key);
+    } else {
+        const char* types[] = {
+            "null",
+            "int",
+            "unit",
+            "real",
+            "string",
+            "boolean",
+            "array",
+            "object",
+        };
+        int size = sizeof(types) / sizeof(char*);
+        if ((expected >= 0 && expected < size) &&
+            (actual >= 0 && actual < size)) {
+            LOGE("%s : '%s' should be '%s', but here it's '%s'\n",
+                errToString(err), key, types[expected], types[actual]);
+        } else {
+            LOGE("%s : %s\n", errToString(err), key);
+        }
+    }
+    return err;
+}
diff --git a/third_party/skia/src/ports/skia_ohos/FontConfig_ohos.h b/third_party/skia/src/ports/skia_ohos/FontConfig_ohos.h
new file mode 100644
index 0000000000..16edfdc31b
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/FontConfig_ohos.h
@@ -0,0 +1,230 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef FONTCONFIG_OHOS_H
+#define FONTCONFIG_OHOS_H
+
+#include <json/json.h>
+#include <vector>
+
+#include "src/core/SkFontDescriptor.h"
+#include "src/ports/SkFontHost_FreeType_common.h"
+#include "include/core/SkFontStyle.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+
+#include "FontInfo_ohos.h"
+#include "SkTypeface_ohos.h"
+
+#ifdef ENABLE_DEBUG
+
+#define LOGE(fmt, args...)        \
+    printf("E %s:%d  %s - " fmt, basename(__FILE__), __LINE__, __FUNCTION__, ##args)
+#define LOGI(fmt, args...)        \
+    printf("I %s:%d - " fmt,  __FUNCTION__, __LINE__, ##args)
+#define LOGW(fmt, args...)        \
+    printf("W %s:%d  %s - " fmt, basename(__FILE__), __LINE__, __FUNCTION__, ##args)
+
+#else
+
+#define LOGE        SkDEBUGF
+#define LOGI        SkDEBUGF
+#define LOGW        SkDEBUGF
+
+#endif
+
+struct FontInfo;
+struct FallbackInfo;
+struct GenericFamily;
+struct FallbackSetPos;
+
+using TypefaceSet = std::vector<sk_sp<SkTypeface_OHOS>>;
+using GenericFamilySet = std::vector<std::unique_ptr<GenericFamily>>;
+using FallbackSet = std::vector<std::unique_ptr<FallbackInfo>>;
+using FallbackForMap = SkTHashMap<SkString, FallbackSetPos>;
+using NamesMap = SkTHashMap<SkString, int>;
+using Coordinate = SkFontArguments::VariationPosition::Coordinate;
+using AxisDefinitions = SkTypeface_FreeType::Scanner::AxisDefinitions;
+
+/*!
+ * Error code definition
+ */
+namespace ErrorCode {
+
+enum  {
+    NO_ERROR = 0,                           // no error
+    ERROR_CONFIG_NOT_FOUND,                 // the configuration document is not found
+    ERROR_CONFIG_FORMAT_NOT_SUPPORTED,      // the formation of configuration is not supported
+    ERROR_CONFIG_MISSING_TAG,               // missing tag in the configuration
+    ERROR_CONFIG_INVALID_VALUE_TYPE,        // invalid value type in the configuration
+    ERROR_FONT_NOT_EXIST,                   // the font file is not exist
+    ERROR_FONT_INVALID_STREAM,              // the stream is not recognized
+    ERROR_FONT_NO_STREAM,                   // no stream in the font data
+    ERROR_FAMILY_NOT_FOUND,                 // the family name is not found in the system
+    ERROR_NO_AVAILABLE_FAMILY,              // no available family in the system
+    ERROR_DIR_NOT_FOUND,                    // the directory is not exist
+};
+
+} /* namespace ErrorCode */
+
+/*!
+ *  \brief To manage the related information of a 'fallbackFor' family name
+ */
+struct FallbackSetPos {
+    unsigned int index; // the index of the first font style set in the fallback set for a specified family name
+    unsigned int count; // the count of font style sets for a specified family name
+};
+
+/*!
+ * \brief To manage the information for a generic family item
+ */
+struct GenericFamily {
+    SkString familyName; // the specified family name of the font style set
+    std::shared_ptr<TypefaceSet> typefaceSet; // the typeface set of the font style set
+    virtual ~GenericFamily() = default;
+};
+
+/*!
+ * \brief To manage the information for a fallback family item
+ */
+struct FallbackInfo : GenericFamily {
+    SkString langs; // the language for which the font style set is
+};
+
+/*!
+ * \brief To parse the font configuration document and manage the system fonts
+ */
+class FontConfig_OHOS {
+public:
+    explicit FontConfig_OHOS(const SkTypeface_FreeType::Scanner& fontScanner,
+        const char* fname = nullptr);
+    virtual ~FontConfig_OHOS() = default;
+    const FallbackForMap& getFallbackForMap() const;
+    const FallbackSet& getFallbackSet() const;
+    int getFamilyCount() const;
+    int getDefaultFamily(SkString* familyName) const;
+    int getFamilyName(int index, SkString* familyName) const;
+    int getTypefaceCount(int styleIndex, bool isFallback = false) const;
+    int getStyleIndex(const char* familyName, bool& isFallback) const;
+
+    SkTypeface_OHOS* getTypeface(int styleIndex, int index, bool isFallback = false) const;
+    SkTypeface_OHOS* getTypeface(int styleIndex, const SkFontStyle& style,
+        bool isFallback = false) const;
+
+#if ENABLE_DEBUG
+    void dumpFont(const FontInfo& font) const;
+    void dumpGeneric() const;
+    void dumpFallback() const;
+#endif
+    bool hasError(int err, const SkString& text) const;
+    int getErrorCount() const;
+
+    static sk_sp<SkTypeface_OHOS> matchFontStyle(const TypefaceSet& typefaceSet, const SkFontStyle& pattern);
+
+    static const char* errToString(int err);
+private:
+    struct AliasInfo;
+    struct AdjustInfo;
+    struct VariationInfo;
+    struct TtcIndexInfo;
+    using AliasMap = SkTHashMap<SkString, std::vector<AliasInfo>>;
+    using AjdustMap = SkTHashMap<SkString, std::vector<AdjustInfo>>;
+    using VariationMap = SkTHashMap<SkString, std::vector<VariationInfo>>;
+    using TtcIndexMap = SkTHashMap<SkString, TtcIndexInfo>;
+
+    /*!
+     * \brief To manage the adjust information
+     */
+    struct AdjustInfo {
+        int origValue; // the real value of the font weight
+        int newValue; // the specified value of weight for a font
+    };
+
+    /*!
+     * \brief To manage the alias information of
+     */
+    struct AliasInfo {
+        int pos; // the index of a font style set in generic family list.
+        int weight; // the weight of the font style set. 0 means no specified weight
+    };
+
+    /*!
+     * \brief To manage the variation information
+     */
+    struct VariationInfo {
+        VariationInfo() : weight(-1), width(-1), slant(-1){}
+        std::vector<Coordinate> axis; // the axis set such as 'wght', 'wdth' and 'slnt'.
+        int weight; // the value of mapping weight
+        int width;  // the value of mapping width
+        int slant; // the value of mapping slant
+    };
+
+    /*!
+     * \brief To manage the 'index' information for ttc fonts
+     */
+    struct TtcIndexInfo {
+        SkString familyName; // the family name of the first typeface in a ttc font
+        int ttcIndex; // the index of a typeface in a ttc font
+    };
+
+    /*!
+     * \brief To manage the information of errors happened
+     */
+    struct ErrorInfo {
+        ErrorInfo(int err, const char* text) : err(err), text(SkString(text)){}
+        ErrorInfo(int err, SkString& text) : err(err), text(std::move(text)){}
+        int err; // error id
+        SkString text; // the part with error
+    };
+
+    std::vector<SkString> fontDirSet; // the directories where the fonts are
+
+    FallbackForMap    fallbackForMap; // a hash table to save the fallbackFor pairs
+    GenericFamilySet genericFamilySet; // the font style set list of generic family
+    FallbackSet fallbackSet; // the font style set list of fallback family
+
+    NamesMap genericNames; // a map to store the index of a family for generic family
+    NamesMap fallbackNames; // a map to store the index of a family for fallback family
+
+    std::vector<ErrorInfo> errSet; // the errors happened
+    AliasMap aliasMap; // to save alias information temporarily
+    AjdustMap adjustMap; // to save adjust information temporarily
+    VariationMap variationMap; // to save variation information temporarily
+    TtcIndexMap ttcIndexMap; // to save 'index' information temporarily
+
+    int parseConfig(const char* fname);
+    int checkConfigFile(const char* fname, Json::Value& root);
+    int parseFontDir(const Json::Value& root);
+    int parseGeneric(const Json::Value& root);
+    int parseFallback(const Json::Value& root);
+    int parseFallbackItem(const Json::Value& root);
+    int parseAlias(const Json::Value& root, std::vector<AliasInfo>& aliasSet);
+    int parseAdjust(const Json::Value& root, std::vector<AdjustInfo>& adjustSet);
+    int parseVariation(const Json::Value& root, std::vector<VariationInfo>& variationSet);
+    int parseTtcIndex(const Json::Value& root, const SkString& familyName);
+    void getAxisValues(const AxisDefinitions& axisDefinitions,
+        const VariationInfo& variation, FontInfo& font) const;
+    bool insertTtcFont(int count, FontInfo& font);
+    bool insertVariableFont(const AxisDefinitions& axisDefinitions, FontInfo& font);
+    TypefaceSet* getTypefaceSet(const SkString& familyName, SkString& specifiedName) const;
+
+    int loadFont(const SkTypeface_FreeType::Scanner& scanner, const char* fname);
+    int scanFonts(const SkTypeface_FreeType::Scanner& fontScanner);
+    void resetGenericValue();
+    void buildSubTypefaceSet(const std::shared_ptr<TypefaceSet>& typefaceSet,
+        std::shared_ptr<TypefaceSet>& subSet, const SkString& familyName, int weight);
+    void resetFallbackValue();
+    int logErrInfo(int err, const char* key, Json::ValueType expected = Json::nullValue,
+        Json::ValueType actual = Json::nullValue);
+    static void sortTypefaceSet(std::shared_ptr<TypefaceSet>& typefaceSet);
+    static uint32_t getFontStyleDifference(const SkFontStyle& style1, const SkFontStyle& style2);
+    static char* getFileData(const char* fname, int& size);
+    FontConfig_OHOS(const FontConfig_OHOS&) = delete;
+    FontConfig_OHOS& operator = (const FontConfig_OHOS&) = delete;
+    FontConfig_OHOS(FontConfig_OHOS&&) = delete;
+    FontConfig_OHOS& operator = (FontConfig_OHOS&&) = delete;
+};
+
+#endif /* FONTCONFIG_OHOS_H */
diff --git a/third_party/skia/src/ports/skia_ohos/FontInfo_ohos.h b/third_party/skia/src/ports/skia_ohos/FontInfo_ohos.h
new file mode 100644
index 0000000000..4c80e099af
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/FontInfo_ohos.h
@@ -0,0 +1,147 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef FONTINFO_OHOS_H
+#define FONTINFO_OHOS_H
+
+#include <vector>
+
+#include "include/private/SkFixed.h"
+#include "src/core/SkFontDescriptor.h"
+#include "src/ports/SkFontHost_FreeType_common.h"
+
+/*!
+ * \brief To manage the font information
+ */
+struct FontInfo {
+public:
+    /*! Constructor
+     *
+     */
+    FontInfo() : familyName(""), fname(""), index(0),
+        style(SkFontStyle::Normal()), isFixedWidth(false), stream(nullptr)
+    {
+        memset(&axisSet, 0, sizeof(AxisSet));
+    }
+    /*! Copy Constructor
+     * \param font an object of FontInfo
+     */
+    explicit FontInfo(const FontInfo& font)
+        : familyName(font.familyName), fname(font.fname), index(font.index),
+          style(font.style), isFixedWidth(font.isFixedWidth), stream(nullptr)
+    {
+        axisSet.axis = font.axisSet.axis;
+        axisSet.range = font.axisSet.range;
+        if (font.stream) {
+            stream = font.stream->duplicate();
+        }
+    }
+
+    /*! Move Constructor
+     * \param font an object of FontInfo
+     */
+    explicit FontInfo(FontInfo&& font)
+        : familyName(std::move(font.familyName)), fname(std::move(font.fname)), index(font.index),
+          style(font.style), isFixedWidth(font.isFixedWidth), stream(nullptr)
+    {
+        axisSet.axis = std::move(font.axisSet.axis);
+        axisSet.range = std::move(font.axisSet.range);
+        if (font.stream) {
+            stream = std::move(font.stream);
+        }
+    }
+
+    /*! Constructor
+     * \param fname the fullname of font file
+     * \param index the index of the typeface in the font file
+     */
+    FontInfo(const char* fname, int index)
+        : familyName(""), fname(""), index(index),
+          style(SkFontStyle::Normal()), isFixedWidth(false), stream(nullptr)
+    {
+        if (fname) {
+            this->fname.set(fname);
+        }
+        memset(&axisSet, 0, sizeof(axisSet));
+    }
+
+    /*! Destructor
+     *
+     */
+    virtual ~FontInfo() = default;
+
+    /*! Copy assignment operator
+     * \param font an object of FontInfo
+     */
+    FontInfo& operator = (const FontInfo& font)
+    {
+        if (this == &font) {
+            return *this;
+        }
+        familyName = font.familyName;
+        fname = font.fname;
+        index = font.index;
+        style = font.style;
+        isFixedWidth = font.isFixedWidth;
+        axisSet.axis = font.axisSet.axis;
+        axisSet.range = font.axisSet.range;
+        if (font.stream) {
+            stream = font.stream->duplicate();
+        }
+        return *this;
+    }
+
+    /*! The move assignment operator
+     * \param font an object of FontInfo
+     */
+    FontInfo& operator = (FontInfo&& font)
+    {
+        if (this == &font) {
+            return *this;
+        }
+        familyName = std::move(font.familyName);
+        fname = std::move(font.fname);
+        index = font.index;
+        style = font.style;
+        isFixedWidth = font.isFixedWidth;
+        axisSet.axis = std::move(font.axisSet.axis);
+        axisSet.range = std::move(font.axisSet.range);
+        if (font.stream) {
+            stream = std::move(font.stream);
+        }
+        return *this;
+    }
+
+    /*! To set axis values
+     * \param count the count of axis
+     * \param axis an array of SkFixed value
+     * \param range an array of AxisDefinition
+     */
+    void setAxisSet(int count, const SkFixed* axis,
+        const SkTypeface_FreeType::Scanner::AxisDefinition* range)
+    {
+        axisSet.axis.clear();
+        axisSet.range.clear();
+        for (int i = 0; i < count; i++) {
+            axisSet.axis.emplace_back(axis[i]);
+            axisSet.range.emplace_back(range[i]);
+        }
+    }
+
+    SkString familyName;  // the real family name of the font
+    SkString fname; // the full name of font file
+    int index; // the index of the font in a ttc font
+    SkFontStyle style; // the font style
+    bool isFixedWidth; // the flag to indicate if the font has fixed width or not
+    /*!
+     * \brief To manage the axis values for variable font
+     */
+    struct AxisSet {
+        std::vector<SkFixed> axis;  // the axis values
+        std::vector<SkTypeface_FreeType::Scanner::AxisDefinition> range; // the axis ranges
+    } axisSet; // the axis values for a variable font
+    std::unique_ptr<SkStreamAsset> stream; // the data stream of font file
+};
+
+#endif /* FONTINFO_OHOS_H */
diff --git a/third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.cpp b/third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.cpp
new file mode 100644
index 0000000000..7fe7c136e3
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.cpp
@@ -0,0 +1,490 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "SkFontMgr_ohos.h"
+
+#include "SkTypeface_ohos.h"
+
+using namespace ErrorCode;
+
+/*! Constructor
+ * \param path the full path of system font configuration document
+ */
+SkFontMgr_OHOS::SkFontMgr_OHOS(const char* path)
+{
+    fontConfig = std::make_shared<FontConfig_OHOS>(fontScanner, path);
+    familyCount = fontConfig->getFamilyCount();
+}
+
+/*! To get the count of families
+ * \return The count of families in the system
+ */
+int SkFontMgr_OHOS::onCountFamilies() const
+{
+    return familyCount;
+}
+
+/*! To get the family name for a font style set
+ * \param index the index of a font style set
+ * \param[out] familyName the family name returned to the caller
+ * \n          The family name will be reset to "", if index is out of range
+ */
+void SkFontMgr_OHOS::onGetFamilyName(int index, SkString* familyName) const
+{
+    if (fontConfig == nullptr || familyName == nullptr) {
+        return;
+    }
+    fontConfig->getFamilyName(index, familyName);
+}
+
+/*! To create an object of SkFontStyleSet
+ * \param index the index of a font style set
+ * \return The pointer of SkFontStyleSet
+ * \n      Return null, if index is out of range
+ * \note   The caller must call unref() on the returned object if it's not null
+ */
+SkFontStyleSet* SkFontMgr_OHOS::onCreateStyleSet(int index) const
+{
+    if (fontConfig == nullptr) {
+        return nullptr;
+    }
+    if (index < 0 || index >= this->countFamilies()) {
+        return nullptr;
+    }
+    return new SkFontStyleSet_OHOS(fontConfig, index);
+}
+
+/*! To get a matched object of SkFontStyleSet
+ * \param familyName the family name of a font style set
+ * \return The pointer of SkFontStyleSet
+ * \n      Return the default font style set, if family name is null
+ * \n      Return null, if family name is not found
+ * \note   The caller must call unref() on the returned object if it's not null
+ */
+SkFontStyleSet* SkFontMgr_OHOS::onMatchFamily(const char familyName[]) const
+{
+    if (fontConfig == nullptr) {
+        return nullptr;
+    }
+    // return default system font when familyName is null
+    if (familyName == nullptr) {
+        return new SkFontStyleSet_OHOS(fontConfig, 0);
+    }
+
+    bool isFallback = false;
+    int index = fontConfig->getStyleIndex(familyName, isFallback);
+    if (index == -1) {
+        return nullptr;
+    }
+    return new SkFontStyleSet_OHOS(fontConfig, index, isFallback);
+}
+
+/*! To get a matched typeface
+ * \param familyName the family name of a font style set
+ * \param style the font style to be matched
+ * \return An object of typeface which is closest matching to 'style'
+ * \n      Return the typeface in the default font style set, if family name is null
+ * \n      Return null, if family name is not found
+ * \note   The caller must call unref() on the returned object if it's not null
+ */
+SkTypeface* SkFontMgr_OHOS::onMatchFamilyStyle(const char familyName[], const SkFontStyle& style) const
+{
+    if (fontConfig == nullptr) {
+        return nullptr;
+    }
+    bool isFallback = false;
+    int styleIndex = 0;
+    if (familyName) {
+        styleIndex = fontConfig->getStyleIndex(familyName, isFallback);
+    }
+    return SkSafeRef(fontConfig->getTypeface(styleIndex, style, isFallback));
+}
+
+/*! To get a matched typeface
+ * \n Use the system fallback to find a typeface for the given character.
+ * \param familyName the family name which the typeface is fallback For
+ * \param style the font style to be matched
+ * \param bcp47 an array of languages which indicate the language of 'character'
+ * \param bcp47Count the array size of bcp47
+ * \param character a UTF8 value to be matched
+ * \return An object of typeface which is for the given character
+ * \return Return the typeface in the default fallback set, if familyName is null
+ * \return Return null, if the typeface is not found for the given character
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+SkTypeface* SkFontMgr_OHOS::onMatchFamilyStyleCharacter(const char familyName[], const SkFontStyle& style,
+    const char* bcp47[], int bcp47Count, SkUnichar character) const
+{
+    if (fontConfig == nullptr) {
+        return nullptr;
+    }
+    const FallbackForMap& fallbackForMap = fontConfig->getFallbackForMap();
+    const FallbackSet& fallbackSet = fontConfig->getFallbackSet();
+    SkString defaultFamily("");
+    SkString key = defaultFamily;
+    FallbackSetPos* item = nullptr;
+    if (familyName == nullptr) {
+        item = fallbackForMap.find(defaultFamily);
+    } else {
+        item = fallbackForMap.find(SkString(familyName));
+        if (item) {
+            key = SkString(familyName);
+        } else {
+            item = fallbackForMap.find(defaultFamily);
+        }
+    }
+    if (item == nullptr) {
+        LOGE("%s : '%s' must be a fallback key in the config file\n",
+            FontConfig_OHOS::errToString(ERROR_FAMILY_NOT_FOUND), defaultFamily.c_str());
+        return nullptr;
+    }
+    while (true) {
+        if (bcp47Count > 0) {
+            SkTypeface* retTp = findTypeface(*item, style, bcp47, bcp47Count, character);
+            if (retTp) {
+                return retTp;
+            }
+            if (key == defaultFamily) {
+                bcp47Count = 0;
+                continue;
+            }
+            item = fallbackForMap.find(defaultFamily);
+            key = defaultFamily;
+        } else {
+            for (unsigned int i = item->index; i < item->index + item->count && i < fallbackSet.size(); i++) {
+                const TypefaceSet& tpSet = *(fallbackSet[i]->typefaceSet.get());
+                if (tpSet.size() > 0 && tpSet[0]->unicharToGlyph(character) != 0) {
+                    sk_sp<SkTypeface> typeface = FontConfig_OHOS::matchFontStyle(tpSet, style);
+                    return SkSafeRef(typeface.get());
+                }
+            }
+            if (key == defaultFamily) {
+                break;
+            }
+            item = fallbackForMap.find(defaultFamily);
+            key = defaultFamily;
+        }
+    }
+    return nullptr;
+}
+
+/*! To find the matched typeface for the given parameters
+ * \n Use the system fallback to find a typeface for the given character.
+ * \param fallbackItem the fallback items in which to find the typeface
+ * \param style the font style to be matched
+ * \param bcp47 an array of languages which indicate the language of 'character'
+ * \param bcp47Count the array size of bcp47
+ * \param character a UTF8 value to be matched
+ * \return An object of typeface which is for the given character
+ * \return Return null, if the typeface is not found for the given character
+ */
+SkTypeface* SkFontMgr_OHOS::findTypeface(const FallbackSetPos& fallbackItem, const SkFontStyle& style,
+    const char* bcp47[], int bcp47Count, SkUnichar character) const
+{
+    if (bcp47Count == 0) {
+        return nullptr;
+    }
+
+    const FallbackSet& fallbackSet = fontConfig->getFallbackSet();
+    // example bcp47 code : 'zh-Hans' : ('zh' : iso639 code, 'Hans' : iso15924 code)
+    // iso639 code will be taken from bcp47 code, so that we can try to match
+    // bcp47 or only iso639. Therefore totalCount need to be 'bcp47Count * 2'
+    int totalCount = bcp47Count * 2;
+    int tps[totalCount];
+    for (int i = 0; i < totalCount; i++) {
+        tps[i] = -1;
+    }
+    // find the families matching the bcp47 list
+    for (unsigned int i = fallbackItem.index; i < fallbackItem.index + fallbackItem.count
+        && i < fallbackSet.size(); i++) {
+        int ret = compareLangs(fallbackSet[i]->langs, bcp47, bcp47Count, tps);
+        if (ret == -1) {
+            continue;
+        }
+        tps[ret] = i;
+    }
+    // match typeface in families
+    for (int i = bcp47Count - 1; i >= 0; i--) {
+        if (tps[i] == -1) {
+            continue;
+        }
+        const TypefaceSet& tpSet = *(fallbackSet[tps[i]]->typefaceSet.get());
+        if (tpSet.size() > 0 && tpSet[0]->unicharToGlyph(character) != 0) {
+            sk_sp<SkTypeface> typeface = FontConfig_OHOS::matchFontStyle(tpSet, style);
+            return SkSafeRef(typeface.get());
+        }
+    }
+    for (int i = totalCount - 1; i >= bcp47Count; i--) {
+        if (tps[i] == -1) {
+            continue;
+        }
+        const TypefaceSet& tpSet = *(fallbackSet[tps[i]]->typefaceSet.get());
+        if (tpSet.size() > 0 && tpSet[0]->unicharToGlyph(character) != 0) {
+            sk_sp<SkTypeface> typeface = FontConfig_OHOS::matchFontStyle(tpSet, style);
+            return SkSafeRef(typeface.get());
+        }
+    }
+    return nullptr;
+}
+
+/*! To compare the languages of an typeface with a bcp47 list
+ * \param langs the supported languages by an typeface
+ * \param bcp47 the array of bcp47 language to be matching
+ * \param bcp47Count the array size of bcp47
+ * \param tps an array of the index of typeface which is matching one value of bcp47
+ * \return The index of language in bcp47, if matching happens
+ * \n      Return -1, if no language matching happens
+ */
+int SkFontMgr_OHOS::compareLangs(const SkString& langs, const char* bcp47[],
+    int bcp47Count, const int tps[]) const
+{
+    /*
+     * zh-Hans : ('zh' : iso639 code, 'Hans' : iso15924 code)
+     */
+    if (bcp47 == nullptr || bcp47Count == 0) {
+        return -1;
+    }
+    for (int i = bcp47Count - 1; i >= 0; i--) {
+        if (tps[i] != -1) {
+            continue;
+        }
+        if (langs.find(bcp47[i]) != -1) {
+            return i;
+        } else {
+            const char* iso15924 = strrchr(bcp47[i], '-');
+            if (iso15924 == nullptr) {
+                continue;
+            }
+            iso15924++;
+            int len = iso15924 - 1 - bcp47[i];
+            SkString country(bcp47[i], len);
+            if (langs.find(iso15924) != -1 ||
+                (strncmp(bcp47[i], "und", strlen("und")) && langs.find(country.c_str()) != -1)) {
+                return i + bcp47Count;
+            }
+        }
+    }
+    return -1;
+}
+
+/*! To get a matched typeface
+ * \param typeface the given typeface with which the returned object should be in the same style set
+ * \param style the font style to be matching
+ * \return The object of typeface which is closest matching to the given 'style'
+ * \n      Return null, if the family name of the given typeface is not found in the system
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+SkTypeface* SkFontMgr_OHOS::onMatchFaceStyle(const SkTypeface* typeface, const SkFontStyle& style) const
+{
+    if (typeface == nullptr) {
+        return nullptr;
+    }
+    SkString familyName;
+    typeface->getFamilyName(&familyName);
+    return this->onMatchFamilyStyle(familyName.c_str(), style);
+}
+
+/*! To create a typeface from the specified data and TTC index
+ * \param data the data to be parsed
+ * \param index the index of typeface. 0 for none
+ * \return The object of typeface, if successful
+ * \n      Return null if the data is not recognized.
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::onMakeFromData(sk_sp<SkData> data, int ttcIndex) const
+{
+    if (data == nullptr) {
+        return nullptr;
+    }
+    std::unique_ptr<SkMemoryStream> memoryStream = std::make_unique<SkMemoryStream>(data);
+    SkFontArguments args;
+    args.setCollectionIndex(ttcIndex);
+    return this->makeTypeface(std::move(memoryStream), args, nullptr);
+}
+
+/*! To create a typeface from the specified stream and TTC index
+ * \param data the stream to be parsed
+ * \param index the index of typeface. 0 for none
+ * \return The object of typeface, if successful
+ * \n      Return null if the stream is not recognized.
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::onMakeFromStreamIndex(std::unique_ptr<SkStreamAsset> stream,
+    int ttcIndex) const
+{
+    if (stream == nullptr) {
+        return nullptr;
+    }
+    SkFontArguments args;
+    args.setCollectionIndex(ttcIndex);
+    return this->makeTypeface(std::move(stream), args, nullptr);
+}
+
+/*! To create a typeface from the specified stream and font arguments
+ * \param data the stream to be parsed
+ * \param args the arguments of font
+ * \return The object of typeface, if successful
+ * \n      Return null if the stream is not recognized.
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::onMakeFromStreamArgs(std::unique_ptr<SkStreamAsset> stream,
+    const SkFontArguments& args) const
+{
+    if (stream == nullptr) {
+        return nullptr;
+    }
+    return this->makeTypeface(std::move(stream), args, nullptr);
+}
+
+/*! To create a typeface from the specified font data
+ * \param fontData the given font data used to create a typeface
+ * \return The object of typeface, if successful
+ * \n      Return null if the typeface cannot be created from the font data.
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::onMakeFromFontData(std::unique_ptr<SkFontData> data) const
+{
+    if (fontConfig == nullptr) {
+        return nullptr;
+    }
+    if (data == nullptr || !data->hasStream()) {
+        LOGE("%s\n", FontConfig_OHOS::errToString(ERROR_FONT_NO_STREAM));
+        return nullptr;
+    }
+
+    return makeTypeface(data.get());
+}
+
+/*! To create a typeface from the specified font file and TTC index
+ * \param path the full path of the given font file
+ * \param ttcIndex the index of typeface in a ttc font file. 0 means none.
+ * \return The object of typeface, if successful
+ * \n      Return null if the font file is not found or the content of file is not recognized.
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::onMakeFromFile(const char path[], int ttcIndex) const
+{
+    if (fontConfig == nullptr) {
+        return nullptr;
+    }
+
+    std::unique_ptr<SkStreamAsset> stream = SkStreamAsset::MakeFromFile(path);
+    if (stream == nullptr) {
+        LOGE("%s : %s\n", FontConfig_OHOS::errToString(ERROR_FONT_NOT_EXIST), path);
+        return nullptr;
+    }
+    SkFontArguments args;
+    args.setCollectionIndex(ttcIndex);
+    return this->makeTypeface(std::move(stream), args, path);
+}
+
+/*! To get a typeface matching the specified family and style
+ * \param familyName the specified name to be matching
+ * \param style the specified style to be matching
+ * \return The object of typeface which is the closest matching 'style' when the familyName is found
+ * \return Return a typeface from the default family, if familyName is not found
+ * \return Return null, if there is no any typeface in the system
+ * \note The caller must caller unref() on the returned object is it's not null
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::onLegacyMakeTypeface(const char familyName[], SkFontStyle style) const
+{
+    SkTypeface* typeface = this->onMatchFamilyStyle(familyName, style);
+    // if familyName is not found, then try the default family
+    if (typeface == nullptr && familyName != nullptr) {
+        typeface = this->onMatchFamilyStyle(nullptr, style);
+    }
+
+    if (typeface) {
+        return sk_sp<SkTypeface>(typeface);
+    }
+    LOGE("%s\n", FontConfig_OHOS::errToString(ERROR_NO_AVAILABLE_FAMILY));
+    return nullptr;
+}
+
+/*! To make a typeface from the specified stream and font arguments
+ * \param stream the specified stream to be parsed to get font information
+ * \param args the arguments of index or axis values
+ * \param path the fullname of font file
+ * \return The object of typeface if successful
+ * \n      Return null, if the stream is not recognized
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::makeTypeface(std::unique_ptr<SkStreamAsset> stream,
+    const SkFontArguments& args, const char path[]) const
+{
+    FontInfo fontInfo;
+    int ttcIndex = args.getCollectionIndex();
+    int axisCount = args.getVariationDesignPosition().coordinateCount;
+
+    if (path) {
+        fontInfo.fname.set(path);
+    }
+    if (axisCount == 0) {
+        if (!fontScanner.scanFont(stream.get(), ttcIndex, &fontInfo.familyName, &fontInfo.style,
+            &fontInfo.isFixedWidth, nullptr)) {
+            LOGE("%s\n", FontConfig_OHOS::errToString(ERROR_FONT_INVALID_STREAM));
+            return nullptr;
+        }
+    } else {
+        AxisDefinitions axisDef;
+        if (!fontScanner.scanFont(stream.get(), ttcIndex, &fontInfo.familyName, &fontInfo.style,
+            &fontInfo.isFixedWidth, &axisDef)) {
+            LOGE("%s\n", FontConfig_OHOS::errToString(ERROR_FONT_INVALID_STREAM));
+            return nullptr;
+        }
+        if (axisDef.count() > 0) {
+            SkFixed axis[axisCount];
+            fontScanner.computeAxisValues(axisDef, args.getVariationDesignPosition(),
+                axis, fontInfo.familyName);
+            fontInfo.setAxisSet(axisCount, axis, axisDef.data());
+        }
+    }
+
+    fontInfo.stream = std::move(stream);
+    fontInfo.index = ttcIndex;
+    return sk_make_sp<SkTypeface_OHOS>(fontInfo);
+}
+
+/*! To make a typeface from the specified font data
+ * \param fontData the given font data used to create a typeface
+ * \return The object of typeface, if successful
+ * \n      Return null, if the font data is not recognized
+ */
+sk_sp<SkTypeface> SkFontMgr_OHOS::makeTypeface(SkFontData* fontData) const
+{
+    FontInfo fontInfo;
+    int ttcIndex = fontData->getIndex();
+    int axisCount = fontData->getAxisCount();
+    SkStreamAsset* stream = fontData->getStream();
+    if (axisCount == 0) {
+        if (!fontScanner.scanFont(stream, ttcIndex, &fontInfo.familyName, &fontInfo.style,
+            &fontInfo.isFixedWidth, nullptr)) {
+            LOGE("%s\n", FontConfig_OHOS::errToString(ERROR_FONT_INVALID_STREAM));
+            return nullptr;
+        }
+    } else {
+        const SkFixed* axis = fontData->getAxis();
+        AxisDefinitions axisDefs;
+        if (!fontScanner.scanFont(stream, ttcIndex, &fontInfo.familyName, &fontInfo.style,
+            &fontInfo.isFixedWidth, &axisDefs)) {
+            LOGE("%s\n", FontConfig_OHOS::errToString(ERROR_FONT_INVALID_STREAM));
+            return nullptr;
+        }
+        if (axisDefs.count() > 0) {
+            fontInfo.setAxisSet(axisCount, axis, axisDefs.data());
+        }
+    }
+
+    fontInfo.stream = fontData->detachStream();
+    fontInfo.index = ttcIndex;
+    return sk_make_sp<SkTypeface_OHOS>(fontInfo);
+}
+
+/*! To create SkFontMgr object for Harmony platform
+ * \param fname the full name of system font configuration documents
+ * \return The object of SkFontMgr_OHOS
+ */
+sk_sp<SkFontMgr> SkFontMgr_New_OHOS(const char* fname)
+{
+    return sk_make_sp<SkFontMgr_OHOS>(fname);
+}
diff --git a/third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.h b/third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.h
new file mode 100644
index 0000000000..9879726589
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/SkFontMgr_ohos.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2015 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ * 2021.2.10 SkFontMgr on ohos.
+ *           Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved.
+ */
+
+#ifndef SKFONTMGR_OHOS_H
+#define SKFONTMGR_OHOS_H
+
+#include "src/core/SkFontDescriptor.h"
+#include "include/core/SkFontMgr.h"
+
+#include "FontConfig_ohos.h"
+#include "SkFontStyleSet_ohos.h"
+
+/*!
+ * \brief To implement the SkFontMgr for ohos platform
+ */
+class SkFontMgr_OHOS : public SkFontMgr {
+public:
+    explicit SkFontMgr_OHOS(const char* path = nullptr);
+    virtual ~SkFontMgr_OHOS() override = default;
+protected:
+    virtual int onCountFamilies() const override;
+    virtual void onGetFamilyName(int index, SkString* familyName) const override;
+    virtual SkFontStyleSet* onCreateStyleSet(int index)const override;
+
+    virtual SkFontStyleSet* onMatchFamily(const char familyName[]) const override;
+
+    virtual SkTypeface* onMatchFamilyStyle(const char familyName[],
+                                           const SkFontStyle& style) const override;
+    virtual SkTypeface* onMatchFamilyStyleCharacter(const char familyName[], const SkFontStyle& style,
+                                                    const char* bcp47[], int bcp47Count,
+                                                    SkUnichar character) const override;
+
+    virtual SkTypeface* onMatchFaceStyle(const SkTypeface* typeface,
+                                         const SkFontStyle& style) const override;
+
+    virtual sk_sp<SkTypeface> onMakeFromData(sk_sp<SkData> data, int ttcIndex) const override;
+    virtual sk_sp<SkTypeface> onMakeFromStreamIndex(std::unique_ptr<SkStreamAsset> stream,
+                                                    int ttcIndex) const override;
+    virtual sk_sp<SkTypeface> onMakeFromStreamArgs(std::unique_ptr<SkStreamAsset> stream,
+                                                   const SkFontArguments& args) const override;
+    virtual sk_sp<SkTypeface> onMakeFromFontData(std::unique_ptr<SkFontData> data) const override;
+    virtual sk_sp<SkTypeface> onMakeFromFile(const char path[], int ttcIndex) const override;
+
+    virtual sk_sp<SkTypeface> onLegacyMakeTypeface(const char familyName[], SkFontStyle style) const override;
+
+private:
+    std::shared_ptr<FontConfig_OHOS> fontConfig = nullptr; // the pointer of FontConfig_OHOS
+    SkTypeface_FreeType::Scanner fontScanner; // the scanner to parse a font file
+    int familyCount = 0; // the count of font style sets in generic family list
+
+    int compareLangs(const SkString& langs, const char* bcp47[], int bcp47Count, const int tps[]) const;
+    sk_sp<SkTypeface> makeTypeface(std::unique_ptr<SkStreamAsset> stream,
+                                    const SkFontArguments& args, const char path[]) const;
+    sk_sp<SkTypeface> makeTypeface(SkFontData* fontData) const;
+    SkTypeface* findTypeface(const FallbackSetPos& fallbackItem, const SkFontStyle& style,
+                             const char* bcp47[], int bcp47Count,
+                             SkUnichar character) const;
+};
+
+SK_API sk_sp<SkFontMgr> SkFontMgr_New_OHOS(const char* path);
+
+#endif /* SKFONTMGR_OHOS_H */
diff --git a/third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.cpp b/third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.cpp
new file mode 100644
index 0000000000..23c046136d
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.cpp
@@ -0,0 +1,103 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "SkFontStyleSet_ohos.h"
+
+/*! Constructor
+ * \param fontConfig the pointer of FontConfig_OHOS
+ * \param index the index of the font style set
+ * \param isFallback true - the font style is from fallback family
+ * \n                false - the font style is from generic family
+ */
+SkFontStyleSet_OHOS::SkFontStyleSet_OHOS(const std::shared_ptr<FontConfig_OHOS>& fontConfig,
+    int index, bool isFallback)
+    : fontConfig_(fontConfig), styleIndex(index), isFallback(isFallback)
+{
+    if (fontConfig) {
+        tpCount = fontConfig_->getTypefaceCount(styleIndex, isFallback);
+    }
+}
+
+/*! To get the count of typeface
+ * \return The count of typeface in this font style set
+ */
+int SkFontStyleSet_OHOS::count()
+{
+    return tpCount;
+}
+
+/*! To get the font style for the specified typeface
+ * \param the index of a typeface
+ * \param[out] style the style value returned to the caller
+ * \param[out] the style name returned to the caller
+ */
+void SkFontStyleSet_OHOS::getStyle(int index, SkFontStyle* style, SkString* styleName)
+{
+    if (index < 0 || index >= this->count() || fontConfig_ == nullptr) {
+        return;
+    }
+
+    SkTypeface* typeface = fontConfig_->getTypeface(styleIndex, index, isFallback);
+    if (typeface == nullptr) {
+        return;
+    }
+
+    if (style) {
+        *style = typeface->fontStyle();
+    }
+    if (styleName) {
+        const char* names[] = {
+            "invisible",
+            "thin",
+            "extralight",
+            "light",
+            "normal",
+            "medium",
+            "semibold",
+            "bold",
+            "extrabold",
+            "black",
+            "extrablack"
+        };
+        // the value of font weight is between 0 ~ 1000 (refer to SkFontStyle::Weight)
+        // the weight is divided by 100 to get the matched name
+        unsigned int i = typeface->fontStyle().weight() / 100;
+        if (i < sizeof(names) / sizeof(char*)) {
+            styleName->set(names[i]);
+        } else {
+            styleName->reset();
+        }
+    }
+}
+
+/*! To create a typeface
+ * \param index the index of the typeface in this font style set
+ * \return The object of a typeface, if successful
+ * \n      Return null, if the 'index' is out of range
+ * \note The caller must call unref() on the returned object if it's not null
+ */
+SkTypeface* SkFontStyleSet_OHOS::createTypeface(int index)
+{
+    if (index < 0 || index >= this->count()) {
+        return nullptr;
+    }
+    if (fontConfig_) {
+        return SkSafeRef(fontConfig_->getTypeface(styleIndex, index, isFallback));
+    }
+    return nullptr;
+}
+
+/*! To get the closest matching typeface
+ * \param pattern the style value to be matching
+ * \return the object of a typeface which is the closest matching to 'pattern'
+ * \note The caller must call unref() on the returned object
+ */
+SkTypeface* SkFontStyleSet_OHOS::matchStyle(const SkFontStyle& pattern)
+{
+    if (fontConfig_) {
+        return SkSafeRef(fontConfig_->getTypeface(styleIndex, pattern, isFallback));
+    }
+    return nullptr;
+}
+
diff --git a/third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.h b/third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.h
new file mode 100644
index 0000000000..b3224c2bd1
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/SkFontStyleSet_ohos.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SKFONTSTYLESET_OHOS_H
+#define SKFONTSTYLESET_OHOS_H
+
+#include "include/core/SkFontMgr.h"
+
+#include "FontConfig_ohos.h"
+#include "SkTypeface_ohos.h"
+
+/*!
+ * \brief To implement SkFontStyleSet for ohos platform
+ */
+class SkFontStyleSet_OHOS : public SkFontStyleSet {
+public:
+    SkFontStyleSet_OHOS(const std::shared_ptr<FontConfig_OHOS>& fontConfig,
+        int index, bool isFallback = false);
+    virtual ~SkFontStyleSet_OHOS() override = default;
+    virtual int count() override;
+    virtual void getStyle(int index, SkFontStyle* style, SkString* styleName) override;
+    virtual SkTypeface* createTypeface(int index) override;
+    virtual SkTypeface* matchStyle(const SkFontStyle& pattern) override;
+private:
+    std::shared_ptr<FontConfig_OHOS> fontConfig_ = nullptr; // the object of FontConfig_OHOS
+    int styleIndex = 0; // the index of the font style set
+    bool isFallback = false; // the flag of font style set. False for fallback family, true for generic family.
+    int tpCount = -1; // the typeface count in the font style set
+};
+
+#endif /* SKFONTSTYLESET_OHOS_H */
diff --git a/third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.cpp b/third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.cpp
new file mode 100644
index 0000000000..b453185cfe
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.cpp
@@ -0,0 +1,139 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "SkTypeface_ohos.h"
+
+#include "src/core/SkFontDescriptor.h"
+#include "src/ports/SkFontHost_FreeType_common.h"
+#include "include/private/SkTArray.h"
+
+/*! Constructor
+ * \param familyName the specified family name for the typeface
+ * \param info the font information for the typeface
+ */
+SkTypeface_OHOS::SkTypeface_OHOS(const SkString& familyName, FontInfo& info)
+    : SkTypeface_FreeType(info.style, info.isFixedWidth),
+      specifiedName(familyName)
+{
+    fontInfo = std::make_unique<FontInfo>(std::move(info));
+}
+
+/*! Constructor
+ * \param info the font information for the typeface
+ */
+SkTypeface_OHOS::SkTypeface_OHOS(FontInfo& info)
+    : SkTypeface_FreeType(info.style, info.isFixedWidth)
+{
+    specifiedName.reset();
+    fontInfo = std::make_unique<FontInfo>(std::move(info));
+}
+
+/*! To get stream of the typeface
+ * \param[out] ttcIndex the index of the typeface in a ttc file returned to the caller
+ * \return The stream object of the typeface
+ */
+std::unique_ptr<SkStreamAsset> SkTypeface_OHOS::onOpenStream(int* ttcIndex) const
+{
+    if (fontInfo) {
+        if (ttcIndex) {
+            *ttcIndex = fontInfo->index;
+        }
+        if (fontInfo->stream == nullptr) {
+            fontInfo->stream = SkStream::MakeFromFile(fontInfo->fname.c_str());
+        }
+        if (fontInfo->stream) {
+            return fontInfo->stream->duplicate();
+        }
+    }
+    return nullptr;
+}
+
+/*! To make font data from the typeface
+ * \return The object of SkFontData
+ */
+std::unique_ptr<SkFontData> SkTypeface_OHOS::onMakeFontData() const
+{
+    if (fontInfo == nullptr) {
+        return nullptr;
+    }
+
+    if (fontInfo->stream.get() == nullptr) {
+        fontInfo->stream = SkStream::MakeFromFile(fontInfo->fname.c_str());
+    }
+    if (fontInfo->stream.get() == nullptr) {
+        return nullptr;
+    }
+    return std::make_unique<SkFontData>(fontInfo->stream->duplicate(), fontInfo->index,
+               fontInfo->axisSet.axis.data(), fontInfo->axisSet.axis.size());
+}
+
+/*! To get the font descriptor of the typeface
+ * \param[out] descriptor the font descriptor returned to the caller
+ * \param[out] isLocal the false to the caller
+ */
+void SkTypeface_OHOS::onGetFontDescriptor(SkFontDescriptor* descriptor, bool* isLocal) const
+{
+    if (isLocal) {
+        *isLocal = false;
+    }
+    if (descriptor) {
+        SkString familyName;
+        onGetFamilyName(&familyName);
+        descriptor->setFamilyName(familyName.c_str());
+        descriptor->setStyle(this->fontStyle());
+    }
+}
+
+/*! To get the family name of the typeface
+ * \param[out] familyName the family name returned to the caller
+ */
+void SkTypeface_OHOS::onGetFamilyName(SkString* familyName) const
+{
+    if (familyName == nullptr) {
+        return;
+    }
+    if (specifiedName.size() > 0) {
+        *familyName = specifiedName;
+    } else {
+        if (fontInfo) {
+            *familyName = fontInfo->familyName;
+        }
+    }
+}
+
+/*! To clone a typeface from this typeface
+ * \param args the specified font arguments from which the new typeface is created
+ * \return The object of a new typeface
+ * \note The caller must call unref() on the returned object
+ */
+sk_sp<SkTypeface> SkTypeface_OHOS::onMakeClone(const SkFontArguments& args) const
+{
+    FontInfo info(*(fontInfo.get()));
+    info.index = args.getCollectionIndex();
+    unsigned int count = args.getVariationDesignPosition().coordinateCount;
+    if (count > 0 && count == fontInfo->axisSet.range.size()) {
+        SkFontArguments::VariationPosition position = args.getVariationDesignPosition();
+        SkTypeface_FreeType::Scanner::AxisDefinitions axisDefs;
+        for (unsigned int i = 0; i < count; i++) {
+            axisDefs.push_back(fontInfo->axisSet.range[i]);
+        }
+        SkFixed axisValues[count];
+        memset(axisValues, 0, sizeof(axisValues));
+        SkTypeface_FreeType::Scanner::computeAxisValues(axisDefs, position,
+            axisValues, fontInfo->familyName);
+        info.axisSet.axis.clear();
+        for (unsigned int i = 0; i < count; i++) {
+            info.axisSet.axis.emplace_back(axisValues[i]);
+        }
+    }
+    return sk_make_sp<SkTypeface_OHOS>(specifiedName, info);
+}
+
+/*! To get the font information of the typeface
+ * \return The object of FontInfo
+ */
+const FontInfo* SkTypeface_OHOS::getFontInfo() const
+{
+    return fontInfo.get();
+}
diff --git a/third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.h b/third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.h
new file mode 100644
index 0000000000..fc36fa8dfe
--- /dev/null
+++ b/third_party/skia/src/ports/skia_ohos/SkTypeface_ohos.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2021 Huawei Device Co., Ltd. All rights reserved
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SKTYPEFACE_OHOS_H
+#define SKTYPEFACE_OHOS_H
+
+#include "src/ports/SkFontHost_FreeType_common.h"
+#include "include/core/SkFontStyle.h"
+#include "include/core/SkStream.h"
+
+#include "FontInfo_ohos.h"
+
+/*!
+ * \brief The implementation of SkTypeface for ohos platform
+ */
+class SkTypeface_OHOS : public SkTypeface_FreeType {
+public:
+    SkTypeface_OHOS(const SkString& specifiedName, FontInfo& info);
+    explicit SkTypeface_OHOS(FontInfo& info);
+    virtual ~SkTypeface_OHOS() override = default;
+    const FontInfo* getFontInfo() const;
+protected:
+    virtual std::unique_ptr<SkStreamAsset> onOpenStream(int* ttcIndex) const override;
+    virtual std::unique_ptr<SkFontData> onMakeFontData() const override;
+    virtual void onGetFontDescriptor(SkFontDescriptor* descriptor, bool* isLocal) const override;
+    virtual void onGetFamilyName(SkString* familyName) const override;
+    virtual sk_sp<SkTypeface> onMakeClone(const SkFontArguments& args) const override;
+private:
+    SkString specifiedName; // specified family name which is defined in the configuration file
+    std::unique_ptr<FontInfo> fontInfo; // the font information of this typeface
+};
+
+#endif /* SKTYPEFACE_OHOS_H */
diff --git a/third_party/tflite/src/tensorflow/lite/profiling/memory_info.cc b/third_party/tflite/src/tensorflow/lite/profiling/memory_info.cc
index 6a4438f480..c9f8076689 100644
--- a/third_party/tflite/src/tensorflow/lite/profiling/memory_info.cc
+++ b/third_party/tflite/src/tensorflow/lite/profiling/memory_info.cc
@@ -35,7 +35,7 @@ bool MemoryUsage::IsSupported() {
 
 MemoryUsage GetMemoryUsage() {
   MemoryUsage result;
-#ifdef __linux__
+#if defined(__linux__) && !defined(__MUSL__)
   rusage res;
   if (getrusage(RUSAGE_SELF, &res) == 0) {
     result.max_rss_kb = res.ru_maxrss;
diff --git a/third_party/unrar/BUILD.gn b/third_party/unrar/BUILD.gn
index 96756a8a53..a7965ae03a 100644
--- a/third_party/unrar/BUILD.gn
+++ b/third_party/unrar/BUILD.gn
@@ -99,6 +99,9 @@ static_library("unrar") {
     # Disables exceptions in unrar, replaces them with process termination.
     "UNRAR_NO_EXCEPTIONS",
   ]
+  if (is_ohos) {
+   defines += [ "UNIX_TIME_NS" ]
+  }
 
   deps = [ "//base" ]
 }
diff --git a/third_party/utf/BUILD.gn b/third_party/utf/BUILD.gn
index e759fc29d6..cc885e82a0 100644
--- a/third_party/utf/BUILD.gn
+++ b/third_party/utf/BUILD.gn
@@ -53,7 +53,7 @@ static_library("utf") {
   # third_party/libphonenumber_metadata already contains its own copy of UTF
   # but only on Android. We do not include these files to avoid double linkage
   # issues.
-  if (!is_android) {
+  if (!is_android && !is_ohos) {
     sources += [
       "src/utf/chartorune.c",
       "src/utf/fullrune.c",
diff --git a/third_party/webrtc/BUILD.gn b/third_party/webrtc/BUILD.gn
index c0b47d5d11..6e795d29a0 100644
--- a/third_party/webrtc/BUILD.gn
+++ b/third_party/webrtc/BUILD.gn
@@ -177,7 +177,7 @@ config("common_inherited_config") {
       "WEBRTC_IOS",
     ]
   }
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     defines += [ "WEBRTC_LINUX" ]
   }
   if (is_mac) {
@@ -190,10 +190,16 @@ config("common_inherited_config") {
     defines += [ "WEBRTC_WIN" ]
   }
   if (is_android) {
-    defines += [
-      "WEBRTC_LINUX",
-      "WEBRTC_ANDROID",
-    ]
+    if (use_musl) {
+      defines += [
+        "WEBRTC_LINUX",
+      ]
+    } else {
+      defines += [
+        "WEBRTC_LINUX",
+        "WEBRTC_ANDROID",
+      ]
+    }
 
     if (build_with_mozilla) {
       defines += [ "WEBRTC_ANDROID_OPENSLES" ]
diff --git a/third_party/webrtc/rtc_base/BUILD.gn b/third_party/webrtc/rtc_base/BUILD.gn
index 32ef93e5c5..a48e414f9a 100644
--- a/third_party/webrtc/rtc_base/BUILD.gn
+++ b/third_party/webrtc/rtc_base/BUILD.gn
@@ -154,7 +154,7 @@ rtc_library("rtc_base_approved") {
         [ "//native_client_sdk/src/libraries/nacl_io" ]
   }
 
-  if (is_android) {
+  if (is_android || is_ohos && !use_musl) {
     libs = [ "log" ]
   }
 
@@ -307,7 +307,7 @@ rtc_library("logging") {
       frameworks = [ "Foundation.framework" ]
     }
 
-    if (is_android) {
+    if (is_android || is_ohos && !use_musl) {
       libs += [ "log" ]
     }
   }
@@ -334,7 +334,7 @@ rtc_library("checks") {
     "//third_party/abseil-cpp/absl/meta:type_traits",
     "//third_party/abseil-cpp/absl/strings",
   ]
-  if (is_android) {
+  if (is_android || is_ohos && !use_musl) {
     libs += [ "log" ]
   }
 }
@@ -671,7 +671,7 @@ rtc_library("net_helpers") {
     "net_helpers.h",
   ]
   deps = []
-  if (is_android) {
+  if (is_android || is_ohos) {
     deps += [ ":ifaddrs_android" ]
   }
   if (is_win) {
@@ -803,7 +803,7 @@ rtc_library("threading") {
     "task_utils:to_queued_task",
     "third_party/sigslot",
   ]
-  if (is_android) {
+  if (is_android || is_ohos) {
     deps += [ ":ifaddrs_android" ]
   }
   if (is_win) {
@@ -857,16 +857,18 @@ rtc_source_set("network_constants") {
   deps = [ ":checks" ]
 }
 
-if (is_android) {
+if (is_android || is_ohos) {
   rtc_library("ifaddrs_android") {
     sources = [
       "ifaddrs_android.cc",
       "ifaddrs_android.h",
     ]
-    libs = [
-      "log",
-      "GLESv2",
-    ]
+    if (!use_musl) {
+      libs = [
+        "log",
+        # "GLESv2",
+      ]
+    }
   }
 }
 
@@ -1062,7 +1064,7 @@ rtc_library("rtc_base") {
     configs += [ ":external_ssl_library" ]
   }
 
-  if (is_android) {
+  if (is_android || is_ohos) {
     deps += [ ":ifaddrs_android" ]
   }
 
diff --git a/third_party/zlib/BUILD.gn b/third_party/zlib/BUILD.gn
index d64cb38bcd..13e15d7c88 100644
--- a/third_party/zlib/BUILD.gn
+++ b/third_party/zlib/BUILD.gn
@@ -108,7 +108,7 @@ if (use_arm_neon_optimizations) {
       defines = [ "CRC32_ARMV8_CRC32" ]
       if (is_android) {
         defines += [ "ARMV8_OS_ANDROID" ]
-      } else if (is_linux || is_chromeos) {
+      } else if (is_linux || is_chromeos || is_ohos) {
         defines += [ "ARMV8_OS_LINUX" ]
       } else if (is_mac) {
         defines += [ "ARMV8_OS_MACOS" ]
@@ -335,10 +335,12 @@ component("zlib") {
 
   if (is_android) {
     import("//build/config/android/config.gni")
-    if (defined(android_ndk_root) && android_ndk_root != "") {
-      deps += [ "//third_party/android_ndk:cpu_features" ]
-    } else {
-      assert(false, "CPU detection requires the Android NDK")
+    if (!use_musl) {
+      if (defined(android_ndk_root) && android_ndk_root != "") {
+        deps += [ "//third_party/android_ndk:cpu_features" ]
+      } else {
+        assert(false, "CPU detection requires the Android NDK")
+      }
     }
   }
 
@@ -385,7 +387,7 @@ static_library("minizip") {
     ]
   }
 
-  if (is_apple || is_android || is_nacl) {
+  if (is_apple || is_android || is_nacl || is_ohos) {
     # Mac, Android and the BSDs don't have fopen64, ftello64, or fseeko64. We
     # use fopen, ftell, and fseek instead on these systems.
     defines = [ "USE_FILE32API" ]
diff --git a/tools/grit/grit_defines.gni b/tools/grit/grit_defines.gni
index 5b92d7a6cd..28a303ca15 100644
--- a/tools/grit/grit_defines.gni
+++ b/tools/grit/grit_defines.gni
@@ -69,6 +69,13 @@ if (is_linux || is_chromeos_lacros) {
   ]
 }
 
+if (is_ohos) {
+  grit_defines += [
+    "-D",
+    "is_ohos",
+  ]
+}
+
 if (toolkit_views) {
   grit_defines += [
     "-D",
diff --git a/tools/perf/BUILD.gn b/tools/perf/BUILD.gn
index 89363eb28b..391ce15ff9 100644
--- a/tools/perf/BUILD.gn
+++ b/tools/perf/BUILD.gn
@@ -5,7 +5,9 @@
 # Keep in sync with group("perf_without_chrome").
 group("perf") {
   testonly = true
-  deps = [ "//tools/perf/chrome_telemetry_build:telemetry_chrome_test" ]
+  if (!use_musl) {
+    deps = [ "//tools/perf/chrome_telemetry_build:telemetry_chrome_test" ]
+  }
   data = [
     "//tools/perf/",
 
diff --git a/tools/v8_context_snapshot/v8_context_snapshot.gni b/tools/v8_context_snapshot/v8_context_snapshot.gni
index 5a2b53f7b5..b7654507fd 100644
--- a/tools/v8_context_snapshot/v8_context_snapshot.gni
+++ b/tools/v8_context_snapshot/v8_context_snapshot.gni
@@ -16,7 +16,7 @@ declare_args() {
   # TODO(crbug.com/764576): Enable the feature on more environments.
   # Disable in mac and win cross builds since building Blink twice is slow.
   use_v8_context_snapshot =
-      !is_chromeos_ash && !is_android && !is_chromecast && !is_fuchsia &&
+      !is_chromeos_ash && !is_android && !is_chromecast && !is_fuchsia && !is_ohos &&
       !(host_os == "mac" && current_cpu == "x86") &&
       (v8_target_cpu == target_cpu || is_msan) &&
       !(is_win && host_os != "win") && !(is_mac && host_os != "mac")
diff --git a/tools/variations/fieldtrial_to_struct.py b/tools/variations/fieldtrial_to_struct.py
index 9ecf389747..e90eff902a 100755
--- a/tools/variations/fieldtrial_to_struct.py
+++ b/tools/variations/fieldtrial_to_struct.py
@@ -41,6 +41,7 @@ _platforms = [
     'linux',
     'mac',
     'windows',
+    'ohos',
 ]
 
 _form_factors = [
diff --git a/ui/aura/BUILD.gn b/ui/aura/BUILD.gn
index 38f9f4f735..e5d4e5e447 100644
--- a/ui/aura/BUILD.gn
+++ b/ui/aura/BUILD.gn
@@ -256,7 +256,7 @@ static_library("test_support") {
     sources += [ "test/ui_controls_factory_aurawin.cc" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [ "test/ui_controls_factory_aura_linux.cc" ]
   }
 
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 5b1b39a6bb..edccf7e485 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -513,7 +513,7 @@ component("base") {
     }
   }
 
-  if (use_aura && (is_linux || is_chromeos)) {
+  if (use_aura && (is_linux || is_chromeos || is_ohos)) {
     sources += [ "resource/resource_bundle_auralinux.cc" ]
   }
 
@@ -530,7 +530,7 @@ component("base") {
     ]
   }
 
-  if (is_chromeos_ash || (use_aura && (is_linux || is_chromeos_lacros))) {
+  if (is_chromeos_ash || (use_aura && (is_linux || is_chromeos_lacros || is_ohos))) {
     sources += [
       "dragdrop/os_exchange_data_provider_non_backed.cc",
       "dragdrop/os_exchange_data_provider_non_backed.h",
@@ -1198,7 +1198,7 @@ if (is_win) {
   }
 }
 
-if (is_linux || is_chromeos) {
+if (is_linux || is_chromeos || is_ohos) {
   # This source set defines linux wm role names and must not have any external
   # dependencies and be kept as minimal as possible.
   source_set("wm_role_names") {
diff --git a/ui/base/clipboard/clipboard_constants.cc b/ui/base/clipboard/clipboard_constants.cc
index df542333f6..8cc7de6b48 100644
--- a/ui/base/clipboard/clipboard_constants.cc
+++ b/ui/base/clipboard/clipboard_constants.cc
@@ -18,7 +18,7 @@ const char kMimeTypeSvg[] = "image/svg+xml";
 const char kMimeTypeRTF[] = "text/rtf";
 const char kMimeTypePNG[] = "image/png";
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
 const char kMimeTypeLinuxUtf8String[] = "UTF8_STRING";
 const char kMimeTypeLinuxString[] = "STRING";
 const char kMimeTypeLinuxText[] = "TEXT";
diff --git a/ui/base/clipboard/clipboard_constants.h b/ui/base/clipboard/clipboard_constants.h
index d0eea2208f..0509ce8d47 100644
--- a/ui/base/clipboard/clipboard_constants.h
+++ b/ui/base/clipboard/clipboard_constants.h
@@ -37,7 +37,7 @@ COMPONENT_EXPORT(UI_BASE_CLIPBOARD_TYPES) extern const char kMimeTypeRTF[];
 COMPONENT_EXPORT(UI_BASE_CLIPBOARD_TYPES) extern const char kMimeTypePNG[];
 
 // Linux-specific MIME type constants (also used in Fuchsia).
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
 COMPONENT_EXPORT(UI_BASE_CLIPBOARD_TYPES)
 extern const char kMimeTypeLinuxUtf8String[];
 COMPONENT_EXPORT(UI_BASE_CLIPBOARD_TYPES)
diff --git a/ui/base/dragdrop/os_exchange_data_provider_factory.cc b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
index 4f5c946a1a..fbaf669cfe 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -7,7 +7,7 @@
 #include "base/notreached.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "ui/base/dragdrop/os_exchange_data_provider_non_backed.h"
 #include "ui/base/ui_base_features.h"
 #if defined(USE_OZONE)
@@ -26,7 +26,7 @@ namespace ui {
 
 namespace {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 std::unique_ptr<OSExchangeDataProvider> CreateProviderForLinux() {
 #if defined(USE_OZONE)
   // The instance can be nullptr in tests that do not instantiate the platform,
@@ -50,7 +50,7 @@ std::unique_ptr<OSExchangeDataProvider> CreateProviderForLinux() {
 // static
 std::unique_ptr<OSExchangeDataProvider>
 OSExchangeDataProviderFactory::CreateProvider() {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   if (features::IsUsingOzonePlatform())
     return CreateProviderForLinux();
 #if defined(USE_X11)
diff --git a/ui/base/idle/BUILD.gn b/ui/base/idle/BUILD.gn
index 73f2aebff6..dbcd63fee5 100644
--- a/ui/base/idle/BUILD.gn
+++ b/ui/base/idle/BUILD.gn
@@ -56,7 +56,7 @@ component("idle") {
     sources += [ "idle_fuchsia.cc" ]
   }
 
-  if (is_linux) {
+  if (is_linux || is_ohos) {
     sources += [ "idle_linux.cc" ]
   }
 
diff --git a/ui/base/ime/linux/BUILD.gn b/ui/base/ime/linux/BUILD.gn
index 672a47ae34..5001af2032 100644
--- a/ui/base/ime/linux/BUILD.gn
+++ b/ui/base/ime/linux/BUILD.gn
@@ -5,7 +5,7 @@
 import("//build/config/chromeos/ui_mode.gni")
 import("//build/config/linux/pangocairo/pangocairo.gni")
 
-assert(is_linux || is_chromeos_lacros)
+assert(is_linux || is_chromeos_lacros || is_ohos)
 
 component("linux") {
   output_name = "ui_base_ime_linux"
diff --git a/ui/base/resource/resource_bundle.cc b/ui/base/resource/resource_bundle.cc
index 3a309475b8..1032f1e903 100644
--- a/ui/base/resource/resource_bundle.cc
+++ b/ui/base/resource/resource_bundle.cc
@@ -371,10 +371,18 @@ base::FilePath ResourceBundle::GetLocaleFilePath(
     return base::FilePath();
 
   base::FilePath locale_file_path;
+#if !defined(OS_OHOS)
   if (base::PathService::Get(ui::DIR_LOCALES, &locale_file_path)) {
     locale_file_path =
         locale_file_path.AppendASCII(app_locale + kPakFileExtension);
   }
+#else
+  if (base::PathService::Get(base::DIR_ASSETS, &locale_file_path)) {
+    locale_file_path =
+        locale_file_path.AppendASCII(app_locale + kPakFileExtension);
+  }
+#endif
+
 
   // Note: The delegate GetPathForLocalePack() override is currently only used
   // by CastResourceDelegate, which does not call this function prior to
diff --git a/ui/color/BUILD.gn b/ui/color/BUILD.gn
index b0c1eba7fe..3c487a0743 100644
--- a/ui/color/BUILD.gn
+++ b/ui/color/BUILD.gn
@@ -101,7 +101,7 @@ component("mixers") {
     sources += [ "cros/native_color_mixers.cc" ]
   } else if (is_fuchsia) {
     sources += [ "fuchsia/native_color_mixers.cc" ]
-  } else if (is_linux || is_chromeos) {
+  } else if (is_linux || is_chromeos || is_ohos) {
     sources += [ "linux/native_color_mixers.cc" ]
   } else if (is_mac) {
     frameworks = [ "AppKit.framework" ]
diff --git a/ui/events/BUILD.gn b/ui/events/BUILD.gn
index 767c19f343..6d317f4c1c 100644
--- a/ui/events/BUILD.gn
+++ b/ui/events/BUILD.gn
@@ -158,6 +158,10 @@ component("events_base") {
     "//ui/gfx/geometry",
   ]
 
+  if (is_ohos) {
+     public_deps += [ "//ui/events/keycodes:x11" ]
+  }
+
   if (use_x11 || ozone_platform_x11) {
     public_deps += [ "//ui/events/keycodes:x11" ]
 
diff --git a/ui/events/keycodes/BUILD.gn b/ui/events/keycodes/BUILD.gn
index 6c06b461c6..bd13f2ad9d 100644
--- a/ui/events/keycodes/BUILD.gn
+++ b/ui/events/keycodes/BUILD.gn
@@ -28,6 +28,28 @@ source_set("xkb") {
   ]
 }
 
+if (is_ohos) {
+  component("x11") {
+    output_name = "keycodes_x11"
+
+    sources = [
+      "keyboard_code_conversion_x.cc",
+      "keyboard_code_conversion_x.h",
+      "keycodes_x_export.h",
+      "keysym_to_unicode.cc",
+      "keysym_to_unicode.h",
+    ]
+
+    defines = [ "KEYCODES_X_IMPLEMENTATION" ]
+
+    deps = [
+      ":xkb",
+      "//base",
+      "//ui/events:dom_keycode_converter",
+    ]
+  }
+}
+
 if (use_x11 || ozone_platform_x11) {
   component("x11") {
     output_name = "keycodes_x11"
diff --git a/ui/events/keycodes/dom/keycode_converter.cc b/ui/events/keycodes/dom/keycode_converter.cc
index c6ed4ac20a..79c91342d9 100644
--- a/ui/events/keycodes/dom/keycode_converter.cc
+++ b/ui/events/keycodes/dom/keycode_converter.cc
@@ -24,7 +24,7 @@ namespace {
 #if defined(OS_WIN)
 #define DOM_CODE(usb, evdev, xkb, win, mac, code, id) \
   { usb, win, code }
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #define DOM_CODE(usb, evdev, xkb, win, mac, code, id) \
   { usb, xkb, code }
 #elif defined(OS_APPLE)
diff --git a/ui/events/keycodes/keyboard_code_conversion_x.cc b/ui/events/keycodes/keyboard_code_conversion_x.cc
index b38af7a801..a5af83c7ca 100644
--- a/ui/events/keycodes/keyboard_code_conversion_x.cc
+++ b/ui/events/keycodes/keyboard_code_conversion_x.cc
@@ -19,8 +19,14 @@
 #include "ui/events/keycodes/keysym_to_unicode.h"
 #include "ui/events/keycodes/xkb_keysym.h"
 #include "ui/gfx/x/keysyms/keysyms.h"
+#if !defined(OS_OHOS)
 #include "ui/gfx/x/xinput.h"
 #include "ui/gfx/x/xproto.h"
+#else
+#include "ui/gfx/x/generated_protos/xinput.h"
+#include "ui/gfx/x/generated_protos/xproto.h"
+#endif
+
 #include "ui/gfx/x/xproto_types.h"
 
 #define VKEY_UNSUPPORTED VKEY_UNKNOWN
diff --git a/ui/gfx/BUILD.gn b/ui/gfx/BUILD.gn
index 181c0c5891..fcd6fe0e43 100644
--- a/ui/gfx/BUILD.gn
+++ b/ui/gfx/BUILD.gn
@@ -350,14 +350,14 @@ component("gfx") {
     ]
   }
 
-  if (is_android || is_fuchsia) {
+  if (is_android || is_fuchsia || is_ohos) {
     sources += [
       "font_fallback_skia.cc",
       "font_render_params_skia.cc",
     ]
   }
 
-  if (is_android || is_fuchsia || is_win || is_mac) {
+  if (is_android || is_fuchsia || is_win || is_mac || is_ohos) {
     sources += [
       "font_fallback_skia_impl.cc",
       "font_fallback_skia_impl.h",
@@ -603,7 +603,14 @@ source_set("memory_buffer_sources") {
     deps += [ "//build/config/linux/libdrm" ]
   }
 
-  if (is_linux || is_chromeos || is_android) {
+  if (is_ohos) {
+    sources += [
+      "linux/native_pixmap_dmabuf.cc",
+      "linux/native_pixmap_dmabuf.h",
+    ]
+  }
+
+  if (is_linux || is_chromeos || is_android || is_ohos) {
     deps += [ "//third_party/libsync" ]
   }
 
diff --git a/ui/gfx/animation/BUILD.gn b/ui/gfx/animation/BUILD.gn
index e544b0972f..a570a20e8d 100644
--- a/ui/gfx/animation/BUILD.gn
+++ b/ui/gfx/animation/BUILD.gn
@@ -45,7 +45,7 @@ component("animation") {
     sources += [ "animation_win.cc" ]
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     sources += [
       "animation_linux.cc",
       "animation_settings_provider_linux.cc",
diff --git a/ui/gfx/gpu_memory_buffer.cc b/ui/gfx/gpu_memory_buffer.cc
index 44b2667960..cd7ece485b 100644
--- a/ui/gfx/gpu_memory_buffer.cc
+++ b/ui/gfx/gpu_memory_buffer.cc
@@ -53,7 +53,7 @@ GpuMemoryBufferHandle GpuMemoryBufferHandle::Clone() const {
   handle.region = region.Duplicate();
   handle.offset = offset;
   handle.stride = stride;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   handle.native_pixmap_handle = CloneHandleForIPC(native_pixmap_handle);
 #elif defined(OS_MAC)
   handle.io_surface = io_surface;
diff --git a/ui/gfx/gpu_memory_buffer.h b/ui/gfx/gpu_memory_buffer.h
index c3a1f813ca..cea4239a25 100644
--- a/ui/gfx/gpu_memory_buffer.h
+++ b/ui/gfx/gpu_memory_buffer.h
@@ -16,7 +16,7 @@
 #include "ui/gfx/gfx_export.h"
 #include "ui/gfx/hdr_metadata.h"
 
-#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(USE_OZONE) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "ui/gfx/native_pixmap_handle.h"
 #elif defined(OS_MAC)
 #include "ui/gfx/mac/io_surface.h"
@@ -70,7 +70,7 @@ struct GFX_EXPORT GpuMemoryBufferHandle {
   base::UnsafeSharedMemoryRegion region;
   uint32_t offset = 0;
   int32_t stride = 0;
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FUCHSIA) || defined(OS_OHOS)
   NativePixmapHandle native_pixmap_handle;
 #elif defined(OS_MAC)
   ScopedIOSurface io_surface;
diff --git a/ui/gfx/mojom/BUILD.gn b/ui/gfx/mojom/BUILD.gn
index 07b61c87c7..5d428cc1bc 100644
--- a/ui/gfx/mojom/BUILD.gn
+++ b/ui/gfx/mojom/BUILD.gn
@@ -303,7 +303,7 @@ mojom("mojom") {
 
 mojom("native_handle_types") {
   sources = [ "native_handle_types.mojom" ]
-  if (is_linux || is_chromeos || use_ozone) {
+  if (is_linux || is_chromeos || use_ozone || is_ohos) {
     enabled_features = [ "supports_native_pixmap" ]
   }
   public_deps = [ "//mojo/public/mojom/base" ]
diff --git a/ui/gfx/mojom/native_handle_types.mojom b/ui/gfx/mojom/native_handle_types.mojom
index 5b7be0a212..98eabee6e8 100644
--- a/ui/gfx/mojom/native_handle_types.mojom
+++ b/ui/gfx/mojom/native_handle_types.mojom
@@ -27,6 +27,8 @@ struct NativePixmapHandle {
   uint64 modifier;
   [EnableIf=is_chromeos]
   uint64 modifier;
+  [EnableIf=is_ohos]
+  uint64 modifier;
 
   [EnableIf=is_fuchsia]
   mojo_base.mojom.UnguessableToken? buffer_collection_id;
diff --git a/ui/gfx/mojom/native_handle_types_mojom_traits.cc b/ui/gfx/mojom/native_handle_types_mojom_traits.cc
index 15e5b8b976..475191bc53 100644
--- a/ui/gfx/mojom/native_handle_types_mojom_traits.cc
+++ b/ui/gfx/mojom/native_handle_types_mojom_traits.cc
@@ -8,11 +8,11 @@
 
 namespace mojo {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_OHOS)
 mojo::PlatformHandle StructTraits<
     gfx::mojom::NativePixmapPlaneDataView,
     gfx::NativePixmapPlane>::buffer_handle(gfx::NativePixmapPlane& plane) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   return mojo::PlatformHandle(std::move(plane.fd));
 #elif defined(OS_FUCHSIA)
   return mojo::PlatformHandle(std::move(plane.vmo));
@@ -28,7 +28,7 @@ bool StructTraits<
   out->size = data.size();
 
   mojo::PlatformHandle handle = data.TakeBufferHandle();
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   if (!handle.is_fd())
     return false;
   out->fd = handle.TakeFD();
@@ -45,7 +45,7 @@ bool StructTraits<
     gfx::mojom::NativePixmapHandleDataView,
     gfx::NativePixmapHandle>::Read(gfx::mojom::NativePixmapHandleDataView data,
                                    gfx::NativePixmapHandle* out) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   out->modifier = data.modifier();
 #endif
 
diff --git a/ui/gfx/mojom/native_handle_types_mojom_traits.h b/ui/gfx/mojom/native_handle_types_mojom_traits.h
index 6e9ed3d64e..ee807fd59d 100644
--- a/ui/gfx/mojom/native_handle_types_mojom_traits.h
+++ b/ui/gfx/mojom/native_handle_types_mojom_traits.h
@@ -14,13 +14,13 @@
 #include "mojo/public/cpp/system/platform_handle.h"
 #include "ui/gfx/mojom/native_handle_types.mojom-shared.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_OHOS)
 #include "ui/gfx/native_pixmap_handle.h"
 #endif
 
 namespace mojo {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(USE_OZONE) || defined(OS_OHOS)
 template <>
 struct COMPONENT_EXPORT(GFX_NATIVE_HANDLE_TYPES_SHARED_MOJOM_TRAITS)
     StructTraits<gfx::mojom::NativePixmapPlaneDataView,
@@ -48,7 +48,7 @@ struct COMPONENT_EXPORT(GFX_NATIVE_HANDLE_TYPES_SHARED_MOJOM_TRAITS)
     return pixmap_handle.planes;
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   static uint64_t modifier(const gfx::NativePixmapHandle& pixmap_handle) {
     return pixmap_handle.modifier;
   }
diff --git a/ui/gfx/native_pixmap_handle.cc b/ui/gfx/native_pixmap_handle.cc
index 137056bcdc..246eaa4b31 100644
--- a/ui/gfx/native_pixmap_handle.cc
+++ b/ui/gfx/native_pixmap_handle.cc
@@ -12,6 +12,10 @@
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
 #include <drm_fourcc.h>
 #include "base/posix/eintr_wrapper.h"
+#elif defined(OS_OHOS)
+#include <drm/drm_fourcc.h>
+#include <unistd.h>
+#include "base/posix/eintr_wrapper.h"
 #endif
 
 #if defined(OS_FUCHSIA)
@@ -21,7 +25,7 @@
 
 namespace gfx {
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 static_assert(NativePixmapHandle::kNoModifier == DRM_FORMAT_MOD_INVALID,
               "gfx::NativePixmapHandle::kNoModifier should be an alias for"
               "DRM_FORMAT_MOD_INVALID");
@@ -32,7 +36,7 @@ NativePixmapPlane::NativePixmapPlane() : stride(0), offset(0), size(0) {}
 NativePixmapPlane::NativePixmapPlane(int stride,
                                      int offset,
                                      uint64_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
                                      ,
                                      base::ScopedFD fd
 #elif defined(OS_FUCHSIA)
@@ -43,7 +47,7 @@ NativePixmapPlane::NativePixmapPlane(int stride,
     : stride(stride),
       offset(offset),
       size(size)
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
       ,
       fd(std::move(fd))
 #elif defined(OS_FUCHSIA)
@@ -71,7 +75,7 @@ NativePixmapHandle& NativePixmapHandle::operator=(NativePixmapHandle&& other) =
 NativePixmapHandle CloneHandleForIPC(const NativePixmapHandle& handle) {
   NativePixmapHandle clone;
   for (auto& plane : handle.planes) {
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
     DCHECK(plane.fd.is_valid());
     base::ScopedFD fd_dup(HANDLE_EINTR(dup(plane.fd.get())));
     if (!fd_dup.is_valid()) {
@@ -97,7 +101,7 @@ NativePixmapHandle CloneHandleForIPC(const NativePixmapHandle& handle) {
 #endif
   }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   clone.modifier = handle.modifier;
 #endif
 
diff --git a/ui/gfx/native_pixmap_handle.h b/ui/gfx/native_pixmap_handle.h
index 1748dd32f7..34ac4c4efd 100644
--- a/ui/gfx/native_pixmap_handle.h
+++ b/ui/gfx/native_pixmap_handle.h
@@ -15,7 +15,7 @@
 #include "build/build_config.h"
 #include "ui/gfx/gfx_export.h"
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
 #include "base/files/scoped_file.h"
 #endif
 
@@ -32,7 +32,7 @@ struct GFX_EXPORT NativePixmapPlane {
   NativePixmapPlane(int stride,
                     int offset,
                     uint64_t size
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
                     ,
                     base::ScopedFD fd
 #elif defined(OS_FUCHSIA)
@@ -53,7 +53,7 @@ struct GFX_EXPORT NativePixmapPlane {
   // This is necessary to map the buffers.
   uint64_t size;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // File descriptor for the underlying memory object (usually dmabuf).
   base::ScopedFD fd;
 #elif defined(OS_FUCHSIA)
@@ -82,7 +82,7 @@ struct GFX_EXPORT NativePixmapHandle {
 
   std::vector<NativePixmapPlane> planes;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_OHOS)
   // The modifier is retrieved from GBM library and passed to EGL driver.
   // Generally it's platform specific, and we don't need to modify it in
   // Chromium code. Also one per plane per entry.
diff --git a/ui/gfx/x/connection.h b/ui/gfx/x/connection.h
index 761a1ef5d5..43dfe10274 100644
--- a/ui/gfx/x/connection.h
+++ b/ui/gfx/x/connection.h
@@ -12,9 +12,14 @@
 #include "base/optional.h"
 #include "base/sequence_checker.h"
 #include "ui/events/platform/platform_event_source.h"
+#if !defined(OS_OHOS)
 #include "ui/gfx/x/extension_manager.h"
-#include "ui/gfx/x/xlib_support.h"
 #include "ui/gfx/x/xproto.h"
+#else
+#include "ui/gfx/x/generated_protos/extension_manager.h"
+#include "ui/gfx/x/generated_protos/xproto.h"
+#endif
+#include "ui/gfx/x/xlib_support.h"
 
 typedef struct xcb_connection_t xcb_connection_t;
 
diff --git a/ui/gfx/x/event.h b/ui/gfx/x/event.h
index ed4f9b0c0f..000131c4f3 100644
--- a/ui/gfx/x/event.h
+++ b/ui/gfx/x/event.h
@@ -11,7 +11,11 @@
 #include "base/component_export.h"
 #include "base/memory/ref_counted_memory.h"
 #include "base/memory/scoped_refptr.h"
+#if !defined(OS_OHOS)
 #include "ui/gfx/x/xproto.h"
+#else
+#include "ui/gfx/x/generated_protos/xproto.h"
+#endif
 
 namespace x11 {
 
diff --git a/ui/gl/features.gni b/ui/gl/features.gni
index 1bbc06c627..50f9268f7d 100644
--- a/ui/gl/features.gni
+++ b/ui/gl/features.gni
@@ -14,7 +14,7 @@ declare_args() {
   # Should EGL support be compiled?
   # Can be overriden to test during bring up of EGL support on other platforms.
   use_egl =
-      is_win || is_android || is_linux || is_chromeos || is_fuchsia || is_mac
+      is_win || is_android || is_linux || is_chromeos || is_fuchsia || is_mac || is_ohos
 
   # Should Dawn support be compiled to back the WebGPU implementation?
   # Also controls linking Dawn depedencies in such as SPIRV-Tools/SPIRV-Cross.
diff --git a/ui/message_center/BUILD.gn b/ui/message_center/BUILD.gn
index 807e24d9bb..9fa47d5223 100644
--- a/ui/message_center/BUILD.gn
+++ b/ui/message_center/BUILD.gn
@@ -88,7 +88,7 @@ component("message_center") {
       ]
     }
 
-    if (toolkit_views) {
+    if (toolkit_views || is_ohos) {
       sources += [
         "views/desktop_message_popup_collection.cc",
         "views/desktop_message_popup_collection.h",
diff --git a/ui/message_center/dummy_message_center.cc b/ui/message_center/dummy_message_center.cc
index db8d9dedf5..c2dc3bfe6d 100644
--- a/ui/message_center/dummy_message_center.cc
+++ b/ui/message_center/dummy_message_center.cc
@@ -9,8 +9,8 @@
 // and link with Android implementations of Chrome which do not have
 // notification systems yet. This is to avoid spreading compile-time flags
 // everywhere in the code.
-#if !(defined(OS_ANDROID) || defined(OS_FUCHSIA))
-#error This file should only be used in Android and Fuchsia.
+#if !(defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_OHOS))
+#error This file should only be used in Android and Fuchsia and Ohos.
 #endif
 
 namespace message_center {
diff --git a/ui/shell_dialogs/BUILD.gn b/ui/shell_dialogs/BUILD.gn
index a7ef6364dc..9206f09d60 100644
--- a/ui/shell_dialogs/BUILD.gn
+++ b/ui/shell_dialogs/BUILD.gn
@@ -27,7 +27,7 @@ component("shell_dialogs") {
     "shell_dialogs_export.h",
   ]
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     sources += [
       "shell_dialog_linux.cc",
       "shell_dialog_linux.h",
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 945ca33ebb..cb7acaf7cd 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -12,7 +12,7 @@ import("//testing/test.gni")
 import("//ui/base/ui_features.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
+assert(toolkit_views || is_ohos)
 
 config("flags") {
   defines = [ "TOOLKIT_VIEWS=1" ]
@@ -549,12 +549,12 @@ component("views") {
     deps += [ "//ui/base/ime/chromeos" ]
   }
 
-  if (is_linux || is_chromeos) {
+  if (is_linux || is_chromeos || is_ohos) {
     public += [ "color_chooser/color_chooser_view.h" ]
     sources += [ "color_chooser/color_chooser_view.cc" ]
   }
 
-  if (is_linux || is_chromeos_lacros) {
+  if (is_linux || is_chromeos_lacros || is_ohos) {
     sources -= [ "window/window_button_order_provider.cc" ]
     public_deps += [ "//ui/base/cursor:theme_manager" ]
     deps += [
@@ -833,7 +833,7 @@ component("views") {
         ]
         deps += [ "//ui/base:hit_test" ]
       }
-      if (is_linux || is_chromeos || is_fuchsia) {
+      if (is_linux || is_chromeos || is_fuchsia || is_ohos) {
         public += [
           "widget/desktop_aura/desktop_window_tree_host_platform.h",
           "widget/desktop_aura/window_move_client_platform.h",
diff --git a/ui/views/controls/webview/BUILD.gn b/ui/views/controls/webview/BUILD.gn
index e4a99da262..3f6a967ec2 100644
--- a/ui/views/controls/webview/BUILD.gn
+++ b/ui/views/controls/webview/BUILD.gn
@@ -51,7 +51,7 @@ component("webview") {
     "//ui/views",
   ]
 
-  if (is_linux || is_chromeos || is_android || is_fuchsia) {
+  if (is_linux || is_chromeos || is_android || is_fuchsia || is_ohos) {
     sources += [ "unhandled_keyboard_event_handler_default.cc" ]
   }
 }
diff --git a/ui/views/views_delegate.cc b/ui/views/views_delegate.cc
index b238d2791d..69b471d07f 100644
--- a/ui/views/views_delegate.cc
+++ b/ui/views/views_delegate.cc
@@ -90,7 +90,7 @@ bool ViewsDelegate::IsWindowInMetro(gfx::NativeWindow window) const {
   return false;
 }
 #elif BUILDFLAG(ENABLE_DESKTOP_AURA) && \
-    (defined(OS_LINUX) || defined(OS_CHROMEOS))
+    (defined(OS_LINUX) || defined(OS_CHROMEOS)) || defined(OS_OHOS)
 gfx::ImageSkia* ViewsDelegate::GetDefaultWindowIcon() const {
   return nullptr;
 }
diff --git a/ui/views/views_delegate.h b/ui/views/views_delegate.h
index d84acfa918..1348e65b91 100644
--- a/ui/views/views_delegate.h
+++ b/ui/views/views_delegate.h
@@ -137,7 +137,7 @@ class VIEWS_EXPORT ViewsDelegate {
   // environment.
   virtual bool IsWindowInMetro(gfx::NativeWindow window) const;
 #elif BUILDFLAG(ENABLE_DESKTOP_AURA) && \
-    (defined(OS_LINUX) || defined(OS_CHROMEOS))
+    (defined(OS_LINUX) || defined(OS_CHROMEOS)) || defined(OS_OHOS)
   virtual gfx::ImageSkia* GetDefaultWindowIcon() const;
 #endif
 
diff --git a/url/origin.cc b/url/origin.cc
index 10099725d7..ce538996af 100644
--- a/url/origin.cc
+++ b/url/origin.cc
@@ -422,11 +422,11 @@ Origin::Nonce& Origin::Nonce::operator=(const Origin::Nonce& other) {
 }
 
 // Moving a nonce does NOT trigger lazy-generation of the token.
-Origin::Nonce::Nonce(Origin::Nonce&& other) : token_(other.token_) {
+Origin::Nonce::Nonce(Origin::Nonce&& other) noexcept : token_(other.token_) {
   other.token_ = base::UnguessableToken();  // Reset |other|.
 }
 
-Origin::Nonce& Origin::Nonce::operator=(Origin::Nonce&& other) {
+Origin::Nonce& Origin::Nonce::operator=(Origin::Nonce&& other) noexcept {
   token_ = other.token_;
   other.token_ = base::UnguessableToken();  // Reset |other|.
   return *this;
